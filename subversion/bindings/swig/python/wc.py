# This file was automatically generated by SWIG (http://www.swig.org).
# Version 3.0.12
#
# Do not make changes to this file unless you know what you are doing--modify
# the SWIG interface file instead.


def _dll_paths():
    import os
    if hasattr(os, 'add_dll_directory'):  # Python 3.8+ on Windows
        cookies = []
        for path in os.environ.get('PATH', '').split(os.pathsep):
            if path and os.path.isabs(path):
                try:
                    cookie = os.add_dll_directory(path)
                except OSError:
                    continue
                else:
                    cookies.append(cookie)
        return cookies
    else:
        return ()

_dll_paths = _dll_paths()
try:
    from . import _wc
finally:
    _dll_path = None
    for _dll_path in _dll_paths:
        _dll_path.close()
    del _dll_paths, _dll_path

try:
    _swig_property = property
except NameError:
    pass  # Python < 2.2 doesn't have 'property'.

try:
    import builtins as __builtin__
except ImportError:
    import __builtin__

def _swig_setattr_nondynamic(self, class_type, name, value, static=1):
    if (name == "thisown"):
        return self.this.own(value)
    if (name == "this"):
        if type(value).__name__ == 'SwigPyObject':
            self.__dict__[name] = value
            return
    method = class_type.__swig_setmethods__.get(name, None)
    if method:
        return method(self, value)
    if (not static):
        object.__setattr__(self, name, value)
    else:
        raise AttributeError("You cannot add attributes to %s" % self)


def _swig_setattr(self, class_type, name, value):
    return _swig_setattr_nondynamic(self, class_type, name, value, 0)


def _swig_getattr(self, class_type, name):
    if (name == "thisown"):
        return self.this.own()
    method = class_type.__swig_getmethods__.get(name, None)
    if method:
        return method(self)
    raise AttributeError("'%s' object has no attribute '%s'" % (class_type.__name__, name))


def _swig_repr(self):
    try:
        strthis = "proxy of " + self.this.__repr__()
    except __builtin__.Exception:
        strthis = ""
    return "<%s.%s; %s >" % (self.__class__.__module__, self.__class__.__name__, strthis,)


def _swig_setattr_nondynamic_method(set):
    def set_attr(self, name, value):
        if (name == "thisown"):
            return self.this.own(value)
        if hasattr(self, name) or (name == "this"):
            set(self, name, value)
        else:
            raise AttributeError("You cannot add attributes to %s" % self)
    return set_attr



def _copy_metadata_deep(value, old_value):
  """Copy all attributes of old_value into value, recursively traversing
  lists and dicts if needed."""
  if value is None or old_value is None or value is old_value: return

  if isinstance(value, dict):
    for k in value:
      _copy_metadata_deep(value[k], old_value[k])
  elif isinstance(value, list):
    for v, old_v in zip(value, old_value):
      _copy_metadata_deep(v, old_v)
  else:
    try:
      value.__dict__.update(old_value.__dict__)
    except AttributeError:
      pass

def _assert_valid_deep(value):
  """Assert value's validity, recursively traversing lists and dicts."""
  if isinstance(value, dict):
    for k in value:
      _assert_valid_deep(value[k])
  elif isinstance(value, list):
    for v in value:
      _assert_valid_deep(v)
# Ensure that the passed in value isn't a type, which could have an
# assert_valid attribute, but it can not be called without an instance.
  elif type(value) != type:
    try:
      fn = value.assert_valid
    except AttributeError:
      pass
    else:
      fn()



  # SWIG classes generated with -modern do not define this variable
try:
  _newclass
except NameError:
  _newclass = 1
else:
  raise RuntimeError("Require -modern option, but _newclass is defined")

_get_instance_attr = object.__getattribute__
_set_instance_attr = _swig_setattr_nondynamic_method(object.__setattr__)


import libsvn.core
import libsvn.delta
import libsvn.ra

def svn_wc_version() -> "svn_version_t const *":
    """svn_wc_version() -> svn_version_t const *"""
    return _wc.svn_wc_version()
SVN_WC_TRANSLATE_FROM_NF = _wc.SVN_WC_TRANSLATE_FROM_NF
SVN_WC_TRANSLATE_TO_NF = _wc.SVN_WC_TRANSLATE_TO_NF
SVN_WC_TRANSLATE_FORCE_EOL_REPAIR = _wc.SVN_WC_TRANSLATE_FORCE_EOL_REPAIR
SVN_WC_TRANSLATE_NO_OUTPUT_CLEANUP = _wc.SVN_WC_TRANSLATE_NO_OUTPUT_CLEANUP
SVN_WC_TRANSLATE_FORCE_COPY = _wc.SVN_WC_TRANSLATE_FORCE_COPY
SVN_WC_TRANSLATE_USE_GLOBAL_TMP = _wc.SVN_WC_TRANSLATE_USE_GLOBAL_TMP

def svn_wc_context_create(*args) -> "SWIGTYPE **":
    """svn_wc_context_create(svn_config_t const * config, apr_pool_t result_pool, apr_pool_t scratch_pool) -> svn_error_t"""
    return _wc.svn_wc_context_create(*args)

def svn_wc_context_destroy(wc_ctx: 'svn_wc_context_t *') -> "svn_error_t *":
    """svn_wc_context_destroy(svn_wc_context_t * wc_ctx) -> svn_error_t"""
    return _wc.svn_wc_context_destroy(wc_ctx)

def svn_wc_adm_open3(*args) -> "svn_wc_adm_access_t **":
    """svn_wc_adm_open3(svn_wc_adm_access_t * associated, char const * path, svn_boolean_t write_lock, int levels_to_lock, svn_cancel_func_t cancel_func, apr_pool_t pool) -> svn_error_t"""
    return _wc.svn_wc_adm_open3(*args)

def svn_wc_adm_open2(*args) -> "svn_wc_adm_access_t **":
    """svn_wc_adm_open2(svn_wc_adm_access_t * associated, char const * path, svn_boolean_t write_lock, int levels_to_lock, apr_pool_t pool) -> svn_error_t"""
    return _wc.svn_wc_adm_open2(*args)

def svn_wc_adm_open(*args) -> "svn_wc_adm_access_t **":
    """svn_wc_adm_open(svn_wc_adm_access_t * associated, char const * path, svn_boolean_t write_lock, svn_boolean_t tree_lock, apr_pool_t pool) -> svn_error_t"""
    return _wc.svn_wc_adm_open(*args)

def svn_wc_adm_probe_open3(*args) -> "svn_wc_adm_access_t **":
    """svn_wc_adm_probe_open3(svn_wc_adm_access_t * associated, char const * path, svn_boolean_t write_lock, int levels_to_lock, svn_cancel_func_t cancel_func, apr_pool_t pool) -> svn_error_t"""
    return _wc.svn_wc_adm_probe_open3(*args)

def svn_wc_adm_probe_open2(*args) -> "svn_wc_adm_access_t **":
    """svn_wc_adm_probe_open2(svn_wc_adm_access_t * associated, char const * path, svn_boolean_t write_lock, int levels_to_lock, apr_pool_t pool) -> svn_error_t"""
    return _wc.svn_wc_adm_probe_open2(*args)

def svn_wc_adm_probe_open(*args) -> "svn_wc_adm_access_t **":
    """svn_wc_adm_probe_open(svn_wc_adm_access_t * associated, char const * path, svn_boolean_t write_lock, svn_boolean_t tree_lock, apr_pool_t pool) -> svn_error_t"""
    return _wc.svn_wc_adm_probe_open(*args)

def svn_wc_adm_open_anchor(*args) -> "svn_wc_adm_access_t **, svn_wc_adm_access_t **, char const **":
    """svn_wc_adm_open_anchor(char const * path, svn_boolean_t write_lock, int levels_to_lock, svn_cancel_func_t cancel_func, apr_pool_t pool) -> svn_error_t"""
    return _wc.svn_wc_adm_open_anchor(*args)

def svn_wc_adm_retrieve(*args) -> "svn_wc_adm_access_t **":
    """svn_wc_adm_retrieve(svn_wc_adm_access_t * associated, char const * path, apr_pool_t pool) -> svn_error_t"""
    return _wc.svn_wc_adm_retrieve(*args)

def svn_wc_adm_probe_retrieve(*args) -> "svn_wc_adm_access_t **":
    """svn_wc_adm_probe_retrieve(svn_wc_adm_access_t * associated, char const * path, apr_pool_t pool) -> svn_error_t"""
    return _wc.svn_wc_adm_probe_retrieve(*args)

def svn_wc_adm_probe_try3(*args) -> "svn_wc_adm_access_t **":
    """svn_wc_adm_probe_try3(svn_wc_adm_access_t * associated, char const * path, svn_boolean_t write_lock, int levels_to_lock, svn_cancel_func_t cancel_func, apr_pool_t pool) -> svn_error_t"""
    return _wc.svn_wc_adm_probe_try3(*args)

def svn_wc_adm_probe_try2(*args) -> "svn_wc_adm_access_t **":
    """svn_wc_adm_probe_try2(svn_wc_adm_access_t * associated, char const * path, svn_boolean_t write_lock, int levels_to_lock, apr_pool_t pool) -> svn_error_t"""
    return _wc.svn_wc_adm_probe_try2(*args)

def svn_wc_adm_probe_try(*args) -> "svn_wc_adm_access_t **":
    """svn_wc_adm_probe_try(svn_wc_adm_access_t * associated, char const * path, svn_boolean_t write_lock, svn_boolean_t tree_lock, apr_pool_t pool) -> svn_error_t"""
    return _wc.svn_wc_adm_probe_try(*args)

def svn_wc_adm_close2(*args) -> "svn_error_t *":
    """svn_wc_adm_close2(svn_wc_adm_access_t * adm_access, apr_pool_t scratch_pool) -> svn_error_t"""
    return _wc.svn_wc_adm_close2(*args)

def svn_wc_adm_close(adm_access: 'svn_wc_adm_access_t *') -> "svn_error_t *":
    """svn_wc_adm_close(svn_wc_adm_access_t * adm_access) -> svn_error_t"""
    return _wc.svn_wc_adm_close(adm_access)

def svn_wc_adm_access_path(adm_access: 'svn_wc_adm_access_t const *') -> "char const *":
    """svn_wc_adm_access_path(svn_wc_adm_access_t const * adm_access) -> char const *"""
    return _wc.svn_wc_adm_access_path(adm_access)

def svn_wc_adm_access_pool(adm_access: 'svn_wc_adm_access_t const *') -> "apr_pool_t *":
    """svn_wc_adm_access_pool(svn_wc_adm_access_t const * adm_access) -> apr_pool_t"""
    return _wc.svn_wc_adm_access_pool(adm_access)

def svn_wc_adm_locked(adm_access: 'svn_wc_adm_access_t const *') -> "svn_boolean_t":
    """svn_wc_adm_locked(svn_wc_adm_access_t const * adm_access) -> svn_boolean_t"""
    return _wc.svn_wc_adm_locked(adm_access)

def svn_wc_locked2(*args) -> "svn_boolean_t *, svn_boolean_t *":
    """svn_wc_locked2(svn_wc_context_t * wc_ctx, char const * local_abspath, apr_pool_t scratch_pool) -> svn_error_t"""
    return _wc.svn_wc_locked2(*args)

def svn_wc_locked(*args) -> "svn_boolean_t *":
    """svn_wc_locked(char const * path, apr_pool_t pool) -> svn_error_t"""
    return _wc.svn_wc_locked(*args)
SVN_WC_ADM_DIR_NAME = _wc.SVN_WC_ADM_DIR_NAME

def svn_wc_is_adm_dir(*args) -> "svn_boolean_t":
    """svn_wc_is_adm_dir(char const * name, apr_pool_t pool) -> svn_boolean_t"""
    return _wc.svn_wc_is_adm_dir(*args)

def svn_wc_get_adm_dir(*args) -> "char const *":
    """svn_wc_get_adm_dir(apr_pool_t pool) -> char const *"""
    return _wc.svn_wc_get_adm_dir(*args)

def svn_wc_set_adm_dir(*args) -> "svn_error_t *":
    """svn_wc_set_adm_dir(char const * name, apr_pool_t pool) -> svn_error_t"""
    return _wc.svn_wc_set_adm_dir(*args)

def svn_wc_init_traversal_info(*args) -> "svn_wc_traversal_info_t *":
    """svn_wc_init_traversal_info(apr_pool_t pool) -> svn_wc_traversal_info_t *"""
    return _wc.svn_wc_init_traversal_info(*args)

def svn_wc_edited_externals(traversal_info: 'svn_wc_traversal_info_t *') -> "apr_hash_t **, apr_hash_t **":
    """svn_wc_edited_externals(svn_wc_traversal_info_t * traversal_info)"""
    return _wc.svn_wc_edited_externals(traversal_info)

def svn_wc_traversed_depths(traversal_info: 'svn_wc_traversal_info_t *') -> "apr_hash_t **":
    """svn_wc_traversed_depths(svn_wc_traversal_info_t * traversal_info)"""
    return _wc.svn_wc_traversed_depths(traversal_info)
class svn_wc_external_item2_t(object):
    """Proxy of C svn_wc_external_item2_t struct."""

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    target_dir = _swig_property(_wc.svn_wc_external_item2_t_target_dir_get, _wc.svn_wc_external_item2_t_target_dir_set)
    url = _swig_property(_wc.svn_wc_external_item2_t_url_get, _wc.svn_wc_external_item2_t_url_set)
    revision = _swig_property(_wc.svn_wc_external_item2_t_revision_get, _wc.svn_wc_external_item2_t_revision_set)
    peg_revision = _swig_property(_wc.svn_wc_external_item2_t_peg_revision_get, _wc.svn_wc_external_item2_t_peg_revision_set)
    def set_parent_pool(self, parent_pool=None):
      """Create a new proxy object for TYPE"""
      import libsvn.core, weakref
      self.__dict__["_parent_pool"] = \
        parent_pool or libsvn.core.application_pool;
      if self.__dict__["_parent_pool"]:
        self.__dict__["_is_valid"] = weakref.ref(
          self.__dict__["_parent_pool"]._is_valid)

    def assert_valid(self):
      """Assert that this object is using valid pool memory"""
      if "_is_valid" in self.__dict__:
        assert self.__dict__["_is_valid"](), "Variable has already been deleted"

    def _retrieve_swig_value(self, name, value):
    # If we got back a different object than we have cached, we need to copy
    # all our metadata into it, so that it looks identical to the one
    # originally set.
      members = self.__dict__.get('_members')
      if members is not None and name in members:
        _copy_metadata_deep(value, members[name])

    # Verify that the new object is good
      _assert_valid_deep(value)

      return value

    # Attribute access must be intercepted to ensure that objects coming from
    # read attribute access match those that are set with write attribute access.
    # Specifically the metadata, such as the associated apr_pool object, should
    # match the originally assigned object.
    #
    # For classic classes it is enough to use __getattr__ to intercept swig
    # derived attributes. However, with new style classes SWIG makes use of
    # descriptors which mean that __getattr__ is never called. Therefore,
    # __getattribute__ must be used for the interception.

    if _newclass:
      def __getattribute__(self, name):
        """Manage access to all attributes of this object."""

    # Start by mimicing __getattr__ behavior: immediately return __dict__ or
    # items directly present in __dict__
        mydict = object.__getattribute__(self, '__dict__')

        if name == "__dict__":
          return mydict

        if name in mydict:
          return mydict[name]

        object.__getattribute__(self, 'assert_valid')()

        value = _get_instance_attr(self, name)
        fn = object.__getattribute__(self, '_retrieve_swig_value')
        return fn(name, value)
    else:
      def __getattr__(self, name):
        """Get an attribute from this object"""
        self.assert_valid()

        value = _swig_getattr(self, self.__class__, name)

        return self._retrieve_swig_value(name, value)

    def __setattr__(self, name, value):
      """Set an attribute on this object"""
      self.assert_valid()

    # Save a copy of the object, so that the garbage
    # collector won't kill the object while it's in
    # SWIG-land
      self.__dict__.setdefault("_members",{})[name] = value

      return _set_instance_attr(self, name, value)


    def __init__(self):
        """__init__(svn_wc_external_item2_t self) -> svn_wc_external_item2_t"""
        this = _wc.new_svn_wc_external_item2_t()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _wc.delete_svn_wc_external_item2_t
    __del__ = lambda self: None
svn_wc_external_item2_t_swigregister = _wc.svn_wc_external_item2_t_swigregister
svn_wc_external_item2_t_swigregister(svn_wc_external_item2_t)


def svn_wc_external_item2_create(*args) -> "svn_wc_external_item2_t **":
    """svn_wc_external_item2_create(apr_pool_t pool) -> svn_error_t"""
    return _wc.svn_wc_external_item2_create(*args)

def svn_wc_external_item_create(*args) -> "svn_wc_external_item2_t **":
    """svn_wc_external_item_create(apr_pool_t pool) -> svn_error_t"""
    return _wc.svn_wc_external_item_create(*args)

def svn_wc_external_item2_dup(*args) -> "svn_wc_external_item2_t *":
    """svn_wc_external_item2_dup(svn_wc_external_item2_t item, apr_pool_t pool) -> svn_wc_external_item2_t"""
    return _wc.svn_wc_external_item2_dup(*args)
class svn_wc_external_item_t(object):
    """Proxy of C svn_wc_external_item_t struct."""

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    target_dir = _swig_property(_wc.svn_wc_external_item_t_target_dir_get, _wc.svn_wc_external_item_t_target_dir_set)
    url = _swig_property(_wc.svn_wc_external_item_t_url_get, _wc.svn_wc_external_item_t_url_set)
    revision = _swig_property(_wc.svn_wc_external_item_t_revision_get, _wc.svn_wc_external_item_t_revision_set)
    def set_parent_pool(self, parent_pool=None):
      """Create a new proxy object for TYPE"""
      import libsvn.core, weakref
      self.__dict__["_parent_pool"] = \
        parent_pool or libsvn.core.application_pool;
      if self.__dict__["_parent_pool"]:
        self.__dict__["_is_valid"] = weakref.ref(
          self.__dict__["_parent_pool"]._is_valid)

    def assert_valid(self):
      """Assert that this object is using valid pool memory"""
      if "_is_valid" in self.__dict__:
        assert self.__dict__["_is_valid"](), "Variable has already been deleted"

    def _retrieve_swig_value(self, name, value):
    # If we got back a different object than we have cached, we need to copy
    # all our metadata into it, so that it looks identical to the one
    # originally set.
      members = self.__dict__.get('_members')
      if members is not None and name in members:
        _copy_metadata_deep(value, members[name])

    # Verify that the new object is good
      _assert_valid_deep(value)

      return value

    # Attribute access must be intercepted to ensure that objects coming from
    # read attribute access match those that are set with write attribute access.
    # Specifically the metadata, such as the associated apr_pool object, should
    # match the originally assigned object.
    #
    # For classic classes it is enough to use __getattr__ to intercept swig
    # derived attributes. However, with new style classes SWIG makes use of
    # descriptors which mean that __getattr__ is never called. Therefore,
    # __getattribute__ must be used for the interception.

    if _newclass:
      def __getattribute__(self, name):
        """Manage access to all attributes of this object."""

    # Start by mimicing __getattr__ behavior: immediately return __dict__ or
    # items directly present in __dict__
        mydict = object.__getattribute__(self, '__dict__')

        if name == "__dict__":
          return mydict

        if name in mydict:
          return mydict[name]

        object.__getattribute__(self, 'assert_valid')()

        value = _get_instance_attr(self, name)
        fn = object.__getattribute__(self, '_retrieve_swig_value')
        return fn(name, value)
    else:
      def __getattr__(self, name):
        """Get an attribute from this object"""
        self.assert_valid()

        value = _swig_getattr(self, self.__class__, name)

        return self._retrieve_swig_value(name, value)

    def __setattr__(self, name, value):
      """Set an attribute on this object"""
      self.assert_valid()

    # Save a copy of the object, so that the garbage
    # collector won't kill the object while it's in
    # SWIG-land
      self.__dict__.setdefault("_members",{})[name] = value

      return _set_instance_attr(self, name, value)


    def __init__(self):
        """__init__(svn_wc_external_item_t self) -> svn_wc_external_item_t"""
        this = _wc.new_svn_wc_external_item_t()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _wc.delete_svn_wc_external_item_t
    __del__ = lambda self: None
svn_wc_external_item_t_swigregister = _wc.svn_wc_external_item_t_swigregister
svn_wc_external_item_t_swigregister(svn_wc_external_item_t)


def svn_wc_external_item_dup(*args) -> "svn_wc_external_item_t *":
    """svn_wc_external_item_dup(svn_wc_external_item_t item, apr_pool_t pool) -> svn_wc_external_item_t"""
    return _wc.svn_wc_external_item_dup(*args)

def svn_wc_parse_externals_description3(*args) -> "apr_array_header_t **":
    """svn_wc_parse_externals_description3(char const * defining_directory, char const * desc, svn_boolean_t canonicalize_url, apr_pool_t pool) -> svn_error_t"""
    return _wc.svn_wc_parse_externals_description3(*args)

def svn_wc_parse_externals_description2(*args) -> "apr_array_header_t **":
    """svn_wc_parse_externals_description2(char const * parent_directory, char const * desc, apr_pool_t pool) -> svn_error_t"""
    return _wc.svn_wc_parse_externals_description2(*args)

def svn_wc_parse_externals_description(*args) -> "apr_hash_t **":
    """svn_wc_parse_externals_description(char const * parent_directory, char const * desc, apr_pool_t pool) -> svn_error_t"""
    return _wc.svn_wc_parse_externals_description(*args)
svn_wc_notify_add = _wc.svn_wc_notify_add
svn_wc_notify_copy = _wc.svn_wc_notify_copy
svn_wc_notify_delete = _wc.svn_wc_notify_delete
svn_wc_notify_restore = _wc.svn_wc_notify_restore
svn_wc_notify_revert = _wc.svn_wc_notify_revert
svn_wc_notify_failed_revert = _wc.svn_wc_notify_failed_revert
svn_wc_notify_resolved = _wc.svn_wc_notify_resolved
svn_wc_notify_skip = _wc.svn_wc_notify_skip
svn_wc_notify_update_delete = _wc.svn_wc_notify_update_delete
svn_wc_notify_update_add = _wc.svn_wc_notify_update_add
svn_wc_notify_update_update = _wc.svn_wc_notify_update_update
svn_wc_notify_update_completed = _wc.svn_wc_notify_update_completed
svn_wc_notify_update_external = _wc.svn_wc_notify_update_external
svn_wc_notify_status_completed = _wc.svn_wc_notify_status_completed
svn_wc_notify_status_external = _wc.svn_wc_notify_status_external
svn_wc_notify_commit_modified = _wc.svn_wc_notify_commit_modified
svn_wc_notify_commit_added = _wc.svn_wc_notify_commit_added
svn_wc_notify_commit_deleted = _wc.svn_wc_notify_commit_deleted
svn_wc_notify_commit_replaced = _wc.svn_wc_notify_commit_replaced
svn_wc_notify_commit_postfix_txdelta = _wc.svn_wc_notify_commit_postfix_txdelta
svn_wc_notify_blame_revision = _wc.svn_wc_notify_blame_revision
svn_wc_notify_locked = _wc.svn_wc_notify_locked
svn_wc_notify_unlocked = _wc.svn_wc_notify_unlocked
svn_wc_notify_failed_lock = _wc.svn_wc_notify_failed_lock
svn_wc_notify_failed_unlock = _wc.svn_wc_notify_failed_unlock
svn_wc_notify_exists = _wc.svn_wc_notify_exists
svn_wc_notify_changelist_set = _wc.svn_wc_notify_changelist_set
svn_wc_notify_changelist_clear = _wc.svn_wc_notify_changelist_clear
svn_wc_notify_changelist_moved = _wc.svn_wc_notify_changelist_moved
svn_wc_notify_merge_begin = _wc.svn_wc_notify_merge_begin
svn_wc_notify_foreign_merge_begin = _wc.svn_wc_notify_foreign_merge_begin
svn_wc_notify_update_replace = _wc.svn_wc_notify_update_replace
svn_wc_notify_property_added = _wc.svn_wc_notify_property_added
svn_wc_notify_property_modified = _wc.svn_wc_notify_property_modified
svn_wc_notify_property_deleted = _wc.svn_wc_notify_property_deleted
svn_wc_notify_property_deleted_nonexistent = _wc.svn_wc_notify_property_deleted_nonexistent
svn_wc_notify_revprop_set = _wc.svn_wc_notify_revprop_set
svn_wc_notify_revprop_deleted = _wc.svn_wc_notify_revprop_deleted
svn_wc_notify_merge_completed = _wc.svn_wc_notify_merge_completed
svn_wc_notify_tree_conflict = _wc.svn_wc_notify_tree_conflict
svn_wc_notify_failed_external = _wc.svn_wc_notify_failed_external
svn_wc_notify_update_started = _wc.svn_wc_notify_update_started
svn_wc_notify_update_skip_obstruction = _wc.svn_wc_notify_update_skip_obstruction
svn_wc_notify_update_skip_working_only = _wc.svn_wc_notify_update_skip_working_only
svn_wc_notify_update_skip_access_denied = _wc.svn_wc_notify_update_skip_access_denied
svn_wc_notify_update_external_removed = _wc.svn_wc_notify_update_external_removed
svn_wc_notify_update_shadowed_add = _wc.svn_wc_notify_update_shadowed_add
svn_wc_notify_update_shadowed_update = _wc.svn_wc_notify_update_shadowed_update
svn_wc_notify_update_shadowed_delete = _wc.svn_wc_notify_update_shadowed_delete
svn_wc_notify_merge_record_info = _wc.svn_wc_notify_merge_record_info
svn_wc_notify_upgraded_path = _wc.svn_wc_notify_upgraded_path
svn_wc_notify_merge_record_info_begin = _wc.svn_wc_notify_merge_record_info_begin
svn_wc_notify_merge_elide_info = _wc.svn_wc_notify_merge_elide_info
svn_wc_notify_patch = _wc.svn_wc_notify_patch
svn_wc_notify_patch_applied_hunk = _wc.svn_wc_notify_patch_applied_hunk
svn_wc_notify_patch_rejected_hunk = _wc.svn_wc_notify_patch_rejected_hunk
svn_wc_notify_patch_hunk_already_applied = _wc.svn_wc_notify_patch_hunk_already_applied
svn_wc_notify_commit_copied = _wc.svn_wc_notify_commit_copied
svn_wc_notify_commit_copied_replaced = _wc.svn_wc_notify_commit_copied_replaced
svn_wc_notify_url_redirect = _wc.svn_wc_notify_url_redirect
svn_wc_notify_path_nonexistent = _wc.svn_wc_notify_path_nonexistent
svn_wc_notify_exclude = _wc.svn_wc_notify_exclude
svn_wc_notify_failed_conflict = _wc.svn_wc_notify_failed_conflict
svn_wc_notify_failed_missing = _wc.svn_wc_notify_failed_missing
svn_wc_notify_failed_out_of_date = _wc.svn_wc_notify_failed_out_of_date
svn_wc_notify_failed_no_parent = _wc.svn_wc_notify_failed_no_parent
svn_wc_notify_failed_locked = _wc.svn_wc_notify_failed_locked
svn_wc_notify_failed_forbidden_by_server = _wc.svn_wc_notify_failed_forbidden_by_server
svn_wc_notify_skip_conflicted = _wc.svn_wc_notify_skip_conflicted
svn_wc_notify_update_broken_lock = _wc.svn_wc_notify_update_broken_lock
svn_wc_notify_failed_obstruction = _wc.svn_wc_notify_failed_obstruction
svn_wc_notify_conflict_resolver_starting = _wc.svn_wc_notify_conflict_resolver_starting
svn_wc_notify_conflict_resolver_done = _wc.svn_wc_notify_conflict_resolver_done
svn_wc_notify_left_local_modifications = _wc.svn_wc_notify_left_local_modifications
svn_wc_notify_foreign_copy_begin = _wc.svn_wc_notify_foreign_copy_begin
svn_wc_notify_move_broken = _wc.svn_wc_notify_move_broken
svn_wc_notify_cleanup_external = _wc.svn_wc_notify_cleanup_external
svn_wc_notify_failed_requires_target = _wc.svn_wc_notify_failed_requires_target
svn_wc_notify_info_external = _wc.svn_wc_notify_info_external
svn_wc_notify_commit_finalizing = _wc.svn_wc_notify_commit_finalizing
svn_wc_notify_resolved_text = _wc.svn_wc_notify_resolved_text
svn_wc_notify_resolved_prop = _wc.svn_wc_notify_resolved_prop
svn_wc_notify_resolved_tree = _wc.svn_wc_notify_resolved_tree
svn_wc_notify_begin_search_tree_conflict_details = _wc.svn_wc_notify_begin_search_tree_conflict_details
svn_wc_notify_tree_conflict_details_progress = _wc.svn_wc_notify_tree_conflict_details_progress
svn_wc_notify_end_search_tree_conflict_details = _wc.svn_wc_notify_end_search_tree_conflict_details
svn_wc_notify_state_inapplicable = _wc.svn_wc_notify_state_inapplicable
svn_wc_notify_state_unknown = _wc.svn_wc_notify_state_unknown
svn_wc_notify_state_unchanged = _wc.svn_wc_notify_state_unchanged
svn_wc_notify_state_missing = _wc.svn_wc_notify_state_missing
svn_wc_notify_state_obstructed = _wc.svn_wc_notify_state_obstructed
svn_wc_notify_state_changed = _wc.svn_wc_notify_state_changed
svn_wc_notify_state_merged = _wc.svn_wc_notify_state_merged
svn_wc_notify_state_conflicted = _wc.svn_wc_notify_state_conflicted
svn_wc_notify_state_source_missing = _wc.svn_wc_notify_state_source_missing
svn_wc_notify_lock_state_inapplicable = _wc.svn_wc_notify_lock_state_inapplicable
svn_wc_notify_lock_state_unknown = _wc.svn_wc_notify_lock_state_unknown
svn_wc_notify_lock_state_unchanged = _wc.svn_wc_notify_lock_state_unchanged
svn_wc_notify_lock_state_locked = _wc.svn_wc_notify_lock_state_locked
svn_wc_notify_lock_state_unlocked = _wc.svn_wc_notify_lock_state_unlocked
class svn_wc_notify_t(object):
    """Proxy of C svn_wc_notify_t struct."""

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    path = _swig_property(_wc.svn_wc_notify_t_path_get, _wc.svn_wc_notify_t_path_set)
    action = _swig_property(_wc.svn_wc_notify_t_action_get, _wc.svn_wc_notify_t_action_set)
    kind = _swig_property(_wc.svn_wc_notify_t_kind_get, _wc.svn_wc_notify_t_kind_set)
    mime_type = _swig_property(_wc.svn_wc_notify_t_mime_type_get, _wc.svn_wc_notify_t_mime_type_set)
    lock = _swig_property(_wc.svn_wc_notify_t_lock_get, _wc.svn_wc_notify_t_lock_set)
    err = _swig_property(_wc.svn_wc_notify_t_err_get, _wc.svn_wc_notify_t_err_set)
    content_state = _swig_property(_wc.svn_wc_notify_t_content_state_get, _wc.svn_wc_notify_t_content_state_set)
    prop_state = _swig_property(_wc.svn_wc_notify_t_prop_state_get, _wc.svn_wc_notify_t_prop_state_set)
    lock_state = _swig_property(_wc.svn_wc_notify_t_lock_state_get, _wc.svn_wc_notify_t_lock_state_set)
    revision = _swig_property(_wc.svn_wc_notify_t_revision_get, _wc.svn_wc_notify_t_revision_set)
    changelist_name = _swig_property(_wc.svn_wc_notify_t_changelist_name_get, _wc.svn_wc_notify_t_changelist_name_set)
    merge_range = _swig_property(_wc.svn_wc_notify_t_merge_range_get, _wc.svn_wc_notify_t_merge_range_set)
    url = _swig_property(_wc.svn_wc_notify_t_url_get, _wc.svn_wc_notify_t_url_set)
    path_prefix = _swig_property(_wc.svn_wc_notify_t_path_prefix_get, _wc.svn_wc_notify_t_path_prefix_set)
    prop_name = _swig_property(_wc.svn_wc_notify_t_prop_name_get, _wc.svn_wc_notify_t_prop_name_set)
    rev_props = _swig_property(_wc.svn_wc_notify_t_rev_props_get, _wc.svn_wc_notify_t_rev_props_set)
    old_revision = _swig_property(_wc.svn_wc_notify_t_old_revision_get, _wc.svn_wc_notify_t_old_revision_set)
    hunk_original_start = _swig_property(_wc.svn_wc_notify_t_hunk_original_start_get, _wc.svn_wc_notify_t_hunk_original_start_set)
    hunk_original_length = _swig_property(_wc.svn_wc_notify_t_hunk_original_length_get, _wc.svn_wc_notify_t_hunk_original_length_set)
    hunk_modified_start = _swig_property(_wc.svn_wc_notify_t_hunk_modified_start_get, _wc.svn_wc_notify_t_hunk_modified_start_set)
    hunk_modified_length = _swig_property(_wc.svn_wc_notify_t_hunk_modified_length_get, _wc.svn_wc_notify_t_hunk_modified_length_set)
    hunk_matched_line = _swig_property(_wc.svn_wc_notify_t_hunk_matched_line_get, _wc.svn_wc_notify_t_hunk_matched_line_set)
    hunk_fuzz = _swig_property(_wc.svn_wc_notify_t_hunk_fuzz_get, _wc.svn_wc_notify_t_hunk_fuzz_set)
    def set_parent_pool(self, parent_pool=None):
      """Create a new proxy object for TYPE"""
      import libsvn.core, weakref
      self.__dict__["_parent_pool"] = \
        parent_pool or libsvn.core.application_pool;
      if self.__dict__["_parent_pool"]:
        self.__dict__["_is_valid"] = weakref.ref(
          self.__dict__["_parent_pool"]._is_valid)

    def assert_valid(self):
      """Assert that this object is using valid pool memory"""
      if "_is_valid" in self.__dict__:
        assert self.__dict__["_is_valid"](), "Variable has already been deleted"

    def _retrieve_swig_value(self, name, value):
    # If we got back a different object than we have cached, we need to copy
    # all our metadata into it, so that it looks identical to the one
    # originally set.
      members = self.__dict__.get('_members')
      if members is not None and name in members:
        _copy_metadata_deep(value, members[name])

    # Verify that the new object is good
      _assert_valid_deep(value)

      return value

    # Attribute access must be intercepted to ensure that objects coming from
    # read attribute access match those that are set with write attribute access.
    # Specifically the metadata, such as the associated apr_pool object, should
    # match the originally assigned object.
    #
    # For classic classes it is enough to use __getattr__ to intercept swig
    # derived attributes. However, with new style classes SWIG makes use of
    # descriptors which mean that __getattr__ is never called. Therefore,
    # __getattribute__ must be used for the interception.

    if _newclass:
      def __getattribute__(self, name):
        """Manage access to all attributes of this object."""

    # Start by mimicing __getattr__ behavior: immediately return __dict__ or
    # items directly present in __dict__
        mydict = object.__getattribute__(self, '__dict__')

        if name == "__dict__":
          return mydict

        if name in mydict:
          return mydict[name]

        object.__getattribute__(self, 'assert_valid')()

        value = _get_instance_attr(self, name)
        fn = object.__getattribute__(self, '_retrieve_swig_value')
        return fn(name, value)
    else:
      def __getattr__(self, name):
        """Get an attribute from this object"""
        self.assert_valid()

        value = _swig_getattr(self, self.__class__, name)

        return self._retrieve_swig_value(name, value)

    def __setattr__(self, name, value):
      """Set an attribute on this object"""
      self.assert_valid()

    # Save a copy of the object, so that the garbage
    # collector won't kill the object while it's in
    # SWIG-land
      self.__dict__.setdefault("_members",{})[name] = value

      return _set_instance_attr(self, name, value)


    def __init__(self):
        """__init__(svn_wc_notify_t self) -> svn_wc_notify_t"""
        this = _wc.new_svn_wc_notify_t()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _wc.delete_svn_wc_notify_t
    __del__ = lambda self: None
svn_wc_notify_t_swigregister = _wc.svn_wc_notify_t_swigregister
svn_wc_notify_t_swigregister(svn_wc_notify_t)


def svn_wc_create_notify(*args) -> "svn_wc_notify_t *":
    """svn_wc_create_notify(char const * path, svn_wc_notify_action_t action, apr_pool_t pool) -> svn_wc_notify_t"""
    return _wc.svn_wc_create_notify(*args)

def svn_wc_create_notify_url(*args) -> "svn_wc_notify_t *":
    """svn_wc_create_notify_url(char const * url, svn_wc_notify_action_t action, apr_pool_t pool) -> svn_wc_notify_t"""
    return _wc.svn_wc_create_notify_url(*args)

def svn_wc_dup_notify(*args) -> "svn_wc_notify_t *":
    """svn_wc_dup_notify(svn_wc_notify_t notify, apr_pool_t pool) -> svn_wc_notify_t"""
    return _wc.svn_wc_dup_notify(*args)
svn_wc_conflict_action_edit = _wc.svn_wc_conflict_action_edit
svn_wc_conflict_action_add = _wc.svn_wc_conflict_action_add
svn_wc_conflict_action_delete = _wc.svn_wc_conflict_action_delete
svn_wc_conflict_action_replace = _wc.svn_wc_conflict_action_replace
svn_wc_conflict_reason_edited = _wc.svn_wc_conflict_reason_edited
svn_wc_conflict_reason_obstructed = _wc.svn_wc_conflict_reason_obstructed
svn_wc_conflict_reason_deleted = _wc.svn_wc_conflict_reason_deleted
svn_wc_conflict_reason_missing = _wc.svn_wc_conflict_reason_missing
svn_wc_conflict_reason_unversioned = _wc.svn_wc_conflict_reason_unversioned
svn_wc_conflict_reason_added = _wc.svn_wc_conflict_reason_added
svn_wc_conflict_reason_replaced = _wc.svn_wc_conflict_reason_replaced
svn_wc_conflict_reason_moved_away = _wc.svn_wc_conflict_reason_moved_away
svn_wc_conflict_reason_moved_here = _wc.svn_wc_conflict_reason_moved_here
svn_wc_conflict_kind_text = _wc.svn_wc_conflict_kind_text
svn_wc_conflict_kind_property = _wc.svn_wc_conflict_kind_property
svn_wc_conflict_kind_tree = _wc.svn_wc_conflict_kind_tree
svn_wc_operation_none = _wc.svn_wc_operation_none
svn_wc_operation_update = _wc.svn_wc_operation_update
svn_wc_operation_switch = _wc.svn_wc_operation_switch
svn_wc_operation_merge = _wc.svn_wc_operation_merge
class svn_wc_conflict_version_t(object):
    """Proxy of C svn_wc_conflict_version_t struct."""

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    repos_url = _swig_property(_wc.svn_wc_conflict_version_t_repos_url_get, _wc.svn_wc_conflict_version_t_repos_url_set)
    peg_rev = _swig_property(_wc.svn_wc_conflict_version_t_peg_rev_get, _wc.svn_wc_conflict_version_t_peg_rev_set)
    path_in_repos = _swig_property(_wc.svn_wc_conflict_version_t_path_in_repos_get, _wc.svn_wc_conflict_version_t_path_in_repos_set)
    node_kind = _swig_property(_wc.svn_wc_conflict_version_t_node_kind_get, _wc.svn_wc_conflict_version_t_node_kind_set)
    repos_uuid = _swig_property(_wc.svn_wc_conflict_version_t_repos_uuid_get, _wc.svn_wc_conflict_version_t_repos_uuid_set)
    def set_parent_pool(self, parent_pool=None):
      """Create a new proxy object for TYPE"""
      import libsvn.core, weakref
      self.__dict__["_parent_pool"] = \
        parent_pool or libsvn.core.application_pool;
      if self.__dict__["_parent_pool"]:
        self.__dict__["_is_valid"] = weakref.ref(
          self.__dict__["_parent_pool"]._is_valid)

    def assert_valid(self):
      """Assert that this object is using valid pool memory"""
      if "_is_valid" in self.__dict__:
        assert self.__dict__["_is_valid"](), "Variable has already been deleted"

    def _retrieve_swig_value(self, name, value):
    # If we got back a different object than we have cached, we need to copy
    # all our metadata into it, so that it looks identical to the one
    # originally set.
      members = self.__dict__.get('_members')
      if members is not None and name in members:
        _copy_metadata_deep(value, members[name])

    # Verify that the new object is good
      _assert_valid_deep(value)

      return value

    # Attribute access must be intercepted to ensure that objects coming from
    # read attribute access match those that are set with write attribute access.
    # Specifically the metadata, such as the associated apr_pool object, should
    # match the originally assigned object.
    #
    # For classic classes it is enough to use __getattr__ to intercept swig
    # derived attributes. However, with new style classes SWIG makes use of
    # descriptors which mean that __getattr__ is never called. Therefore,
    # __getattribute__ must be used for the interception.

    if _newclass:
      def __getattribute__(self, name):
        """Manage access to all attributes of this object."""

    # Start by mimicing __getattr__ behavior: immediately return __dict__ or
    # items directly present in __dict__
        mydict = object.__getattribute__(self, '__dict__')

        if name == "__dict__":
          return mydict

        if name in mydict:
          return mydict[name]

        object.__getattribute__(self, 'assert_valid')()

        value = _get_instance_attr(self, name)
        fn = object.__getattribute__(self, '_retrieve_swig_value')
        return fn(name, value)
    else:
      def __getattr__(self, name):
        """Get an attribute from this object"""
        self.assert_valid()

        value = _swig_getattr(self, self.__class__, name)

        return self._retrieve_swig_value(name, value)

    def __setattr__(self, name, value):
      """Set an attribute on this object"""
      self.assert_valid()

    # Save a copy of the object, so that the garbage
    # collector won't kill the object while it's in
    # SWIG-land
      self.__dict__.setdefault("_members",{})[name] = value

      return _set_instance_attr(self, name, value)


    def __init__(self):
        """__init__(svn_wc_conflict_version_t self) -> svn_wc_conflict_version_t"""
        this = _wc.new_svn_wc_conflict_version_t()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _wc.delete_svn_wc_conflict_version_t
    __del__ = lambda self: None
svn_wc_conflict_version_t_swigregister = _wc.svn_wc_conflict_version_t_swigregister
svn_wc_conflict_version_t_swigregister(svn_wc_conflict_version_t)


def svn_wc_conflict_version_create2(*args) -> "svn_wc_conflict_version_t *":
    """svn_wc_conflict_version_create2(char const * repos_root_url, char const * repos_uuid, char const * repos_relpath, svn_revnum_t revision, svn_node_kind_t kind, apr_pool_t result_pool) -> svn_wc_conflict_version_t"""
    return _wc.svn_wc_conflict_version_create2(*args)

def svn_wc_conflict_version_create(*args) -> "svn_wc_conflict_version_t *":
    """svn_wc_conflict_version_create(char const * repos_url, char const * path_in_repos, svn_revnum_t peg_rev, svn_node_kind_t node_kind, apr_pool_t pool) -> svn_wc_conflict_version_t"""
    return _wc.svn_wc_conflict_version_create(*args)

def svn_wc_conflict_version_dup(*args) -> "svn_wc_conflict_version_t *":
    """svn_wc_conflict_version_dup(svn_wc_conflict_version_t version, apr_pool_t pool) -> svn_wc_conflict_version_t"""
    return _wc.svn_wc_conflict_version_dup(*args)
class svn_wc_conflict_description_t(object):
    """Proxy of C svn_wc_conflict_description_t struct."""

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    path = _swig_property(_wc.svn_wc_conflict_description_t_path_get, _wc.svn_wc_conflict_description_t_path_set)
    node_kind = _swig_property(_wc.svn_wc_conflict_description_t_node_kind_get, _wc.svn_wc_conflict_description_t_node_kind_set)
    kind = _swig_property(_wc.svn_wc_conflict_description_t_kind_get, _wc.svn_wc_conflict_description_t_kind_set)
    property_name = _swig_property(_wc.svn_wc_conflict_description_t_property_name_get, _wc.svn_wc_conflict_description_t_property_name_set)
    is_binary = _swig_property(_wc.svn_wc_conflict_description_t_is_binary_get, _wc.svn_wc_conflict_description_t_is_binary_set)
    mime_type = _swig_property(_wc.svn_wc_conflict_description_t_mime_type_get, _wc.svn_wc_conflict_description_t_mime_type_set)
    access = _swig_property(_wc.svn_wc_conflict_description_t_access_get, _wc.svn_wc_conflict_description_t_access_set)
    action = _swig_property(_wc.svn_wc_conflict_description_t_action_get, _wc.svn_wc_conflict_description_t_action_set)
    reason = _swig_property(_wc.svn_wc_conflict_description_t_reason_get, _wc.svn_wc_conflict_description_t_reason_set)
    base_file = _swig_property(_wc.svn_wc_conflict_description_t_base_file_get, _wc.svn_wc_conflict_description_t_base_file_set)
    their_file = _swig_property(_wc.svn_wc_conflict_description_t_their_file_get, _wc.svn_wc_conflict_description_t_their_file_set)
    my_file = _swig_property(_wc.svn_wc_conflict_description_t_my_file_get, _wc.svn_wc_conflict_description_t_my_file_set)
    merged_file = _swig_property(_wc.svn_wc_conflict_description_t_merged_file_get, _wc.svn_wc_conflict_description_t_merged_file_set)
    operation = _swig_property(_wc.svn_wc_conflict_description_t_operation_get, _wc.svn_wc_conflict_description_t_operation_set)
    src_left_version = _swig_property(_wc.svn_wc_conflict_description_t_src_left_version_get, _wc.svn_wc_conflict_description_t_src_left_version_set)
    src_right_version = _swig_property(_wc.svn_wc_conflict_description_t_src_right_version_get, _wc.svn_wc_conflict_description_t_src_right_version_set)
    def set_parent_pool(self, parent_pool=None):
      """Create a new proxy object for TYPE"""
      import libsvn.core, weakref
      self.__dict__["_parent_pool"] = \
        parent_pool or libsvn.core.application_pool;
      if self.__dict__["_parent_pool"]:
        self.__dict__["_is_valid"] = weakref.ref(
          self.__dict__["_parent_pool"]._is_valid)

    def assert_valid(self):
      """Assert that this object is using valid pool memory"""
      if "_is_valid" in self.__dict__:
        assert self.__dict__["_is_valid"](), "Variable has already been deleted"

    def _retrieve_swig_value(self, name, value):
    # If we got back a different object than we have cached, we need to copy
    # all our metadata into it, so that it looks identical to the one
    # originally set.
      members = self.__dict__.get('_members')
      if members is not None and name in members:
        _copy_metadata_deep(value, members[name])

    # Verify that the new object is good
      _assert_valid_deep(value)

      return value

    # Attribute access must be intercepted to ensure that objects coming from
    # read attribute access match those that are set with write attribute access.
    # Specifically the metadata, such as the associated apr_pool object, should
    # match the originally assigned object.
    #
    # For classic classes it is enough to use __getattr__ to intercept swig
    # derived attributes. However, with new style classes SWIG makes use of
    # descriptors which mean that __getattr__ is never called. Therefore,
    # __getattribute__ must be used for the interception.

    if _newclass:
      def __getattribute__(self, name):
        """Manage access to all attributes of this object."""

    # Start by mimicing __getattr__ behavior: immediately return __dict__ or
    # items directly present in __dict__
        mydict = object.__getattribute__(self, '__dict__')

        if name == "__dict__":
          return mydict

        if name in mydict:
          return mydict[name]

        object.__getattribute__(self, 'assert_valid')()

        value = _get_instance_attr(self, name)
        fn = object.__getattribute__(self, '_retrieve_swig_value')
        return fn(name, value)
    else:
      def __getattr__(self, name):
        """Get an attribute from this object"""
        self.assert_valid()

        value = _swig_getattr(self, self.__class__, name)

        return self._retrieve_swig_value(name, value)

    def __setattr__(self, name, value):
      """Set an attribute on this object"""
      self.assert_valid()

    # Save a copy of the object, so that the garbage
    # collector won't kill the object while it's in
    # SWIG-land
      self.__dict__.setdefault("_members",{})[name] = value

      return _set_instance_attr(self, name, value)


    def __init__(self):
        """__init__(svn_wc_conflict_description_t self) -> svn_wc_conflict_description_t"""
        this = _wc.new_svn_wc_conflict_description_t()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _wc.delete_svn_wc_conflict_description_t
    __del__ = lambda self: None
svn_wc_conflict_description_t_swigregister = _wc.svn_wc_conflict_description_t_swigregister
svn_wc_conflict_description_t_swigregister(svn_wc_conflict_description_t)


def svn_wc_conflict_description_create_text2(*args) -> "svn_wc_conflict_description2_t *":
    """svn_wc_conflict_description_create_text2(char const * local_abspath, apr_pool_t result_pool) -> svn_wc_conflict_description2_t *"""
    return _wc.svn_wc_conflict_description_create_text2(*args)

def svn_wc_conflict_description_create_text(*args) -> "svn_wc_conflict_description_t *":
    """svn_wc_conflict_description_create_text(char const * path, svn_wc_adm_access_t * adm_access, apr_pool_t pool) -> svn_wc_conflict_description_t"""
    return _wc.svn_wc_conflict_description_create_text(*args)

def svn_wc_conflict_description_create_prop2(*args) -> "svn_wc_conflict_description2_t *":
    """svn_wc_conflict_description_create_prop2(char const * local_abspath, svn_node_kind_t node_kind, char const * property_name, apr_pool_t result_pool) -> svn_wc_conflict_description2_t *"""
    return _wc.svn_wc_conflict_description_create_prop2(*args)

def svn_wc_conflict_description_create_prop(*args) -> "svn_wc_conflict_description_t *":
    """svn_wc_conflict_description_create_prop(char const * path, svn_wc_adm_access_t * adm_access, svn_node_kind_t node_kind, char const * property_name, apr_pool_t pool) -> svn_wc_conflict_description_t"""
    return _wc.svn_wc_conflict_description_create_prop(*args)

def svn_wc_conflict_description_create_tree2(*args) -> "svn_wc_conflict_description2_t *":
    """svn_wc_conflict_description_create_tree2(char const * local_abspath, svn_node_kind_t node_kind, svn_wc_operation_t operation, svn_wc_conflict_version_t src_left_version, svn_wc_conflict_version_t src_right_version, apr_pool_t result_pool) -> svn_wc_conflict_description2_t *"""
    return _wc.svn_wc_conflict_description_create_tree2(*args)

def svn_wc_conflict_description_create_tree(*args) -> "svn_wc_conflict_description_t *":
    """svn_wc_conflict_description_create_tree(char const * path, svn_wc_adm_access_t * adm_access, svn_node_kind_t node_kind, svn_wc_operation_t operation, svn_wc_conflict_version_t src_left_version, svn_wc_conflict_version_t src_right_version, apr_pool_t pool) -> svn_wc_conflict_description_t"""
    return _wc.svn_wc_conflict_description_create_tree(*args)

def svn_wc_conflict_description2_dup(*args) -> "svn_wc_conflict_description2_t *":
    """svn_wc_conflict_description2_dup(svn_wc_conflict_description2_t const * conflict, apr_pool_t result_pool) -> svn_wc_conflict_description2_t *"""
    return _wc.svn_wc_conflict_description2_dup(*args)

def svn_wc__conflict_description2_dup(*args) -> "svn_wc_conflict_description2_t *":
    """svn_wc__conflict_description2_dup(svn_wc_conflict_description2_t const * conflict, apr_pool_t result_pool) -> svn_wc_conflict_description2_t *"""
    return _wc.svn_wc__conflict_description2_dup(*args)
svn_wc_conflict_choose_undefined = _wc.svn_wc_conflict_choose_undefined
svn_wc_conflict_choose_postpone = _wc.svn_wc_conflict_choose_postpone
svn_wc_conflict_choose_base = _wc.svn_wc_conflict_choose_base
svn_wc_conflict_choose_theirs_full = _wc.svn_wc_conflict_choose_theirs_full
svn_wc_conflict_choose_mine_full = _wc.svn_wc_conflict_choose_mine_full
svn_wc_conflict_choose_theirs_conflict = _wc.svn_wc_conflict_choose_theirs_conflict
svn_wc_conflict_choose_mine_conflict = _wc.svn_wc_conflict_choose_mine_conflict
svn_wc_conflict_choose_merged = _wc.svn_wc_conflict_choose_merged
svn_wc_conflict_choose_unspecified = _wc.svn_wc_conflict_choose_unspecified

def svn_wc_create_conflict_result(*args) -> "svn_wc_conflict_result_t *":
    """svn_wc_create_conflict_result(svn_wc_conflict_choice_t choice, char const * merged_file, apr_pool_t pool) -> svn_wc_conflict_result_t *"""
    return _wc.svn_wc_create_conflict_result(*args)
class svn_wc_diff_callbacks4_t(object):
    """Proxy of C svn_wc_diff_callbacks4_t struct."""

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    file_opened = _swig_property(_wc.svn_wc_diff_callbacks4_t_file_opened_get, _wc.svn_wc_diff_callbacks4_t_file_opened_set)
    file_changed = _swig_property(_wc.svn_wc_diff_callbacks4_t_file_changed_get, _wc.svn_wc_diff_callbacks4_t_file_changed_set)
    file_added = _swig_property(_wc.svn_wc_diff_callbacks4_t_file_added_get, _wc.svn_wc_diff_callbacks4_t_file_added_set)
    file_deleted = _swig_property(_wc.svn_wc_diff_callbacks4_t_file_deleted_get, _wc.svn_wc_diff_callbacks4_t_file_deleted_set)
    dir_deleted = _swig_property(_wc.svn_wc_diff_callbacks4_t_dir_deleted_get, _wc.svn_wc_diff_callbacks4_t_dir_deleted_set)
    dir_opened = _swig_property(_wc.svn_wc_diff_callbacks4_t_dir_opened_get, _wc.svn_wc_diff_callbacks4_t_dir_opened_set)
    dir_added = _swig_property(_wc.svn_wc_diff_callbacks4_t_dir_added_get, _wc.svn_wc_diff_callbacks4_t_dir_added_set)
    dir_props_changed = _swig_property(_wc.svn_wc_diff_callbacks4_t_dir_props_changed_get, _wc.svn_wc_diff_callbacks4_t_dir_props_changed_set)
    dir_closed = _swig_property(_wc.svn_wc_diff_callbacks4_t_dir_closed_get, _wc.svn_wc_diff_callbacks4_t_dir_closed_set)
    def set_parent_pool(self, parent_pool=None):
      """Create a new proxy object for TYPE"""
      import libsvn.core, weakref
      self.__dict__["_parent_pool"] = \
        parent_pool or libsvn.core.application_pool;
      if self.__dict__["_parent_pool"]:
        self.__dict__["_is_valid"] = weakref.ref(
          self.__dict__["_parent_pool"]._is_valid)

    def assert_valid(self):
      """Assert that this object is using valid pool memory"""
      if "_is_valid" in self.__dict__:
        assert self.__dict__["_is_valid"](), "Variable has already been deleted"

    def _retrieve_swig_value(self, name, value):
    # If we got back a different object than we have cached, we need to copy
    # all our metadata into it, so that it looks identical to the one
    # originally set.
      members = self.__dict__.get('_members')
      if members is not None and name in members:
        _copy_metadata_deep(value, members[name])

    # Verify that the new object is good
      _assert_valid_deep(value)

      return value

    # Attribute access must be intercepted to ensure that objects coming from
    # read attribute access match those that are set with write attribute access.
    # Specifically the metadata, such as the associated apr_pool object, should
    # match the originally assigned object.
    #
    # For classic classes it is enough to use __getattr__ to intercept swig
    # derived attributes. However, with new style classes SWIG makes use of
    # descriptors which mean that __getattr__ is never called. Therefore,
    # __getattribute__ must be used for the interception.

    if _newclass:
      def __getattribute__(self, name):
        """Manage access to all attributes of this object."""

    # Start by mimicing __getattr__ behavior: immediately return __dict__ or
    # items directly present in __dict__
        mydict = object.__getattribute__(self, '__dict__')

        if name == "__dict__":
          return mydict

        if name in mydict:
          return mydict[name]

        object.__getattribute__(self, 'assert_valid')()

        value = _get_instance_attr(self, name)
        fn = object.__getattribute__(self, '_retrieve_swig_value')
        return fn(name, value)
    else:
      def __getattr__(self, name):
        """Get an attribute from this object"""
        self.assert_valid()

        value = _swig_getattr(self, self.__class__, name)

        return self._retrieve_swig_value(name, value)

    def __setattr__(self, name, value):
      """Set an attribute on this object"""
      self.assert_valid()

    # Save a copy of the object, so that the garbage
    # collector won't kill the object while it's in
    # SWIG-land
      self.__dict__.setdefault("_members",{})[name] = value

      return _set_instance_attr(self, name, value)


    def file_opened(self, *args):
      return svn_wc_diff_callbacks4_invoke_file_opened(self, *args)


    def file_changed(self, *args):
      return svn_wc_diff_callbacks4_invoke_file_changed(self, *args)


    def file_added(self, *args):
      return svn_wc_diff_callbacks4_invoke_file_added(self, *args)


    def file_deleted(self, *args):
      return svn_wc_diff_callbacks4_invoke_file_deleted(self, *args)


    def dir_deleted(self, *args):
      return svn_wc_diff_callbacks4_invoke_dir_deleted(self, *args)


    def dir_opened(self, *args):
      return svn_wc_diff_callbacks4_invoke_dir_opened(self, *args)


    def dir_added(self, *args):
      return svn_wc_diff_callbacks4_invoke_dir_added(self, *args)


    def dir_props_changed(self, *args):
      return svn_wc_diff_callbacks4_invoke_dir_props_changed(self, *args)


    def dir_closed(self, *args):
      return svn_wc_diff_callbacks4_invoke_dir_closed(self, *args)


    def __init__(self):
        """__init__(svn_wc_diff_callbacks4_t self) -> svn_wc_diff_callbacks4_t"""
        this = _wc.new_svn_wc_diff_callbacks4_t()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _wc.delete_svn_wc_diff_callbacks4_t
    __del__ = lambda self: None
svn_wc_diff_callbacks4_t_swigregister = _wc.svn_wc_diff_callbacks4_t_swigregister
svn_wc_diff_callbacks4_t_swigregister(svn_wc_diff_callbacks4_t)

class svn_wc_diff_callbacks3_t(object):
    """Proxy of C svn_wc_diff_callbacks3_t struct."""

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    file_changed = _swig_property(_wc.svn_wc_diff_callbacks3_t_file_changed_get, _wc.svn_wc_diff_callbacks3_t_file_changed_set)
    file_added = _swig_property(_wc.svn_wc_diff_callbacks3_t_file_added_get, _wc.svn_wc_diff_callbacks3_t_file_added_set)
    file_deleted = _swig_property(_wc.svn_wc_diff_callbacks3_t_file_deleted_get, _wc.svn_wc_diff_callbacks3_t_file_deleted_set)
    dir_added = _swig_property(_wc.svn_wc_diff_callbacks3_t_dir_added_get, _wc.svn_wc_diff_callbacks3_t_dir_added_set)
    dir_deleted = _swig_property(_wc.svn_wc_diff_callbacks3_t_dir_deleted_get, _wc.svn_wc_diff_callbacks3_t_dir_deleted_set)
    dir_props_changed = _swig_property(_wc.svn_wc_diff_callbacks3_t_dir_props_changed_get, _wc.svn_wc_diff_callbacks3_t_dir_props_changed_set)
    dir_opened = _swig_property(_wc.svn_wc_diff_callbacks3_t_dir_opened_get, _wc.svn_wc_diff_callbacks3_t_dir_opened_set)
    dir_closed = _swig_property(_wc.svn_wc_diff_callbacks3_t_dir_closed_get, _wc.svn_wc_diff_callbacks3_t_dir_closed_set)
    def set_parent_pool(self, parent_pool=None):
      """Create a new proxy object for TYPE"""
      import libsvn.core, weakref
      self.__dict__["_parent_pool"] = \
        parent_pool or libsvn.core.application_pool;
      if self.__dict__["_parent_pool"]:
        self.__dict__["_is_valid"] = weakref.ref(
          self.__dict__["_parent_pool"]._is_valid)

    def assert_valid(self):
      """Assert that this object is using valid pool memory"""
      if "_is_valid" in self.__dict__:
        assert self.__dict__["_is_valid"](), "Variable has already been deleted"

    def _retrieve_swig_value(self, name, value):
    # If we got back a different object than we have cached, we need to copy
    # all our metadata into it, so that it looks identical to the one
    # originally set.
      members = self.__dict__.get('_members')
      if members is not None and name in members:
        _copy_metadata_deep(value, members[name])

    # Verify that the new object is good
      _assert_valid_deep(value)

      return value

    # Attribute access must be intercepted to ensure that objects coming from
    # read attribute access match those that are set with write attribute access.
    # Specifically the metadata, such as the associated apr_pool object, should
    # match the originally assigned object.
    #
    # For classic classes it is enough to use __getattr__ to intercept swig
    # derived attributes. However, with new style classes SWIG makes use of
    # descriptors which mean that __getattr__ is never called. Therefore,
    # __getattribute__ must be used for the interception.

    if _newclass:
      def __getattribute__(self, name):
        """Manage access to all attributes of this object."""

    # Start by mimicing __getattr__ behavior: immediately return __dict__ or
    # items directly present in __dict__
        mydict = object.__getattribute__(self, '__dict__')

        if name == "__dict__":
          return mydict

        if name in mydict:
          return mydict[name]

        object.__getattribute__(self, 'assert_valid')()

        value = _get_instance_attr(self, name)
        fn = object.__getattribute__(self, '_retrieve_swig_value')
        return fn(name, value)
    else:
      def __getattr__(self, name):
        """Get an attribute from this object"""
        self.assert_valid()

        value = _swig_getattr(self, self.__class__, name)

        return self._retrieve_swig_value(name, value)

    def __setattr__(self, name, value):
      """Set an attribute on this object"""
      self.assert_valid()

    # Save a copy of the object, so that the garbage
    # collector won't kill the object while it's in
    # SWIG-land
      self.__dict__.setdefault("_members",{})[name] = value

      return _set_instance_attr(self, name, value)


    def file_changed(self, *args):
      return svn_wc_diff_callbacks3_invoke_file_changed(self, *args)


    def file_added(self, *args):
      return svn_wc_diff_callbacks3_invoke_file_added(self, *args)


    def file_deleted(self, *args):
      return svn_wc_diff_callbacks3_invoke_file_deleted(self, *args)


    def dir_added(self, *args):
      return svn_wc_diff_callbacks3_invoke_dir_added(self, *args)


    def dir_deleted(self, *args):
      return svn_wc_diff_callbacks3_invoke_dir_deleted(self, *args)


    def dir_props_changed(self, *args):
      return svn_wc_diff_callbacks3_invoke_dir_props_changed(self, *args)


    def dir_opened(self, *args):
      return svn_wc_diff_callbacks3_invoke_dir_opened(self, *args)


    def dir_closed(self, *args):
      return svn_wc_diff_callbacks3_invoke_dir_closed(self, *args)


    def __init__(self):
        """__init__(svn_wc_diff_callbacks3_t self) -> svn_wc_diff_callbacks3_t"""
        this = _wc.new_svn_wc_diff_callbacks3_t()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _wc.delete_svn_wc_diff_callbacks3_t
    __del__ = lambda self: None
svn_wc_diff_callbacks3_t_swigregister = _wc.svn_wc_diff_callbacks3_t_swigregister
svn_wc_diff_callbacks3_t_swigregister(svn_wc_diff_callbacks3_t)

class svn_wc_diff_callbacks2_t(object):
    """Proxy of C svn_wc_diff_callbacks2_t struct."""

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    file_changed = _swig_property(_wc.svn_wc_diff_callbacks2_t_file_changed_get, _wc.svn_wc_diff_callbacks2_t_file_changed_set)
    file_added = _swig_property(_wc.svn_wc_diff_callbacks2_t_file_added_get, _wc.svn_wc_diff_callbacks2_t_file_added_set)
    file_deleted = _swig_property(_wc.svn_wc_diff_callbacks2_t_file_deleted_get, _wc.svn_wc_diff_callbacks2_t_file_deleted_set)
    dir_added = _swig_property(_wc.svn_wc_diff_callbacks2_t_dir_added_get, _wc.svn_wc_diff_callbacks2_t_dir_added_set)
    dir_deleted = _swig_property(_wc.svn_wc_diff_callbacks2_t_dir_deleted_get, _wc.svn_wc_diff_callbacks2_t_dir_deleted_set)
    dir_props_changed = _swig_property(_wc.svn_wc_diff_callbacks2_t_dir_props_changed_get, _wc.svn_wc_diff_callbacks2_t_dir_props_changed_set)
    def set_parent_pool(self, parent_pool=None):
      """Create a new proxy object for TYPE"""
      import libsvn.core, weakref
      self.__dict__["_parent_pool"] = \
        parent_pool or libsvn.core.application_pool;
      if self.__dict__["_parent_pool"]:
        self.__dict__["_is_valid"] = weakref.ref(
          self.__dict__["_parent_pool"]._is_valid)

    def assert_valid(self):
      """Assert that this object is using valid pool memory"""
      if "_is_valid" in self.__dict__:
        assert self.__dict__["_is_valid"](), "Variable has already been deleted"

    def _retrieve_swig_value(self, name, value):
    # If we got back a different object than we have cached, we need to copy
    # all our metadata into it, so that it looks identical to the one
    # originally set.
      members = self.__dict__.get('_members')
      if members is not None and name in members:
        _copy_metadata_deep(value, members[name])

    # Verify that the new object is good
      _assert_valid_deep(value)

      return value

    # Attribute access must be intercepted to ensure that objects coming from
    # read attribute access match those that are set with write attribute access.
    # Specifically the metadata, such as the associated apr_pool object, should
    # match the originally assigned object.
    #
    # For classic classes it is enough to use __getattr__ to intercept swig
    # derived attributes. However, with new style classes SWIG makes use of
    # descriptors which mean that __getattr__ is never called. Therefore,
    # __getattribute__ must be used for the interception.

    if _newclass:
      def __getattribute__(self, name):
        """Manage access to all attributes of this object."""

    # Start by mimicing __getattr__ behavior: immediately return __dict__ or
    # items directly present in __dict__
        mydict = object.__getattribute__(self, '__dict__')

        if name == "__dict__":
          return mydict

        if name in mydict:
          return mydict[name]

        object.__getattribute__(self, 'assert_valid')()

        value = _get_instance_attr(self, name)
        fn = object.__getattribute__(self, '_retrieve_swig_value')
        return fn(name, value)
    else:
      def __getattr__(self, name):
        """Get an attribute from this object"""
        self.assert_valid()

        value = _swig_getattr(self, self.__class__, name)

        return self._retrieve_swig_value(name, value)

    def __setattr__(self, name, value):
      """Set an attribute on this object"""
      self.assert_valid()

    # Save a copy of the object, so that the garbage
    # collector won't kill the object while it's in
    # SWIG-land
      self.__dict__.setdefault("_members",{})[name] = value

      return _set_instance_attr(self, name, value)


    def file_changed(self, *args):
      return svn_wc_diff_callbacks2_invoke_file_changed(self, *args)


    def file_added(self, *args):
      return svn_wc_diff_callbacks2_invoke_file_added(self, *args)


    def file_deleted(self, *args):
      return svn_wc_diff_callbacks2_invoke_file_deleted(self, *args)


    def dir_added(self, *args):
      return svn_wc_diff_callbacks2_invoke_dir_added(self, *args)


    def dir_deleted(self, *args):
      return svn_wc_diff_callbacks2_invoke_dir_deleted(self, *args)


    def dir_props_changed(self, *args):
      return svn_wc_diff_callbacks2_invoke_dir_props_changed(self, *args)


    def __init__(self):
        """__init__(svn_wc_diff_callbacks2_t self) -> svn_wc_diff_callbacks2_t"""
        this = _wc.new_svn_wc_diff_callbacks2_t()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _wc.delete_svn_wc_diff_callbacks2_t
    __del__ = lambda self: None
svn_wc_diff_callbacks2_t_swigregister = _wc.svn_wc_diff_callbacks2_t_swigregister
svn_wc_diff_callbacks2_t_swigregister(svn_wc_diff_callbacks2_t)

class svn_wc_diff_callbacks_t(object):
    """Proxy of C svn_wc_diff_callbacks_t struct."""

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    file_changed = _swig_property(_wc.svn_wc_diff_callbacks_t_file_changed_get, _wc.svn_wc_diff_callbacks_t_file_changed_set)
    file_added = _swig_property(_wc.svn_wc_diff_callbacks_t_file_added_get, _wc.svn_wc_diff_callbacks_t_file_added_set)
    file_deleted = _swig_property(_wc.svn_wc_diff_callbacks_t_file_deleted_get, _wc.svn_wc_diff_callbacks_t_file_deleted_set)
    dir_added = _swig_property(_wc.svn_wc_diff_callbacks_t_dir_added_get, _wc.svn_wc_diff_callbacks_t_dir_added_set)
    dir_deleted = _swig_property(_wc.svn_wc_diff_callbacks_t_dir_deleted_get, _wc.svn_wc_diff_callbacks_t_dir_deleted_set)
    props_changed = _swig_property(_wc.svn_wc_diff_callbacks_t_props_changed_get, _wc.svn_wc_diff_callbacks_t_props_changed_set)
    def set_parent_pool(self, parent_pool=None):
      """Create a new proxy object for TYPE"""
      import libsvn.core, weakref
      self.__dict__["_parent_pool"] = \
        parent_pool or libsvn.core.application_pool;
      if self.__dict__["_parent_pool"]:
        self.__dict__["_is_valid"] = weakref.ref(
          self.__dict__["_parent_pool"]._is_valid)

    def assert_valid(self):
      """Assert that this object is using valid pool memory"""
      if "_is_valid" in self.__dict__:
        assert self.__dict__["_is_valid"](), "Variable has already been deleted"

    def _retrieve_swig_value(self, name, value):
    # If we got back a different object than we have cached, we need to copy
    # all our metadata into it, so that it looks identical to the one
    # originally set.
      members = self.__dict__.get('_members')
      if members is not None and name in members:
        _copy_metadata_deep(value, members[name])

    # Verify that the new object is good
      _assert_valid_deep(value)

      return value

    # Attribute access must be intercepted to ensure that objects coming from
    # read attribute access match those that are set with write attribute access.
    # Specifically the metadata, such as the associated apr_pool object, should
    # match the originally assigned object.
    #
    # For classic classes it is enough to use __getattr__ to intercept swig
    # derived attributes. However, with new style classes SWIG makes use of
    # descriptors which mean that __getattr__ is never called. Therefore,
    # __getattribute__ must be used for the interception.

    if _newclass:
      def __getattribute__(self, name):
        """Manage access to all attributes of this object."""

    # Start by mimicing __getattr__ behavior: immediately return __dict__ or
    # items directly present in __dict__
        mydict = object.__getattribute__(self, '__dict__')

        if name == "__dict__":
          return mydict

        if name in mydict:
          return mydict[name]

        object.__getattribute__(self, 'assert_valid')()

        value = _get_instance_attr(self, name)
        fn = object.__getattribute__(self, '_retrieve_swig_value')
        return fn(name, value)
    else:
      def __getattr__(self, name):
        """Get an attribute from this object"""
        self.assert_valid()

        value = _swig_getattr(self, self.__class__, name)

        return self._retrieve_swig_value(name, value)

    def __setattr__(self, name, value):
      """Set an attribute on this object"""
      self.assert_valid()

    # Save a copy of the object, so that the garbage
    # collector won't kill the object while it's in
    # SWIG-land
      self.__dict__.setdefault("_members",{})[name] = value

      return _set_instance_attr(self, name, value)


    def file_changed(self, *args):
      return svn_wc_diff_callbacks_invoke_file_changed(self, *args)


    def file_added(self, *args):
      return svn_wc_diff_callbacks_invoke_file_added(self, *args)


    def file_deleted(self, *args):
      return svn_wc_diff_callbacks_invoke_file_deleted(self, *args)


    def dir_added(self, *args):
      return svn_wc_diff_callbacks_invoke_dir_added(self, *args)


    def dir_deleted(self, *args):
      return svn_wc_diff_callbacks_invoke_dir_deleted(self, *args)


    def props_changed(self, *args):
      return svn_wc_diff_callbacks_invoke_props_changed(self, *args)


    def __init__(self):
        """__init__(svn_wc_diff_callbacks_t self) -> svn_wc_diff_callbacks_t"""
        this = _wc.new_svn_wc_diff_callbacks_t()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _wc.delete_svn_wc_diff_callbacks_t
    __del__ = lambda self: None
svn_wc_diff_callbacks_t_swigregister = _wc.svn_wc_diff_callbacks_t_swigregister
svn_wc_diff_callbacks_t_swigregister(svn_wc_diff_callbacks_t)


def svn_wc_check_wc2(*args) -> "int *":
    """svn_wc_check_wc2(svn_wc_context_t * wc_ctx, char const * local_abspath, apr_pool_t scratch_pool) -> svn_error_t"""
    return _wc.svn_wc_check_wc2(*args)

def svn_wc_check_wc(*args) -> "int *":
    """svn_wc_check_wc(char const * path, apr_pool_t pool) -> svn_error_t"""
    return _wc.svn_wc_check_wc(*args)

def svn_wc_has_binary_prop(*args) -> "svn_boolean_t *":
    """svn_wc_has_binary_prop(char const * path, svn_wc_adm_access_t * adm_access, apr_pool_t pool) -> svn_error_t"""
    return _wc.svn_wc_has_binary_prop(*args)

def svn_wc_text_modified_p2(*args) -> "svn_boolean_t *":
    """svn_wc_text_modified_p2(svn_wc_context_t * wc_ctx, char const * local_abspath, svn_boolean_t unused, apr_pool_t scratch_pool) -> svn_error_t"""
    return _wc.svn_wc_text_modified_p2(*args)

def svn_wc_text_modified_p(*args) -> "svn_boolean_t *":
    """svn_wc_text_modified_p(char const * filename, svn_boolean_t force_comparison, svn_wc_adm_access_t * adm_access, apr_pool_t pool) -> svn_error_t"""
    return _wc.svn_wc_text_modified_p(*args)

def svn_wc_props_modified_p2(*args) -> "svn_boolean_t *":
    """svn_wc_props_modified_p2(svn_wc_context_t * wc_ctx, char const * local_abspath, apr_pool_t scratch_pool) -> svn_error_t"""
    return _wc.svn_wc_props_modified_p2(*args)

def svn_wc_props_modified_p(*args) -> "svn_boolean_t *":
    """svn_wc_props_modified_p(char const * path, svn_wc_adm_access_t * adm_access, apr_pool_t pool) -> svn_error_t"""
    return _wc.svn_wc_props_modified_p(*args)
svn_wc_schedule_normal = _wc.svn_wc_schedule_normal
svn_wc_schedule_add = _wc.svn_wc_schedule_add
svn_wc_schedule_delete = _wc.svn_wc_schedule_delete
svn_wc_schedule_replace = _wc.svn_wc_schedule_replace
SVN_WC_ENTRY_WORKING_SIZE_UNKNOWN = _wc.SVN_WC_ENTRY_WORKING_SIZE_UNKNOWN
class svn_wc_entry_t(object):
    """Proxy of C svn_wc_entry_t struct."""

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    name = _swig_property(_wc.svn_wc_entry_t_name_get, _wc.svn_wc_entry_t_name_set)
    revision = _swig_property(_wc.svn_wc_entry_t_revision_get, _wc.svn_wc_entry_t_revision_set)
    url = _swig_property(_wc.svn_wc_entry_t_url_get, _wc.svn_wc_entry_t_url_set)
    repos = _swig_property(_wc.svn_wc_entry_t_repos_get, _wc.svn_wc_entry_t_repos_set)
    uuid = _swig_property(_wc.svn_wc_entry_t_uuid_get, _wc.svn_wc_entry_t_uuid_set)
    kind = _swig_property(_wc.svn_wc_entry_t_kind_get, _wc.svn_wc_entry_t_kind_set)
    schedule = _swig_property(_wc.svn_wc_entry_t_schedule_get, _wc.svn_wc_entry_t_schedule_set)
    copied = _swig_property(_wc.svn_wc_entry_t_copied_get, _wc.svn_wc_entry_t_copied_set)
    deleted = _swig_property(_wc.svn_wc_entry_t_deleted_get, _wc.svn_wc_entry_t_deleted_set)
    absent = _swig_property(_wc.svn_wc_entry_t_absent_get, _wc.svn_wc_entry_t_absent_set)
    incomplete = _swig_property(_wc.svn_wc_entry_t_incomplete_get, _wc.svn_wc_entry_t_incomplete_set)
    copyfrom_url = _swig_property(_wc.svn_wc_entry_t_copyfrom_url_get, _wc.svn_wc_entry_t_copyfrom_url_set)
    copyfrom_rev = _swig_property(_wc.svn_wc_entry_t_copyfrom_rev_get, _wc.svn_wc_entry_t_copyfrom_rev_set)
    conflict_old = _swig_property(_wc.svn_wc_entry_t_conflict_old_get, _wc.svn_wc_entry_t_conflict_old_set)
    conflict_new = _swig_property(_wc.svn_wc_entry_t_conflict_new_get, _wc.svn_wc_entry_t_conflict_new_set)
    conflict_wrk = _swig_property(_wc.svn_wc_entry_t_conflict_wrk_get, _wc.svn_wc_entry_t_conflict_wrk_set)
    prejfile = _swig_property(_wc.svn_wc_entry_t_prejfile_get, _wc.svn_wc_entry_t_prejfile_set)
    text_time = _swig_property(_wc.svn_wc_entry_t_text_time_get, _wc.svn_wc_entry_t_text_time_set)
    prop_time = _swig_property(_wc.svn_wc_entry_t_prop_time_get, _wc.svn_wc_entry_t_prop_time_set)
    checksum = _swig_property(_wc.svn_wc_entry_t_checksum_get, _wc.svn_wc_entry_t_checksum_set)
    cmt_rev = _swig_property(_wc.svn_wc_entry_t_cmt_rev_get, _wc.svn_wc_entry_t_cmt_rev_set)
    cmt_date = _swig_property(_wc.svn_wc_entry_t_cmt_date_get, _wc.svn_wc_entry_t_cmt_date_set)
    cmt_author = _swig_property(_wc.svn_wc_entry_t_cmt_author_get, _wc.svn_wc_entry_t_cmt_author_set)
    lock_token = _swig_property(_wc.svn_wc_entry_t_lock_token_get, _wc.svn_wc_entry_t_lock_token_set)
    lock_owner = _swig_property(_wc.svn_wc_entry_t_lock_owner_get, _wc.svn_wc_entry_t_lock_owner_set)
    lock_comment = _swig_property(_wc.svn_wc_entry_t_lock_comment_get, _wc.svn_wc_entry_t_lock_comment_set)
    lock_creation_date = _swig_property(_wc.svn_wc_entry_t_lock_creation_date_get, _wc.svn_wc_entry_t_lock_creation_date_set)
    has_props = _swig_property(_wc.svn_wc_entry_t_has_props_get, _wc.svn_wc_entry_t_has_props_set)
    has_prop_mods = _swig_property(_wc.svn_wc_entry_t_has_prop_mods_get, _wc.svn_wc_entry_t_has_prop_mods_set)
    cachable_props = _swig_property(_wc.svn_wc_entry_t_cachable_props_get, _wc.svn_wc_entry_t_cachable_props_set)
    present_props = _swig_property(_wc.svn_wc_entry_t_present_props_get, _wc.svn_wc_entry_t_present_props_set)
    changelist = _swig_property(_wc.svn_wc_entry_t_changelist_get, _wc.svn_wc_entry_t_changelist_set)
    working_size = _swig_property(_wc.svn_wc_entry_t_working_size_get, _wc.svn_wc_entry_t_working_size_set)
    keep_local = _swig_property(_wc.svn_wc_entry_t_keep_local_get, _wc.svn_wc_entry_t_keep_local_set)
    depth = _swig_property(_wc.svn_wc_entry_t_depth_get, _wc.svn_wc_entry_t_depth_set)
    tree_conflict_data = _swig_property(_wc.svn_wc_entry_t_tree_conflict_data_get, _wc.svn_wc_entry_t_tree_conflict_data_set)
    file_external_path = _swig_property(_wc.svn_wc_entry_t_file_external_path_get, _wc.svn_wc_entry_t_file_external_path_set)
    file_external_peg_rev = _swig_property(_wc.svn_wc_entry_t_file_external_peg_rev_get, _wc.svn_wc_entry_t_file_external_peg_rev_set)
    file_external_rev = _swig_property(_wc.svn_wc_entry_t_file_external_rev_get, _wc.svn_wc_entry_t_file_external_rev_set)
    def set_parent_pool(self, parent_pool=None):
      """Create a new proxy object for TYPE"""
      import libsvn.core, weakref
      self.__dict__["_parent_pool"] = \
        parent_pool or libsvn.core.application_pool;
      if self.__dict__["_parent_pool"]:
        self.__dict__["_is_valid"] = weakref.ref(
          self.__dict__["_parent_pool"]._is_valid)

    def assert_valid(self):
      """Assert that this object is using valid pool memory"""
      if "_is_valid" in self.__dict__:
        assert self.__dict__["_is_valid"](), "Variable has already been deleted"

    def _retrieve_swig_value(self, name, value):
    # If we got back a different object than we have cached, we need to copy
    # all our metadata into it, so that it looks identical to the one
    # originally set.
      members = self.__dict__.get('_members')
      if members is not None and name in members:
        _copy_metadata_deep(value, members[name])

    # Verify that the new object is good
      _assert_valid_deep(value)

      return value

    # Attribute access must be intercepted to ensure that objects coming from
    # read attribute access match those that are set with write attribute access.
    # Specifically the metadata, such as the associated apr_pool object, should
    # match the originally assigned object.
    #
    # For classic classes it is enough to use __getattr__ to intercept swig
    # derived attributes. However, with new style classes SWIG makes use of
    # descriptors which mean that __getattr__ is never called. Therefore,
    # __getattribute__ must be used for the interception.

    if _newclass:
      def __getattribute__(self, name):
        """Manage access to all attributes of this object."""

    # Start by mimicing __getattr__ behavior: immediately return __dict__ or
    # items directly present in __dict__
        mydict = object.__getattribute__(self, '__dict__')

        if name == "__dict__":
          return mydict

        if name in mydict:
          return mydict[name]

        object.__getattribute__(self, 'assert_valid')()

        value = _get_instance_attr(self, name)
        fn = object.__getattribute__(self, '_retrieve_swig_value')
        return fn(name, value)
    else:
      def __getattr__(self, name):
        """Get an attribute from this object"""
        self.assert_valid()

        value = _swig_getattr(self, self.__class__, name)

        return self._retrieve_swig_value(name, value)

    def __setattr__(self, name, value):
      """Set an attribute on this object"""
      self.assert_valid()

    # Save a copy of the object, so that the garbage
    # collector won't kill the object while it's in
    # SWIG-land
      self.__dict__.setdefault("_members",{})[name] = value

      return _set_instance_attr(self, name, value)


    def __init__(self):
        """__init__(svn_wc_entry_t self) -> svn_wc_entry_t"""
        this = _wc.new_svn_wc_entry_t()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _wc.delete_svn_wc_entry_t
    __del__ = lambda self: None
svn_wc_entry_t_swigregister = _wc.svn_wc_entry_t_swigregister
svn_wc_entry_t_swigregister(svn_wc_entry_t)

SVN_WC_ENTRY_THIS_DIR = _wc.SVN_WC_ENTRY_THIS_DIR

def svn_wc_entry(*args) -> "svn_wc_entry_t **":
    """svn_wc_entry(char const * path, svn_wc_adm_access_t * adm_access, svn_boolean_t show_hidden, apr_pool_t pool) -> svn_error_t"""
    return _wc.svn_wc_entry(*args)

def svn_wc_entries_read(*args) -> "apr_hash_t **":
    """svn_wc_entries_read(svn_wc_adm_access_t * adm_access, svn_boolean_t show_hidden, apr_pool_t pool) -> svn_error_t"""
    return _wc.svn_wc_entries_read(*args)

def svn_wc_entry_dup(*args) -> "svn_wc_entry_t *":
    """svn_wc_entry_dup(svn_wc_entry_t entry, apr_pool_t pool) -> svn_wc_entry_t"""
    return _wc.svn_wc_entry_dup(*args)
class svn_wc_info_t(object):
    """Proxy of C svn_wc_info_t struct."""

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    schedule = _swig_property(_wc.svn_wc_info_t_schedule_get, _wc.svn_wc_info_t_schedule_set)
    copyfrom_url = _swig_property(_wc.svn_wc_info_t_copyfrom_url_get, _wc.svn_wc_info_t_copyfrom_url_set)
    copyfrom_rev = _swig_property(_wc.svn_wc_info_t_copyfrom_rev_get, _wc.svn_wc_info_t_copyfrom_rev_set)
    checksum = _swig_property(_wc.svn_wc_info_t_checksum_get, _wc.svn_wc_info_t_checksum_set)
    changelist = _swig_property(_wc.svn_wc_info_t_changelist_get, _wc.svn_wc_info_t_changelist_set)
    depth = _swig_property(_wc.svn_wc_info_t_depth_get, _wc.svn_wc_info_t_depth_set)
    recorded_size = _swig_property(_wc.svn_wc_info_t_recorded_size_get, _wc.svn_wc_info_t_recorded_size_set)
    recorded_time = _swig_property(_wc.svn_wc_info_t_recorded_time_get, _wc.svn_wc_info_t_recorded_time_set)
    conflicts = _swig_property(_wc.svn_wc_info_t_conflicts_get, _wc.svn_wc_info_t_conflicts_set)
    wcroot_abspath = _swig_property(_wc.svn_wc_info_t_wcroot_abspath_get, _wc.svn_wc_info_t_wcroot_abspath_set)
    moved_from_abspath = _swig_property(_wc.svn_wc_info_t_moved_from_abspath_get, _wc.svn_wc_info_t_moved_from_abspath_set)
    moved_to_abspath = _swig_property(_wc.svn_wc_info_t_moved_to_abspath_get, _wc.svn_wc_info_t_moved_to_abspath_set)
    def set_parent_pool(self, parent_pool=None):
      """Create a new proxy object for TYPE"""
      import libsvn.core, weakref
      self.__dict__["_parent_pool"] = \
        parent_pool or libsvn.core.application_pool;
      if self.__dict__["_parent_pool"]:
        self.__dict__["_is_valid"] = weakref.ref(
          self.__dict__["_parent_pool"]._is_valid)

    def assert_valid(self):
      """Assert that this object is using valid pool memory"""
      if "_is_valid" in self.__dict__:
        assert self.__dict__["_is_valid"](), "Variable has already been deleted"

    def _retrieve_swig_value(self, name, value):
    # If we got back a different object than we have cached, we need to copy
    # all our metadata into it, so that it looks identical to the one
    # originally set.
      members = self.__dict__.get('_members')
      if members is not None and name in members:
        _copy_metadata_deep(value, members[name])

    # Verify that the new object is good
      _assert_valid_deep(value)

      return value

    # Attribute access must be intercepted to ensure that objects coming from
    # read attribute access match those that are set with write attribute access.
    # Specifically the metadata, such as the associated apr_pool object, should
    # match the originally assigned object.
    #
    # For classic classes it is enough to use __getattr__ to intercept swig
    # derived attributes. However, with new style classes SWIG makes use of
    # descriptors which mean that __getattr__ is never called. Therefore,
    # __getattribute__ must be used for the interception.

    if _newclass:
      def __getattribute__(self, name):
        """Manage access to all attributes of this object."""

    # Start by mimicing __getattr__ behavior: immediately return __dict__ or
    # items directly present in __dict__
        mydict = object.__getattribute__(self, '__dict__')

        if name == "__dict__":
          return mydict

        if name in mydict:
          return mydict[name]

        object.__getattribute__(self, 'assert_valid')()

        value = _get_instance_attr(self, name)
        fn = object.__getattribute__(self, '_retrieve_swig_value')
        return fn(name, value)
    else:
      def __getattr__(self, name):
        """Get an attribute from this object"""
        self.assert_valid()

        value = _swig_getattr(self, self.__class__, name)

        return self._retrieve_swig_value(name, value)

    def __setattr__(self, name, value):
      """Set an attribute on this object"""
      self.assert_valid()

    # Save a copy of the object, so that the garbage
    # collector won't kill the object while it's in
    # SWIG-land
      self.__dict__.setdefault("_members",{})[name] = value

      return _set_instance_attr(self, name, value)


    def __init__(self):
        """__init__(svn_wc_info_t self) -> svn_wc_info_t"""
        this = _wc.new_svn_wc_info_t()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _wc.delete_svn_wc_info_t
    __del__ = lambda self: None
svn_wc_info_t_swigregister = _wc.svn_wc_info_t_swigregister
svn_wc_info_t_swigregister(svn_wc_info_t)


def svn_wc_info_dup(*args) -> "svn_wc_info_t *":
    """svn_wc_info_dup(svn_wc_info_t info, apr_pool_t pool) -> svn_wc_info_t"""
    return _wc.svn_wc_info_dup(*args)

def svn_wc_conflicted_p3(*args) -> "svn_boolean_t *, svn_boolean_t *, svn_boolean_t *":
    """svn_wc_conflicted_p3(svn_wc_context_t * wc_ctx, char const * local_abspath, apr_pool_t scratch_pool) -> svn_error_t"""
    return _wc.svn_wc_conflicted_p3(*args)

def svn_wc_conflicted_p2(*args) -> "svn_boolean_t *, svn_boolean_t *, svn_boolean_t *":
    """svn_wc_conflicted_p2(char const * path, svn_wc_adm_access_t * adm_access, apr_pool_t pool) -> svn_error_t"""
    return _wc.svn_wc_conflicted_p2(*args)

def svn_wc_conflicted_p(*args) -> "svn_boolean_t *, svn_boolean_t *":
    """svn_wc_conflicted_p(char const * dir_path, svn_wc_entry_t entry, apr_pool_t pool) -> svn_error_t"""
    return _wc.svn_wc_conflicted_p(*args)

def svn_wc_get_ancestry(*args) -> "char **, svn_revnum_t *":
    """svn_wc_get_ancestry(char const * path, svn_wc_adm_access_t * adm_access, apr_pool_t pool) -> svn_error_t"""
    return _wc.svn_wc_get_ancestry(*args)
class svn_wc_entry_callbacks2_t(object):
    """Proxy of C svn_wc_entry_callbacks2_t struct."""

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    found_entry = _swig_property(_wc.svn_wc_entry_callbacks2_t_found_entry_get, _wc.svn_wc_entry_callbacks2_t_found_entry_set)
    handle_error = _swig_property(_wc.svn_wc_entry_callbacks2_t_handle_error_get, _wc.svn_wc_entry_callbacks2_t_handle_error_set)
    def set_parent_pool(self, parent_pool=None):
      """Create a new proxy object for TYPE"""
      import libsvn.core, weakref
      self.__dict__["_parent_pool"] = \
        parent_pool or libsvn.core.application_pool;
      if self.__dict__["_parent_pool"]:
        self.__dict__["_is_valid"] = weakref.ref(
          self.__dict__["_parent_pool"]._is_valid)

    def assert_valid(self):
      """Assert that this object is using valid pool memory"""
      if "_is_valid" in self.__dict__:
        assert self.__dict__["_is_valid"](), "Variable has already been deleted"

    def _retrieve_swig_value(self, name, value):
    # If we got back a different object than we have cached, we need to copy
    # all our metadata into it, so that it looks identical to the one
    # originally set.
      members = self.__dict__.get('_members')
      if members is not None and name in members:
        _copy_metadata_deep(value, members[name])

    # Verify that the new object is good
      _assert_valid_deep(value)

      return value

    # Attribute access must be intercepted to ensure that objects coming from
    # read attribute access match those that are set with write attribute access.
    # Specifically the metadata, such as the associated apr_pool object, should
    # match the originally assigned object.
    #
    # For classic classes it is enough to use __getattr__ to intercept swig
    # derived attributes. However, with new style classes SWIG makes use of
    # descriptors which mean that __getattr__ is never called. Therefore,
    # __getattribute__ must be used for the interception.

    if _newclass:
      def __getattribute__(self, name):
        """Manage access to all attributes of this object."""

    # Start by mimicing __getattr__ behavior: immediately return __dict__ or
    # items directly present in __dict__
        mydict = object.__getattribute__(self, '__dict__')

        if name == "__dict__":
          return mydict

        if name in mydict:
          return mydict[name]

        object.__getattribute__(self, 'assert_valid')()

        value = _get_instance_attr(self, name)
        fn = object.__getattribute__(self, '_retrieve_swig_value')
        return fn(name, value)
    else:
      def __getattr__(self, name):
        """Get an attribute from this object"""
        self.assert_valid()

        value = _swig_getattr(self, self.__class__, name)

        return self._retrieve_swig_value(name, value)

    def __setattr__(self, name, value):
      """Set an attribute on this object"""
      self.assert_valid()

    # Save a copy of the object, so that the garbage
    # collector won't kill the object while it's in
    # SWIG-land
      self.__dict__.setdefault("_members",{})[name] = value

      return _set_instance_attr(self, name, value)


    def found_entry(self, *args):
      return svn_wc_entry_callbacks2_invoke_found_entry(self, *args)


    def handle_error(self, *args):
      return svn_wc_entry_callbacks2_invoke_handle_error(self, *args)


    def __init__(self):
        """__init__(svn_wc_entry_callbacks2_t self) -> svn_wc_entry_callbacks2_t"""
        this = _wc.new_svn_wc_entry_callbacks2_t()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _wc.delete_svn_wc_entry_callbacks2_t
    __del__ = lambda self: None
svn_wc_entry_callbacks2_t_swigregister = _wc.svn_wc_entry_callbacks2_t_swigregister
svn_wc_entry_callbacks2_t_swigregister(svn_wc_entry_callbacks2_t)

class svn_wc_entry_callbacks_t(object):
    """Proxy of C svn_wc_entry_callbacks_t struct."""

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    found_entry = _swig_property(_wc.svn_wc_entry_callbacks_t_found_entry_get, _wc.svn_wc_entry_callbacks_t_found_entry_set)
    def set_parent_pool(self, parent_pool=None):
      """Create a new proxy object for TYPE"""
      import libsvn.core, weakref
      self.__dict__["_parent_pool"] = \
        parent_pool or libsvn.core.application_pool;
      if self.__dict__["_parent_pool"]:
        self.__dict__["_is_valid"] = weakref.ref(
          self.__dict__["_parent_pool"]._is_valid)

    def assert_valid(self):
      """Assert that this object is using valid pool memory"""
      if "_is_valid" in self.__dict__:
        assert self.__dict__["_is_valid"](), "Variable has already been deleted"

    def _retrieve_swig_value(self, name, value):
    # If we got back a different object than we have cached, we need to copy
    # all our metadata into it, so that it looks identical to the one
    # originally set.
      members = self.__dict__.get('_members')
      if members is not None and name in members:
        _copy_metadata_deep(value, members[name])

    # Verify that the new object is good
      _assert_valid_deep(value)

      return value

    # Attribute access must be intercepted to ensure that objects coming from
    # read attribute access match those that are set with write attribute access.
    # Specifically the metadata, such as the associated apr_pool object, should
    # match the originally assigned object.
    #
    # For classic classes it is enough to use __getattr__ to intercept swig
    # derived attributes. However, with new style classes SWIG makes use of
    # descriptors which mean that __getattr__ is never called. Therefore,
    # __getattribute__ must be used for the interception.

    if _newclass:
      def __getattribute__(self, name):
        """Manage access to all attributes of this object."""

    # Start by mimicing __getattr__ behavior: immediately return __dict__ or
    # items directly present in __dict__
        mydict = object.__getattribute__(self, '__dict__')

        if name == "__dict__":
          return mydict

        if name in mydict:
          return mydict[name]

        object.__getattribute__(self, 'assert_valid')()

        value = _get_instance_attr(self, name)
        fn = object.__getattribute__(self, '_retrieve_swig_value')
        return fn(name, value)
    else:
      def __getattr__(self, name):
        """Get an attribute from this object"""
        self.assert_valid()

        value = _swig_getattr(self, self.__class__, name)

        return self._retrieve_swig_value(name, value)

    def __setattr__(self, name, value):
      """Set an attribute on this object"""
      self.assert_valid()

    # Save a copy of the object, so that the garbage
    # collector won't kill the object while it's in
    # SWIG-land
      self.__dict__.setdefault("_members",{})[name] = value

      return _set_instance_attr(self, name, value)


    def found_entry(self, *args):
      return svn_wc_entry_callbacks_invoke_found_entry(self, *args)


    def __init__(self):
        """__init__(svn_wc_entry_callbacks_t self) -> svn_wc_entry_callbacks_t"""
        this = _wc.new_svn_wc_entry_callbacks_t()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _wc.delete_svn_wc_entry_callbacks_t
    __del__ = lambda self: None
svn_wc_entry_callbacks_t_swigregister = _wc.svn_wc_entry_callbacks_t_swigregister
svn_wc_entry_callbacks_t_swigregister(svn_wc_entry_callbacks_t)


def svn_wc_walk_entries3(*args) -> "svn_error_t *":
    """svn_wc_walk_entries3(char const * path, svn_wc_adm_access_t * adm_access, svn_wc_entry_callbacks2_t walk_callbacks, void * walk_baton, svn_depth_t depth, svn_boolean_t show_hidden, svn_cancel_func_t cancel_func, apr_pool_t pool) -> svn_error_t"""
    return _wc.svn_wc_walk_entries3(*args)

def svn_wc_walk_entries2(*args) -> "svn_error_t *":
    """svn_wc_walk_entries2(char const * path, svn_wc_adm_access_t * adm_access, svn_wc_entry_callbacks_t walk_callbacks, void * walk_baton, svn_boolean_t show_hidden, svn_cancel_func_t cancel_func, apr_pool_t pool) -> svn_error_t"""
    return _wc.svn_wc_walk_entries2(*args)

def svn_wc_walk_entries(*args) -> "svn_error_t *":
    """svn_wc_walk_entries(char const * path, svn_wc_adm_access_t * adm_access, svn_wc_entry_callbacks_t walk_callbacks, void * walk_baton, svn_boolean_t show_hidden, apr_pool_t pool) -> svn_error_t"""
    return _wc.svn_wc_walk_entries(*args)

def svn_wc_mark_missing_deleted(*args) -> "svn_error_t *":
    """svn_wc_mark_missing_deleted(char const * path, svn_wc_adm_access_t * parent, apr_pool_t pool) -> svn_error_t"""
    return _wc.svn_wc_mark_missing_deleted(*args)

def svn_wc_ensure_adm4(*args) -> "svn_error_t *":
    """svn_wc_ensure_adm4(svn_wc_context_t * wc_ctx, char const * local_abspath, char const * url, char const * repos_root_url, char const * repos_uuid, svn_revnum_t revision, svn_depth_t depth, apr_pool_t scratch_pool) -> svn_error_t"""
    return _wc.svn_wc_ensure_adm4(*args)

def svn_wc_ensure_adm3(*args) -> "svn_error_t *":
    """svn_wc_ensure_adm3(char const * path, char const * uuid, char const * url, char const * repos, svn_revnum_t revision, svn_depth_t depth, apr_pool_t pool) -> svn_error_t"""
    return _wc.svn_wc_ensure_adm3(*args)

def svn_wc_ensure_adm2(*args) -> "svn_error_t *":
    """svn_wc_ensure_adm2(char const * path, char const * uuid, char const * url, char const * repos, svn_revnum_t revision, apr_pool_t pool) -> svn_error_t"""
    return _wc.svn_wc_ensure_adm2(*args)

def svn_wc_ensure_adm(*args) -> "svn_error_t *":
    """svn_wc_ensure_adm(char const * path, char const * uuid, char const * url, svn_revnum_t revision, apr_pool_t pool) -> svn_error_t"""
    return _wc.svn_wc_ensure_adm(*args)

def svn_wc_maybe_set_repos_root(*args) -> "svn_error_t *":
    """svn_wc_maybe_set_repos_root(svn_wc_adm_access_t * adm_access, char const * path, char const * repos, apr_pool_t pool) -> svn_error_t"""
    return _wc.svn_wc_maybe_set_repos_root(*args)
svn_wc_status_none = _wc.svn_wc_status_none
svn_wc_status_unversioned = _wc.svn_wc_status_unversioned
svn_wc_status_normal = _wc.svn_wc_status_normal
svn_wc_status_added = _wc.svn_wc_status_added
svn_wc_status_missing = _wc.svn_wc_status_missing
svn_wc_status_deleted = _wc.svn_wc_status_deleted
svn_wc_status_replaced = _wc.svn_wc_status_replaced
svn_wc_status_modified = _wc.svn_wc_status_modified
svn_wc_status_merged = _wc.svn_wc_status_merged
svn_wc_status_conflicted = _wc.svn_wc_status_conflicted
svn_wc_status_ignored = _wc.svn_wc_status_ignored
svn_wc_status_obstructed = _wc.svn_wc_status_obstructed
svn_wc_status_external = _wc.svn_wc_status_external
svn_wc_status_incomplete = _wc.svn_wc_status_incomplete
class svn_wc_status3_t(object):
    """Proxy of C svn_wc_status3_t struct."""

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    kind = _swig_property(_wc.svn_wc_status3_t_kind_get, _wc.svn_wc_status3_t_kind_set)
    depth = _swig_property(_wc.svn_wc_status3_t_depth_get, _wc.svn_wc_status3_t_depth_set)
    filesize = _swig_property(_wc.svn_wc_status3_t_filesize_get, _wc.svn_wc_status3_t_filesize_set)
    versioned = _swig_property(_wc.svn_wc_status3_t_versioned_get, _wc.svn_wc_status3_t_versioned_set)
    conflicted = _swig_property(_wc.svn_wc_status3_t_conflicted_get, _wc.svn_wc_status3_t_conflicted_set)
    node_status = _swig_property(_wc.svn_wc_status3_t_node_status_get, _wc.svn_wc_status3_t_node_status_set)
    text_status = _swig_property(_wc.svn_wc_status3_t_text_status_get, _wc.svn_wc_status3_t_text_status_set)
    prop_status = _swig_property(_wc.svn_wc_status3_t_prop_status_get, _wc.svn_wc_status3_t_prop_status_set)
    copied = _swig_property(_wc.svn_wc_status3_t_copied_get, _wc.svn_wc_status3_t_copied_set)
    revision = _swig_property(_wc.svn_wc_status3_t_revision_get, _wc.svn_wc_status3_t_revision_set)
    changed_rev = _swig_property(_wc.svn_wc_status3_t_changed_rev_get, _wc.svn_wc_status3_t_changed_rev_set)
    changed_date = _swig_property(_wc.svn_wc_status3_t_changed_date_get, _wc.svn_wc_status3_t_changed_date_set)
    changed_author = _swig_property(_wc.svn_wc_status3_t_changed_author_get, _wc.svn_wc_status3_t_changed_author_set)
    repos_root_url = _swig_property(_wc.svn_wc_status3_t_repos_root_url_get, _wc.svn_wc_status3_t_repos_root_url_set)
    repos_uuid = _swig_property(_wc.svn_wc_status3_t_repos_uuid_get, _wc.svn_wc_status3_t_repos_uuid_set)
    repos_relpath = _swig_property(_wc.svn_wc_status3_t_repos_relpath_get, _wc.svn_wc_status3_t_repos_relpath_set)
    switched = _swig_property(_wc.svn_wc_status3_t_switched_get, _wc.svn_wc_status3_t_switched_set)
    locked = _swig_property(_wc.svn_wc_status3_t_locked_get, _wc.svn_wc_status3_t_locked_set)
    lock = _swig_property(_wc.svn_wc_status3_t_lock_get, _wc.svn_wc_status3_t_lock_set)
    changelist = _swig_property(_wc.svn_wc_status3_t_changelist_get, _wc.svn_wc_status3_t_changelist_set)
    ood_kind = _swig_property(_wc.svn_wc_status3_t_ood_kind_get, _wc.svn_wc_status3_t_ood_kind_set)
    repos_node_status = _swig_property(_wc.svn_wc_status3_t_repos_node_status_get, _wc.svn_wc_status3_t_repos_node_status_set)
    repos_text_status = _swig_property(_wc.svn_wc_status3_t_repos_text_status_get, _wc.svn_wc_status3_t_repos_text_status_set)
    repos_prop_status = _swig_property(_wc.svn_wc_status3_t_repos_prop_status_get, _wc.svn_wc_status3_t_repos_prop_status_set)
    repos_lock = _swig_property(_wc.svn_wc_status3_t_repos_lock_get, _wc.svn_wc_status3_t_repos_lock_set)
    ood_changed_rev = _swig_property(_wc.svn_wc_status3_t_ood_changed_rev_get, _wc.svn_wc_status3_t_ood_changed_rev_set)
    ood_changed_date = _swig_property(_wc.svn_wc_status3_t_ood_changed_date_get, _wc.svn_wc_status3_t_ood_changed_date_set)
    ood_changed_author = _swig_property(_wc.svn_wc_status3_t_ood_changed_author_get, _wc.svn_wc_status3_t_ood_changed_author_set)
    moved_from_abspath = _swig_property(_wc.svn_wc_status3_t_moved_from_abspath_get, _wc.svn_wc_status3_t_moved_from_abspath_set)
    moved_to_abspath = _swig_property(_wc.svn_wc_status3_t_moved_to_abspath_get, _wc.svn_wc_status3_t_moved_to_abspath_set)
    file_external = _swig_property(_wc.svn_wc_status3_t_file_external_get, _wc.svn_wc_status3_t_file_external_set)
    actual_kind = _swig_property(_wc.svn_wc_status3_t_actual_kind_get, _wc.svn_wc_status3_t_actual_kind_set)
    def set_parent_pool(self, parent_pool=None):
      """Create a new proxy object for TYPE"""
      import libsvn.core, weakref
      self.__dict__["_parent_pool"] = \
        parent_pool or libsvn.core.application_pool;
      if self.__dict__["_parent_pool"]:
        self.__dict__["_is_valid"] = weakref.ref(
          self.__dict__["_parent_pool"]._is_valid)

    def assert_valid(self):
      """Assert that this object is using valid pool memory"""
      if "_is_valid" in self.__dict__:
        assert self.__dict__["_is_valid"](), "Variable has already been deleted"

    def _retrieve_swig_value(self, name, value):
    # If we got back a different object than we have cached, we need to copy
    # all our metadata into it, so that it looks identical to the one
    # originally set.
      members = self.__dict__.get('_members')
      if members is not None and name in members:
        _copy_metadata_deep(value, members[name])

    # Verify that the new object is good
      _assert_valid_deep(value)

      return value

    # Attribute access must be intercepted to ensure that objects coming from
    # read attribute access match those that are set with write attribute access.
    # Specifically the metadata, such as the associated apr_pool object, should
    # match the originally assigned object.
    #
    # For classic classes it is enough to use __getattr__ to intercept swig
    # derived attributes. However, with new style classes SWIG makes use of
    # descriptors which mean that __getattr__ is never called. Therefore,
    # __getattribute__ must be used for the interception.

    if _newclass:
      def __getattribute__(self, name):
        """Manage access to all attributes of this object."""

    # Start by mimicing __getattr__ behavior: immediately return __dict__ or
    # items directly present in __dict__
        mydict = object.__getattribute__(self, '__dict__')

        if name == "__dict__":
          return mydict

        if name in mydict:
          return mydict[name]

        object.__getattribute__(self, 'assert_valid')()

        value = _get_instance_attr(self, name)
        fn = object.__getattribute__(self, '_retrieve_swig_value')
        return fn(name, value)
    else:
      def __getattr__(self, name):
        """Get an attribute from this object"""
        self.assert_valid()

        value = _swig_getattr(self, self.__class__, name)

        return self._retrieve_swig_value(name, value)

    def __setattr__(self, name, value):
      """Set an attribute on this object"""
      self.assert_valid()

    # Save a copy of the object, so that the garbage
    # collector won't kill the object while it's in
    # SWIG-land
      self.__dict__.setdefault("_members",{})[name] = value

      return _set_instance_attr(self, name, value)


    def __init__(self):
        """__init__(svn_wc_status3_t self) -> svn_wc_status3_t"""
        this = _wc.new_svn_wc_status3_t()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _wc.delete_svn_wc_status3_t
    __del__ = lambda self: None
svn_wc_status3_t_swigregister = _wc.svn_wc_status3_t_swigregister
svn_wc_status3_t_swigregister(svn_wc_status3_t)

class svn_wc_status2_t(object):
    """Proxy of C svn_wc_status2_t struct."""

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    entry = _swig_property(_wc.svn_wc_status2_t_entry_get, _wc.svn_wc_status2_t_entry_set)
    text_status = _swig_property(_wc.svn_wc_status2_t_text_status_get, _wc.svn_wc_status2_t_text_status_set)
    prop_status = _swig_property(_wc.svn_wc_status2_t_prop_status_get, _wc.svn_wc_status2_t_prop_status_set)
    locked = _swig_property(_wc.svn_wc_status2_t_locked_get, _wc.svn_wc_status2_t_locked_set)
    copied = _swig_property(_wc.svn_wc_status2_t_copied_get, _wc.svn_wc_status2_t_copied_set)
    switched = _swig_property(_wc.svn_wc_status2_t_switched_get, _wc.svn_wc_status2_t_switched_set)
    repos_text_status = _swig_property(_wc.svn_wc_status2_t_repos_text_status_get, _wc.svn_wc_status2_t_repos_text_status_set)
    repos_prop_status = _swig_property(_wc.svn_wc_status2_t_repos_prop_status_get, _wc.svn_wc_status2_t_repos_prop_status_set)
    repos_lock = _swig_property(_wc.svn_wc_status2_t_repos_lock_get, _wc.svn_wc_status2_t_repos_lock_set)
    url = _swig_property(_wc.svn_wc_status2_t_url_get, _wc.svn_wc_status2_t_url_set)
    ood_last_cmt_rev = _swig_property(_wc.svn_wc_status2_t_ood_last_cmt_rev_get, _wc.svn_wc_status2_t_ood_last_cmt_rev_set)
    ood_last_cmt_date = _swig_property(_wc.svn_wc_status2_t_ood_last_cmt_date_get, _wc.svn_wc_status2_t_ood_last_cmt_date_set)
    ood_kind = _swig_property(_wc.svn_wc_status2_t_ood_kind_get, _wc.svn_wc_status2_t_ood_kind_set)
    ood_last_cmt_author = _swig_property(_wc.svn_wc_status2_t_ood_last_cmt_author_get, _wc.svn_wc_status2_t_ood_last_cmt_author_set)
    tree_conflict = _swig_property(_wc.svn_wc_status2_t_tree_conflict_get, _wc.svn_wc_status2_t_tree_conflict_set)
    file_external = _swig_property(_wc.svn_wc_status2_t_file_external_get, _wc.svn_wc_status2_t_file_external_set)
    pristine_text_status = _swig_property(_wc.svn_wc_status2_t_pristine_text_status_get, _wc.svn_wc_status2_t_pristine_text_status_set)
    pristine_prop_status = _swig_property(_wc.svn_wc_status2_t_pristine_prop_status_get, _wc.svn_wc_status2_t_pristine_prop_status_set)
    def set_parent_pool(self, parent_pool=None):
      """Create a new proxy object for TYPE"""
      import libsvn.core, weakref
      self.__dict__["_parent_pool"] = \
        parent_pool or libsvn.core.application_pool;
      if self.__dict__["_parent_pool"]:
        self.__dict__["_is_valid"] = weakref.ref(
          self.__dict__["_parent_pool"]._is_valid)

    def assert_valid(self):
      """Assert that this object is using valid pool memory"""
      if "_is_valid" in self.__dict__:
        assert self.__dict__["_is_valid"](), "Variable has already been deleted"

    def _retrieve_swig_value(self, name, value):
    # If we got back a different object than we have cached, we need to copy
    # all our metadata into it, so that it looks identical to the one
    # originally set.
      members = self.__dict__.get('_members')
      if members is not None and name in members:
        _copy_metadata_deep(value, members[name])

    # Verify that the new object is good
      _assert_valid_deep(value)

      return value

    # Attribute access must be intercepted to ensure that objects coming from
    # read attribute access match those that are set with write attribute access.
    # Specifically the metadata, such as the associated apr_pool object, should
    # match the originally assigned object.
    #
    # For classic classes it is enough to use __getattr__ to intercept swig
    # derived attributes. However, with new style classes SWIG makes use of
    # descriptors which mean that __getattr__ is never called. Therefore,
    # __getattribute__ must be used for the interception.

    if _newclass:
      def __getattribute__(self, name):
        """Manage access to all attributes of this object."""

    # Start by mimicing __getattr__ behavior: immediately return __dict__ or
    # items directly present in __dict__
        mydict = object.__getattribute__(self, '__dict__')

        if name == "__dict__":
          return mydict

        if name in mydict:
          return mydict[name]

        object.__getattribute__(self, 'assert_valid')()

        value = _get_instance_attr(self, name)
        fn = object.__getattribute__(self, '_retrieve_swig_value')
        return fn(name, value)
    else:
      def __getattr__(self, name):
        """Get an attribute from this object"""
        self.assert_valid()

        value = _swig_getattr(self, self.__class__, name)

        return self._retrieve_swig_value(name, value)

    def __setattr__(self, name, value):
      """Set an attribute on this object"""
      self.assert_valid()

    # Save a copy of the object, so that the garbage
    # collector won't kill the object while it's in
    # SWIG-land
      self.__dict__.setdefault("_members",{})[name] = value

      return _set_instance_attr(self, name, value)


    def __init__(self):
        """__init__(svn_wc_status2_t self) -> svn_wc_status2_t"""
        this = _wc.new_svn_wc_status2_t()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _wc.delete_svn_wc_status2_t
    __del__ = lambda self: None
svn_wc_status2_t_swigregister = _wc.svn_wc_status2_t_swigregister
svn_wc_status2_t_swigregister(svn_wc_status2_t)

class svn_wc_status_t(object):
    """Proxy of C svn_wc_status_t struct."""

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    entry = _swig_property(_wc.svn_wc_status_t_entry_get, _wc.svn_wc_status_t_entry_set)
    text_status = _swig_property(_wc.svn_wc_status_t_text_status_get, _wc.svn_wc_status_t_text_status_set)
    prop_status = _swig_property(_wc.svn_wc_status_t_prop_status_get, _wc.svn_wc_status_t_prop_status_set)
    locked = _swig_property(_wc.svn_wc_status_t_locked_get, _wc.svn_wc_status_t_locked_set)
    copied = _swig_property(_wc.svn_wc_status_t_copied_get, _wc.svn_wc_status_t_copied_set)
    switched = _swig_property(_wc.svn_wc_status_t_switched_get, _wc.svn_wc_status_t_switched_set)
    repos_text_status = _swig_property(_wc.svn_wc_status_t_repos_text_status_get, _wc.svn_wc_status_t_repos_text_status_set)
    repos_prop_status = _swig_property(_wc.svn_wc_status_t_repos_prop_status_get, _wc.svn_wc_status_t_repos_prop_status_set)
    def set_parent_pool(self, parent_pool=None):
      """Create a new proxy object for TYPE"""
      import libsvn.core, weakref
      self.__dict__["_parent_pool"] = \
        parent_pool or libsvn.core.application_pool;
      if self.__dict__["_parent_pool"]:
        self.__dict__["_is_valid"] = weakref.ref(
          self.__dict__["_parent_pool"]._is_valid)

    def assert_valid(self):
      """Assert that this object is using valid pool memory"""
      if "_is_valid" in self.__dict__:
        assert self.__dict__["_is_valid"](), "Variable has already been deleted"

    def _retrieve_swig_value(self, name, value):
    # If we got back a different object than we have cached, we need to copy
    # all our metadata into it, so that it looks identical to the one
    # originally set.
      members = self.__dict__.get('_members')
      if members is not None and name in members:
        _copy_metadata_deep(value, members[name])

    # Verify that the new object is good
      _assert_valid_deep(value)

      return value

    # Attribute access must be intercepted to ensure that objects coming from
    # read attribute access match those that are set with write attribute access.
    # Specifically the metadata, such as the associated apr_pool object, should
    # match the originally assigned object.
    #
    # For classic classes it is enough to use __getattr__ to intercept swig
    # derived attributes. However, with new style classes SWIG makes use of
    # descriptors which mean that __getattr__ is never called. Therefore,
    # __getattribute__ must be used for the interception.

    if _newclass:
      def __getattribute__(self, name):
        """Manage access to all attributes of this object."""

    # Start by mimicing __getattr__ behavior: immediately return __dict__ or
    # items directly present in __dict__
        mydict = object.__getattribute__(self, '__dict__')

        if name == "__dict__":
          return mydict

        if name in mydict:
          return mydict[name]

        object.__getattribute__(self, 'assert_valid')()

        value = _get_instance_attr(self, name)
        fn = object.__getattribute__(self, '_retrieve_swig_value')
        return fn(name, value)
    else:
      def __getattr__(self, name):
        """Get an attribute from this object"""
        self.assert_valid()

        value = _swig_getattr(self, self.__class__, name)

        return self._retrieve_swig_value(name, value)

    def __setattr__(self, name, value):
      """Set an attribute on this object"""
      self.assert_valid()

    # Save a copy of the object, so that the garbage
    # collector won't kill the object while it's in
    # SWIG-land
      self.__dict__.setdefault("_members",{})[name] = value

      return _set_instance_attr(self, name, value)


    def __init__(self):
        """__init__(svn_wc_status_t self) -> svn_wc_status_t"""
        this = _wc.new_svn_wc_status_t()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _wc.delete_svn_wc_status_t
    __del__ = lambda self: None
svn_wc_status_t_swigregister = _wc.svn_wc_status_t_swigregister
svn_wc_status_t_swigregister(svn_wc_status_t)


def svn_wc_dup_status3(*args) -> "svn_wc_status3_t *":
    """svn_wc_dup_status3(svn_wc_status3_t orig_stat, apr_pool_t pool) -> svn_wc_status3_t"""
    return _wc.svn_wc_dup_status3(*args)

def svn_wc_dup_status2(*args) -> "svn_wc_status2_t *":
    """svn_wc_dup_status2(svn_wc_status2_t orig_stat, apr_pool_t pool) -> svn_wc_status2_t"""
    return _wc.svn_wc_dup_status2(*args)

def svn_wc_dup_status(*args) -> "svn_wc_status_t *":
    """svn_wc_dup_status(svn_wc_status_t orig_stat, apr_pool_t pool) -> svn_wc_status_t"""
    return _wc.svn_wc_dup_status(*args)

def svn_wc_status3(*args) -> "SWIGTYPE **":
    """svn_wc_status3(svn_wc_context_t * wc_ctx, char const * local_abspath, apr_pool_t result_pool, apr_pool_t scratch_pool) -> svn_error_t"""
    return _wc.svn_wc_status3(*args)

def svn_wc_status2(*args) -> "svn_wc_status2_t **":
    """svn_wc_status2(char const * path, svn_wc_adm_access_t * adm_access, apr_pool_t pool) -> svn_error_t"""
    return _wc.svn_wc_status2(*args)

def svn_wc_status(*args) -> "svn_wc_status_t **":
    """svn_wc_status(char const * path, svn_wc_adm_access_t * adm_access, apr_pool_t pool) -> svn_error_t"""
    return _wc.svn_wc_status(*args)

def svn_wc_walk_status(*args) -> "svn_error_t *":
    """svn_wc_walk_status(svn_wc_context_t * wc_ctx, char const * local_abspath, svn_depth_t depth, svn_boolean_t get_all, svn_boolean_t no_ignore, svn_boolean_t ignore_text_mods, apr_array_header_t ignore_patterns, svn_wc_status_func4_t status_func, void * status_baton, svn_cancel_func_t cancel_func, apr_pool_t scratch_pool) -> svn_error_t"""
    return _wc.svn_wc_walk_status(*args)

def svn_wc_get_status_editor5(*args) -> "svn_delta_editor_t const **, void **, void **, svn_revnum_t *":
    """svn_wc_get_status_editor5(svn_wc_context_t * wc_ctx, char const * anchor_abspath, char const * target_basename, svn_depth_t depth, svn_boolean_t get_all, svn_boolean_t no_ignore, svn_boolean_t depth_as_sticky, svn_boolean_t server_performs_filtering, apr_array_header_t ignore_patterns, svn_wc_status_func4_t status_func, void * status_baton, svn_cancel_func_t cancel_func, apr_pool_t result_pool, apr_pool_t scratch_pool) -> svn_error_t"""
    return _wc.svn_wc_get_status_editor5(*args)

def svn_wc_get_status_editor4(*args) -> "svn_delta_editor_t const **, void **, void **, svn_revnum_t *":
    """svn_wc_get_status_editor4(svn_wc_adm_access_t * anchor, char const * target, svn_depth_t depth, svn_boolean_t get_all, svn_boolean_t no_ignore, apr_array_header_t ignore_patterns, svn_wc_status_func3_t status_func, void * status_baton, svn_cancel_func_t cancel_func, svn_wc_traversal_info_t * traversal_info, apr_pool_t pool) -> svn_error_t"""
    return _wc.svn_wc_get_status_editor4(*args)

def svn_wc_get_status_editor3(*args) -> "svn_delta_editor_t const **, void **, void **, svn_revnum_t *":
    """svn_wc_get_status_editor3(svn_wc_adm_access_t * anchor, char const * target, svn_depth_t depth, svn_boolean_t get_all, svn_boolean_t no_ignore, apr_array_header_t ignore_patterns, svn_wc_status_func2_t status_func, svn_cancel_func_t cancel_func, svn_wc_traversal_info_t * traversal_info, apr_pool_t pool) -> svn_error_t"""
    return _wc.svn_wc_get_status_editor3(*args)

def svn_wc_get_status_editor2(*args) -> "svn_delta_editor_t const **, void **, void **, svn_revnum_t *":
    """svn_wc_get_status_editor2(svn_wc_adm_access_t * anchor, char const * target, apr_hash_t config, svn_boolean_t recurse, svn_boolean_t get_all, svn_boolean_t no_ignore, svn_wc_status_func2_t status_func, svn_cancel_func_t cancel_func, svn_wc_traversal_info_t * traversal_info, apr_pool_t pool) -> svn_error_t"""
    return _wc.svn_wc_get_status_editor2(*args)

def svn_wc_get_status_editor(*args) -> "svn_delta_editor_t const **, void **, svn_revnum_t *":
    """svn_wc_get_status_editor(svn_wc_adm_access_t * anchor, char const * target, apr_hash_t config, svn_boolean_t recurse, svn_boolean_t get_all, svn_boolean_t no_ignore, svn_wc_status_func_t status_func, svn_cancel_func_t cancel_func, svn_wc_traversal_info_t * traversal_info, apr_pool_t pool) -> svn_error_t"""
    return _wc.svn_wc_get_status_editor(*args)

def svn_wc_status_set_repos_locks(*args) -> "svn_error_t *":
    """svn_wc_status_set_repos_locks(void * set_locks_baton, apr_hash_t locks, char const * repos_root, apr_pool_t pool) -> svn_error_t"""
    return _wc.svn_wc_status_set_repos_locks(*args)

def svn_wc_copy3(*args) -> "svn_error_t *":
    """svn_wc_copy3(svn_wc_context_t * wc_ctx, char const * src_abspath, char const * dst_abspath, svn_boolean_t metadata_only, svn_cancel_func_t cancel_func, svn_wc_notify_func2_t notify_func, apr_pool_t scratch_pool) -> svn_error_t"""
    return _wc.svn_wc_copy3(*args)

def svn_wc_copy2(*args) -> "svn_error_t *":
    """svn_wc_copy2(char const * src, svn_wc_adm_access_t * dst_parent, char const * dst_basename, svn_cancel_func_t cancel_func, svn_wc_notify_func2_t notify_func, apr_pool_t pool) -> svn_error_t"""
    return _wc.svn_wc_copy2(*args)

def svn_wc_copy(*args) -> "svn_error_t *":
    """svn_wc_copy(char const * src, svn_wc_adm_access_t * dst_parent, char const * dst_basename, svn_cancel_func_t cancel_func, svn_wc_notify_func_t notify_func, apr_pool_t pool) -> svn_error_t"""
    return _wc.svn_wc_copy(*args)

def svn_wc_move(*args) -> "svn_error_t *":
    """svn_wc_move(svn_wc_context_t * wc_ctx, char const * src_abspath, char const * dst_abspath, svn_boolean_t metadata_only, svn_cancel_func_t cancel_func, svn_wc_notify_func2_t notify_func, apr_pool_t scratch_pool) -> svn_error_t"""
    return _wc.svn_wc_move(*args)

def svn_wc_delete4(*args) -> "svn_error_t *":
    """svn_wc_delete4(svn_wc_context_t * wc_ctx, char const * local_abspath, svn_boolean_t keep_local, svn_boolean_t delete_unversioned_target, svn_cancel_func_t cancel_func, svn_wc_notify_func2_t notify_func, apr_pool_t scratch_pool) -> svn_error_t"""
    return _wc.svn_wc_delete4(*args)

def svn_wc_delete3(*args) -> "svn_error_t *":
    """svn_wc_delete3(char const * path, svn_wc_adm_access_t * adm_access, svn_cancel_func_t cancel_func, svn_wc_notify_func2_t notify_func, svn_boolean_t keep_local, apr_pool_t pool) -> svn_error_t"""
    return _wc.svn_wc_delete3(*args)

def svn_wc_delete2(*args) -> "svn_error_t *":
    """svn_wc_delete2(char const * path, svn_wc_adm_access_t * adm_access, svn_cancel_func_t cancel_func, svn_wc_notify_func2_t notify_func, apr_pool_t pool) -> svn_error_t"""
    return _wc.svn_wc_delete2(*args)

def svn_wc_delete(*args) -> "svn_error_t *":
    """svn_wc_delete(char const * path, svn_wc_adm_access_t * adm_access, svn_cancel_func_t cancel_func, svn_wc_notify_func_t notify_func, apr_pool_t pool) -> svn_error_t"""
    return _wc.svn_wc_delete(*args)

def svn_wc_add_from_disk3(*args) -> "svn_error_t *":
    """svn_wc_add_from_disk3(svn_wc_context_t * wc_ctx, char const * local_abspath, apr_hash_t props, svn_boolean_t skip_checks, svn_wc_notify_func2_t notify_func, apr_pool_t scratch_pool) -> svn_error_t"""
    return _wc.svn_wc_add_from_disk3(*args)

def svn_wc_add_from_disk2(*args) -> "svn_error_t *":
    """svn_wc_add_from_disk2(svn_wc_context_t * wc_ctx, char const * local_abspath, apr_hash_t props, svn_wc_notify_func2_t notify_func, apr_pool_t scratch_pool) -> svn_error_t"""
    return _wc.svn_wc_add_from_disk2(*args)

def svn_wc_add_from_disk(*args) -> "svn_error_t *":
    """svn_wc_add_from_disk(svn_wc_context_t * wc_ctx, char const * local_abspath, svn_wc_notify_func2_t notify_func, apr_pool_t scratch_pool) -> svn_error_t"""
    return _wc.svn_wc_add_from_disk(*args)

def svn_wc_add4(*args) -> "svn_error_t *":
    """svn_wc_add4(svn_wc_context_t * wc_ctx, char const * local_abspath, svn_depth_t depth, char const * copyfrom_url, svn_revnum_t copyfrom_rev, svn_cancel_func_t cancel_func, svn_wc_notify_func2_t notify_func, apr_pool_t scratch_pool) -> svn_error_t"""
    return _wc.svn_wc_add4(*args)

def svn_wc_add3(*args) -> "svn_error_t *":
    """svn_wc_add3(char const * path, svn_wc_adm_access_t * parent_access, svn_depth_t depth, char const * copyfrom_url, svn_revnum_t copyfrom_rev, svn_cancel_func_t cancel_func, svn_wc_notify_func2_t notify_func, apr_pool_t pool) -> svn_error_t"""
    return _wc.svn_wc_add3(*args)

def svn_wc_add2(*args) -> "svn_error_t *":
    """svn_wc_add2(char const * path, svn_wc_adm_access_t * parent_access, char const * copyfrom_url, svn_revnum_t copyfrom_rev, svn_cancel_func_t cancel_func, svn_wc_notify_func2_t notify_func, apr_pool_t pool) -> svn_error_t"""
    return _wc.svn_wc_add2(*args)

def svn_wc_add(*args) -> "svn_error_t *":
    """svn_wc_add(char const * path, svn_wc_adm_access_t * parent_access, char const * copyfrom_url, svn_revnum_t copyfrom_rev, svn_cancel_func_t cancel_func, svn_wc_notify_func_t notify_func, apr_pool_t pool) -> svn_error_t"""
    return _wc.svn_wc_add(*args)

def svn_wc_add_repos_file4(*args) -> "svn_error_t *":
    """svn_wc_add_repos_file4(svn_wc_context_t * wc_ctx, char const * local_abspath, svn_stream_t * new_base_contents, svn_stream_t * new_contents, apr_hash_t new_base_props, apr_hash_t new_props, char const * copyfrom_url, svn_revnum_t copyfrom_rev, svn_cancel_func_t cancel_func, apr_pool_t scratch_pool) -> svn_error_t"""
    return _wc.svn_wc_add_repos_file4(*args)

def svn_wc_add_repos_file3(*args) -> "svn_error_t *":
    """svn_wc_add_repos_file3(char const * dst_path, svn_wc_adm_access_t * adm_access, svn_stream_t * new_base_contents, svn_stream_t * new_contents, apr_hash_t new_base_props, apr_hash_t new_props, char const * copyfrom_url, svn_revnum_t copyfrom_rev, svn_cancel_func_t cancel_func, svn_wc_notify_func2_t notify_func, apr_pool_t scratch_pool) -> svn_error_t"""
    return _wc.svn_wc_add_repos_file3(*args)

def svn_wc_add_repos_file2(*args) -> "svn_error_t *":
    """svn_wc_add_repos_file2(char const * dst_path, svn_wc_adm_access_t * adm_access, char const * new_text_base_path, char const * new_text_path, apr_hash_t new_base_props, apr_hash_t new_props, char const * copyfrom_url, svn_revnum_t copyfrom_rev, apr_pool_t pool) -> svn_error_t"""
    return _wc.svn_wc_add_repos_file2(*args)

def svn_wc_add_repos_file(*args) -> "svn_error_t *":
    """svn_wc_add_repos_file(char const * dst_path, svn_wc_adm_access_t * adm_access, char const * new_text_path, apr_hash_t new_props, char const * copyfrom_url, svn_revnum_t copyfrom_rev, apr_pool_t pool) -> svn_error_t"""
    return _wc.svn_wc_add_repos_file(*args)

def svn_wc_remove_from_revision_control2(*args) -> "svn_error_t *":
    """svn_wc_remove_from_revision_control2(svn_wc_context_t * wc_ctx, char const * local_abspath, svn_boolean_t destroy_wf, svn_boolean_t instant_error, svn_cancel_func_t cancel_func, apr_pool_t pool) -> svn_error_t"""
    return _wc.svn_wc_remove_from_revision_control2(*args)

def svn_wc_remove_from_revision_control(*args) -> "svn_error_t *":
    """svn_wc_remove_from_revision_control(svn_wc_adm_access_t * adm_access, char const * name, svn_boolean_t destroy_wf, svn_boolean_t instant_error, svn_cancel_func_t cancel_func, apr_pool_t pool) -> svn_error_t"""
    return _wc.svn_wc_remove_from_revision_control(*args)

def svn_wc_resolved_conflict5(*args) -> "svn_error_t *":
    """svn_wc_resolved_conflict5(svn_wc_context_t * wc_ctx, char const * local_abspath, svn_depth_t depth, svn_boolean_t resolve_text, char const * resolve_prop, svn_boolean_t resolve_tree, svn_wc_conflict_choice_t conflict_choice, svn_cancel_func_t cancel_func, svn_wc_notify_func2_t notify_func, apr_pool_t scratch_pool) -> svn_error_t"""
    return _wc.svn_wc_resolved_conflict5(*args)

def svn_wc_resolved_conflict4(*args) -> "svn_error_t *":
    """svn_wc_resolved_conflict4(char const * path, svn_wc_adm_access_t * adm_access, svn_boolean_t resolve_text, svn_boolean_t resolve_props, svn_boolean_t resolve_tree, svn_depth_t depth, svn_wc_conflict_choice_t conflict_choice, svn_wc_notify_func2_t notify_func, svn_cancel_func_t cancel_func, apr_pool_t pool) -> svn_error_t"""
    return _wc.svn_wc_resolved_conflict4(*args)

def svn_wc_resolved_conflict3(*args) -> "svn_error_t *":
    """svn_wc_resolved_conflict3(char const * path, svn_wc_adm_access_t * adm_access, svn_boolean_t resolve_text, svn_boolean_t resolve_props, svn_depth_t depth, svn_wc_conflict_choice_t conflict_choice, svn_wc_notify_func2_t notify_func, svn_cancel_func_t cancel_func, apr_pool_t pool) -> svn_error_t"""
    return _wc.svn_wc_resolved_conflict3(*args)

def svn_wc_resolved_conflict2(*args) -> "svn_error_t *":
    """svn_wc_resolved_conflict2(char const * path, svn_wc_adm_access_t * adm_access, svn_boolean_t resolve_text, svn_boolean_t resolve_props, svn_boolean_t recurse, svn_wc_notify_func2_t notify_func, svn_cancel_func_t cancel_func, apr_pool_t pool) -> svn_error_t"""
    return _wc.svn_wc_resolved_conflict2(*args)

def svn_wc_resolved_conflict(*args) -> "svn_error_t *":
    """svn_wc_resolved_conflict(char const * path, svn_wc_adm_access_t * adm_access, svn_boolean_t resolve_text, svn_boolean_t resolve_props, svn_boolean_t recurse, svn_wc_notify_func_t notify_func, apr_pool_t pool) -> svn_error_t"""
    return _wc.svn_wc_resolved_conflict(*args)

def svn_wc_committed_queue_create(*args) -> "svn_wc_committed_queue_t *":
    """svn_wc_committed_queue_create(apr_pool_t pool) -> svn_wc_committed_queue_t *"""
    return _wc.svn_wc_committed_queue_create(*args)

def svn_wc_queue_committed4(*args) -> "svn_error_t *":
    """svn_wc_queue_committed4(svn_wc_committed_queue_t * queue, svn_wc_context_t * wc_ctx, char const * local_abspath, svn_boolean_t recurse, svn_boolean_t is_committed, apr_array_header_t wcprop_changes, svn_boolean_t remove_lock, svn_boolean_t remove_changelist, svn_checksum_t sha1_checksum, apr_pool_t scratch_pool) -> svn_error_t"""
    return _wc.svn_wc_queue_committed4(*args)

def svn_wc_queue_committed3(*args) -> "svn_error_t *":
    """svn_wc_queue_committed3(svn_wc_committed_queue_t * queue, svn_wc_context_t * wc_ctx, char const * local_abspath, svn_boolean_t recurse, apr_array_header_t wcprop_changes, svn_boolean_t remove_lock, svn_boolean_t remove_changelist, svn_checksum_t sha1_checksum, apr_pool_t scratch_pool) -> svn_error_t"""
    return _wc.svn_wc_queue_committed3(*args)

def svn_wc_queue_committed2(*args) -> "svn_error_t *":
    """svn_wc_queue_committed2(svn_wc_committed_queue_t * queue, char const * path, svn_wc_adm_access_t * adm_access, svn_boolean_t recurse, apr_array_header_t wcprop_changes, svn_boolean_t remove_lock, svn_boolean_t remove_changelist, svn_checksum_t md5_checksum, apr_pool_t scratch_pool) -> svn_error_t"""
    return _wc.svn_wc_queue_committed2(*args)

def svn_wc_queue_committed(*args) -> "svn_wc_committed_queue_t **, unsigned char const *":
    """svn_wc_queue_committed(char const * path, svn_wc_adm_access_t * adm_access, svn_boolean_t recurse, apr_array_header_t wcprop_changes, svn_boolean_t remove_lock, svn_boolean_t remove_changelist, unsigned char const * digest, apr_pool_t pool) -> svn_error_t"""
    return _wc.svn_wc_queue_committed(*args)

def svn_wc_process_committed_queue2(*args) -> "svn_error_t *":
    """svn_wc_process_committed_queue2(svn_wc_committed_queue_t * queue, svn_wc_context_t * wc_ctx, svn_revnum_t new_revnum, char const * rev_date, char const * rev_author, svn_cancel_func_t cancel_func, apr_pool_t scratch_pool) -> svn_error_t"""
    return _wc.svn_wc_process_committed_queue2(*args)

def svn_wc_process_committed_queue(*args) -> "svn_error_t *":
    """svn_wc_process_committed_queue(svn_wc_committed_queue_t * queue, svn_wc_adm_access_t * adm_access, svn_revnum_t new_revnum, char const * rev_date, char const * rev_author, apr_pool_t pool) -> svn_error_t"""
    return _wc.svn_wc_process_committed_queue(*args)

def svn_wc_process_committed4(*args) -> "unsigned char const *":
    """svn_wc_process_committed4(char const * path, svn_wc_adm_access_t * adm_access, svn_boolean_t recurse, svn_revnum_t new_revnum, char const * rev_date, char const * rev_author, apr_array_header_t wcprop_changes, svn_boolean_t remove_lock, svn_boolean_t remove_changelist, unsigned char const * digest, apr_pool_t pool) -> svn_error_t"""
    return _wc.svn_wc_process_committed4(*args)

def svn_wc_process_committed3(*args) -> "unsigned char const *":
    """svn_wc_process_committed3(char const * path, svn_wc_adm_access_t * adm_access, svn_boolean_t recurse, svn_revnum_t new_revnum, char const * rev_date, char const * rev_author, apr_array_header_t wcprop_changes, svn_boolean_t remove_lock, unsigned char const * digest, apr_pool_t pool) -> svn_error_t"""
    return _wc.svn_wc_process_committed3(*args)

def svn_wc_process_committed2(*args) -> "svn_error_t *":
    """svn_wc_process_committed2(char const * path, svn_wc_adm_access_t * adm_access, svn_boolean_t recurse, svn_revnum_t new_revnum, char const * rev_date, char const * rev_author, apr_array_header_t wcprop_changes, svn_boolean_t remove_lock, apr_pool_t pool) -> svn_error_t"""
    return _wc.svn_wc_process_committed2(*args)

def svn_wc_process_committed(*args) -> "svn_error_t *":
    """svn_wc_process_committed(char const * path, svn_wc_adm_access_t * adm_access, svn_boolean_t recurse, svn_revnum_t new_revnum, char const * rev_date, char const * rev_author, apr_array_header_t wcprop_changes, apr_pool_t pool) -> svn_error_t"""
    return _wc.svn_wc_process_committed(*args)

def svn_wc_crawl_revisions5(*args) -> "svn_error_t *":
    """svn_wc_crawl_revisions5(svn_wc_context_t * wc_ctx, char const * local_abspath, svn_ra_reporter3_t reporter, void * report_baton, svn_boolean_t restore_files, svn_depth_t depth, svn_boolean_t honor_depth_exclude, svn_boolean_t depth_compatibility_trick, svn_boolean_t use_commit_times, svn_cancel_func_t cancel_func, svn_wc_notify_func2_t notify_func, apr_pool_t scratch_pool) -> svn_error_t"""
    return _wc.svn_wc_crawl_revisions5(*args)

def svn_wc_crawl_revisions4(*args) -> "svn_error_t *":
    """svn_wc_crawl_revisions4(char const * path, svn_wc_adm_access_t * adm_access, svn_ra_reporter3_t reporter, void * report_baton, svn_boolean_t restore_files, svn_depth_t depth, svn_boolean_t honor_depth_exclude, svn_boolean_t depth_compatibility_trick, svn_boolean_t use_commit_times, svn_wc_notify_func2_t notify_func, svn_wc_traversal_info_t * traversal_info, apr_pool_t pool) -> svn_error_t"""
    return _wc.svn_wc_crawl_revisions4(*args)

def svn_wc_crawl_revisions3(*args) -> "svn_error_t *":
    """svn_wc_crawl_revisions3(char const * path, svn_wc_adm_access_t * adm_access, svn_ra_reporter3_t reporter, void * report_baton, svn_boolean_t restore_files, svn_depth_t depth, svn_boolean_t depth_compatibility_trick, svn_boolean_t use_commit_times, svn_wc_notify_func2_t notify_func, svn_wc_traversal_info_t * traversal_info, apr_pool_t pool) -> svn_error_t"""
    return _wc.svn_wc_crawl_revisions3(*args)

def svn_wc_crawl_revisions2(*args) -> "svn_error_t *":
    """svn_wc_crawl_revisions2(char const * path, svn_wc_adm_access_t * adm_access, svn_ra_reporter2_t reporter, svn_boolean_t restore_files, svn_boolean_t recurse, svn_boolean_t use_commit_times, svn_wc_notify_func2_t notify_func, svn_wc_traversal_info_t * traversal_info, apr_pool_t pool) -> svn_error_t"""
    return _wc.svn_wc_crawl_revisions2(*args)

def svn_wc_crawl_revisions(*args) -> "svn_error_t *":
    """svn_wc_crawl_revisions(char const * path, svn_wc_adm_access_t * adm_access, svn_ra_reporter_t reporter, void * report_baton, svn_boolean_t restore_files, svn_boolean_t recurse, svn_boolean_t use_commit_times, svn_wc_notify_func_t notify_func, svn_wc_traversal_info_t * traversal_info, apr_pool_t pool) -> svn_error_t"""
    return _wc.svn_wc_crawl_revisions(*args)

def svn_wc_check_root(*args) -> "svn_boolean_t *, svn_boolean_t *, svn_node_kind_t *":
    """svn_wc_check_root(svn_wc_context_t * wc_ctx, char const * local_abspath, apr_pool_t scratch_pool) -> svn_error_t"""
    return _wc.svn_wc_check_root(*args)

def svn_wc_is_wc_root2(*args) -> "svn_boolean_t *":
    """svn_wc_is_wc_root2(svn_wc_context_t * wc_ctx, char const * local_abspath, apr_pool_t scratch_pool) -> svn_error_t"""
    return _wc.svn_wc_is_wc_root2(*args)

def svn_wc_is_wc_root(*args) -> "svn_boolean_t *":
    """svn_wc_is_wc_root(char const * path, svn_wc_adm_access_t * adm_access, apr_pool_t pool) -> svn_error_t"""
    return _wc.svn_wc_is_wc_root(*args)

def svn_wc_get_actual_target2(*args) -> "char const **, char const **":
    """svn_wc_get_actual_target2(svn_wc_context_t * wc_ctx, char const * path, apr_pool_t result_pool, apr_pool_t scratch_pool) -> svn_error_t"""
    return _wc.svn_wc_get_actual_target2(*args)

def svn_wc_get_actual_target(*args) -> "char const **, char const **":
    """svn_wc_get_actual_target(char const * path, apr_pool_t pool) -> svn_error_t"""
    return _wc.svn_wc_get_actual_target(*args)

def svn_wc_get_update_editor4(*args) -> "svn_delta_editor_t const **, void **, svn_revnum_t *":
    """svn_wc_get_update_editor4(svn_wc_context_t * wc_ctx, char const * anchor_abspath, char const * target_basename, svn_boolean_t use_commit_times, svn_depth_t depth, svn_boolean_t depth_is_sticky, svn_boolean_t allow_unver_obstructions, svn_boolean_t adds_as_modification, svn_boolean_t server_performs_filtering, svn_boolean_t clean_checkout, char const * diff3_cmd, apr_array_header_t preserved_exts, svn_wc_dirents_func_t fetch_dirents_func, void * fetch_dirents_baton, svn_wc_conflict_resolver_func2_t conflict_func, void * conflict_baton, svn_wc_external_update_t external_func, void * external_baton, svn_cancel_func_t cancel_func, svn_wc_notify_func2_t notify_func, apr_pool_t result_pool, apr_pool_t scratch_pool) -> svn_error_t"""
    return _wc.svn_wc_get_update_editor4(*args)

def svn_wc_get_update_editor3(*args) -> "svn_revnum_t *, svn_delta_editor_t const **, void **":
    """svn_wc_get_update_editor3(svn_wc_adm_access_t * anchor, char const * target, svn_boolean_t use_commit_times, svn_depth_t depth, svn_boolean_t depth_is_sticky, svn_boolean_t allow_unver_obstructions, svn_wc_notify_func2_t notify_func, svn_cancel_func_t cancel_func, svn_wc_conflict_resolver_func_t conflict_func, void * conflict_baton, svn_wc_get_file_t fetch_func, void * fetch_baton, char const * diff3_cmd, apr_array_header_t preserved_exts, svn_wc_traversal_info_t * ti, apr_pool_t pool) -> svn_error_t"""
    return _wc.svn_wc_get_update_editor3(*args)

def svn_wc_get_update_editor2(*args) -> "svn_revnum_t *, svn_delta_editor_t const **, void **":
    """svn_wc_get_update_editor2(svn_wc_adm_access_t * anchor, char const * target, svn_boolean_t use_commit_times, svn_boolean_t recurse, svn_wc_notify_func2_t notify_func, svn_cancel_func_t cancel_func, char const * diff3_cmd, svn_wc_traversal_info_t * ti, apr_pool_t pool) -> svn_error_t"""
    return _wc.svn_wc_get_update_editor2(*args)

def svn_wc_get_update_editor(*args) -> "svn_revnum_t *, svn_delta_editor_t const **, void **":
    """svn_wc_get_update_editor(svn_wc_adm_access_t * anchor, char const * target, svn_boolean_t use_commit_times, svn_boolean_t recurse, svn_wc_notify_func_t notify_func, svn_cancel_func_t cancel_func, char const * diff3_cmd, svn_wc_traversal_info_t * ti, apr_pool_t pool) -> svn_error_t"""
    return _wc.svn_wc_get_update_editor(*args)

def svn_wc_get_switch_editor4(*args) -> "svn_delta_editor_t const **, void **, svn_revnum_t *":
    """svn_wc_get_switch_editor4(svn_wc_context_t * wc_ctx, char const * anchor_abspath, char const * target_basename, char const * switch_url, svn_boolean_t use_commit_times, svn_depth_t depth, svn_boolean_t depth_is_sticky, svn_boolean_t allow_unver_obstructions, svn_boolean_t server_performs_filtering, char const * diff3_cmd, apr_array_header_t preserved_exts, svn_wc_dirents_func_t fetch_dirents_func, void * fetch_dirents_baton, svn_wc_conflict_resolver_func2_t conflict_func, void * conflict_baton, svn_wc_external_update_t external_func, void * external_baton, svn_cancel_func_t cancel_func, svn_wc_notify_func2_t notify_func, apr_pool_t result_pool, apr_pool_t scratch_pool) -> svn_error_t"""
    return _wc.svn_wc_get_switch_editor4(*args)

def svn_wc_get_switch_editor3(*args) -> "svn_revnum_t *, svn_delta_editor_t const **, void **":
    """svn_wc_get_switch_editor3(svn_wc_adm_access_t * anchor, char const * target, char const * switch_url, svn_boolean_t use_commit_times, svn_depth_t depth, svn_boolean_t depth_is_sticky, svn_boolean_t allow_unver_obstructions, svn_wc_notify_func2_t notify_func, svn_cancel_func_t cancel_func, svn_wc_conflict_resolver_func_t conflict_func, void * conflict_baton, char const * diff3_cmd, apr_array_header_t preserved_exts, svn_wc_traversal_info_t * ti, apr_pool_t pool) -> svn_error_t"""
    return _wc.svn_wc_get_switch_editor3(*args)

def svn_wc_get_switch_editor2(*args) -> "svn_revnum_t *, svn_delta_editor_t const **, void **":
    """svn_wc_get_switch_editor2(svn_wc_adm_access_t * anchor, char const * target, char const * switch_url, svn_boolean_t use_commit_times, svn_boolean_t recurse, svn_wc_notify_func2_t notify_func, svn_cancel_func_t cancel_func, char const * diff3_cmd, svn_wc_traversal_info_t * ti, apr_pool_t pool) -> svn_error_t"""
    return _wc.svn_wc_get_switch_editor2(*args)

def svn_wc_get_switch_editor(*args) -> "svn_revnum_t *, svn_delta_editor_t const **, void **":
    """svn_wc_get_switch_editor(svn_wc_adm_access_t * anchor, char const * target, char const * switch_url, svn_boolean_t use_commit_times, svn_boolean_t recurse, svn_wc_notify_func_t notify_func, svn_cancel_func_t cancel_func, char const * diff3_cmd, svn_wc_traversal_info_t * ti, apr_pool_t pool) -> svn_error_t"""
    return _wc.svn_wc_get_switch_editor(*args)

def svn_wc_prop_list2(*args) -> "apr_hash_t **":
    """svn_wc_prop_list2(svn_wc_context_t * wc_ctx, char const * local_abspath, apr_pool_t result_pool, apr_pool_t scratch_pool) -> svn_error_t"""
    return _wc.svn_wc_prop_list2(*args)

def svn_wc_prop_list(*args) -> "apr_hash_t **":
    """svn_wc_prop_list(char const * path, svn_wc_adm_access_t * adm_access, apr_pool_t pool) -> svn_error_t"""
    return _wc.svn_wc_prop_list(*args)

def svn_wc_get_pristine_props(*args) -> "apr_hash_t **":
    """svn_wc_get_pristine_props(svn_wc_context_t * wc_ctx, char const * local_abspath, apr_pool_t result_pool, apr_pool_t scratch_pool) -> svn_error_t"""
    return _wc.svn_wc_get_pristine_props(*args)

def svn_wc_prop_get2(*args) -> "svn_string_t **":
    """svn_wc_prop_get2(svn_wc_context_t * wc_ctx, char const * local_abspath, char const * name, apr_pool_t result_pool, apr_pool_t scratch_pool) -> svn_error_t"""
    return _wc.svn_wc_prop_get2(*args)

def svn_wc_prop_get(*args) -> "svn_string_t **":
    """svn_wc_prop_get(char const * name, char const * path, svn_wc_adm_access_t * adm_access, apr_pool_t pool) -> svn_error_t"""
    return _wc.svn_wc_prop_get(*args)

def svn_wc_prop_set4(*args) -> "svn_error_t *":
    """svn_wc_prop_set4(svn_wc_context_t * wc_ctx, char const * local_abspath, char const * name, svn_string_t const * value, svn_depth_t depth, svn_boolean_t skip_checks, apr_array_header_t changelist_filter, svn_cancel_func_t cancel_func, svn_wc_notify_func2_t notify_func, apr_pool_t scratch_pool) -> svn_error_t"""
    return _wc.svn_wc_prop_set4(*args)

def svn_wc_prop_set3(*args) -> "svn_error_t *":
    """svn_wc_prop_set3(char const * name, svn_string_t const * value, char const * path, svn_wc_adm_access_t * adm_access, svn_boolean_t skip_checks, svn_wc_notify_func2_t notify_func, apr_pool_t pool) -> svn_error_t"""
    return _wc.svn_wc_prop_set3(*args)

def svn_wc_prop_set2(*args) -> "svn_error_t *":
    """svn_wc_prop_set2(char const * name, svn_string_t const * value, char const * path, svn_wc_adm_access_t * adm_access, svn_boolean_t skip_checks, apr_pool_t pool) -> svn_error_t"""
    return _wc.svn_wc_prop_set2(*args)

def svn_wc_prop_set(*args) -> "svn_error_t *":
    """svn_wc_prop_set(char const * name, svn_string_t const * value, char const * path, svn_wc_adm_access_t * adm_access, apr_pool_t pool) -> svn_error_t"""
    return _wc.svn_wc_prop_set(*args)

def svn_wc_is_normal_prop(name: 'char const *') -> "svn_boolean_t":
    """svn_wc_is_normal_prop(char const * name) -> svn_boolean_t"""
    return _wc.svn_wc_is_normal_prop(name)

def svn_wc_is_wc_prop(name: 'char const *') -> "svn_boolean_t":
    """svn_wc_is_wc_prop(char const * name) -> svn_boolean_t"""
    return _wc.svn_wc_is_wc_prop(name)

def svn_wc_is_entry_prop(name: 'char const *') -> "svn_boolean_t":
    """svn_wc_is_entry_prop(char const * name) -> svn_boolean_t"""
    return _wc.svn_wc_is_entry_prop(name)

def svn_wc_canonicalize_svn_prop(*args) -> "svn_string_t **":
    """svn_wc_canonicalize_svn_prop(char const * propname, svn_string_t const * propval, char const * path, svn_node_kind_t kind, svn_boolean_t skip_some_checks, svn_wc_canonicalize_svn_prop_get_file_t prop_getter, void * getter_baton, apr_pool_t pool) -> svn_error_t"""
    return _wc.svn_wc_canonicalize_svn_prop(*args)

def svn_wc_get_diff_editor6(*args) -> "svn_delta_editor_t const **, void **":
    """svn_wc_get_diff_editor6(svn_wc_context_t * wc_ctx, char const * anchor_abspath, char const * target, svn_depth_t depth, svn_boolean_t ignore_ancestry, svn_boolean_t show_copies_as_adds, svn_boolean_t use_git_diff_format, svn_boolean_t use_text_base, svn_boolean_t reverse_order, svn_boolean_t server_performs_filtering, apr_array_header_t changelist_filter, svn_wc_diff_callbacks4_t callbacks, void * callback_baton, svn_cancel_func_t cancel_func, apr_pool_t result_pool, apr_pool_t scratch_pool) -> svn_error_t"""
    return _wc.svn_wc_get_diff_editor6(*args)

def svn_wc_get_diff_editor5(*args) -> "svn_delta_editor_t const **, void **":
    """svn_wc_get_diff_editor5(svn_wc_adm_access_t * anchor, char const * target, svn_wc_diff_callbacks3_t callbacks, void * callback_baton, svn_depth_t depth, svn_boolean_t ignore_ancestry, svn_boolean_t use_text_base, svn_boolean_t reverse_order, svn_cancel_func_t cancel_func, apr_array_header_t changelist_filter, apr_pool_t pool) -> svn_error_t"""
    return _wc.svn_wc_get_diff_editor5(*args)

def svn_wc_get_diff_editor4(*args) -> "svn_delta_editor_t const **, void **":
    """svn_wc_get_diff_editor4(svn_wc_adm_access_t * anchor, char const * target, svn_wc_diff_callbacks2_t callbacks, svn_depth_t depth, svn_boolean_t ignore_ancestry, svn_boolean_t use_text_base, svn_boolean_t reverse_order, svn_cancel_func_t cancel_func, apr_array_header_t changelist_filter, apr_pool_t pool) -> svn_error_t"""
    return _wc.svn_wc_get_diff_editor4(*args)

def svn_wc_get_diff_editor3(*args) -> "svn_delta_editor_t const **, void **":
    """svn_wc_get_diff_editor3(svn_wc_adm_access_t * anchor, char const * target, svn_wc_diff_callbacks2_t callbacks, svn_boolean_t recurse, svn_boolean_t ignore_ancestry, svn_boolean_t use_text_base, svn_boolean_t reverse_order, svn_cancel_func_t cancel_func, apr_pool_t pool) -> svn_error_t"""
    return _wc.svn_wc_get_diff_editor3(*args)

def svn_wc_get_diff_editor2(*args) -> "svn_delta_editor_t const **, void **":
    """svn_wc_get_diff_editor2(svn_wc_adm_access_t * anchor, char const * target, svn_wc_diff_callbacks_t callbacks, void * callback_baton, svn_boolean_t recurse, svn_boolean_t ignore_ancestry, svn_boolean_t use_text_base, svn_boolean_t reverse_order, svn_cancel_func_t cancel_func, apr_pool_t pool) -> svn_error_t"""
    return _wc.svn_wc_get_diff_editor2(*args)

def svn_wc_get_diff_editor(*args) -> "svn_delta_editor_t const **, void **":
    """svn_wc_get_diff_editor(svn_wc_adm_access_t * anchor, char const * target, svn_wc_diff_callbacks_t callbacks, void * callback_baton, svn_boolean_t recurse, svn_boolean_t use_text_base, svn_boolean_t reverse_order, svn_cancel_func_t cancel_func, apr_pool_t pool) -> svn_error_t"""
    return _wc.svn_wc_get_diff_editor(*args)

def svn_wc_diff6(*args) -> "svn_error_t *":
    """svn_wc_diff6(svn_wc_context_t * wc_ctx, char const * target_abspath, svn_wc_diff_callbacks4_t callbacks, void * callback_baton, svn_depth_t depth, svn_boolean_t ignore_ancestry, svn_boolean_t show_copies_as_adds, svn_boolean_t use_git_diff_format, apr_array_header_t changelist_filter, svn_cancel_func_t cancel_func, apr_pool_t scratch_pool) -> svn_error_t"""
    return _wc.svn_wc_diff6(*args)

def svn_wc_diff5(*args) -> "svn_error_t *":
    """svn_wc_diff5(svn_wc_adm_access_t * anchor, char const * target, svn_wc_diff_callbacks3_t callbacks, void * callback_baton, svn_depth_t depth, svn_boolean_t ignore_ancestry, apr_array_header_t changelist_filter, apr_pool_t pool) -> svn_error_t"""
    return _wc.svn_wc_diff5(*args)

def svn_wc_diff4(*args) -> "svn_error_t *":
    """svn_wc_diff4(svn_wc_adm_access_t * anchor, char const * target, svn_wc_diff_callbacks2_t callbacks, svn_depth_t depth, svn_boolean_t ignore_ancestry, apr_array_header_t changelist_filter, apr_pool_t pool) -> svn_error_t"""
    return _wc.svn_wc_diff4(*args)

def svn_wc_diff3(*args) -> "svn_error_t *":
    """svn_wc_diff3(svn_wc_adm_access_t * anchor, char const * target, svn_wc_diff_callbacks2_t callbacks, svn_boolean_t recurse, svn_boolean_t ignore_ancestry, apr_pool_t pool) -> svn_error_t"""
    return _wc.svn_wc_diff3(*args)

def svn_wc_diff2(*args) -> "svn_error_t *":
    """svn_wc_diff2(svn_wc_adm_access_t * anchor, char const * target, svn_wc_diff_callbacks_t callbacks, void * callback_baton, svn_boolean_t recurse, svn_boolean_t ignore_ancestry, apr_pool_t pool) -> svn_error_t"""
    return _wc.svn_wc_diff2(*args)

def svn_wc_diff(*args) -> "svn_error_t *":
    """svn_wc_diff(svn_wc_adm_access_t * anchor, char const * target, svn_wc_diff_callbacks_t callbacks, void * callback_baton, svn_boolean_t recurse, apr_pool_t pool) -> svn_error_t"""
    return _wc.svn_wc_diff(*args)

def svn_wc_get_prop_diffs2(*args) -> "apr_array_header_t **, apr_hash_t **":
    """svn_wc_get_prop_diffs2(svn_wc_context_t * wc_ctx, char const * local_abspath, apr_pool_t result_pool, apr_pool_t scratch_pool) -> svn_error_t"""
    return _wc.svn_wc_get_prop_diffs2(*args)

def svn_wc_get_prop_diffs(*args) -> "apr_array_header_t **, apr_hash_t **":
    """svn_wc_get_prop_diffs(char const * path, svn_wc_adm_access_t * adm_access, apr_pool_t pool) -> svn_error_t"""
    return _wc.svn_wc_get_prop_diffs(*args)
svn_wc_merge_unchanged = _wc.svn_wc_merge_unchanged
svn_wc_merge_merged = _wc.svn_wc_merge_merged
svn_wc_merge_conflict = _wc.svn_wc_merge_conflict
svn_wc_merge_no_merge = _wc.svn_wc_merge_no_merge

def svn_wc_merge5(*args) -> "enum svn_wc_merge_outcome_t *":
    """svn_wc_merge5(enum svn_wc_notify_state_t * merge_props_state, svn_wc_context_t * wc_ctx, char const * left_abspath, char const * right_abspath, char const * target_abspath, char const * left_label, char const * right_label, char const * target_label, svn_wc_conflict_version_t left_version, svn_wc_conflict_version_t right_version, svn_boolean_t dry_run, char const * diff3_cmd, apr_array_header_t merge_options, apr_hash_t original_props, apr_array_header_t prop_diff, svn_wc_conflict_resolver_func2_t conflict_func, void * conflict_baton, svn_cancel_func_t cancel_func, apr_pool_t scratch_pool) -> svn_error_t"""
    return _wc.svn_wc_merge5(*args)

def svn_wc_merge4(*args) -> "enum svn_wc_merge_outcome_t *":
    """svn_wc_merge4(svn_wc_context_t * wc_ctx, char const * left_abspath, char const * right_abspath, char const * target_abspath, char const * left_label, char const * right_label, char const * target_label, svn_wc_conflict_version_t left_version, svn_wc_conflict_version_t right_version, svn_boolean_t dry_run, char const * diff3_cmd, apr_array_header_t merge_options, apr_array_header_t prop_diff, svn_wc_conflict_resolver_func2_t conflict_func, void * conflict_baton, svn_cancel_func_t cancel_func, apr_pool_t scratch_pool) -> svn_error_t"""
    return _wc.svn_wc_merge4(*args)

def svn_wc_merge3(*args) -> "enum svn_wc_merge_outcome_t *":
    """svn_wc_merge3(char const * left, char const * right, char const * merge_target, svn_wc_adm_access_t * adm_access, char const * left_label, char const * right_label, char const * target_label, svn_boolean_t dry_run, char const * diff3_cmd, apr_array_header_t merge_options, apr_array_header_t prop_diff, svn_wc_conflict_resolver_func_t conflict_func, void * conflict_baton, apr_pool_t pool) -> svn_error_t"""
    return _wc.svn_wc_merge3(*args)

def svn_wc_merge2(*args) -> "enum svn_wc_merge_outcome_t *":
    """svn_wc_merge2(char const * left, char const * right, char const * merge_target, svn_wc_adm_access_t * adm_access, char const * left_label, char const * right_label, char const * target_label, svn_boolean_t dry_run, char const * diff3_cmd, apr_array_header_t merge_options, apr_pool_t pool) -> svn_error_t"""
    return _wc.svn_wc_merge2(*args)

def svn_wc_merge(*args) -> "enum svn_wc_merge_outcome_t *":
    """svn_wc_merge(char const * left, char const * right, char const * merge_target, svn_wc_adm_access_t * adm_access, char const * left_label, char const * right_label, char const * target_label, svn_boolean_t dry_run, char const * diff3_cmd, apr_pool_t pool) -> svn_error_t"""
    return _wc.svn_wc_merge(*args)

def svn_wc_merge_props3(*args) -> "svn_error_t *":
    """svn_wc_merge_props3(svn_wc_notify_state_t * state, svn_wc_context_t * wc_ctx, char const * local_abspath, svn_wc_conflict_version_t left_version, svn_wc_conflict_version_t right_version, apr_hash_t baseprops, apr_array_header_t propchanges, svn_boolean_t dry_run, svn_wc_conflict_resolver_func2_t conflict_func, void * conflict_baton, svn_cancel_func_t cancel_func, apr_pool_t scratch_pool) -> svn_error_t"""
    return _wc.svn_wc_merge_props3(*args)

def svn_wc_merge_props2(*args) -> "svn_error_t *":
    """svn_wc_merge_props2(svn_wc_notify_state_t * state, char const * path, svn_wc_adm_access_t * adm_access, apr_hash_t baseprops, apr_array_header_t propchanges, svn_boolean_t base_merge, svn_boolean_t dry_run, svn_wc_conflict_resolver_func_t conflict_func, void * conflict_baton, apr_pool_t pool) -> svn_error_t"""
    return _wc.svn_wc_merge_props2(*args)

def svn_wc_merge_props(*args) -> "svn_error_t *":
    """svn_wc_merge_props(svn_wc_notify_state_t * state, char const * path, svn_wc_adm_access_t * adm_access, apr_hash_t baseprops, apr_array_header_t propchanges, svn_boolean_t base_merge, svn_boolean_t dry_run, apr_pool_t pool) -> svn_error_t"""
    return _wc.svn_wc_merge_props(*args)

def svn_wc_merge_prop_diffs(*args) -> "svn_error_t *":
    """svn_wc_merge_prop_diffs(svn_wc_notify_state_t * state, char const * path, svn_wc_adm_access_t * adm_access, apr_array_header_t propchanges, svn_boolean_t base_merge, svn_boolean_t dry_run, apr_pool_t pool) -> svn_error_t"""
    return _wc.svn_wc_merge_prop_diffs(*args)

def svn_wc_get_pristine_contents2(*args) -> "svn_stream_t **":
    """svn_wc_get_pristine_contents2(svn_wc_context_t * wc_ctx, char const * local_abspath, apr_pool_t result_pool, apr_pool_t scratch_pool) -> svn_error_t"""
    return _wc.svn_wc_get_pristine_contents2(*args)

def svn_wc_get_pristine_contents(*args) -> "svn_stream_t **":
    """svn_wc_get_pristine_contents(char const * path, apr_pool_t result_pool, apr_pool_t scratch_pool) -> svn_error_t"""
    return _wc.svn_wc_get_pristine_contents(*args)

def svn_wc_get_pristine_copy_path(*args) -> "char const **":
    """svn_wc_get_pristine_copy_path(char const * path, apr_pool_t pool) -> svn_error_t"""
    return _wc.svn_wc_get_pristine_copy_path(*args)

def svn_wc_cleanup4(*args) -> "svn_error_t *":
    """svn_wc_cleanup4(svn_wc_context_t * wc_ctx, char const * local_abspath, svn_boolean_t break_locks, svn_boolean_t fix_recorded_timestamps, svn_boolean_t clear_dav_cache, svn_boolean_t vacuum_pristines, svn_cancel_func_t cancel_func, svn_wc_notify_func2_t notify_func, apr_pool_t scratch_pool) -> svn_error_t"""
    return _wc.svn_wc_cleanup4(*args)

def svn_wc_cleanup3(*args) -> "svn_error_t *":
    """svn_wc_cleanup3(svn_wc_context_t * wc_ctx, char const * local_abspath, svn_cancel_func_t cancel_func, apr_pool_t scratch_pool) -> svn_error_t"""
    return _wc.svn_wc_cleanup3(*args)

def svn_wc_cleanup2(*args) -> "svn_error_t *":
    """svn_wc_cleanup2(char const * path, char const * diff3_cmd, svn_cancel_func_t cancel_func, apr_pool_t pool) -> svn_error_t"""
    return _wc.svn_wc_cleanup2(*args)

def svn_wc_cleanup(*args) -> "svn_error_t *":
    """svn_wc_cleanup(char const * path, svn_wc_adm_access_t * optional_adm_access, char const * diff3_cmd, svn_cancel_func_t cancel_func, apr_pool_t pool) -> svn_error_t"""
    return _wc.svn_wc_cleanup(*args)

def svn_wc_upgrade(*args) -> "svn_error_t *":
    """svn_wc_upgrade(svn_wc_context_t * wc_ctx, char const * local_abspath, svn_wc_upgrade_get_repos_info_t repos_info_func, void * repos_info_baton, svn_cancel_func_t cancel_func, svn_wc_notify_func2_t notify_func, apr_pool_t scratch_pool) -> svn_error_t"""
    return _wc.svn_wc_upgrade(*args)

def svn_wc_relocate4(*args) -> "svn_error_t *":
    """svn_wc_relocate4(svn_wc_context_t * wc_ctx, char const * wcroot_abspath, char const * arg3, char const * to, svn_wc_relocation_validator3_t validator, void * validator_baton, apr_pool_t scratch_pool) -> svn_error_t"""
    return _wc.svn_wc_relocate4(*args)

def svn_wc_relocate3(*args) -> "svn_error_t *":
    """svn_wc_relocate3(char const * path, svn_wc_adm_access_t * adm_access, char const * arg3, char const * to, svn_boolean_t recurse, svn_wc_relocation_validator3_t validator, void * validator_baton, apr_pool_t pool) -> svn_error_t"""
    return _wc.svn_wc_relocate3(*args)

def svn_wc_relocate2(*args) -> "svn_error_t *":
    """svn_wc_relocate2(char const * path, svn_wc_adm_access_t * adm_access, char const * arg3, char const * to, svn_boolean_t recurse, svn_wc_relocation_validator2_t validator, void * validator_baton, apr_pool_t pool) -> svn_error_t"""
    return _wc.svn_wc_relocate2(*args)

def svn_wc_relocate(*args) -> "svn_error_t *":
    """svn_wc_relocate(char const * path, svn_wc_adm_access_t * adm_access, char const * arg3, char const * to, svn_boolean_t recurse, svn_wc_relocation_validator_t validator, void * validator_baton, apr_pool_t pool) -> svn_error_t"""
    return _wc.svn_wc_relocate(*args)

def svn_wc_revert6(*args) -> "svn_error_t *":
    """svn_wc_revert6(svn_wc_context_t * wc_ctx, char const * local_abspath, svn_depth_t depth, svn_boolean_t use_commit_times, apr_array_header_t changelist_filter, svn_boolean_t clear_changelists, svn_boolean_t metadata_only, svn_boolean_t added_keep_local, svn_cancel_func_t cancel_func, svn_wc_notify_func2_t notify_func, apr_pool_t scratch_pool) -> svn_error_t"""
    return _wc.svn_wc_revert6(*args)

def svn_wc_revert5(*args) -> "svn_error_t *":
    """svn_wc_revert5(svn_wc_context_t * wc_ctx, char const * local_abspath, svn_depth_t depth, svn_boolean_t use_commit_times, apr_array_header_t changelist_filter, svn_boolean_t clear_changelists, svn_boolean_t metadata_only, svn_cancel_func_t cancel_func, svn_wc_notify_func2_t notify_func, apr_pool_t scratch_pool) -> svn_error_t"""
    return _wc.svn_wc_revert5(*args)

def svn_wc_revert4(*args) -> "svn_error_t *":
    """svn_wc_revert4(svn_wc_context_t * wc_ctx, char const * local_abspath, svn_depth_t depth, svn_boolean_t use_commit_times, apr_array_header_t changelist_filter, svn_cancel_func_t cancel_func, svn_wc_notify_func2_t notify_func, apr_pool_t scratch_pool) -> svn_error_t"""
    return _wc.svn_wc_revert4(*args)

def svn_wc_revert3(*args) -> "svn_error_t *":
    """svn_wc_revert3(char const * path, svn_wc_adm_access_t * parent_access, svn_depth_t depth, svn_boolean_t use_commit_times, apr_array_header_t changelist_filter, svn_cancel_func_t cancel_func, svn_wc_notify_func2_t notify_func, apr_pool_t pool) -> svn_error_t"""
    return _wc.svn_wc_revert3(*args)

def svn_wc_revert2(*args) -> "svn_error_t *":
    """svn_wc_revert2(char const * path, svn_wc_adm_access_t * parent_access, svn_boolean_t recursive, svn_boolean_t use_commit_times, svn_cancel_func_t cancel_func, svn_wc_notify_func2_t notify_func, apr_pool_t pool) -> svn_error_t"""
    return _wc.svn_wc_revert2(*args)

def svn_wc_revert(*args) -> "svn_error_t *":
    """svn_wc_revert(char const * path, svn_wc_adm_access_t * parent_access, svn_boolean_t recursive, svn_boolean_t use_commit_times, svn_cancel_func_t cancel_func, svn_wc_notify_func_t notify_func, apr_pool_t pool) -> svn_error_t"""
    return _wc.svn_wc_revert(*args)

def svn_wc_restore(*args) -> "svn_error_t *":
    """svn_wc_restore(svn_wc_context_t * wc_ctx, char const * local_abspath, svn_boolean_t use_commit_times, apr_pool_t scratch_pool) -> svn_error_t"""
    return _wc.svn_wc_restore(*args)

def svn_wc_create_tmp_file2(*args) -> "apr_file_t **, char const **":
    """svn_wc_create_tmp_file2(char const * path, svn_io_file_del_t delete_when, apr_pool_t pool) -> svn_error_t"""
    return _wc.svn_wc_create_tmp_file2(*args)

def svn_wc_create_tmp_file(*args) -> "apr_file_t **":
    """svn_wc_create_tmp_file(char const * path, svn_boolean_t delete_on_close, apr_pool_t pool) -> svn_error_t"""
    return _wc.svn_wc_create_tmp_file(*args)

def svn_wc_translated_file2(*args) -> "char const **":
    """svn_wc_translated_file2(char const * src, char const * versioned_file, svn_wc_adm_access_t * adm_access, apr_uint32_t flags, apr_pool_t pool) -> svn_error_t"""
    return _wc.svn_wc_translated_file2(*args)

def svn_wc_translated_file(*args) -> "char const **":
    """svn_wc_translated_file(char const * vfile, svn_wc_adm_access_t * adm_access, svn_boolean_t force_repair, apr_pool_t pool) -> svn_error_t"""
    return _wc.svn_wc_translated_file(*args)

def svn_wc_translated_stream(*args) -> "svn_stream_t **":
    """svn_wc_translated_stream(char const * path, char const * versioned_file, svn_wc_adm_access_t * adm_access, apr_uint32_t flags, apr_pool_t pool) -> svn_error_t"""
    return _wc.svn_wc_translated_stream(*args)

def svn_wc_transmit_text_deltas3(*args) -> "svn_checksum_t **, svn_checksum_t **":
    """svn_wc_transmit_text_deltas3(svn_wc_context_t * wc_ctx, char const * local_abspath, svn_boolean_t fulltext, svn_delta_editor_t editor, void * file_baton, apr_pool_t result_pool, apr_pool_t scratch_pool) -> svn_error_t"""
    return _wc.svn_wc_transmit_text_deltas3(*args)

def svn_wc_transmit_text_deltas2(*args) -> "char const **, unsigned char [ANY]":
    """svn_wc_transmit_text_deltas2(char const * path, svn_wc_adm_access_t * adm_access, svn_boolean_t fulltext, svn_delta_editor_t editor, void * file_baton, apr_pool_t pool) -> svn_error_t"""
    return _wc.svn_wc_transmit_text_deltas2(*args)

def svn_wc_transmit_text_deltas(*args) -> "char const **":
    """svn_wc_transmit_text_deltas(char const * path, svn_wc_adm_access_t * adm_access, svn_boolean_t fulltext, svn_delta_editor_t editor, void * file_baton, apr_pool_t pool) -> svn_error_t"""
    return _wc.svn_wc_transmit_text_deltas(*args)

def svn_wc_transmit_prop_deltas2(*args) -> "svn_error_t *":
    """svn_wc_transmit_prop_deltas2(svn_wc_context_t * wc_ctx, char const * local_abspath, svn_delta_editor_t editor, void * baton, apr_pool_t scratch_pool) -> svn_error_t"""
    return _wc.svn_wc_transmit_prop_deltas2(*args)

def svn_wc_transmit_prop_deltas(*args) -> "char const **":
    """svn_wc_transmit_prop_deltas(char const * path, svn_wc_adm_access_t * adm_access, svn_wc_entry_t entry, svn_delta_editor_t editor, void * baton, apr_pool_t pool) -> svn_error_t"""
    return _wc.svn_wc_transmit_prop_deltas(*args)

def svn_wc_get_default_ignores(*args) -> "apr_array_header_t **":
    """svn_wc_get_default_ignores(apr_hash_t config, apr_pool_t pool) -> svn_error_t"""
    return _wc.svn_wc_get_default_ignores(*args)

def svn_wc_get_ignores2(*args) -> "apr_array_header_t **":
    """svn_wc_get_ignores2(svn_wc_context_t * wc_ctx, char const * local_abspath, apr_hash_t config, apr_pool_t result_pool, apr_pool_t scratch_pool) -> svn_error_t"""
    return _wc.svn_wc_get_ignores2(*args)

def svn_wc_get_ignores(*args) -> "apr_array_header_t **":
    """svn_wc_get_ignores(apr_hash_t config, svn_wc_adm_access_t * adm_access, apr_pool_t pool) -> svn_error_t"""
    return _wc.svn_wc_get_ignores(*args)

def svn_wc_match_ignore_list(*args) -> "svn_boolean_t":
    """svn_wc_match_ignore_list(char const * str, apr_array_header_t list, apr_pool_t pool) -> svn_boolean_t"""
    return _wc.svn_wc_match_ignore_list(*args)

def svn_wc_add_lock2(*args) -> "svn_error_t *":
    """svn_wc_add_lock2(svn_wc_context_t * wc_ctx, char const * abspath, svn_lock_t lock, apr_pool_t scratch_pool) -> svn_error_t"""
    return _wc.svn_wc_add_lock2(*args)

def svn_wc_add_lock(*args) -> "svn_error_t *":
    """svn_wc_add_lock(char const * path, svn_lock_t lock, svn_wc_adm_access_t * adm_access, apr_pool_t pool) -> svn_error_t"""
    return _wc.svn_wc_add_lock(*args)

def svn_wc_remove_lock2(*args) -> "svn_error_t *":
    """svn_wc_remove_lock2(svn_wc_context_t * wc_ctx, char const * local_abspath, apr_pool_t scratch_pool) -> svn_error_t"""
    return _wc.svn_wc_remove_lock2(*args)

def svn_wc_remove_lock(*args) -> "svn_error_t *":
    """svn_wc_remove_lock(char const * path, svn_wc_adm_access_t * adm_access, apr_pool_t pool) -> svn_error_t"""
    return _wc.svn_wc_remove_lock(*args)
class svn_wc_revision_status_t(object):
    """Proxy of C svn_wc_revision_status_t struct."""

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    min_rev = _swig_property(_wc.svn_wc_revision_status_t_min_rev_get, _wc.svn_wc_revision_status_t_min_rev_set)
    max_rev = _swig_property(_wc.svn_wc_revision_status_t_max_rev_get, _wc.svn_wc_revision_status_t_max_rev_set)
    switched = _swig_property(_wc.svn_wc_revision_status_t_switched_get, _wc.svn_wc_revision_status_t_switched_set)
    modified = _swig_property(_wc.svn_wc_revision_status_t_modified_get, _wc.svn_wc_revision_status_t_modified_set)
    sparse_checkout = _swig_property(_wc.svn_wc_revision_status_t_sparse_checkout_get, _wc.svn_wc_revision_status_t_sparse_checkout_set)
    def set_parent_pool(self, parent_pool=None):
      """Create a new proxy object for TYPE"""
      import libsvn.core, weakref
      self.__dict__["_parent_pool"] = \
        parent_pool or libsvn.core.application_pool;
      if self.__dict__["_parent_pool"]:
        self.__dict__["_is_valid"] = weakref.ref(
          self.__dict__["_parent_pool"]._is_valid)

    def assert_valid(self):
      """Assert that this object is using valid pool memory"""
      if "_is_valid" in self.__dict__:
        assert self.__dict__["_is_valid"](), "Variable has already been deleted"

    def _retrieve_swig_value(self, name, value):
    # If we got back a different object than we have cached, we need to copy
    # all our metadata into it, so that it looks identical to the one
    # originally set.
      members = self.__dict__.get('_members')
      if members is not None and name in members:
        _copy_metadata_deep(value, members[name])

    # Verify that the new object is good
      _assert_valid_deep(value)

      return value

    # Attribute access must be intercepted to ensure that objects coming from
    # read attribute access match those that are set with write attribute access.
    # Specifically the metadata, such as the associated apr_pool object, should
    # match the originally assigned object.
    #
    # For classic classes it is enough to use __getattr__ to intercept swig
    # derived attributes. However, with new style classes SWIG makes use of
    # descriptors which mean that __getattr__ is never called. Therefore,
    # __getattribute__ must be used for the interception.

    if _newclass:
      def __getattribute__(self, name):
        """Manage access to all attributes of this object."""

    # Start by mimicing __getattr__ behavior: immediately return __dict__ or
    # items directly present in __dict__
        mydict = object.__getattribute__(self, '__dict__')

        if name == "__dict__":
          return mydict

        if name in mydict:
          return mydict[name]

        object.__getattribute__(self, 'assert_valid')()

        value = _get_instance_attr(self, name)
        fn = object.__getattribute__(self, '_retrieve_swig_value')
        return fn(name, value)
    else:
      def __getattr__(self, name):
        """Get an attribute from this object"""
        self.assert_valid()

        value = _swig_getattr(self, self.__class__, name)

        return self._retrieve_swig_value(name, value)

    def __setattr__(self, name, value):
      """Set an attribute on this object"""
      self.assert_valid()

    # Save a copy of the object, so that the garbage
    # collector won't kill the object while it's in
    # SWIG-land
      self.__dict__.setdefault("_members",{})[name] = value

      return _set_instance_attr(self, name, value)


    def __init__(self):
        """__init__(svn_wc_revision_status_t self) -> svn_wc_revision_status_t"""
        this = _wc.new_svn_wc_revision_status_t()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _wc.delete_svn_wc_revision_status_t
    __del__ = lambda self: None
svn_wc_revision_status_t_swigregister = _wc.svn_wc_revision_status_t_swigregister
svn_wc_revision_status_t_swigregister(svn_wc_revision_status_t)


def svn_wc_revision_status2(*args) -> "svn_wc_revision_status_t **":
    """svn_wc_revision_status2(svn_wc_context_t * wc_ctx, char const * local_abspath, char const * trail_url, svn_boolean_t committed, svn_cancel_func_t cancel_func, apr_pool_t result_pool, apr_pool_t scratch_pool) -> svn_error_t"""
    return _wc.svn_wc_revision_status2(*args)

def svn_wc_revision_status(*args) -> "svn_wc_revision_status_t **":
    """svn_wc_revision_status(char const * wc_path, char const * trail_url, svn_boolean_t committed, svn_cancel_func_t cancel_func, apr_pool_t pool) -> svn_error_t"""
    return _wc.svn_wc_revision_status(*args)

def svn_wc_set_changelist2(*args) -> "svn_error_t *":
    """svn_wc_set_changelist2(svn_wc_context_t * wc_ctx, char const * local_abspath, char const * changelist, svn_depth_t depth, apr_array_header_t changelist_filter, svn_cancel_func_t cancel_func, svn_wc_notify_func2_t notify_func, apr_pool_t scratch_pool) -> svn_error_t"""
    return _wc.svn_wc_set_changelist2(*args)

def svn_wc_set_changelist(*args) -> "svn_error_t *":
    """svn_wc_set_changelist(char const * path, char const * changelist, svn_wc_adm_access_t * adm_access, svn_cancel_func_t cancel_func, svn_wc_notify_func2_t notify_func, apr_pool_t pool) -> svn_error_t"""
    return _wc.svn_wc_set_changelist(*args)

def svn_wc_get_changelists(*args) -> "svn_error_t *":
    """svn_wc_get_changelists(svn_wc_context_t * wc_ctx, char const * local_abspath, svn_depth_t depth, apr_array_header_t changelist_filter, svn_changelist_receiver_t callback_func, void * callback_baton, svn_cancel_func_t cancel_func, apr_pool_t scratch_pool) -> svn_error_t"""
    return _wc.svn_wc_get_changelists(*args)

def svn_wc_crop_tree2(*args) -> "svn_error_t *":
    """svn_wc_crop_tree2(svn_wc_context_t * wc_ctx, char const * local_abspath, svn_depth_t depth, svn_cancel_func_t cancel_func, svn_wc_notify_func2_t notify_func, apr_pool_t scratch_pool) -> svn_error_t"""
    return _wc.svn_wc_crop_tree2(*args)

def svn_wc_crop_tree(*args) -> "svn_error_t *":
    """svn_wc_crop_tree(svn_wc_adm_access_t * anchor, char const * target, svn_depth_t depth, svn_wc_notify_func2_t notify_func, svn_cancel_func_t cancel_func, apr_pool_t pool) -> svn_error_t"""
    return _wc.svn_wc_crop_tree(*args)

def svn_wc_exclude(*args) -> "svn_error_t *":
    """svn_wc_exclude(svn_wc_context_t * wc_ctx, char const * local_abspath, svn_cancel_func_t cancel_func, svn_wc_notify_func2_t notify_func, apr_pool_t scratch_pool) -> svn_error_t"""
    return _wc.svn_wc_exclude(*args)

def svn_wc_read_kind2(*args) -> "svn_node_kind_t *":
    """svn_wc_read_kind2(svn_wc_context_t * wc_ctx, char const * local_abspath, svn_boolean_t show_deleted, svn_boolean_t show_hidden, apr_pool_t scratch_pool) -> svn_error_t"""
    return _wc.svn_wc_read_kind2(*args)

def svn_wc_read_kind(*args) -> "svn_node_kind_t *":
    """svn_wc_read_kind(svn_wc_context_t * wc_ctx, char const * abspath, svn_boolean_t show_hidden, apr_pool_t scratch_pool) -> svn_error_t"""
    return _wc.svn_wc_read_kind(*args)
class svn_wc_context_t(object):
    """Proxy of C svn_wc_context_t struct."""

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    def set_parent_pool(self, parent_pool=None):
      """Create a new proxy object for TYPE"""
      import libsvn.core, weakref
      self.__dict__["_parent_pool"] = \
        parent_pool or libsvn.core.application_pool;
      if self.__dict__["_parent_pool"]:
        self.__dict__["_is_valid"] = weakref.ref(
          self.__dict__["_parent_pool"]._is_valid)

    def assert_valid(self):
      """Assert that this object is using valid pool memory"""
      if "_is_valid" in self.__dict__:
        assert self.__dict__["_is_valid"](), "Variable has already been deleted"

    def _retrieve_swig_value(self, name, value):
    # If we got back a different object than we have cached, we need to copy
    # all our metadata into it, so that it looks identical to the one
    # originally set.
      members = self.__dict__.get('_members')
      if members is not None and name in members:
        _copy_metadata_deep(value, members[name])

    # Verify that the new object is good
      _assert_valid_deep(value)

      return value

    # Attribute access must be intercepted to ensure that objects coming from
    # read attribute access match those that are set with write attribute access.
    # Specifically the metadata, such as the associated apr_pool object, should
    # match the originally assigned object.
    #
    # For classic classes it is enough to use __getattr__ to intercept swig
    # derived attributes. However, with new style classes SWIG makes use of
    # descriptors which mean that __getattr__ is never called. Therefore,
    # __getattribute__ must be used for the interception.

    if _newclass:
      def __getattribute__(self, name):
        """Manage access to all attributes of this object."""

    # Start by mimicing __getattr__ behavior: immediately return __dict__ or
    # items directly present in __dict__
        mydict = object.__getattribute__(self, '__dict__')

        if name == "__dict__":
          return mydict

        if name in mydict:
          return mydict[name]

        object.__getattribute__(self, 'assert_valid')()

        value = _get_instance_attr(self, name)
        fn = object.__getattribute__(self, '_retrieve_swig_value')
        return fn(name, value)
    else:
      def __getattr__(self, name):
        """Get an attribute from this object"""
        self.assert_valid()

        value = _swig_getattr(self, self.__class__, name)

        return self._retrieve_swig_value(name, value)

    def __setattr__(self, name, value):
      """Set an attribute on this object"""
      self.assert_valid()

    # Save a copy of the object, so that the garbage
    # collector won't kill the object while it's in
    # SWIG-land
      self.__dict__.setdefault("_members",{})[name] = value

      return _set_instance_attr(self, name, value)

svn_wc_context_t_swigregister = _wc.svn_wc_context_t_swigregister
svn_wc_context_t_swigregister(svn_wc_context_t)

class svn_wc_adm_access_t(object):
    """Proxy of C svn_wc_adm_access_t struct."""

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    def set_parent_pool(self, parent_pool=None):
      """Create a new proxy object for TYPE"""
      import libsvn.core, weakref
      self.__dict__["_parent_pool"] = \
        parent_pool or libsvn.core.application_pool;
      if self.__dict__["_parent_pool"]:
        self.__dict__["_is_valid"] = weakref.ref(
          self.__dict__["_parent_pool"]._is_valid)

    def assert_valid(self):
      """Assert that this object is using valid pool memory"""
      if "_is_valid" in self.__dict__:
        assert self.__dict__["_is_valid"](), "Variable has already been deleted"

    def _retrieve_swig_value(self, name, value):
    # If we got back a different object than we have cached, we need to copy
    # all our metadata into it, so that it looks identical to the one
    # originally set.
      members = self.__dict__.get('_members')
      if members is not None and name in members:
        _copy_metadata_deep(value, members[name])

    # Verify that the new object is good
      _assert_valid_deep(value)

      return value

    # Attribute access must be intercepted to ensure that objects coming from
    # read attribute access match those that are set with write attribute access.
    # Specifically the metadata, such as the associated apr_pool object, should
    # match the originally assigned object.
    #
    # For classic classes it is enough to use __getattr__ to intercept swig
    # derived attributes. However, with new style classes SWIG makes use of
    # descriptors which mean that __getattr__ is never called. Therefore,
    # __getattribute__ must be used for the interception.

    if _newclass:
      def __getattribute__(self, name):
        """Manage access to all attributes of this object."""

    # Start by mimicing __getattr__ behavior: immediately return __dict__ or
    # items directly present in __dict__
        mydict = object.__getattribute__(self, '__dict__')

        if name == "__dict__":
          return mydict

        if name in mydict:
          return mydict[name]

        object.__getattribute__(self, 'assert_valid')()

        value = _get_instance_attr(self, name)
        fn = object.__getattribute__(self, '_retrieve_swig_value')
        return fn(name, value)
    else:
      def __getattr__(self, name):
        """Get an attribute from this object"""
        self.assert_valid()

        value = _swig_getattr(self, self.__class__, name)

        return self._retrieve_swig_value(name, value)

    def __setattr__(self, name, value):
      """Set an attribute on this object"""
      self.assert_valid()

    # Save a copy of the object, so that the garbage
    # collector won't kill the object while it's in
    # SWIG-land
      self.__dict__.setdefault("_members",{})[name] = value

      return _set_instance_attr(self, name, value)

svn_wc_adm_access_t_swigregister = _wc.svn_wc_adm_access_t_swigregister
svn_wc_adm_access_t_swigregister(svn_wc_adm_access_t)

class svn_wc_traversal_info_t(object):
    """Proxy of C svn_wc_traversal_info_t struct."""

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    def set_parent_pool(self, parent_pool=None):
      """Create a new proxy object for TYPE"""
      import libsvn.core, weakref
      self.__dict__["_parent_pool"] = \
        parent_pool or libsvn.core.application_pool;
      if self.__dict__["_parent_pool"]:
        self.__dict__["_is_valid"] = weakref.ref(
          self.__dict__["_parent_pool"]._is_valid)

    def assert_valid(self):
      """Assert that this object is using valid pool memory"""
      if "_is_valid" in self.__dict__:
        assert self.__dict__["_is_valid"](), "Variable has already been deleted"

    def _retrieve_swig_value(self, name, value):
    # If we got back a different object than we have cached, we need to copy
    # all our metadata into it, so that it looks identical to the one
    # originally set.
      members = self.__dict__.get('_members')
      if members is not None and name in members:
        _copy_metadata_deep(value, members[name])

    # Verify that the new object is good
      _assert_valid_deep(value)

      return value

    # Attribute access must be intercepted to ensure that objects coming from
    # read attribute access match those that are set with write attribute access.
    # Specifically the metadata, such as the associated apr_pool object, should
    # match the originally assigned object.
    #
    # For classic classes it is enough to use __getattr__ to intercept swig
    # derived attributes. However, with new style classes SWIG makes use of
    # descriptors which mean that __getattr__ is never called. Therefore,
    # __getattribute__ must be used for the interception.

    if _newclass:
      def __getattribute__(self, name):
        """Manage access to all attributes of this object."""

    # Start by mimicing __getattr__ behavior: immediately return __dict__ or
    # items directly present in __dict__
        mydict = object.__getattribute__(self, '__dict__')

        if name == "__dict__":
          return mydict

        if name in mydict:
          return mydict[name]

        object.__getattribute__(self, 'assert_valid')()

        value = _get_instance_attr(self, name)
        fn = object.__getattribute__(self, '_retrieve_swig_value')
        return fn(name, value)
    else:
      def __getattr__(self, name):
        """Get an attribute from this object"""
        self.assert_valid()

        value = _swig_getattr(self, self.__class__, name)

        return self._retrieve_swig_value(name, value)

    def __setattr__(self, name, value):
      """Set an attribute on this object"""
      self.assert_valid()

    # Save a copy of the object, so that the garbage
    # collector won't kill the object while it's in
    # SWIG-land
      self.__dict__.setdefault("_members",{})[name] = value

      return _set_instance_attr(self, name, value)

svn_wc_traversal_info_t_swigregister = _wc.svn_wc_traversal_info_t_swigregister
svn_wc_traversal_info_t_swigregister(svn_wc_traversal_info_t)

class svn_wc_committed_queue_t(object):
    """Proxy of C svn_wc_committed_queue_t struct."""

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    def set_parent_pool(self, parent_pool=None):
      """Create a new proxy object for TYPE"""
      import libsvn.core, weakref
      self.__dict__["_parent_pool"] = \
        parent_pool or libsvn.core.application_pool;
      if self.__dict__["_parent_pool"]:
        self.__dict__["_is_valid"] = weakref.ref(
          self.__dict__["_parent_pool"]._is_valid)

    def assert_valid(self):
      """Assert that this object is using valid pool memory"""
      if "_is_valid" in self.__dict__:
        assert self.__dict__["_is_valid"](), "Variable has already been deleted"

    def _retrieve_swig_value(self, name, value):
    # If we got back a different object than we have cached, we need to copy
    # all our metadata into it, so that it looks identical to the one
    # originally set.
      members = self.__dict__.get('_members')
      if members is not None and name in members:
        _copy_metadata_deep(value, members[name])

    # Verify that the new object is good
      _assert_valid_deep(value)

      return value

    # Attribute access must be intercepted to ensure that objects coming from
    # read attribute access match those that are set with write attribute access.
    # Specifically the metadata, such as the associated apr_pool object, should
    # match the originally assigned object.
    #
    # For classic classes it is enough to use __getattr__ to intercept swig
    # derived attributes. However, with new style classes SWIG makes use of
    # descriptors which mean that __getattr__ is never called. Therefore,
    # __getattribute__ must be used for the interception.

    if _newclass:
      def __getattribute__(self, name):
        """Manage access to all attributes of this object."""

    # Start by mimicing __getattr__ behavior: immediately return __dict__ or
    # items directly present in __dict__
        mydict = object.__getattribute__(self, '__dict__')

        if name == "__dict__":
          return mydict

        if name in mydict:
          return mydict[name]

        object.__getattribute__(self, 'assert_valid')()

        value = _get_instance_attr(self, name)
        fn = object.__getattribute__(self, '_retrieve_swig_value')
        return fn(name, value)
    else:
      def __getattr__(self, name):
        """Get an attribute from this object"""
        self.assert_valid()

        value = _swig_getattr(self, self.__class__, name)

        return self._retrieve_swig_value(name, value)

    def __setattr__(self, name, value):
      """Set an attribute on this object"""
      self.assert_valid()

    # Save a copy of the object, so that the garbage
    # collector won't kill the object while it's in
    # SWIG-land
      self.__dict__.setdefault("_members",{})[name] = value

      return _set_instance_attr(self, name, value)

svn_wc_committed_queue_t_swigregister = _wc.svn_wc_committed_queue_t_swigregister
svn_wc_committed_queue_t_swigregister(svn_wc_committed_queue_t)


def svn_wc_diff_callbacks4_invoke_file_opened(*args) -> "svn_boolean_t *, svn_boolean_t *":
    """svn_wc_diff_callbacks4_invoke_file_opened(svn_wc_diff_callbacks4_t _obj, char const * path, svn_revnum_t rev, void * diff_baton, apr_pool_t scratch_pool) -> svn_error_t"""
    return _wc.svn_wc_diff_callbacks4_invoke_file_opened(*args)

def svn_wc_diff_callbacks4_invoke_file_changed(*args) -> "svn_boolean_t *":
    """svn_wc_diff_callbacks4_invoke_file_changed(svn_wc_diff_callbacks4_t _obj, svn_wc_notify_state_t * contentstate, svn_wc_notify_state_t * propstate, char const * path, char const * tmpfile1, char const * tmpfile2, svn_revnum_t rev1, svn_revnum_t rev2, char const * mimetype1, char const * mimetype2, apr_array_header_t propchanges, apr_hash_t originalprops, void * diff_baton, apr_pool_t scratch_pool) -> svn_error_t"""
    return _wc.svn_wc_diff_callbacks4_invoke_file_changed(*args)

def svn_wc_diff_callbacks4_invoke_file_added(*args) -> "svn_boolean_t *":
    """svn_wc_diff_callbacks4_invoke_file_added(svn_wc_diff_callbacks4_t _obj, svn_wc_notify_state_t * contentstate, svn_wc_notify_state_t * propstate, char const * path, char const * tmpfile1, char const * tmpfile2, svn_revnum_t rev1, svn_revnum_t rev2, char const * mimetype1, char const * mimetype2, char const * copyfrom_path, svn_revnum_t copyfrom_revision, apr_array_header_t propchanges, apr_hash_t originalprops, void * diff_baton, apr_pool_t scratch_pool) -> svn_error_t"""
    return _wc.svn_wc_diff_callbacks4_invoke_file_added(*args)

def svn_wc_diff_callbacks4_invoke_file_deleted(*args) -> "svn_boolean_t *":
    """svn_wc_diff_callbacks4_invoke_file_deleted(svn_wc_diff_callbacks4_t _obj, svn_wc_notify_state_t * state, char const * path, char const * tmpfile1, char const * tmpfile2, char const * mimetype1, char const * mimetype2, apr_hash_t originalprops, void * diff_baton, apr_pool_t scratch_pool) -> svn_error_t"""
    return _wc.svn_wc_diff_callbacks4_invoke_file_deleted(*args)

def svn_wc_diff_callbacks4_invoke_dir_deleted(*args) -> "svn_boolean_t *":
    """svn_wc_diff_callbacks4_invoke_dir_deleted(svn_wc_diff_callbacks4_t _obj, svn_wc_notify_state_t * state, char const * path, void * diff_baton, apr_pool_t scratch_pool) -> svn_error_t"""
    return _wc.svn_wc_diff_callbacks4_invoke_dir_deleted(*args)

def svn_wc_diff_callbacks4_invoke_dir_opened(*args) -> "svn_boolean_t *, svn_boolean_t *, svn_boolean_t *":
    """svn_wc_diff_callbacks4_invoke_dir_opened(svn_wc_diff_callbacks4_t _obj, char const * path, svn_revnum_t rev, void * diff_baton, apr_pool_t scratch_pool) -> svn_error_t"""
    return _wc.svn_wc_diff_callbacks4_invoke_dir_opened(*args)

def svn_wc_diff_callbacks4_invoke_dir_added(*args) -> "svn_boolean_t *, svn_boolean_t *, svn_boolean_t *":
    """svn_wc_diff_callbacks4_invoke_dir_added(svn_wc_diff_callbacks4_t _obj, svn_wc_notify_state_t * state, char const * path, svn_revnum_t rev, char const * copyfrom_path, svn_revnum_t copyfrom_revision, void * diff_baton, apr_pool_t scratch_pool) -> svn_error_t"""
    return _wc.svn_wc_diff_callbacks4_invoke_dir_added(*args)

def svn_wc_diff_callbacks4_invoke_dir_props_changed(*args) -> "svn_boolean_t *":
    """svn_wc_diff_callbacks4_invoke_dir_props_changed(svn_wc_diff_callbacks4_t _obj, svn_wc_notify_state_t * propstate, char const * path, svn_boolean_t dir_was_added, apr_array_header_t propchanges, apr_hash_t original_props, void * diff_baton, apr_pool_t scratch_pool) -> svn_error_t"""
    return _wc.svn_wc_diff_callbacks4_invoke_dir_props_changed(*args)

def svn_wc_diff_callbacks4_invoke_dir_closed(*args) -> "svn_boolean_t *":
    """svn_wc_diff_callbacks4_invoke_dir_closed(svn_wc_diff_callbacks4_t _obj, svn_wc_notify_state_t * contentstate, svn_wc_notify_state_t * propstate, char const * path, svn_boolean_t dir_was_added, void * diff_baton, apr_pool_t scratch_pool) -> svn_error_t"""
    return _wc.svn_wc_diff_callbacks4_invoke_dir_closed(*args)

def svn_wc_diff_callbacks3_invoke_file_changed(_obj: 'svn_wc_diff_callbacks3_t', adm_access: 'svn_wc_adm_access_t *', contentstate: 'svn_wc_notify_state_t *', propstate: 'svn_wc_notify_state_t *', path: 'char const *', tmpfile1: 'char const *', tmpfile2: 'char const *', rev1: 'svn_revnum_t', rev2: 'svn_revnum_t', mimetype1: 'char const *', mimetype2: 'char const *', propchanges: 'apr_array_header_t', originalprops: 'apr_hash_t', diff_baton: 'void *') -> "svn_boolean_t *":
    """svn_wc_diff_callbacks3_invoke_file_changed(svn_wc_diff_callbacks3_t _obj, svn_wc_adm_access_t * adm_access, svn_wc_notify_state_t * contentstate, svn_wc_notify_state_t * propstate, char const * path, char const * tmpfile1, char const * tmpfile2, svn_revnum_t rev1, svn_revnum_t rev2, char const * mimetype1, char const * mimetype2, apr_array_header_t propchanges, apr_hash_t originalprops, void * diff_baton) -> svn_error_t"""
    return _wc.svn_wc_diff_callbacks3_invoke_file_changed(_obj, adm_access, contentstate, propstate, path, tmpfile1, tmpfile2, rev1, rev2, mimetype1, mimetype2, propchanges, originalprops, diff_baton)

def svn_wc_diff_callbacks3_invoke_file_added(_obj: 'svn_wc_diff_callbacks3_t', adm_access: 'svn_wc_adm_access_t *', contentstate: 'svn_wc_notify_state_t *', propstate: 'svn_wc_notify_state_t *', path: 'char const *', tmpfile1: 'char const *', tmpfile2: 'char const *', rev1: 'svn_revnum_t', rev2: 'svn_revnum_t', mimetype1: 'char const *', mimetype2: 'char const *', propchanges: 'apr_array_header_t', originalprops: 'apr_hash_t', diff_baton: 'void *') -> "svn_boolean_t *":
    """svn_wc_diff_callbacks3_invoke_file_added(svn_wc_diff_callbacks3_t _obj, svn_wc_adm_access_t * adm_access, svn_wc_notify_state_t * contentstate, svn_wc_notify_state_t * propstate, char const * path, char const * tmpfile1, char const * tmpfile2, svn_revnum_t rev1, svn_revnum_t rev2, char const * mimetype1, char const * mimetype2, apr_array_header_t propchanges, apr_hash_t originalprops, void * diff_baton) -> svn_error_t"""
    return _wc.svn_wc_diff_callbacks3_invoke_file_added(_obj, adm_access, contentstate, propstate, path, tmpfile1, tmpfile2, rev1, rev2, mimetype1, mimetype2, propchanges, originalprops, diff_baton)

def svn_wc_diff_callbacks3_invoke_file_deleted(_obj: 'svn_wc_diff_callbacks3_t', adm_access: 'svn_wc_adm_access_t *', state: 'svn_wc_notify_state_t *', path: 'char const *', tmpfile1: 'char const *', tmpfile2: 'char const *', mimetype1: 'char const *', mimetype2: 'char const *', originalprops: 'apr_hash_t', diff_baton: 'void *') -> "svn_boolean_t *":
    """svn_wc_diff_callbacks3_invoke_file_deleted(svn_wc_diff_callbacks3_t _obj, svn_wc_adm_access_t * adm_access, svn_wc_notify_state_t * state, char const * path, char const * tmpfile1, char const * tmpfile2, char const * mimetype1, char const * mimetype2, apr_hash_t originalprops, void * diff_baton) -> svn_error_t"""
    return _wc.svn_wc_diff_callbacks3_invoke_file_deleted(_obj, adm_access, state, path, tmpfile1, tmpfile2, mimetype1, mimetype2, originalprops, diff_baton)

def svn_wc_diff_callbacks3_invoke_dir_added(_obj: 'svn_wc_diff_callbacks3_t', adm_access: 'svn_wc_adm_access_t *', state: 'svn_wc_notify_state_t *', path: 'char const *', rev: 'svn_revnum_t', diff_baton: 'void *') -> "svn_boolean_t *":
    """svn_wc_diff_callbacks3_invoke_dir_added(svn_wc_diff_callbacks3_t _obj, svn_wc_adm_access_t * adm_access, svn_wc_notify_state_t * state, char const * path, svn_revnum_t rev, void * diff_baton) -> svn_error_t"""
    return _wc.svn_wc_diff_callbacks3_invoke_dir_added(_obj, adm_access, state, path, rev, diff_baton)

def svn_wc_diff_callbacks3_invoke_dir_deleted(_obj: 'svn_wc_diff_callbacks3_t', adm_access: 'svn_wc_adm_access_t *', state: 'svn_wc_notify_state_t *', path: 'char const *', diff_baton: 'void *') -> "svn_boolean_t *":
    """svn_wc_diff_callbacks3_invoke_dir_deleted(svn_wc_diff_callbacks3_t _obj, svn_wc_adm_access_t * adm_access, svn_wc_notify_state_t * state, char const * path, void * diff_baton) -> svn_error_t"""
    return _wc.svn_wc_diff_callbacks3_invoke_dir_deleted(_obj, adm_access, state, path, diff_baton)

def svn_wc_diff_callbacks3_invoke_dir_props_changed(_obj: 'svn_wc_diff_callbacks3_t', adm_access: 'svn_wc_adm_access_t *', propstate: 'svn_wc_notify_state_t *', path: 'char const *', propchanges: 'apr_array_header_t', original_props: 'apr_hash_t', diff_baton: 'void *') -> "svn_boolean_t *":
    """svn_wc_diff_callbacks3_invoke_dir_props_changed(svn_wc_diff_callbacks3_t _obj, svn_wc_adm_access_t * adm_access, svn_wc_notify_state_t * propstate, char const * path, apr_array_header_t propchanges, apr_hash_t original_props, void * diff_baton) -> svn_error_t"""
    return _wc.svn_wc_diff_callbacks3_invoke_dir_props_changed(_obj, adm_access, propstate, path, propchanges, original_props, diff_baton)

def svn_wc_diff_callbacks3_invoke_dir_opened(_obj: 'svn_wc_diff_callbacks3_t', adm_access: 'svn_wc_adm_access_t *', path: 'char const *', rev: 'svn_revnum_t', diff_baton: 'void *') -> "svn_boolean_t *":
    """svn_wc_diff_callbacks3_invoke_dir_opened(svn_wc_diff_callbacks3_t _obj, svn_wc_adm_access_t * adm_access, char const * path, svn_revnum_t rev, void * diff_baton) -> svn_error_t"""
    return _wc.svn_wc_diff_callbacks3_invoke_dir_opened(_obj, adm_access, path, rev, diff_baton)

def svn_wc_diff_callbacks3_invoke_dir_closed(_obj: 'svn_wc_diff_callbacks3_t', adm_access: 'svn_wc_adm_access_t *', contentstate: 'svn_wc_notify_state_t *', propstate: 'svn_wc_notify_state_t *', path: 'char const *', diff_baton: 'void *') -> "svn_boolean_t *":
    """svn_wc_diff_callbacks3_invoke_dir_closed(svn_wc_diff_callbacks3_t _obj, svn_wc_adm_access_t * adm_access, svn_wc_notify_state_t * contentstate, svn_wc_notify_state_t * propstate, char const * path, void * diff_baton) -> svn_error_t"""
    return _wc.svn_wc_diff_callbacks3_invoke_dir_closed(_obj, adm_access, contentstate, propstate, path, diff_baton)

def svn_wc_diff_callbacks2_invoke_file_changed(_obj: 'svn_wc_diff_callbacks2_t', adm_access: 'svn_wc_adm_access_t *', contentstate: 'svn_wc_notify_state_t *', propstate: 'svn_wc_notify_state_t *', path: 'char const *', tmpfile1: 'char const *', tmpfile2: 'char const *', rev1: 'svn_revnum_t', rev2: 'svn_revnum_t', mimetype1: 'char const *', mimetype2: 'char const *', propchanges: 'apr_array_header_t', originalprops: 'apr_hash_t', diff_baton: 'void *') -> "svn_error_t *":
    """svn_wc_diff_callbacks2_invoke_file_changed(svn_wc_diff_callbacks2_t _obj, svn_wc_adm_access_t * adm_access, svn_wc_notify_state_t * contentstate, svn_wc_notify_state_t * propstate, char const * path, char const * tmpfile1, char const * tmpfile2, svn_revnum_t rev1, svn_revnum_t rev2, char const * mimetype1, char const * mimetype2, apr_array_header_t propchanges, apr_hash_t originalprops, void * diff_baton) -> svn_error_t"""
    return _wc.svn_wc_diff_callbacks2_invoke_file_changed(_obj, adm_access, contentstate, propstate, path, tmpfile1, tmpfile2, rev1, rev2, mimetype1, mimetype2, propchanges, originalprops, diff_baton)

def svn_wc_diff_callbacks2_invoke_file_added(_obj: 'svn_wc_diff_callbacks2_t', adm_access: 'svn_wc_adm_access_t *', contentstate: 'svn_wc_notify_state_t *', propstate: 'svn_wc_notify_state_t *', path: 'char const *', tmpfile1: 'char const *', tmpfile2: 'char const *', rev1: 'svn_revnum_t', rev2: 'svn_revnum_t', mimetype1: 'char const *', mimetype2: 'char const *', propchanges: 'apr_array_header_t', originalprops: 'apr_hash_t', diff_baton: 'void *') -> "svn_error_t *":
    """svn_wc_diff_callbacks2_invoke_file_added(svn_wc_diff_callbacks2_t _obj, svn_wc_adm_access_t * adm_access, svn_wc_notify_state_t * contentstate, svn_wc_notify_state_t * propstate, char const * path, char const * tmpfile1, char const * tmpfile2, svn_revnum_t rev1, svn_revnum_t rev2, char const * mimetype1, char const * mimetype2, apr_array_header_t propchanges, apr_hash_t originalprops, void * diff_baton) -> svn_error_t"""
    return _wc.svn_wc_diff_callbacks2_invoke_file_added(_obj, adm_access, contentstate, propstate, path, tmpfile1, tmpfile2, rev1, rev2, mimetype1, mimetype2, propchanges, originalprops, diff_baton)

def svn_wc_diff_callbacks2_invoke_file_deleted(_obj: 'svn_wc_diff_callbacks2_t', adm_access: 'svn_wc_adm_access_t *', state: 'svn_wc_notify_state_t *', path: 'char const *', tmpfile1: 'char const *', tmpfile2: 'char const *', mimetype1: 'char const *', mimetype2: 'char const *', originalprops: 'apr_hash_t', diff_baton: 'void *') -> "svn_error_t *":
    """svn_wc_diff_callbacks2_invoke_file_deleted(svn_wc_diff_callbacks2_t _obj, svn_wc_adm_access_t * adm_access, svn_wc_notify_state_t * state, char const * path, char const * tmpfile1, char const * tmpfile2, char const * mimetype1, char const * mimetype2, apr_hash_t originalprops, void * diff_baton) -> svn_error_t"""
    return _wc.svn_wc_diff_callbacks2_invoke_file_deleted(_obj, adm_access, state, path, tmpfile1, tmpfile2, mimetype1, mimetype2, originalprops, diff_baton)

def svn_wc_diff_callbacks2_invoke_dir_added(_obj: 'svn_wc_diff_callbacks2_t', adm_access: 'svn_wc_adm_access_t *', state: 'svn_wc_notify_state_t *', path: 'char const *', rev: 'svn_revnum_t', diff_baton: 'void *') -> "svn_error_t *":
    """svn_wc_diff_callbacks2_invoke_dir_added(svn_wc_diff_callbacks2_t _obj, svn_wc_adm_access_t * adm_access, svn_wc_notify_state_t * state, char const * path, svn_revnum_t rev, void * diff_baton) -> svn_error_t"""
    return _wc.svn_wc_diff_callbacks2_invoke_dir_added(_obj, adm_access, state, path, rev, diff_baton)

def svn_wc_diff_callbacks2_invoke_dir_deleted(_obj: 'svn_wc_diff_callbacks2_t', adm_access: 'svn_wc_adm_access_t *', state: 'svn_wc_notify_state_t *', path: 'char const *', diff_baton: 'void *') -> "svn_error_t *":
    """svn_wc_diff_callbacks2_invoke_dir_deleted(svn_wc_diff_callbacks2_t _obj, svn_wc_adm_access_t * adm_access, svn_wc_notify_state_t * state, char const * path, void * diff_baton) -> svn_error_t"""
    return _wc.svn_wc_diff_callbacks2_invoke_dir_deleted(_obj, adm_access, state, path, diff_baton)

def svn_wc_diff_callbacks2_invoke_dir_props_changed(_obj: 'svn_wc_diff_callbacks2_t', adm_access: 'svn_wc_adm_access_t *', state: 'svn_wc_notify_state_t *', path: 'char const *', propchanges: 'apr_array_header_t', original_props: 'apr_hash_t', diff_baton: 'void *') -> "svn_error_t *":
    """svn_wc_diff_callbacks2_invoke_dir_props_changed(svn_wc_diff_callbacks2_t _obj, svn_wc_adm_access_t * adm_access, svn_wc_notify_state_t * state, char const * path, apr_array_header_t propchanges, apr_hash_t original_props, void * diff_baton) -> svn_error_t"""
    return _wc.svn_wc_diff_callbacks2_invoke_dir_props_changed(_obj, adm_access, state, path, propchanges, original_props, diff_baton)

def svn_wc_diff_callbacks_invoke_file_changed(_obj: 'svn_wc_diff_callbacks_t', adm_access: 'svn_wc_adm_access_t *', state: 'svn_wc_notify_state_t *', path: 'char const *', tmpfile1: 'char const *', tmpfile2: 'char const *', rev1: 'svn_revnum_t', rev2: 'svn_revnum_t', mimetype1: 'char const *', mimetype2: 'char const *', diff_baton: 'void *') -> "svn_error_t *":
    """svn_wc_diff_callbacks_invoke_file_changed(svn_wc_diff_callbacks_t _obj, svn_wc_adm_access_t * adm_access, svn_wc_notify_state_t * state, char const * path, char const * tmpfile1, char const * tmpfile2, svn_revnum_t rev1, svn_revnum_t rev2, char const * mimetype1, char const * mimetype2, void * diff_baton) -> svn_error_t"""
    return _wc.svn_wc_diff_callbacks_invoke_file_changed(_obj, adm_access, state, path, tmpfile1, tmpfile2, rev1, rev2, mimetype1, mimetype2, diff_baton)

def svn_wc_diff_callbacks_invoke_file_added(_obj: 'svn_wc_diff_callbacks_t', adm_access: 'svn_wc_adm_access_t *', state: 'svn_wc_notify_state_t *', path: 'char const *', tmpfile1: 'char const *', tmpfile2: 'char const *', rev1: 'svn_revnum_t', rev2: 'svn_revnum_t', mimetype1: 'char const *', mimetype2: 'char const *', diff_baton: 'void *') -> "svn_error_t *":
    """svn_wc_diff_callbacks_invoke_file_added(svn_wc_diff_callbacks_t _obj, svn_wc_adm_access_t * adm_access, svn_wc_notify_state_t * state, char const * path, char const * tmpfile1, char const * tmpfile2, svn_revnum_t rev1, svn_revnum_t rev2, char const * mimetype1, char const * mimetype2, void * diff_baton) -> svn_error_t"""
    return _wc.svn_wc_diff_callbacks_invoke_file_added(_obj, adm_access, state, path, tmpfile1, tmpfile2, rev1, rev2, mimetype1, mimetype2, diff_baton)

def svn_wc_diff_callbacks_invoke_file_deleted(_obj: 'svn_wc_diff_callbacks_t', adm_access: 'svn_wc_adm_access_t *', state: 'svn_wc_notify_state_t *', path: 'char const *', tmpfile1: 'char const *', tmpfile2: 'char const *', mimetype1: 'char const *', mimetype2: 'char const *', diff_baton: 'void *') -> "svn_error_t *":
    """svn_wc_diff_callbacks_invoke_file_deleted(svn_wc_diff_callbacks_t _obj, svn_wc_adm_access_t * adm_access, svn_wc_notify_state_t * state, char const * path, char const * tmpfile1, char const * tmpfile2, char const * mimetype1, char const * mimetype2, void * diff_baton) -> svn_error_t"""
    return _wc.svn_wc_diff_callbacks_invoke_file_deleted(_obj, adm_access, state, path, tmpfile1, tmpfile2, mimetype1, mimetype2, diff_baton)

def svn_wc_diff_callbacks_invoke_dir_added(_obj: 'svn_wc_diff_callbacks_t', adm_access: 'svn_wc_adm_access_t *', state: 'svn_wc_notify_state_t *', path: 'char const *', rev: 'svn_revnum_t', diff_baton: 'void *') -> "svn_error_t *":
    """svn_wc_diff_callbacks_invoke_dir_added(svn_wc_diff_callbacks_t _obj, svn_wc_adm_access_t * adm_access, svn_wc_notify_state_t * state, char const * path, svn_revnum_t rev, void * diff_baton) -> svn_error_t"""
    return _wc.svn_wc_diff_callbacks_invoke_dir_added(_obj, adm_access, state, path, rev, diff_baton)

def svn_wc_diff_callbacks_invoke_dir_deleted(_obj: 'svn_wc_diff_callbacks_t', adm_access: 'svn_wc_adm_access_t *', state: 'svn_wc_notify_state_t *', path: 'char const *', diff_baton: 'void *') -> "svn_error_t *":
    """svn_wc_diff_callbacks_invoke_dir_deleted(svn_wc_diff_callbacks_t _obj, svn_wc_adm_access_t * adm_access, svn_wc_notify_state_t * state, char const * path, void * diff_baton) -> svn_error_t"""
    return _wc.svn_wc_diff_callbacks_invoke_dir_deleted(_obj, adm_access, state, path, diff_baton)

def svn_wc_diff_callbacks_invoke_props_changed(_obj: 'svn_wc_diff_callbacks_t', adm_access: 'svn_wc_adm_access_t *', state: 'svn_wc_notify_state_t *', path: 'char const *', propchanges: 'apr_array_header_t', original_props: 'apr_hash_t', diff_baton: 'void *') -> "svn_error_t *":
    """svn_wc_diff_callbacks_invoke_props_changed(svn_wc_diff_callbacks_t _obj, svn_wc_adm_access_t * adm_access, svn_wc_notify_state_t * state, char const * path, apr_array_header_t propchanges, apr_hash_t original_props, void * diff_baton) -> svn_error_t"""
    return _wc.svn_wc_diff_callbacks_invoke_props_changed(_obj, adm_access, state, path, propchanges, original_props, diff_baton)

def svn_wc_entry_callbacks2_invoke_found_entry(*args) -> "svn_error_t *":
    """svn_wc_entry_callbacks2_invoke_found_entry(svn_wc_entry_callbacks2_t _obj, char const * path, svn_wc_entry_t entry, void * walk_baton, apr_pool_t pool) -> svn_error_t"""
    return _wc.svn_wc_entry_callbacks2_invoke_found_entry(*args)

def svn_wc_entry_callbacks2_invoke_handle_error(*args) -> "svn_error_t *":
    """svn_wc_entry_callbacks2_invoke_handle_error(svn_wc_entry_callbacks2_t _obj, char const * path, svn_error_t err, void * walk_baton, apr_pool_t pool) -> svn_error_t"""
    return _wc.svn_wc_entry_callbacks2_invoke_handle_error(*args)

def svn_wc_entry_callbacks_invoke_found_entry(*args) -> "svn_error_t *":
    """svn_wc_entry_callbacks_invoke_found_entry(svn_wc_entry_callbacks_t _obj, char const * path, svn_wc_entry_t entry, void * walk_baton, apr_pool_t pool) -> svn_error_t"""
    return _wc.svn_wc_entry_callbacks_invoke_found_entry(*args)

def svn_wc_invoke_external_update(*args) -> "svn_error_t *":
    """svn_wc_invoke_external_update(svn_wc_external_update_t _obj, void * baton, char const * local_abspath, svn_string_t const * old_val, svn_string_t const * new_val, svn_depth_t depth, apr_pool_t scratch_pool) -> svn_error_t"""
    return _wc.svn_wc_invoke_external_update(*args)

def svn_wc_invoke_notify_func2(*args) -> "void":
    """svn_wc_invoke_notify_func2(svn_wc_notify_func2_t _obj, void * baton, svn_wc_notify_t notify, apr_pool_t pool)"""
    return _wc.svn_wc_invoke_notify_func2(*args)

def svn_wc_invoke_notify_func(_obj: 'svn_wc_notify_func_t', baton: 'void *', path: 'char const *', action: 'svn_wc_notify_action_t', kind: 'svn_node_kind_t', mime_type: 'char const *', content_state: 'svn_wc_notify_state_t', prop_state: 'svn_wc_notify_state_t', revision: 'svn_revnum_t') -> "void":
    """svn_wc_invoke_notify_func(svn_wc_notify_func_t _obj, void * baton, char const * path, svn_wc_notify_action_t action, svn_node_kind_t kind, char const * mime_type, svn_wc_notify_state_t content_state, svn_wc_notify_state_t prop_state, svn_revnum_t revision)"""
    return _wc.svn_wc_invoke_notify_func(_obj, baton, path, action, kind, mime_type, content_state, prop_state, revision)

def svn_wc_invoke_conflict_resolver_func2(*args) -> "SWIGTYPE **":
    """svn_wc_invoke_conflict_resolver_func2(svn_wc_conflict_resolver_func2_t _obj, svn_wc_conflict_description2_t const * description, void * baton, apr_pool_t result_pool, apr_pool_t scratch_pool) -> svn_error_t"""
    return _wc.svn_wc_invoke_conflict_resolver_func2(*args)

def svn_wc_invoke_conflict_resolver_func(*args) -> "SWIGTYPE **":
    """svn_wc_invoke_conflict_resolver_func(svn_wc_conflict_resolver_func_t _obj, svn_wc_conflict_description_t description, void * baton, apr_pool_t pool) -> svn_error_t"""
    return _wc.svn_wc_invoke_conflict_resolver_func(*args)

def svn_wc_invoke_status_func4(*args) -> "svn_error_t *":
    """svn_wc_invoke_status_func4(svn_wc_status_func4_t _obj, void * baton, char const * local_abspath, svn_wc_status3_t status, apr_pool_t scratch_pool) -> svn_error_t"""
    return _wc.svn_wc_invoke_status_func4(*args)

def svn_wc_invoke_status_func3(*args) -> "svn_error_t *":
    """svn_wc_invoke_status_func3(svn_wc_status_func3_t _obj, void * baton, char const * path, svn_wc_status2_t status, apr_pool_t pool) -> svn_error_t"""
    return _wc.svn_wc_invoke_status_func3(*args)

def svn_wc_invoke_status_func2(_obj: 'svn_wc_status_func2_t', baton: 'void *', path: 'char const *', status: 'svn_wc_status2_t') -> "void":
    """svn_wc_invoke_status_func2(svn_wc_status_func2_t _obj, void * baton, char const * path, svn_wc_status2_t status)"""
    return _wc.svn_wc_invoke_status_func2(_obj, baton, path, status)

def svn_wc_invoke_status_func(_obj: 'svn_wc_status_func_t', baton: 'void *', path: 'char const *', status: 'svn_wc_status_t') -> "void":
    """svn_wc_invoke_status_func(svn_wc_status_func_t _obj, void * baton, char const * path, svn_wc_status_t status)"""
    return _wc.svn_wc_invoke_status_func(_obj, baton, path, status)

def svn_wc_invoke_get_file(*args) -> "svn_revnum_t *, apr_hash_t **":
    """svn_wc_invoke_get_file(svn_wc_get_file_t _obj, void * baton, char const * path, svn_revnum_t revision, svn_stream_t * stream, apr_pool_t pool) -> svn_error_t"""
    return _wc.svn_wc_invoke_get_file(*args)

def svn_wc_invoke_dirents_func(*args) -> "apr_hash_t **":
    """svn_wc_invoke_dirents_func(svn_wc_dirents_func_t _obj, void * baton, char const * repos_root_url, char const * repos_relpath, apr_pool_t result_pool, apr_pool_t scratch_pool) -> svn_error_t"""
    return _wc.svn_wc_invoke_dirents_func(*args)

def svn_wc_invoke_canonicalize_svn_prop_get_file(*args) -> "svn_string_t **":
    """svn_wc_invoke_canonicalize_svn_prop_get_file(svn_wc_canonicalize_svn_prop_get_file_t _obj, svn_stream_t * stream, void * baton, apr_pool_t pool) -> svn_error_t"""
    return _wc.svn_wc_invoke_canonicalize_svn_prop_get_file(*args)

def svn_wc_invoke_upgrade_get_repos_info(*args) -> "char const **, char const **":
    """svn_wc_invoke_upgrade_get_repos_info(svn_wc_upgrade_get_repos_info_t _obj, void * baton, char const * url, apr_pool_t result_pool, apr_pool_t scratch_pool) -> svn_error_t"""
    return _wc.svn_wc_invoke_upgrade_get_repos_info(*args)

def svn_wc_invoke_relocation_validator3(*args) -> "svn_error_t *":
    """svn_wc_invoke_relocation_validator3(svn_wc_relocation_validator3_t _obj, void * baton, char const * uuid, char const * url, char const * root_url, apr_pool_t pool) -> svn_error_t"""
    return _wc.svn_wc_invoke_relocation_validator3(*args)

def svn_wc_invoke_relocation_validator2(*args) -> "svn_error_t *":
    """svn_wc_invoke_relocation_validator2(svn_wc_relocation_validator2_t _obj, void * baton, char const * uuid, char const * url, svn_boolean_t root, apr_pool_t pool) -> svn_error_t"""
    return _wc.svn_wc_invoke_relocation_validator2(*args)

def svn_wc_invoke_relocation_validator(_obj: 'svn_wc_relocation_validator_t', baton: 'void *', uuid: 'char const *', url: 'char const *') -> "svn_error_t *":
    """svn_wc_invoke_relocation_validator(svn_wc_relocation_validator_t _obj, void * baton, char const * uuid, char const * url) -> svn_error_t"""
    return _wc.svn_wc_invoke_relocation_validator(_obj, baton, uuid, url)

def svn_changelist_invoke_receiver(*args) -> "svn_error_t *":
    """svn_changelist_invoke_receiver(svn_changelist_receiver_t _obj, void * baton, char const * path, char const * changelist, apr_pool_t pool) -> svn_error_t"""
    return _wc.svn_changelist_invoke_receiver(*args)
class svn_wc_external_update_t(object):
    """Proxy of C svn_wc_external_update_t struct."""

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    def set_parent_pool(self, parent_pool=None):
      """Create a new proxy object for TYPE"""
      import libsvn.core, weakref
      self.__dict__["_parent_pool"] = \
        parent_pool or libsvn.core.application_pool;
      if self.__dict__["_parent_pool"]:
        self.__dict__["_is_valid"] = weakref.ref(
          self.__dict__["_parent_pool"]._is_valid)

    def assert_valid(self):
      """Assert that this object is using valid pool memory"""
      if "_is_valid" in self.__dict__:
        assert self.__dict__["_is_valid"](), "Variable has already been deleted"

    def _retrieve_swig_value(self, name, value):
    # If we got back a different object than we have cached, we need to copy
    # all our metadata into it, so that it looks identical to the one
    # originally set.
      members = self.__dict__.get('_members')
      if members is not None and name in members:
        _copy_metadata_deep(value, members[name])

    # Verify that the new object is good
      _assert_valid_deep(value)

      return value

    # Attribute access must be intercepted to ensure that objects coming from
    # read attribute access match those that are set with write attribute access.
    # Specifically the metadata, such as the associated apr_pool object, should
    # match the originally assigned object.
    #
    # For classic classes it is enough to use __getattr__ to intercept swig
    # derived attributes. However, with new style classes SWIG makes use of
    # descriptors which mean that __getattr__ is never called. Therefore,
    # __getattribute__ must be used for the interception.

    if _newclass:
      def __getattribute__(self, name):
        """Manage access to all attributes of this object."""

    # Start by mimicing __getattr__ behavior: immediately return __dict__ or
    # items directly present in __dict__
        mydict = object.__getattribute__(self, '__dict__')

        if name == "__dict__":
          return mydict

        if name in mydict:
          return mydict[name]

        object.__getattribute__(self, 'assert_valid')()

        value = _get_instance_attr(self, name)
        fn = object.__getattribute__(self, '_retrieve_swig_value')
        return fn(name, value)
    else:
      def __getattr__(self, name):
        """Get an attribute from this object"""
        self.assert_valid()

        value = _swig_getattr(self, self.__class__, name)

        return self._retrieve_swig_value(name, value)

    def __setattr__(self, name, value):
      """Set an attribute on this object"""
      self.assert_valid()

    # Save a copy of the object, so that the garbage
    # collector won't kill the object while it's in
    # SWIG-land
      self.__dict__.setdefault("_members",{})[name] = value

      return _set_instance_attr(self, name, value)


    def __call__(self, *args):
      return svn_wc_invoke_external_update(self, *args)

svn_wc_external_update_t_swigregister = _wc.svn_wc_external_update_t_swigregister
svn_wc_external_update_t_swigregister(svn_wc_external_update_t)

class svn_wc_notify_func2_t(object):
    """Proxy of C svn_wc_notify_func2_t struct."""

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    def set_parent_pool(self, parent_pool=None):
      """Create a new proxy object for TYPE"""
      import libsvn.core, weakref
      self.__dict__["_parent_pool"] = \
        parent_pool or libsvn.core.application_pool;
      if self.__dict__["_parent_pool"]:
        self.__dict__["_is_valid"] = weakref.ref(
          self.__dict__["_parent_pool"]._is_valid)

    def assert_valid(self):
      """Assert that this object is using valid pool memory"""
      if "_is_valid" in self.__dict__:
        assert self.__dict__["_is_valid"](), "Variable has already been deleted"

    def _retrieve_swig_value(self, name, value):
    # If we got back a different object than we have cached, we need to copy
    # all our metadata into it, so that it looks identical to the one
    # originally set.
      members = self.__dict__.get('_members')
      if members is not None and name in members:
        _copy_metadata_deep(value, members[name])

    # Verify that the new object is good
      _assert_valid_deep(value)

      return value

    # Attribute access must be intercepted to ensure that objects coming from
    # read attribute access match those that are set with write attribute access.
    # Specifically the metadata, such as the associated apr_pool object, should
    # match the originally assigned object.
    #
    # For classic classes it is enough to use __getattr__ to intercept swig
    # derived attributes. However, with new style classes SWIG makes use of
    # descriptors which mean that __getattr__ is never called. Therefore,
    # __getattribute__ must be used for the interception.

    if _newclass:
      def __getattribute__(self, name):
        """Manage access to all attributes of this object."""

    # Start by mimicing __getattr__ behavior: immediately return __dict__ or
    # items directly present in __dict__
        mydict = object.__getattribute__(self, '__dict__')

        if name == "__dict__":
          return mydict

        if name in mydict:
          return mydict[name]

        object.__getattribute__(self, 'assert_valid')()

        value = _get_instance_attr(self, name)
        fn = object.__getattribute__(self, '_retrieve_swig_value')
        return fn(name, value)
    else:
      def __getattr__(self, name):
        """Get an attribute from this object"""
        self.assert_valid()

        value = _swig_getattr(self, self.__class__, name)

        return self._retrieve_swig_value(name, value)

    def __setattr__(self, name, value):
      """Set an attribute on this object"""
      self.assert_valid()

    # Save a copy of the object, so that the garbage
    # collector won't kill the object while it's in
    # SWIG-land
      self.__dict__.setdefault("_members",{})[name] = value

      return _set_instance_attr(self, name, value)


    def __call__(self, *args):
      return svn_wc_invoke_notify_func2(self, *args)

svn_wc_notify_func2_t_swigregister = _wc.svn_wc_notify_func2_t_swigregister
svn_wc_notify_func2_t_swigregister(svn_wc_notify_func2_t)

class svn_wc_notify_func_t(object):
    """Proxy of C svn_wc_notify_func_t struct."""

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    def set_parent_pool(self, parent_pool=None):
      """Create a new proxy object for TYPE"""
      import libsvn.core, weakref
      self.__dict__["_parent_pool"] = \
        parent_pool or libsvn.core.application_pool;
      if self.__dict__["_parent_pool"]:
        self.__dict__["_is_valid"] = weakref.ref(
          self.__dict__["_parent_pool"]._is_valid)

    def assert_valid(self):
      """Assert that this object is using valid pool memory"""
      if "_is_valid" in self.__dict__:
        assert self.__dict__["_is_valid"](), "Variable has already been deleted"

    def _retrieve_swig_value(self, name, value):
    # If we got back a different object than we have cached, we need to copy
    # all our metadata into it, so that it looks identical to the one
    # originally set.
      members = self.__dict__.get('_members')
      if members is not None and name in members:
        _copy_metadata_deep(value, members[name])

    # Verify that the new object is good
      _assert_valid_deep(value)

      return value

    # Attribute access must be intercepted to ensure that objects coming from
    # read attribute access match those that are set with write attribute access.
    # Specifically the metadata, such as the associated apr_pool object, should
    # match the originally assigned object.
    #
    # For classic classes it is enough to use __getattr__ to intercept swig
    # derived attributes. However, with new style classes SWIG makes use of
    # descriptors which mean that __getattr__ is never called. Therefore,
    # __getattribute__ must be used for the interception.

    if _newclass:
      def __getattribute__(self, name):
        """Manage access to all attributes of this object."""

    # Start by mimicing __getattr__ behavior: immediately return __dict__ or
    # items directly present in __dict__
        mydict = object.__getattribute__(self, '__dict__')

        if name == "__dict__":
          return mydict

        if name in mydict:
          return mydict[name]

        object.__getattribute__(self, 'assert_valid')()

        value = _get_instance_attr(self, name)
        fn = object.__getattribute__(self, '_retrieve_swig_value')
        return fn(name, value)
    else:
      def __getattr__(self, name):
        """Get an attribute from this object"""
        self.assert_valid()

        value = _swig_getattr(self, self.__class__, name)

        return self._retrieve_swig_value(name, value)

    def __setattr__(self, name, value):
      """Set an attribute on this object"""
      self.assert_valid()

    # Save a copy of the object, so that the garbage
    # collector won't kill the object while it's in
    # SWIG-land
      self.__dict__.setdefault("_members",{})[name] = value

      return _set_instance_attr(self, name, value)


    def __call__(self, *args):
      return svn_wc_invoke_notify_func(self, *args)

svn_wc_notify_func_t_swigregister = _wc.svn_wc_notify_func_t_swigregister
svn_wc_notify_func_t_swigregister(svn_wc_notify_func_t)

class svn_wc_conflict_resolver_func2_t(object):
    """Proxy of C svn_wc_conflict_resolver_func2_t struct."""

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    def set_parent_pool(self, parent_pool=None):
      """Create a new proxy object for TYPE"""
      import libsvn.core, weakref
      self.__dict__["_parent_pool"] = \
        parent_pool or libsvn.core.application_pool;
      if self.__dict__["_parent_pool"]:
        self.__dict__["_is_valid"] = weakref.ref(
          self.__dict__["_parent_pool"]._is_valid)

    def assert_valid(self):
      """Assert that this object is using valid pool memory"""
      if "_is_valid" in self.__dict__:
        assert self.__dict__["_is_valid"](), "Variable has already been deleted"

    def _retrieve_swig_value(self, name, value):
    # If we got back a different object than we have cached, we need to copy
    # all our metadata into it, so that it looks identical to the one
    # originally set.
      members = self.__dict__.get('_members')
      if members is not None and name in members:
        _copy_metadata_deep(value, members[name])

    # Verify that the new object is good
      _assert_valid_deep(value)

      return value

    # Attribute access must be intercepted to ensure that objects coming from
    # read attribute access match those that are set with write attribute access.
    # Specifically the metadata, such as the associated apr_pool object, should
    # match the originally assigned object.
    #
    # For classic classes it is enough to use __getattr__ to intercept swig
    # derived attributes. However, with new style classes SWIG makes use of
    # descriptors which mean that __getattr__ is never called. Therefore,
    # __getattribute__ must be used for the interception.

    if _newclass:
      def __getattribute__(self, name):
        """Manage access to all attributes of this object."""

    # Start by mimicing __getattr__ behavior: immediately return __dict__ or
    # items directly present in __dict__
        mydict = object.__getattribute__(self, '__dict__')

        if name == "__dict__":
          return mydict

        if name in mydict:
          return mydict[name]

        object.__getattribute__(self, 'assert_valid')()

        value = _get_instance_attr(self, name)
        fn = object.__getattribute__(self, '_retrieve_swig_value')
        return fn(name, value)
    else:
      def __getattr__(self, name):
        """Get an attribute from this object"""
        self.assert_valid()

        value = _swig_getattr(self, self.__class__, name)

        return self._retrieve_swig_value(name, value)

    def __setattr__(self, name, value):
      """Set an attribute on this object"""
      self.assert_valid()

    # Save a copy of the object, so that the garbage
    # collector won't kill the object while it's in
    # SWIG-land
      self.__dict__.setdefault("_members",{})[name] = value

      return _set_instance_attr(self, name, value)


    def __call__(self, *args):
      return svn_wc_invoke_conflict_resolver_func2(self, *args)

svn_wc_conflict_resolver_func2_t_swigregister = _wc.svn_wc_conflict_resolver_func2_t_swigregister
svn_wc_conflict_resolver_func2_t_swigregister(svn_wc_conflict_resolver_func2_t)

class svn_wc_conflict_resolver_func_t(object):
    """Proxy of C svn_wc_conflict_resolver_func_t struct."""

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    def set_parent_pool(self, parent_pool=None):
      """Create a new proxy object for TYPE"""
      import libsvn.core, weakref
      self.__dict__["_parent_pool"] = \
        parent_pool or libsvn.core.application_pool;
      if self.__dict__["_parent_pool"]:
        self.__dict__["_is_valid"] = weakref.ref(
          self.__dict__["_parent_pool"]._is_valid)

    def assert_valid(self):
      """Assert that this object is using valid pool memory"""
      if "_is_valid" in self.__dict__:
        assert self.__dict__["_is_valid"](), "Variable has already been deleted"

    def _retrieve_swig_value(self, name, value):
    # If we got back a different object than we have cached, we need to copy
    # all our metadata into it, so that it looks identical to the one
    # originally set.
      members = self.__dict__.get('_members')
      if members is not None and name in members:
        _copy_metadata_deep(value, members[name])

    # Verify that the new object is good
      _assert_valid_deep(value)

      return value

    # Attribute access must be intercepted to ensure that objects coming from
    # read attribute access match those that are set with write attribute access.
    # Specifically the metadata, such as the associated apr_pool object, should
    # match the originally assigned object.
    #
    # For classic classes it is enough to use __getattr__ to intercept swig
    # derived attributes. However, with new style classes SWIG makes use of
    # descriptors which mean that __getattr__ is never called. Therefore,
    # __getattribute__ must be used for the interception.

    if _newclass:
      def __getattribute__(self, name):
        """Manage access to all attributes of this object."""

    # Start by mimicing __getattr__ behavior: immediately return __dict__ or
    # items directly present in __dict__
        mydict = object.__getattribute__(self, '__dict__')

        if name == "__dict__":
          return mydict

        if name in mydict:
          return mydict[name]

        object.__getattribute__(self, 'assert_valid')()

        value = _get_instance_attr(self, name)
        fn = object.__getattribute__(self, '_retrieve_swig_value')
        return fn(name, value)
    else:
      def __getattr__(self, name):
        """Get an attribute from this object"""
        self.assert_valid()

        value = _swig_getattr(self, self.__class__, name)

        return self._retrieve_swig_value(name, value)

    def __setattr__(self, name, value):
      """Set an attribute on this object"""
      self.assert_valid()

    # Save a copy of the object, so that the garbage
    # collector won't kill the object while it's in
    # SWIG-land
      self.__dict__.setdefault("_members",{})[name] = value

      return _set_instance_attr(self, name, value)


    def __call__(self, *args):
      return svn_wc_invoke_conflict_resolver_func(self, *args)

svn_wc_conflict_resolver_func_t_swigregister = _wc.svn_wc_conflict_resolver_func_t_swigregister
svn_wc_conflict_resolver_func_t_swigregister(svn_wc_conflict_resolver_func_t)

class svn_wc_status_func4_t(object):
    """Proxy of C svn_wc_status_func4_t struct."""

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    def set_parent_pool(self, parent_pool=None):
      """Create a new proxy object for TYPE"""
      import libsvn.core, weakref
      self.__dict__["_parent_pool"] = \
        parent_pool or libsvn.core.application_pool;
      if self.__dict__["_parent_pool"]:
        self.__dict__["_is_valid"] = weakref.ref(
          self.__dict__["_parent_pool"]._is_valid)

    def assert_valid(self):
      """Assert that this object is using valid pool memory"""
      if "_is_valid" in self.__dict__:
        assert self.__dict__["_is_valid"](), "Variable has already been deleted"

    def _retrieve_swig_value(self, name, value):
    # If we got back a different object than we have cached, we need to copy
    # all our metadata into it, so that it looks identical to the one
    # originally set.
      members = self.__dict__.get('_members')
      if members is not None and name in members:
        _copy_metadata_deep(value, members[name])

    # Verify that the new object is good
      _assert_valid_deep(value)

      return value

    # Attribute access must be intercepted to ensure that objects coming from
    # read attribute access match those that are set with write attribute access.
    # Specifically the metadata, such as the associated apr_pool object, should
    # match the originally assigned object.
    #
    # For classic classes it is enough to use __getattr__ to intercept swig
    # derived attributes. However, with new style classes SWIG makes use of
    # descriptors which mean that __getattr__ is never called. Therefore,
    # __getattribute__ must be used for the interception.

    if _newclass:
      def __getattribute__(self, name):
        """Manage access to all attributes of this object."""

    # Start by mimicing __getattr__ behavior: immediately return __dict__ or
    # items directly present in __dict__
        mydict = object.__getattribute__(self, '__dict__')

        if name == "__dict__":
          return mydict

        if name in mydict:
          return mydict[name]

        object.__getattribute__(self, 'assert_valid')()

        value = _get_instance_attr(self, name)
        fn = object.__getattribute__(self, '_retrieve_swig_value')
        return fn(name, value)
    else:
      def __getattr__(self, name):
        """Get an attribute from this object"""
        self.assert_valid()

        value = _swig_getattr(self, self.__class__, name)

        return self._retrieve_swig_value(name, value)

    def __setattr__(self, name, value):
      """Set an attribute on this object"""
      self.assert_valid()

    # Save a copy of the object, so that the garbage
    # collector won't kill the object while it's in
    # SWIG-land
      self.__dict__.setdefault("_members",{})[name] = value

      return _set_instance_attr(self, name, value)


    def __call__(self, *args):
      return svn_wc_invoke_status_func4(self, *args)

svn_wc_status_func4_t_swigregister = _wc.svn_wc_status_func4_t_swigregister
svn_wc_status_func4_t_swigregister(svn_wc_status_func4_t)

class svn_wc_status_func3_t(object):
    """Proxy of C svn_wc_status_func3_t struct."""

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    def set_parent_pool(self, parent_pool=None):
      """Create a new proxy object for TYPE"""
      import libsvn.core, weakref
      self.__dict__["_parent_pool"] = \
        parent_pool or libsvn.core.application_pool;
      if self.__dict__["_parent_pool"]:
        self.__dict__["_is_valid"] = weakref.ref(
          self.__dict__["_parent_pool"]._is_valid)

    def assert_valid(self):
      """Assert that this object is using valid pool memory"""
      if "_is_valid" in self.__dict__:
        assert self.__dict__["_is_valid"](), "Variable has already been deleted"

    def _retrieve_swig_value(self, name, value):
    # If we got back a different object than we have cached, we need to copy
    # all our metadata into it, so that it looks identical to the one
    # originally set.
      members = self.__dict__.get('_members')
      if members is not None and name in members:
        _copy_metadata_deep(value, members[name])

    # Verify that the new object is good
      _assert_valid_deep(value)

      return value

    # Attribute access must be intercepted to ensure that objects coming from
    # read attribute access match those that are set with write attribute access.
    # Specifically the metadata, such as the associated apr_pool object, should
    # match the originally assigned object.
    #
    # For classic classes it is enough to use __getattr__ to intercept swig
    # derived attributes. However, with new style classes SWIG makes use of
    # descriptors which mean that __getattr__ is never called. Therefore,
    # __getattribute__ must be used for the interception.

    if _newclass:
      def __getattribute__(self, name):
        """Manage access to all attributes of this object."""

    # Start by mimicing __getattr__ behavior: immediately return __dict__ or
    # items directly present in __dict__
        mydict = object.__getattribute__(self, '__dict__')

        if name == "__dict__":
          return mydict

        if name in mydict:
          return mydict[name]

        object.__getattribute__(self, 'assert_valid')()

        value = _get_instance_attr(self, name)
        fn = object.__getattribute__(self, '_retrieve_swig_value')
        return fn(name, value)
    else:
      def __getattr__(self, name):
        """Get an attribute from this object"""
        self.assert_valid()

        value = _swig_getattr(self, self.__class__, name)

        return self._retrieve_swig_value(name, value)

    def __setattr__(self, name, value):
      """Set an attribute on this object"""
      self.assert_valid()

    # Save a copy of the object, so that the garbage
    # collector won't kill the object while it's in
    # SWIG-land
      self.__dict__.setdefault("_members",{})[name] = value

      return _set_instance_attr(self, name, value)


    def __call__(self, *args):
      return svn_wc_invoke_status_func3(self, *args)

svn_wc_status_func3_t_swigregister = _wc.svn_wc_status_func3_t_swigregister
svn_wc_status_func3_t_swigregister(svn_wc_status_func3_t)

class svn_wc_status_func2_t(object):
    """Proxy of C svn_wc_status_func2_t struct."""

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    def set_parent_pool(self, parent_pool=None):
      """Create a new proxy object for TYPE"""
      import libsvn.core, weakref
      self.__dict__["_parent_pool"] = \
        parent_pool or libsvn.core.application_pool;
      if self.__dict__["_parent_pool"]:
        self.__dict__["_is_valid"] = weakref.ref(
          self.__dict__["_parent_pool"]._is_valid)

    def assert_valid(self):
      """Assert that this object is using valid pool memory"""
      if "_is_valid" in self.__dict__:
        assert self.__dict__["_is_valid"](), "Variable has already been deleted"

    def _retrieve_swig_value(self, name, value):
    # If we got back a different object than we have cached, we need to copy
    # all our metadata into it, so that it looks identical to the one
    # originally set.
      members = self.__dict__.get('_members')
      if members is not None and name in members:
        _copy_metadata_deep(value, members[name])

    # Verify that the new object is good
      _assert_valid_deep(value)

      return value

    # Attribute access must be intercepted to ensure that objects coming from
    # read attribute access match those that are set with write attribute access.
    # Specifically the metadata, such as the associated apr_pool object, should
    # match the originally assigned object.
    #
    # For classic classes it is enough to use __getattr__ to intercept swig
    # derived attributes. However, with new style classes SWIG makes use of
    # descriptors which mean that __getattr__ is never called. Therefore,
    # __getattribute__ must be used for the interception.

    if _newclass:
      def __getattribute__(self, name):
        """Manage access to all attributes of this object."""

    # Start by mimicing __getattr__ behavior: immediately return __dict__ or
    # items directly present in __dict__
        mydict = object.__getattribute__(self, '__dict__')

        if name == "__dict__":
          return mydict

        if name in mydict:
          return mydict[name]

        object.__getattribute__(self, 'assert_valid')()

        value = _get_instance_attr(self, name)
        fn = object.__getattribute__(self, '_retrieve_swig_value')
        return fn(name, value)
    else:
      def __getattr__(self, name):
        """Get an attribute from this object"""
        self.assert_valid()

        value = _swig_getattr(self, self.__class__, name)

        return self._retrieve_swig_value(name, value)

    def __setattr__(self, name, value):
      """Set an attribute on this object"""
      self.assert_valid()

    # Save a copy of the object, so that the garbage
    # collector won't kill the object while it's in
    # SWIG-land
      self.__dict__.setdefault("_members",{})[name] = value

      return _set_instance_attr(self, name, value)


    def __call__(self, *args):
      return svn_wc_invoke_status_func2(self, *args)

svn_wc_status_func2_t_swigregister = _wc.svn_wc_status_func2_t_swigregister
svn_wc_status_func2_t_swigregister(svn_wc_status_func2_t)

class svn_wc_status_func_t(object):
    """Proxy of C svn_wc_status_func_t struct."""

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    def set_parent_pool(self, parent_pool=None):
      """Create a new proxy object for TYPE"""
      import libsvn.core, weakref
      self.__dict__["_parent_pool"] = \
        parent_pool or libsvn.core.application_pool;
      if self.__dict__["_parent_pool"]:
        self.__dict__["_is_valid"] = weakref.ref(
          self.__dict__["_parent_pool"]._is_valid)

    def assert_valid(self):
      """Assert that this object is using valid pool memory"""
      if "_is_valid" in self.__dict__:
        assert self.__dict__["_is_valid"](), "Variable has already been deleted"

    def _retrieve_swig_value(self, name, value):
    # If we got back a different object than we have cached, we need to copy
    # all our metadata into it, so that it looks identical to the one
    # originally set.
      members = self.__dict__.get('_members')
      if members is not None and name in members:
        _copy_metadata_deep(value, members[name])

    # Verify that the new object is good
      _assert_valid_deep(value)

      return value

    # Attribute access must be intercepted to ensure that objects coming from
    # read attribute access match those that are set with write attribute access.
    # Specifically the metadata, such as the associated apr_pool object, should
    # match the originally assigned object.
    #
    # For classic classes it is enough to use __getattr__ to intercept swig
    # derived attributes. However, with new style classes SWIG makes use of
    # descriptors which mean that __getattr__ is never called. Therefore,
    # __getattribute__ must be used for the interception.

    if _newclass:
      def __getattribute__(self, name):
        """Manage access to all attributes of this object."""

    # Start by mimicing __getattr__ behavior: immediately return __dict__ or
    # items directly present in __dict__
        mydict = object.__getattribute__(self, '__dict__')

        if name == "__dict__":
          return mydict

        if name in mydict:
          return mydict[name]

        object.__getattribute__(self, 'assert_valid')()

        value = _get_instance_attr(self, name)
        fn = object.__getattribute__(self, '_retrieve_swig_value')
        return fn(name, value)
    else:
      def __getattr__(self, name):
        """Get an attribute from this object"""
        self.assert_valid()

        value = _swig_getattr(self, self.__class__, name)

        return self._retrieve_swig_value(name, value)

    def __setattr__(self, name, value):
      """Set an attribute on this object"""
      self.assert_valid()

    # Save a copy of the object, so that the garbage
    # collector won't kill the object while it's in
    # SWIG-land
      self.__dict__.setdefault("_members",{})[name] = value

      return _set_instance_attr(self, name, value)


    def __call__(self, *args):
      return svn_wc_invoke_status_func(self, *args)

svn_wc_status_func_t_swigregister = _wc.svn_wc_status_func_t_swigregister
svn_wc_status_func_t_swigregister(svn_wc_status_func_t)

class svn_wc_get_file_t(object):
    """Proxy of C svn_wc_get_file_t struct."""

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    def set_parent_pool(self, parent_pool=None):
      """Create a new proxy object for TYPE"""
      import libsvn.core, weakref
      self.__dict__["_parent_pool"] = \
        parent_pool or libsvn.core.application_pool;
      if self.__dict__["_parent_pool"]:
        self.__dict__["_is_valid"] = weakref.ref(
          self.__dict__["_parent_pool"]._is_valid)

    def assert_valid(self):
      """Assert that this object is using valid pool memory"""
      if "_is_valid" in self.__dict__:
        assert self.__dict__["_is_valid"](), "Variable has already been deleted"

    def _retrieve_swig_value(self, name, value):
    # If we got back a different object than we have cached, we need to copy
    # all our metadata into it, so that it looks identical to the one
    # originally set.
      members = self.__dict__.get('_members')
      if members is not None and name in members:
        _copy_metadata_deep(value, members[name])

    # Verify that the new object is good
      _assert_valid_deep(value)

      return value

    # Attribute access must be intercepted to ensure that objects coming from
    # read attribute access match those that are set with write attribute access.
    # Specifically the metadata, such as the associated apr_pool object, should
    # match the originally assigned object.
    #
    # For classic classes it is enough to use __getattr__ to intercept swig
    # derived attributes. However, with new style classes SWIG makes use of
    # descriptors which mean that __getattr__ is never called. Therefore,
    # __getattribute__ must be used for the interception.

    if _newclass:
      def __getattribute__(self, name):
        """Manage access to all attributes of this object."""

    # Start by mimicing __getattr__ behavior: immediately return __dict__ or
    # items directly present in __dict__
        mydict = object.__getattribute__(self, '__dict__')

        if name == "__dict__":
          return mydict

        if name in mydict:
          return mydict[name]

        object.__getattribute__(self, 'assert_valid')()

        value = _get_instance_attr(self, name)
        fn = object.__getattribute__(self, '_retrieve_swig_value')
        return fn(name, value)
    else:
      def __getattr__(self, name):
        """Get an attribute from this object"""
        self.assert_valid()

        value = _swig_getattr(self, self.__class__, name)

        return self._retrieve_swig_value(name, value)

    def __setattr__(self, name, value):
      """Set an attribute on this object"""
      self.assert_valid()

    # Save a copy of the object, so that the garbage
    # collector won't kill the object while it's in
    # SWIG-land
      self.__dict__.setdefault("_members",{})[name] = value

      return _set_instance_attr(self, name, value)


    def __call__(self, *args):
      return svn_wc_invoke_get_file(self, *args)

svn_wc_get_file_t_swigregister = _wc.svn_wc_get_file_t_swigregister
svn_wc_get_file_t_swigregister(svn_wc_get_file_t)

class svn_wc_dirents_func_t(object):
    """Proxy of C svn_wc_dirents_func_t struct."""

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    def set_parent_pool(self, parent_pool=None):
      """Create a new proxy object for TYPE"""
      import libsvn.core, weakref
      self.__dict__["_parent_pool"] = \
        parent_pool or libsvn.core.application_pool;
      if self.__dict__["_parent_pool"]:
        self.__dict__["_is_valid"] = weakref.ref(
          self.__dict__["_parent_pool"]._is_valid)

    def assert_valid(self):
      """Assert that this object is using valid pool memory"""
      if "_is_valid" in self.__dict__:
        assert self.__dict__["_is_valid"](), "Variable has already been deleted"

    def _retrieve_swig_value(self, name, value):
    # If we got back a different object than we have cached, we need to copy
    # all our metadata into it, so that it looks identical to the one
    # originally set.
      members = self.__dict__.get('_members')
      if members is not None and name in members:
        _copy_metadata_deep(value, members[name])

    # Verify that the new object is good
      _assert_valid_deep(value)

      return value

    # Attribute access must be intercepted to ensure that objects coming from
    # read attribute access match those that are set with write attribute access.
    # Specifically the metadata, such as the associated apr_pool object, should
    # match the originally assigned object.
    #
    # For classic classes it is enough to use __getattr__ to intercept swig
    # derived attributes. However, with new style classes SWIG makes use of
    # descriptors which mean that __getattr__ is never called. Therefore,
    # __getattribute__ must be used for the interception.

    if _newclass:
      def __getattribute__(self, name):
        """Manage access to all attributes of this object."""

    # Start by mimicing __getattr__ behavior: immediately return __dict__ or
    # items directly present in __dict__
        mydict = object.__getattribute__(self, '__dict__')

        if name == "__dict__":
          return mydict

        if name in mydict:
          return mydict[name]

        object.__getattribute__(self, 'assert_valid')()

        value = _get_instance_attr(self, name)
        fn = object.__getattribute__(self, '_retrieve_swig_value')
        return fn(name, value)
    else:
      def __getattr__(self, name):
        """Get an attribute from this object"""
        self.assert_valid()

        value = _swig_getattr(self, self.__class__, name)

        return self._retrieve_swig_value(name, value)

    def __setattr__(self, name, value):
      """Set an attribute on this object"""
      self.assert_valid()

    # Save a copy of the object, so that the garbage
    # collector won't kill the object while it's in
    # SWIG-land
      self.__dict__.setdefault("_members",{})[name] = value

      return _set_instance_attr(self, name, value)


    def __call__(self, *args):
      return svn_wc_invoke_dirents_func(self, *args)

svn_wc_dirents_func_t_swigregister = _wc.svn_wc_dirents_func_t_swigregister
svn_wc_dirents_func_t_swigregister(svn_wc_dirents_func_t)

class svn_wc_canonicalize_svn_prop_get_file_t(object):
    """Proxy of C svn_wc_canonicalize_svn_prop_get_file_t struct."""

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    def set_parent_pool(self, parent_pool=None):
      """Create a new proxy object for TYPE"""
      import libsvn.core, weakref
      self.__dict__["_parent_pool"] = \
        parent_pool or libsvn.core.application_pool;
      if self.__dict__["_parent_pool"]:
        self.__dict__["_is_valid"] = weakref.ref(
          self.__dict__["_parent_pool"]._is_valid)

    def assert_valid(self):
      """Assert that this object is using valid pool memory"""
      if "_is_valid" in self.__dict__:
        assert self.__dict__["_is_valid"](), "Variable has already been deleted"

    def _retrieve_swig_value(self, name, value):
    # If we got back a different object than we have cached, we need to copy
    # all our metadata into it, so that it looks identical to the one
    # originally set.
      members = self.__dict__.get('_members')
      if members is not None and name in members:
        _copy_metadata_deep(value, members[name])

    # Verify that the new object is good
      _assert_valid_deep(value)

      return value

    # Attribute access must be intercepted to ensure that objects coming from
    # read attribute access match those that are set with write attribute access.
    # Specifically the metadata, such as the associated apr_pool object, should
    # match the originally assigned object.
    #
    # For classic classes it is enough to use __getattr__ to intercept swig
    # derived attributes. However, with new style classes SWIG makes use of
    # descriptors which mean that __getattr__ is never called. Therefore,
    # __getattribute__ must be used for the interception.

    if _newclass:
      def __getattribute__(self, name):
        """Manage access to all attributes of this object."""

    # Start by mimicing __getattr__ behavior: immediately return __dict__ or
    # items directly present in __dict__
        mydict = object.__getattribute__(self, '__dict__')

        if name == "__dict__":
          return mydict

        if name in mydict:
          return mydict[name]

        object.__getattribute__(self, 'assert_valid')()

        value = _get_instance_attr(self, name)
        fn = object.__getattribute__(self, '_retrieve_swig_value')
        return fn(name, value)
    else:
      def __getattr__(self, name):
        """Get an attribute from this object"""
        self.assert_valid()

        value = _swig_getattr(self, self.__class__, name)

        return self._retrieve_swig_value(name, value)

    def __setattr__(self, name, value):
      """Set an attribute on this object"""
      self.assert_valid()

    # Save a copy of the object, so that the garbage
    # collector won't kill the object while it's in
    # SWIG-land
      self.__dict__.setdefault("_members",{})[name] = value

      return _set_instance_attr(self, name, value)


    def __call__(self, *args):
      return svn_wc_invoke_canonicalize_svn_prop_get_file(self, *args)

svn_wc_canonicalize_svn_prop_get_file_t_swigregister = _wc.svn_wc_canonicalize_svn_prop_get_file_t_swigregister
svn_wc_canonicalize_svn_prop_get_file_t_swigregister(svn_wc_canonicalize_svn_prop_get_file_t)

class svn_wc_upgrade_get_repos_info_t(object):
    """Proxy of C svn_wc_upgrade_get_repos_info_t struct."""

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    def set_parent_pool(self, parent_pool=None):
      """Create a new proxy object for TYPE"""
      import libsvn.core, weakref
      self.__dict__["_parent_pool"] = \
        parent_pool or libsvn.core.application_pool;
      if self.__dict__["_parent_pool"]:
        self.__dict__["_is_valid"] = weakref.ref(
          self.__dict__["_parent_pool"]._is_valid)

    def assert_valid(self):
      """Assert that this object is using valid pool memory"""
      if "_is_valid" in self.__dict__:
        assert self.__dict__["_is_valid"](), "Variable has already been deleted"

    def _retrieve_swig_value(self, name, value):
    # If we got back a different object than we have cached, we need to copy
    # all our metadata into it, so that it looks identical to the one
    # originally set.
      members = self.__dict__.get('_members')
      if members is not None and name in members:
        _copy_metadata_deep(value, members[name])

    # Verify that the new object is good
      _assert_valid_deep(value)

      return value

    # Attribute access must be intercepted to ensure that objects coming from
    # read attribute access match those that are set with write attribute access.
    # Specifically the metadata, such as the associated apr_pool object, should
    # match the originally assigned object.
    #
    # For classic classes it is enough to use __getattr__ to intercept swig
    # derived attributes. However, with new style classes SWIG makes use of
    # descriptors which mean that __getattr__ is never called. Therefore,
    # __getattribute__ must be used for the interception.

    if _newclass:
      def __getattribute__(self, name):
        """Manage access to all attributes of this object."""

    # Start by mimicing __getattr__ behavior: immediately return __dict__ or
    # items directly present in __dict__
        mydict = object.__getattribute__(self, '__dict__')

        if name == "__dict__":
          return mydict

        if name in mydict:
          return mydict[name]

        object.__getattribute__(self, 'assert_valid')()

        value = _get_instance_attr(self, name)
        fn = object.__getattribute__(self, '_retrieve_swig_value')
        return fn(name, value)
    else:
      def __getattr__(self, name):
        """Get an attribute from this object"""
        self.assert_valid()

        value = _swig_getattr(self, self.__class__, name)

        return self._retrieve_swig_value(name, value)

    def __setattr__(self, name, value):
      """Set an attribute on this object"""
      self.assert_valid()

    # Save a copy of the object, so that the garbage
    # collector won't kill the object while it's in
    # SWIG-land
      self.__dict__.setdefault("_members",{})[name] = value

      return _set_instance_attr(self, name, value)


    def __call__(self, *args):
      return svn_wc_invoke_upgrade_get_repos_info(self, *args)

svn_wc_upgrade_get_repos_info_t_swigregister = _wc.svn_wc_upgrade_get_repos_info_t_swigregister
svn_wc_upgrade_get_repos_info_t_swigregister(svn_wc_upgrade_get_repos_info_t)

class svn_wc_relocation_validator3_t(object):
    """Proxy of C svn_wc_relocation_validator3_t struct."""

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    def set_parent_pool(self, parent_pool=None):
      """Create a new proxy object for TYPE"""
      import libsvn.core, weakref
      self.__dict__["_parent_pool"] = \
        parent_pool or libsvn.core.application_pool;
      if self.__dict__["_parent_pool"]:
        self.__dict__["_is_valid"] = weakref.ref(
          self.__dict__["_parent_pool"]._is_valid)

    def assert_valid(self):
      """Assert that this object is using valid pool memory"""
      if "_is_valid" in self.__dict__:
        assert self.__dict__["_is_valid"](), "Variable has already been deleted"

    def _retrieve_swig_value(self, name, value):
    # If we got back a different object than we have cached, we need to copy
    # all our metadata into it, so that it looks identical to the one
    # originally set.
      members = self.__dict__.get('_members')
      if members is not None and name in members:
        _copy_metadata_deep(value, members[name])

    # Verify that the new object is good
      _assert_valid_deep(value)

      return value

    # Attribute access must be intercepted to ensure that objects coming from
    # read attribute access match those that are set with write attribute access.
    # Specifically the metadata, such as the associated apr_pool object, should
    # match the originally assigned object.
    #
    # For classic classes it is enough to use __getattr__ to intercept swig
    # derived attributes. However, with new style classes SWIG makes use of
    # descriptors which mean that __getattr__ is never called. Therefore,
    # __getattribute__ must be used for the interception.

    if _newclass:
      def __getattribute__(self, name):
        """Manage access to all attributes of this object."""

    # Start by mimicing __getattr__ behavior: immediately return __dict__ or
    # items directly present in __dict__
        mydict = object.__getattribute__(self, '__dict__')

        if name == "__dict__":
          return mydict

        if name in mydict:
          return mydict[name]

        object.__getattribute__(self, 'assert_valid')()

        value = _get_instance_attr(self, name)
        fn = object.__getattribute__(self, '_retrieve_swig_value')
        return fn(name, value)
    else:
      def __getattr__(self, name):
        """Get an attribute from this object"""
        self.assert_valid()

        value = _swig_getattr(self, self.__class__, name)

        return self._retrieve_swig_value(name, value)

    def __setattr__(self, name, value):
      """Set an attribute on this object"""
      self.assert_valid()

    # Save a copy of the object, so that the garbage
    # collector won't kill the object while it's in
    # SWIG-land
      self.__dict__.setdefault("_members",{})[name] = value

      return _set_instance_attr(self, name, value)


    def __call__(self, *args):
      return svn_wc_invoke_relocation_validator3(self, *args)

svn_wc_relocation_validator3_t_swigregister = _wc.svn_wc_relocation_validator3_t_swigregister
svn_wc_relocation_validator3_t_swigregister(svn_wc_relocation_validator3_t)

class svn_wc_relocation_validator2_t(object):
    """Proxy of C svn_wc_relocation_validator2_t struct."""

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    def set_parent_pool(self, parent_pool=None):
      """Create a new proxy object for TYPE"""
      import libsvn.core, weakref
      self.__dict__["_parent_pool"] = \
        parent_pool or libsvn.core.application_pool;
      if self.__dict__["_parent_pool"]:
        self.__dict__["_is_valid"] = weakref.ref(
          self.__dict__["_parent_pool"]._is_valid)

    def assert_valid(self):
      """Assert that this object is using valid pool memory"""
      if "_is_valid" in self.__dict__:
        assert self.__dict__["_is_valid"](), "Variable has already been deleted"

    def _retrieve_swig_value(self, name, value):
    # If we got back a different object than we have cached, we need to copy
    # all our metadata into it, so that it looks identical to the one
    # originally set.
      members = self.__dict__.get('_members')
      if members is not None and name in members:
        _copy_metadata_deep(value, members[name])

    # Verify that the new object is good
      _assert_valid_deep(value)

      return value

    # Attribute access must be intercepted to ensure that objects coming from
    # read attribute access match those that are set with write attribute access.
    # Specifically the metadata, such as the associated apr_pool object, should
    # match the originally assigned object.
    #
    # For classic classes it is enough to use __getattr__ to intercept swig
    # derived attributes. However, with new style classes SWIG makes use of
    # descriptors which mean that __getattr__ is never called. Therefore,
    # __getattribute__ must be used for the interception.

    if _newclass:
      def __getattribute__(self, name):
        """Manage access to all attributes of this object."""

    # Start by mimicing __getattr__ behavior: immediately return __dict__ or
    # items directly present in __dict__
        mydict = object.__getattribute__(self, '__dict__')

        if name == "__dict__":
          return mydict

        if name in mydict:
          return mydict[name]

        object.__getattribute__(self, 'assert_valid')()

        value = _get_instance_attr(self, name)
        fn = object.__getattribute__(self, '_retrieve_swig_value')
        return fn(name, value)
    else:
      def __getattr__(self, name):
        """Get an attribute from this object"""
        self.assert_valid()

        value = _swig_getattr(self, self.__class__, name)

        return self._retrieve_swig_value(name, value)

    def __setattr__(self, name, value):
      """Set an attribute on this object"""
      self.assert_valid()

    # Save a copy of the object, so that the garbage
    # collector won't kill the object while it's in
    # SWIG-land
      self.__dict__.setdefault("_members",{})[name] = value

      return _set_instance_attr(self, name, value)


    def __call__(self, *args):
      return svn_wc_invoke_relocation_validator2(self, *args)

svn_wc_relocation_validator2_t_swigregister = _wc.svn_wc_relocation_validator2_t_swigregister
svn_wc_relocation_validator2_t_swigregister(svn_wc_relocation_validator2_t)

class svn_wc_relocation_validator_t(object):
    """Proxy of C svn_wc_relocation_validator_t struct."""

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    def set_parent_pool(self, parent_pool=None):
      """Create a new proxy object for TYPE"""
      import libsvn.core, weakref
      self.__dict__["_parent_pool"] = \
        parent_pool or libsvn.core.application_pool;
      if self.__dict__["_parent_pool"]:
        self.__dict__["_is_valid"] = weakref.ref(
          self.__dict__["_parent_pool"]._is_valid)

    def assert_valid(self):
      """Assert that this object is using valid pool memory"""
      if "_is_valid" in self.__dict__:
        assert self.__dict__["_is_valid"](), "Variable has already been deleted"

    def _retrieve_swig_value(self, name, value):
    # If we got back a different object than we have cached, we need to copy
    # all our metadata into it, so that it looks identical to the one
    # originally set.
      members = self.__dict__.get('_members')
      if members is not None and name in members:
        _copy_metadata_deep(value, members[name])

    # Verify that the new object is good
      _assert_valid_deep(value)

      return value

    # Attribute access must be intercepted to ensure that objects coming from
    # read attribute access match those that are set with write attribute access.
    # Specifically the metadata, such as the associated apr_pool object, should
    # match the originally assigned object.
    #
    # For classic classes it is enough to use __getattr__ to intercept swig
    # derived attributes. However, with new style classes SWIG makes use of
    # descriptors which mean that __getattr__ is never called. Therefore,
    # __getattribute__ must be used for the interception.

    if _newclass:
      def __getattribute__(self, name):
        """Manage access to all attributes of this object."""

    # Start by mimicing __getattr__ behavior: immediately return __dict__ or
    # items directly present in __dict__
        mydict = object.__getattribute__(self, '__dict__')

        if name == "__dict__":
          return mydict

        if name in mydict:
          return mydict[name]

        object.__getattribute__(self, 'assert_valid')()

        value = _get_instance_attr(self, name)
        fn = object.__getattribute__(self, '_retrieve_swig_value')
        return fn(name, value)
    else:
      def __getattr__(self, name):
        """Get an attribute from this object"""
        self.assert_valid()

        value = _swig_getattr(self, self.__class__, name)

        return self._retrieve_swig_value(name, value)

    def __setattr__(self, name, value):
      """Set an attribute on this object"""
      self.assert_valid()

    # Save a copy of the object, so that the garbage
    # collector won't kill the object while it's in
    # SWIG-land
      self.__dict__.setdefault("_members",{})[name] = value

      return _set_instance_attr(self, name, value)


    def __call__(self, *args):
      return svn_wc_invoke_relocation_validator(self, *args)

svn_wc_relocation_validator_t_swigregister = _wc.svn_wc_relocation_validator_t_swigregister
svn_wc_relocation_validator_t_swigregister(svn_wc_relocation_validator_t)

class svn_changelist_receiver_t(object):
    """Proxy of C svn_changelist_receiver_t struct."""

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    def set_parent_pool(self, parent_pool=None):
      """Create a new proxy object for TYPE"""
      import libsvn.core, weakref
      self.__dict__["_parent_pool"] = \
        parent_pool or libsvn.core.application_pool;
      if self.__dict__["_parent_pool"]:
        self.__dict__["_is_valid"] = weakref.ref(
          self.__dict__["_parent_pool"]._is_valid)

    def assert_valid(self):
      """Assert that this object is using valid pool memory"""
      if "_is_valid" in self.__dict__:
        assert self.__dict__["_is_valid"](), "Variable has already been deleted"

    def _retrieve_swig_value(self, name, value):
    # If we got back a different object than we have cached, we need to copy
    # all our metadata into it, so that it looks identical to the one
    # originally set.
      members = self.__dict__.get('_members')
      if members is not None and name in members:
        _copy_metadata_deep(value, members[name])

    # Verify that the new object is good
      _assert_valid_deep(value)

      return value

    # Attribute access must be intercepted to ensure that objects coming from
    # read attribute access match those that are set with write attribute access.
    # Specifically the metadata, such as the associated apr_pool object, should
    # match the originally assigned object.
    #
    # For classic classes it is enough to use __getattr__ to intercept swig
    # derived attributes. However, with new style classes SWIG makes use of
    # descriptors which mean that __getattr__ is never called. Therefore,
    # __getattribute__ must be used for the interception.

    if _newclass:
      def __getattribute__(self, name):
        """Manage access to all attributes of this object."""

    # Start by mimicing __getattr__ behavior: immediately return __dict__ or
    # items directly present in __dict__
        mydict = object.__getattribute__(self, '__dict__')

        if name == "__dict__":
          return mydict

        if name in mydict:
          return mydict[name]

        object.__getattribute__(self, 'assert_valid')()

        value = _get_instance_attr(self, name)
        fn = object.__getattribute__(self, '_retrieve_swig_value')
        return fn(name, value)
    else:
      def __getattr__(self, name):
        """Get an attribute from this object"""
        self.assert_valid()

        value = _swig_getattr(self, self.__class__, name)

        return self._retrieve_swig_value(name, value)

    def __setattr__(self, name, value):
      """Set an attribute on this object"""
      self.assert_valid()

    # Save a copy of the object, so that the garbage
    # collector won't kill the object while it's in
    # SWIG-land
      self.__dict__.setdefault("_members",{})[name] = value

      return _set_instance_attr(self, name, value)


    def __call__(self, *args):
      return svn_changelist_invoke_receiver(self, *args)

svn_changelist_receiver_t_swigregister = _wc.svn_changelist_receiver_t_swigregister
svn_changelist_receiver_t_swigregister(svn_changelist_receiver_t)


def svn_wc_swig_init_asp_dot_net_hack(*args) -> "svn_error_t *":
    """svn_wc_swig_init_asp_dot_net_hack(apr_pool_t pool) -> svn_error_t"""
    return _wc.svn_wc_swig_init_asp_dot_net_hack(*args)
svn_wc_swig_init_asp_dot_net_hack() 


