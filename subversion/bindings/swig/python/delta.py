# This file was automatically generated by SWIG (http://www.swig.org).
# Version 3.0.12
#
# Do not make changes to this file unless you know what you are doing--modify
# the SWIG interface file instead.


def _dll_paths():
    import os
    if hasattr(os, 'add_dll_directory'):  # Python 3.8+ on Windows
        cookies = []
        for path in os.environ.get('PATH', '').split(os.pathsep):
            if path and os.path.isabs(path):
                try:
                    cookie = os.add_dll_directory(path)
                except OSError:
                    continue
                else:
                    cookies.append(cookie)
        return cookies
    else:
        return ()

_dll_paths = _dll_paths()
try:
    from . import _delta
finally:
    _dll_path = None
    for _dll_path in _dll_paths:
        _dll_path.close()
    del _dll_paths, _dll_path

try:
    _swig_property = property
except NameError:
    pass  # Python < 2.2 doesn't have 'property'.

try:
    import builtins as __builtin__
except ImportError:
    import __builtin__

def _swig_setattr_nondynamic(self, class_type, name, value, static=1):
    if (name == "thisown"):
        return self.this.own(value)
    if (name == "this"):
        if type(value).__name__ == 'SwigPyObject':
            self.__dict__[name] = value
            return
    method = class_type.__swig_setmethods__.get(name, None)
    if method:
        return method(self, value)
    if (not static):
        object.__setattr__(self, name, value)
    else:
        raise AttributeError("You cannot add attributes to %s" % self)


def _swig_setattr(self, class_type, name, value):
    return _swig_setattr_nondynamic(self, class_type, name, value, 0)


def _swig_getattr(self, class_type, name):
    if (name == "thisown"):
        return self.this.own()
    method = class_type.__swig_getmethods__.get(name, None)
    if method:
        return method(self)
    raise AttributeError("'%s' object has no attribute '%s'" % (class_type.__name__, name))


def _swig_repr(self):
    try:
        strthis = "proxy of " + self.this.__repr__()
    except __builtin__.Exception:
        strthis = ""
    return "<%s.%s; %s >" % (self.__class__.__module__, self.__class__.__name__, strthis,)


def _swig_setattr_nondynamic_method(set):
    def set_attr(self, name, value):
        if (name == "thisown"):
            return self.this.own(value)
        if hasattr(self, name) or (name == "this"):
            set(self, name, value)
        else:
            raise AttributeError("You cannot add attributes to %s" % self)
    return set_attr



def _copy_metadata_deep(value, old_value):
  """Copy all attributes of old_value into value, recursively traversing
  lists and dicts if needed."""
  if value is None or old_value is None or value is old_value: return

  if isinstance(value, dict):
    for k in value:
      _copy_metadata_deep(value[k], old_value[k])
  elif isinstance(value, list):
    for v, old_v in zip(value, old_value):
      _copy_metadata_deep(v, old_v)
  else:
    try:
      value.__dict__.update(old_value.__dict__)
    except AttributeError:
      pass

def _assert_valid_deep(value):
  """Assert value's validity, recursively traversing lists and dicts."""
  if isinstance(value, dict):
    for k in value:
      _assert_valid_deep(value[k])
  elif isinstance(value, list):
    for v in value:
      _assert_valid_deep(v)
# Ensure that the passed in value isn't a type, which could have an
# assert_valid attribute, but it can not be called without an instance.
  elif type(value) != type:
    try:
      fn = value.assert_valid
    except AttributeError:
      pass
    else:
      fn()



  # SWIG classes generated with -modern do not define this variable
try:
  _newclass
except NameError:
  _newclass = 1
else:
  raise RuntimeError("Require -modern option, but _newclass is defined")

_get_instance_attr = object.__getattribute__
_set_instance_attr = _swig_setattr_nondynamic_method(object.__setattr__)


import libsvn.core

def svn_swig_py_make_editor(*args) -> "svn_delta_editor_t const **, void **":
    """svn_swig_py_make_editor(PyObject * py_editor, apr_pool_t pool)"""
    return _delta.svn_swig_py_make_editor(*args)
SVN_DELTA_COMPRESSION_LEVEL_NONE = _delta.SVN_DELTA_COMPRESSION_LEVEL_NONE
SVN_DELTA_COMPRESSION_LEVEL_MAX = _delta.SVN_DELTA_COMPRESSION_LEVEL_MAX
SVN_DELTA_COMPRESSION_LEVEL_DEFAULT = _delta.SVN_DELTA_COMPRESSION_LEVEL_DEFAULT

def svn_delta_version() -> "svn_version_t const *":
    """svn_delta_version() -> svn_version_t const *"""
    return _delta.svn_delta_version()
svn_txdelta_source = _delta.svn_txdelta_source
svn_txdelta_target = _delta.svn_txdelta_target
svn_txdelta_new = _delta.svn_txdelta_new
class svn_txdelta_op_t(object):
    """Proxy of C svn_txdelta_op_t struct."""

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    action_code = _swig_property(_delta.svn_txdelta_op_t_action_code_get, _delta.svn_txdelta_op_t_action_code_set)
    offset = _swig_property(_delta.svn_txdelta_op_t_offset_get, _delta.svn_txdelta_op_t_offset_set)
    length = _swig_property(_delta.svn_txdelta_op_t_length_get, _delta.svn_txdelta_op_t_length_set)
    def set_parent_pool(self, parent_pool=None):
      """Create a new proxy object for TYPE"""
      import libsvn.core, weakref
      self.__dict__["_parent_pool"] = \
        parent_pool or libsvn.core.application_pool;
      if self.__dict__["_parent_pool"]:
        self.__dict__["_is_valid"] = weakref.ref(
          self.__dict__["_parent_pool"]._is_valid)

    def assert_valid(self):
      """Assert that this object is using valid pool memory"""
      if "_is_valid" in self.__dict__:
        assert self.__dict__["_is_valid"](), "Variable has already been deleted"

    def _retrieve_swig_value(self, name, value):
    # If we got back a different object than we have cached, we need to copy
    # all our metadata into it, so that it looks identical to the one
    # originally set.
      members = self.__dict__.get('_members')
      if members is not None and name in members:
        _copy_metadata_deep(value, members[name])

    # Verify that the new object is good
      _assert_valid_deep(value)

      return value

    # Attribute access must be intercepted to ensure that objects coming from
    # read attribute access match those that are set with write attribute access.
    # Specifically the metadata, such as the associated apr_pool object, should
    # match the originally assigned object.
    #
    # For classic classes it is enough to use __getattr__ to intercept swig
    # derived attributes. However, with new style classes SWIG makes use of
    # descriptors which mean that __getattr__ is never called. Therefore,
    # __getattribute__ must be used for the interception.

    if _newclass:
      def __getattribute__(self, name):
        """Manage access to all attributes of this object."""

    # Start by mimicing __getattr__ behavior: immediately return __dict__ or
    # items directly present in __dict__
        mydict = object.__getattribute__(self, '__dict__')

        if name == "__dict__":
          return mydict

        if name in mydict:
          return mydict[name]

        object.__getattribute__(self, 'assert_valid')()

        value = _get_instance_attr(self, name)
        fn = object.__getattribute__(self, '_retrieve_swig_value')
        return fn(name, value)
    else:
      def __getattr__(self, name):
        """Get an attribute from this object"""
        self.assert_valid()

        value = _swig_getattr(self, self.__class__, name)

        return self._retrieve_swig_value(name, value)

    def __setattr__(self, name, value):
      """Set an attribute on this object"""
      self.assert_valid()

    # Save a copy of the object, so that the garbage
    # collector won't kill the object while it's in
    # SWIG-land
      self.__dict__.setdefault("_members",{})[name] = value

      return _set_instance_attr(self, name, value)


    def __init__(self):
        """__init__(svn_txdelta_op_t self) -> svn_txdelta_op_t"""
        this = _delta.new_svn_txdelta_op_t()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _delta.delete_svn_txdelta_op_t
    __del__ = lambda self: None
svn_txdelta_op_t_swigregister = _delta.svn_txdelta_op_t_swigregister
svn_txdelta_op_t_swigregister(svn_txdelta_op_t)

class svn_txdelta_window_t(object):
    """Proxy of C svn_txdelta_window_t struct."""

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    sview_offset = _swig_property(_delta.svn_txdelta_window_t_sview_offset_get, _delta.svn_txdelta_window_t_sview_offset_set)
    sview_len = _swig_property(_delta.svn_txdelta_window_t_sview_len_get, _delta.svn_txdelta_window_t_sview_len_set)
    tview_len = _swig_property(_delta.svn_txdelta_window_t_tview_len_get, _delta.svn_txdelta_window_t_tview_len_set)
    num_ops = _swig_property(_delta.svn_txdelta_window_t_num_ops_get, _delta.svn_txdelta_window_t_num_ops_set)
    src_ops = _swig_property(_delta.svn_txdelta_window_t_src_ops_get, _delta.svn_txdelta_window_t_src_ops_set)
    new_data = _swig_property(_delta.svn_txdelta_window_t_new_data_get)

    def _ops_get(self) -> "void":
        """_ops_get(svn_txdelta_window_t self)"""
        return _delta.svn_txdelta_window_t__ops_get(self)


    ops = property(_ops_get)

    def set_parent_pool(self, parent_pool=None):
      """Create a new proxy object for TYPE"""
      import libsvn.core, weakref
      self.__dict__["_parent_pool"] = \
        parent_pool or libsvn.core.application_pool;
      if self.__dict__["_parent_pool"]:
        self.__dict__["_is_valid"] = weakref.ref(
          self.__dict__["_parent_pool"]._is_valid)

    def assert_valid(self):
      """Assert that this object is using valid pool memory"""
      if "_is_valid" in self.__dict__:
        assert self.__dict__["_is_valid"](), "Variable has already been deleted"

    def _retrieve_swig_value(self, name, value):
    # If we got back a different object than we have cached, we need to copy
    # all our metadata into it, so that it looks identical to the one
    # originally set.
      members = self.__dict__.get('_members')
      if members is not None and name in members:
        _copy_metadata_deep(value, members[name])

    # Verify that the new object is good
      _assert_valid_deep(value)

      return value

    # Attribute access must be intercepted to ensure that objects coming from
    # read attribute access match those that are set with write attribute access.
    # Specifically the metadata, such as the associated apr_pool object, should
    # match the originally assigned object.
    #
    # For classic classes it is enough to use __getattr__ to intercept swig
    # derived attributes. However, with new style classes SWIG makes use of
    # descriptors which mean that __getattr__ is never called. Therefore,
    # __getattribute__ must be used for the interception.

    if _newclass:
      def __getattribute__(self, name):
        """Manage access to all attributes of this object."""

    # Start by mimicing __getattr__ behavior: immediately return __dict__ or
    # items directly present in __dict__
        mydict = object.__getattribute__(self, '__dict__')

        if name == "__dict__":
          return mydict

        if name in mydict:
          return mydict[name]

        object.__getattribute__(self, 'assert_valid')()

        value = _get_instance_attr(self, name)
        fn = object.__getattribute__(self, '_retrieve_swig_value')
        return fn(name, value)
    else:
      def __getattr__(self, name):
        """Get an attribute from this object"""
        self.assert_valid()

        value = _swig_getattr(self, self.__class__, name)

        return self._retrieve_swig_value(name, value)

    def __setattr__(self, name, value):
      """Set an attribute on this object"""
      self.assert_valid()

    # Save a copy of the object, so that the garbage
    # collector won't kill the object while it's in
    # SWIG-land
      self.__dict__.setdefault("_members",{})[name] = value

      return _set_instance_attr(self, name, value)


    def __init__(self):
        """__init__(svn_txdelta_window_t self) -> svn_txdelta_window_t"""
        this = _delta.new_svn_txdelta_window_t()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _delta.delete_svn_txdelta_window_t
    __del__ = lambda self: None
svn_txdelta_window_t_swigregister = _delta.svn_txdelta_window_t_swigregister
svn_txdelta_window_t_swigregister(svn_txdelta_window_t)


def svn_txdelta_window_dup(*args) -> "svn_txdelta_window_t *":
    """svn_txdelta_window_dup(svn_txdelta_window_t window, apr_pool_t pool) -> svn_txdelta_window_t"""
    return _delta.svn_txdelta_window_dup(*args)

def svn_txdelta_compose_windows(*args) -> "svn_txdelta_window_t *":
    """svn_txdelta_compose_windows(svn_txdelta_window_t window_A, svn_txdelta_window_t window_B, apr_pool_t pool) -> svn_txdelta_window_t"""
    return _delta.svn_txdelta_compose_windows(*args)

def svn_txdelta_apply_instructions(window: 'svn_txdelta_window_t', sbuf: 'char const *', tbuf: 'char *') -> "apr_size_t *":
    """svn_txdelta_apply_instructions(svn_txdelta_window_t window, char const * sbuf, char * tbuf)"""
    return _delta.svn_txdelta_apply_instructions(window, sbuf, tbuf)

def svn_txdelta_run(*args) -> "svn_checksum_t **":
    """svn_txdelta_run(svn_stream_t * source, svn_stream_t * target, svn_txdelta_window_handler_t handler, void * handler_baton, svn_checksum_kind_t checksum_kind, svn_cancel_func_t cancel_func, apr_pool_t result_pool, apr_pool_t scratch_pool) -> svn_error_t"""
    return _delta.svn_txdelta_run(*args)

def svn_txdelta_stream_create(*args) -> "svn_txdelta_stream_t *":
    """svn_txdelta_stream_create(void * baton, svn_txdelta_next_window_fn_t next_window, svn_txdelta_md5_digest_fn_t md5_digest, apr_pool_t pool) -> svn_txdelta_stream_t *"""
    return _delta.svn_txdelta_stream_create(*args)

def svn_txdelta_next_window(*args) -> "svn_txdelta_window_t **":
    """svn_txdelta_next_window(svn_txdelta_stream_t * stream, apr_pool_t pool) -> svn_error_t"""
    return _delta.svn_txdelta_next_window(*args)

def svn_txdelta_md5_digest(stream: 'svn_txdelta_stream_t *') -> "unsigned char const *":
    """svn_txdelta_md5_digest(svn_txdelta_stream_t * stream) -> unsigned char const *"""
    return _delta.svn_txdelta_md5_digest(stream)

def svn_txdelta2(*args) -> "svn_txdelta_stream_t **":
    """svn_txdelta2(svn_stream_t * source, svn_stream_t * target, svn_boolean_t calculate_checksum, apr_pool_t pool)"""
    return _delta.svn_txdelta2(*args)

def svn_txdelta(*args) -> "svn_txdelta_stream_t **":
    """svn_txdelta(svn_stream_t * source, svn_stream_t * target, apr_pool_t pool)"""
    return _delta.svn_txdelta(*args)

def svn_txdelta_target_push(*args) -> "svn_stream_t *":
    """svn_txdelta_target_push(svn_txdelta_window_handler_t handler, void * handler_baton, svn_stream_t * source, apr_pool_t pool) -> svn_stream_t *"""
    return _delta.svn_txdelta_target_push(*args)

def svn_txdelta_send_string(*args) -> "svn_error_t *":
    """svn_txdelta_send_string(svn_string_t const * string, svn_txdelta_window_handler_t handler, void * handler_baton, apr_pool_t pool) -> svn_error_t"""
    return _delta.svn_txdelta_send_string(*args)

def svn_txdelta_send_stream(*args) -> "unsigned char *":
    """svn_txdelta_send_stream(svn_stream_t * stream, svn_txdelta_window_handler_t handler, void * handler_baton, apr_pool_t pool) -> svn_error_t"""
    return _delta.svn_txdelta_send_stream(*args)

def svn_txdelta_send_txstream(*args) -> "svn_error_t *":
    """svn_txdelta_send_txstream(svn_txdelta_stream_t * txstream, svn_txdelta_window_handler_t handler, void * handler_baton, apr_pool_t pool) -> svn_error_t"""
    return _delta.svn_txdelta_send_txstream(*args)

def svn_txdelta_send_contents(*args) -> "svn_error_t *":
    """svn_txdelta_send_contents(unsigned char const * contents, apr_size_t len, svn_txdelta_window_handler_t handler, void * handler_baton, apr_pool_t pool) -> svn_error_t"""
    return _delta.svn_txdelta_send_contents(*args)

def svn_txdelta_apply(*args) -> "svn_txdelta_window_handler_t *, void **":
    """svn_txdelta_apply(svn_stream_t * source, svn_stream_t * target, char const * error_info, apr_pool_t pool)"""
    return _delta.svn_txdelta_apply(*args)

def svn_txdelta_to_svndiff3(*args) -> "svn_txdelta_window_handler_t *, void **":
    """svn_txdelta_to_svndiff3(svn_stream_t * output, int svndiff_version, int compression_level, apr_pool_t pool)"""
    return _delta.svn_txdelta_to_svndiff3(*args)

def svn_txdelta_to_svndiff2(*args) -> "svn_txdelta_window_handler_t *, void **":
    """svn_txdelta_to_svndiff2(svn_stream_t * output, int svndiff_version, apr_pool_t pool)"""
    return _delta.svn_txdelta_to_svndiff2(*args)

def svn_txdelta_to_svndiff(*args) -> "svn_txdelta_window_handler_t *, void **":
    """svn_txdelta_to_svndiff(svn_stream_t * output, apr_pool_t pool)"""
    return _delta.svn_txdelta_to_svndiff(*args)

def svn_txdelta_to_svndiff_stream(*args) -> "svn_stream_t *":
    """svn_txdelta_to_svndiff_stream(svn_txdelta_stream_t * txstream, int svndiff_version, int compression_level, apr_pool_t pool) -> svn_stream_t *"""
    return _delta.svn_txdelta_to_svndiff_stream(*args)

def svn_txdelta_parse_svndiff(*args) -> "svn_stream_t *":
    """svn_txdelta_parse_svndiff(svn_txdelta_window_handler_t handler, void * handler_baton, svn_boolean_t error_on_early_close, apr_pool_t pool) -> svn_stream_t *"""
    return _delta.svn_txdelta_parse_svndiff(*args)

def svn_txdelta_read_svndiff_window(*args) -> "svn_txdelta_window_t **":
    """svn_txdelta_read_svndiff_window(svn_stream_t * stream, int svndiff_version, apr_pool_t pool) -> svn_error_t"""
    return _delta.svn_txdelta_read_svndiff_window(*args)

def svn_txdelta_skip_svndiff_window(*args) -> "svn_error_t *":
    """svn_txdelta_skip_svndiff_window(apr_file_t file, int svndiff_version, apr_pool_t pool) -> svn_error_t"""
    return _delta.svn_txdelta_skip_svndiff_window(*args)
class svn_delta_editor_t(object):
    """Proxy of C svn_delta_editor_t struct."""

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    set_target_revision = _swig_property(_delta.svn_delta_editor_t_set_target_revision_get, _delta.svn_delta_editor_t_set_target_revision_set)
    open_root = _swig_property(_delta.svn_delta_editor_t_open_root_get, _delta.svn_delta_editor_t_open_root_set)
    delete_entry = _swig_property(_delta.svn_delta_editor_t_delete_entry_get, _delta.svn_delta_editor_t_delete_entry_set)
    add_directory = _swig_property(_delta.svn_delta_editor_t_add_directory_get, _delta.svn_delta_editor_t_add_directory_set)
    open_directory = _swig_property(_delta.svn_delta_editor_t_open_directory_get, _delta.svn_delta_editor_t_open_directory_set)
    change_dir_prop = _swig_property(_delta.svn_delta_editor_t_change_dir_prop_get, _delta.svn_delta_editor_t_change_dir_prop_set)
    close_directory = _swig_property(_delta.svn_delta_editor_t_close_directory_get, _delta.svn_delta_editor_t_close_directory_set)
    absent_directory = _swig_property(_delta.svn_delta_editor_t_absent_directory_get, _delta.svn_delta_editor_t_absent_directory_set)
    add_file = _swig_property(_delta.svn_delta_editor_t_add_file_get, _delta.svn_delta_editor_t_add_file_set)
    open_file = _swig_property(_delta.svn_delta_editor_t_open_file_get, _delta.svn_delta_editor_t_open_file_set)
    apply_textdelta = _swig_property(_delta.svn_delta_editor_t_apply_textdelta_get, _delta.svn_delta_editor_t_apply_textdelta_set)
    change_file_prop = _swig_property(_delta.svn_delta_editor_t_change_file_prop_get, _delta.svn_delta_editor_t_change_file_prop_set)
    close_file = _swig_property(_delta.svn_delta_editor_t_close_file_get, _delta.svn_delta_editor_t_close_file_set)
    absent_file = _swig_property(_delta.svn_delta_editor_t_absent_file_get, _delta.svn_delta_editor_t_absent_file_set)
    close_edit = _swig_property(_delta.svn_delta_editor_t_close_edit_get, _delta.svn_delta_editor_t_close_edit_set)
    abort_edit = _swig_property(_delta.svn_delta_editor_t_abort_edit_get, _delta.svn_delta_editor_t_abort_edit_set)
    apply_textdelta_stream = _swig_property(_delta.svn_delta_editor_t_apply_textdelta_stream_get, _delta.svn_delta_editor_t_apply_textdelta_stream_set)
    def set_parent_pool(self, parent_pool=None):
      """Create a new proxy object for TYPE"""
      import libsvn.core, weakref
      self.__dict__["_parent_pool"] = \
        parent_pool or libsvn.core.application_pool;
      if self.__dict__["_parent_pool"]:
        self.__dict__["_is_valid"] = weakref.ref(
          self.__dict__["_parent_pool"]._is_valid)

    def assert_valid(self):
      """Assert that this object is using valid pool memory"""
      if "_is_valid" in self.__dict__:
        assert self.__dict__["_is_valid"](), "Variable has already been deleted"

    def _retrieve_swig_value(self, name, value):
    # If we got back a different object than we have cached, we need to copy
    # all our metadata into it, so that it looks identical to the one
    # originally set.
      members = self.__dict__.get('_members')
      if members is not None and name in members:
        _copy_metadata_deep(value, members[name])

    # Verify that the new object is good
      _assert_valid_deep(value)

      return value

    # Attribute access must be intercepted to ensure that objects coming from
    # read attribute access match those that are set with write attribute access.
    # Specifically the metadata, such as the associated apr_pool object, should
    # match the originally assigned object.
    #
    # For classic classes it is enough to use __getattr__ to intercept swig
    # derived attributes. However, with new style classes SWIG makes use of
    # descriptors which mean that __getattr__ is never called. Therefore,
    # __getattribute__ must be used for the interception.

    if _newclass:
      def __getattribute__(self, name):
        """Manage access to all attributes of this object."""

    # Start by mimicing __getattr__ behavior: immediately return __dict__ or
    # items directly present in __dict__
        mydict = object.__getattribute__(self, '__dict__')

        if name == "__dict__":
          return mydict

        if name in mydict:
          return mydict[name]

        object.__getattribute__(self, 'assert_valid')()

        value = _get_instance_attr(self, name)
        fn = object.__getattribute__(self, '_retrieve_swig_value')
        return fn(name, value)
    else:
      def __getattr__(self, name):
        """Get an attribute from this object"""
        self.assert_valid()

        value = _swig_getattr(self, self.__class__, name)

        return self._retrieve_swig_value(name, value)

    def __setattr__(self, name, value):
      """Set an attribute on this object"""
      self.assert_valid()

    # Save a copy of the object, so that the garbage
    # collector won't kill the object while it's in
    # SWIG-land
      self.__dict__.setdefault("_members",{})[name] = value

      return _set_instance_attr(self, name, value)


    def set_target_revision(self, *args):
      return svn_delta_editor_invoke_set_target_revision(self, *args)


    def open_root(self, *args):
      return svn_delta_editor_invoke_open_root(self, *args)


    def delete_entry(self, *args):
      return svn_delta_editor_invoke_delete_entry(self, *args)


    def add_directory(self, *args):
      return svn_delta_editor_invoke_add_directory(self, *args)


    def open_directory(self, *args):
      return svn_delta_editor_invoke_open_directory(self, *args)


    def change_dir_prop(self, *args):
      return svn_delta_editor_invoke_change_dir_prop(self, *args)


    def close_directory(self, *args):
      return svn_delta_editor_invoke_close_directory(self, *args)


    def absent_directory(self, *args):
      return svn_delta_editor_invoke_absent_directory(self, *args)


    def add_file(self, *args):
      return svn_delta_editor_invoke_add_file(self, *args)


    def open_file(self, *args):
      return svn_delta_editor_invoke_open_file(self, *args)


    def apply_textdelta(self, *args):
      return svn_delta_editor_invoke_apply_textdelta(self, *args)


    def change_file_prop(self, *args):
      return svn_delta_editor_invoke_change_file_prop(self, *args)


    def close_file(self, *args):
      return svn_delta_editor_invoke_close_file(self, *args)


    def absent_file(self, *args):
      return svn_delta_editor_invoke_absent_file(self, *args)


    def close_edit(self, *args):
      return svn_delta_editor_invoke_close_edit(self, *args)


    def abort_edit(self, *args):
      return svn_delta_editor_invoke_abort_edit(self, *args)


    def apply_textdelta_stream(self, *args):
      return svn_delta_editor_invoke_apply_textdelta_stream(self, *args)


    def __init__(self):
        """__init__(svn_delta_editor_t self) -> svn_delta_editor_t"""
        this = _delta.new_svn_delta_editor_t()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _delta.delete_svn_delta_editor_t
    __del__ = lambda self: None
svn_delta_editor_t_swigregister = _delta.svn_delta_editor_t_swigregister
svn_delta_editor_t_swigregister(svn_delta_editor_t)


def svn_delta_default_editor(*args) -> "svn_delta_editor_t *":
    """svn_delta_default_editor(apr_pool_t pool) -> svn_delta_editor_t"""
    return _delta.svn_delta_default_editor(*args)

def svn_delta_noop_window_handler(window: 'svn_txdelta_window_t', baton: 'void *') -> "svn_error_t *":
    """svn_delta_noop_window_handler(svn_txdelta_window_t window, void * baton) -> svn_error_t"""
    return _delta.svn_delta_noop_window_handler(window, baton)

def svn_delta_get_cancellation_editor(*args) -> "svn_delta_editor_t const **, void **":
    """svn_delta_get_cancellation_editor(svn_cancel_func_t cancel_func, svn_delta_editor_t wrapped_editor, void * wrapped_baton, apr_pool_t pool) -> svn_error_t"""
    return _delta.svn_delta_get_cancellation_editor(*args)

def svn_delta_depth_filter_editor(*args) -> "svn_delta_editor_t const **, void **":
    """svn_delta_depth_filter_editor(svn_delta_editor_t wrapped_editor, void * wrapped_edit_baton, svn_depth_t requested_depth, svn_boolean_t has_target, apr_pool_t pool) -> svn_error_t"""
    return _delta.svn_delta_depth_filter_editor(*args)

def svn_delta_path_driver3(*args) -> "svn_error_t *":
    """svn_delta_path_driver3(svn_delta_editor_t editor, void * edit_baton, apr_array_header_t relpaths, svn_boolean_t sort_paths, svn_delta_path_driver_cb_func2_t callback_func, void * callback_baton, apr_pool_t pool) -> svn_error_t"""
    return _delta.svn_delta_path_driver3(*args)

def svn_delta_path_driver2(*args) -> "svn_error_t *":
    """svn_delta_path_driver2(svn_delta_editor_t editor, void * edit_baton, apr_array_header_t paths, svn_boolean_t sort_paths, svn_delta_path_driver_cb_func_t callback_func, apr_pool_t scratch_pool) -> svn_error_t"""
    return _delta.svn_delta_path_driver2(*args)

def svn_delta_path_driver(*args) -> "svn_error_t *":
    """svn_delta_path_driver(svn_delta_editor_t editor, void * edit_baton, svn_revnum_t revision, apr_array_header_t paths, svn_delta_path_driver_cb_func_t callback_func, apr_pool_t scratch_pool) -> svn_error_t"""
    return _delta.svn_delta_path_driver(*args)

def svn_delta_path_driver_start(*args) -> "SWIGTYPE **":
    """svn_delta_path_driver_start(svn_delta_editor_t editor, void * edit_baton, svn_delta_path_driver_cb_func2_t callback_func, void * callback_baton, apr_pool_t result_pool) -> svn_error_t"""
    return _delta.svn_delta_path_driver_start(*args)

def svn_delta_path_driver_step(*args) -> "svn_error_t *":
    """svn_delta_path_driver_step(svn_delta_path_driver_state_t * state, char const * relpath, apr_pool_t scratch_pool) -> svn_error_t"""
    return _delta.svn_delta_path_driver_step(*args)

def svn_delta_path_driver_finish(*args) -> "svn_error_t *":
    """svn_delta_path_driver_finish(svn_delta_path_driver_state_t * state, apr_pool_t scratch_pool) -> svn_error_t"""
    return _delta.svn_delta_path_driver_finish(*args)

def svn_compat_wrap_file_rev_handler(*args) -> "svn_file_rev_handler_t *, void **":
    """svn_compat_wrap_file_rev_handler(svn_file_rev_handler_old_t handler, void * handler_baton, apr_pool_t pool)"""
    return _delta.svn_compat_wrap_file_rev_handler(*args)
class svn_txdelta_stream_t(object):
    """Proxy of C svn_txdelta_stream_t struct."""

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    def set_parent_pool(self, parent_pool=None):
      """Create a new proxy object for TYPE"""
      import libsvn.core, weakref
      self.__dict__["_parent_pool"] = \
        parent_pool or libsvn.core.application_pool;
      if self.__dict__["_parent_pool"]:
        self.__dict__["_is_valid"] = weakref.ref(
          self.__dict__["_parent_pool"]._is_valid)

    def assert_valid(self):
      """Assert that this object is using valid pool memory"""
      if "_is_valid" in self.__dict__:
        assert self.__dict__["_is_valid"](), "Variable has already been deleted"

    def _retrieve_swig_value(self, name, value):
    # If we got back a different object than we have cached, we need to copy
    # all our metadata into it, so that it looks identical to the one
    # originally set.
      members = self.__dict__.get('_members')
      if members is not None and name in members:
        _copy_metadata_deep(value, members[name])

    # Verify that the new object is good
      _assert_valid_deep(value)

      return value

    # Attribute access must be intercepted to ensure that objects coming from
    # read attribute access match those that are set with write attribute access.
    # Specifically the metadata, such as the associated apr_pool object, should
    # match the originally assigned object.
    #
    # For classic classes it is enough to use __getattr__ to intercept swig
    # derived attributes. However, with new style classes SWIG makes use of
    # descriptors which mean that __getattr__ is never called. Therefore,
    # __getattribute__ must be used for the interception.

    if _newclass:
      def __getattribute__(self, name):
        """Manage access to all attributes of this object."""

    # Start by mimicing __getattr__ behavior: immediately return __dict__ or
    # items directly present in __dict__
        mydict = object.__getattribute__(self, '__dict__')

        if name == "__dict__":
          return mydict

        if name in mydict:
          return mydict[name]

        object.__getattribute__(self, 'assert_valid')()

        value = _get_instance_attr(self, name)
        fn = object.__getattribute__(self, '_retrieve_swig_value')
        return fn(name, value)
    else:
      def __getattr__(self, name):
        """Get an attribute from this object"""
        self.assert_valid()

        value = _swig_getattr(self, self.__class__, name)

        return self._retrieve_swig_value(name, value)

    def __setattr__(self, name, value):
      """Set an attribute on this object"""
      self.assert_valid()

    # Save a copy of the object, so that the garbage
    # collector won't kill the object while it's in
    # SWIG-land
      self.__dict__.setdefault("_members",{})[name] = value

      return _set_instance_attr(self, name, value)

svn_txdelta_stream_t_swigregister = _delta.svn_txdelta_stream_t_swigregister
svn_txdelta_stream_t_swigregister(svn_txdelta_stream_t)

class svn_delta_path_driver_state_t(object):
    """Proxy of C svn_delta_path_driver_state_t struct."""

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    def set_parent_pool(self, parent_pool=None):
      """Create a new proxy object for TYPE"""
      import libsvn.core, weakref
      self.__dict__["_parent_pool"] = \
        parent_pool or libsvn.core.application_pool;
      if self.__dict__["_parent_pool"]:
        self.__dict__["_is_valid"] = weakref.ref(
          self.__dict__["_parent_pool"]._is_valid)

    def assert_valid(self):
      """Assert that this object is using valid pool memory"""
      if "_is_valid" in self.__dict__:
        assert self.__dict__["_is_valid"](), "Variable has already been deleted"

    def _retrieve_swig_value(self, name, value):
    # If we got back a different object than we have cached, we need to copy
    # all our metadata into it, so that it looks identical to the one
    # originally set.
      members = self.__dict__.get('_members')
      if members is not None and name in members:
        _copy_metadata_deep(value, members[name])

    # Verify that the new object is good
      _assert_valid_deep(value)

      return value

    # Attribute access must be intercepted to ensure that objects coming from
    # read attribute access match those that are set with write attribute access.
    # Specifically the metadata, such as the associated apr_pool object, should
    # match the originally assigned object.
    #
    # For classic classes it is enough to use __getattr__ to intercept swig
    # derived attributes. However, with new style classes SWIG makes use of
    # descriptors which mean that __getattr__ is never called. Therefore,
    # __getattribute__ must be used for the interception.

    if _newclass:
      def __getattribute__(self, name):
        """Manage access to all attributes of this object."""

    # Start by mimicing __getattr__ behavior: immediately return __dict__ or
    # items directly present in __dict__
        mydict = object.__getattribute__(self, '__dict__')

        if name == "__dict__":
          return mydict

        if name in mydict:
          return mydict[name]

        object.__getattribute__(self, 'assert_valid')()

        value = _get_instance_attr(self, name)
        fn = object.__getattribute__(self, '_retrieve_swig_value')
        return fn(name, value)
    else:
      def __getattr__(self, name):
        """Get an attribute from this object"""
        self.assert_valid()

        value = _swig_getattr(self, self.__class__, name)

        return self._retrieve_swig_value(name, value)

    def __setattr__(self, name, value):
      """Set an attribute on this object"""
      self.assert_valid()

    # Save a copy of the object, so that the garbage
    # collector won't kill the object while it's in
    # SWIG-land
      self.__dict__.setdefault("_members",{})[name] = value

      return _set_instance_attr(self, name, value)

svn_delta_path_driver_state_t_swigregister = _delta.svn_delta_path_driver_state_t_swigregister
svn_delta_path_driver_state_t_swigregister(svn_delta_path_driver_state_t)


def svn_delta_editor_invoke_set_target_revision(*args) -> "svn_error_t *":
    """svn_delta_editor_invoke_set_target_revision(svn_delta_editor_t _obj, void * edit_baton, svn_revnum_t target_revision, apr_pool_t scratch_pool) -> svn_error_t"""
    return _delta.svn_delta_editor_invoke_set_target_revision(*args)

def svn_delta_editor_invoke_open_root(*args) -> "void **":
    """svn_delta_editor_invoke_open_root(svn_delta_editor_t _obj, void * edit_baton, svn_revnum_t base_revision, apr_pool_t result_pool) -> svn_error_t"""
    return _delta.svn_delta_editor_invoke_open_root(*args)

def svn_delta_editor_invoke_delete_entry(*args) -> "svn_error_t *":
    """svn_delta_editor_invoke_delete_entry(svn_delta_editor_t _obj, char const * path, svn_revnum_t revision, void * parent_baton, apr_pool_t scratch_pool) -> svn_error_t"""
    return _delta.svn_delta_editor_invoke_delete_entry(*args)

def svn_delta_editor_invoke_add_directory(*args) -> "void **":
    """svn_delta_editor_invoke_add_directory(svn_delta_editor_t _obj, char const * path, void * parent_baton, char const * copyfrom_path, svn_revnum_t copyfrom_revision, apr_pool_t result_pool) -> svn_error_t"""
    return _delta.svn_delta_editor_invoke_add_directory(*args)

def svn_delta_editor_invoke_open_directory(*args) -> "void **":
    """svn_delta_editor_invoke_open_directory(svn_delta_editor_t _obj, char const * path, void * parent_baton, svn_revnum_t base_revision, apr_pool_t result_pool) -> svn_error_t"""
    return _delta.svn_delta_editor_invoke_open_directory(*args)

def svn_delta_editor_invoke_change_dir_prop(*args) -> "svn_error_t *":
    """svn_delta_editor_invoke_change_dir_prop(svn_delta_editor_t _obj, void * dir_baton, char const * name, svn_string_t const * value, apr_pool_t scratch_pool) -> svn_error_t"""
    return _delta.svn_delta_editor_invoke_change_dir_prop(*args)

def svn_delta_editor_invoke_close_directory(*args) -> "svn_error_t *":
    """svn_delta_editor_invoke_close_directory(svn_delta_editor_t _obj, void * dir_baton, apr_pool_t scratch_pool) -> svn_error_t"""
    return _delta.svn_delta_editor_invoke_close_directory(*args)

def svn_delta_editor_invoke_absent_directory(*args) -> "svn_error_t *":
    """svn_delta_editor_invoke_absent_directory(svn_delta_editor_t _obj, char const * path, void * parent_baton, apr_pool_t scratch_pool) -> svn_error_t"""
    return _delta.svn_delta_editor_invoke_absent_directory(*args)

def svn_delta_editor_invoke_add_file(*args) -> "void **":
    """svn_delta_editor_invoke_add_file(svn_delta_editor_t _obj, char const * path, void * parent_baton, char const * copyfrom_path, svn_revnum_t copyfrom_revision, apr_pool_t result_pool) -> svn_error_t"""
    return _delta.svn_delta_editor_invoke_add_file(*args)

def svn_delta_editor_invoke_open_file(*args) -> "void **":
    """svn_delta_editor_invoke_open_file(svn_delta_editor_t _obj, char const * path, void * parent_baton, svn_revnum_t base_revision, apr_pool_t result_pool) -> svn_error_t"""
    return _delta.svn_delta_editor_invoke_open_file(*args)

def svn_delta_editor_invoke_apply_textdelta(*args) -> "svn_txdelta_window_handler_t *, void **":
    """svn_delta_editor_invoke_apply_textdelta(svn_delta_editor_t _obj, void * file_baton, char const * base_checksum, apr_pool_t result_pool) -> svn_error_t"""
    return _delta.svn_delta_editor_invoke_apply_textdelta(*args)

def svn_delta_editor_invoke_change_file_prop(*args) -> "svn_error_t *":
    """svn_delta_editor_invoke_change_file_prop(svn_delta_editor_t _obj, void * file_baton, char const * name, svn_string_t const * value, apr_pool_t scratch_pool) -> svn_error_t"""
    return _delta.svn_delta_editor_invoke_change_file_prop(*args)

def svn_delta_editor_invoke_close_file(*args) -> "svn_error_t *":
    """svn_delta_editor_invoke_close_file(svn_delta_editor_t _obj, void * file_baton, char const * text_checksum, apr_pool_t scratch_pool) -> svn_error_t"""
    return _delta.svn_delta_editor_invoke_close_file(*args)

def svn_delta_editor_invoke_absent_file(*args) -> "svn_error_t *":
    """svn_delta_editor_invoke_absent_file(svn_delta_editor_t _obj, char const * path, void * parent_baton, apr_pool_t scratch_pool) -> svn_error_t"""
    return _delta.svn_delta_editor_invoke_absent_file(*args)

def svn_delta_editor_invoke_close_edit(*args) -> "svn_error_t *":
    """svn_delta_editor_invoke_close_edit(svn_delta_editor_t _obj, void * edit_baton, apr_pool_t scratch_pool) -> svn_error_t"""
    return _delta.svn_delta_editor_invoke_close_edit(*args)

def svn_delta_editor_invoke_abort_edit(*args) -> "svn_error_t *":
    """svn_delta_editor_invoke_abort_edit(svn_delta_editor_t _obj, void * edit_baton, apr_pool_t scratch_pool) -> svn_error_t"""
    return _delta.svn_delta_editor_invoke_abort_edit(*args)

def svn_delta_editor_invoke_apply_textdelta_stream(*args) -> "svn_error_t *":
    """svn_delta_editor_invoke_apply_textdelta_stream(svn_delta_editor_t _obj, svn_delta_editor_t editor, void * file_baton, char const * base_checksum, svn_txdelta_stream_open_func_t open_func, void * open_baton, apr_pool_t scratch_pool) -> svn_error_t"""
    return _delta.svn_delta_editor_invoke_apply_textdelta_stream(*args)

def svn_txdelta_invoke_window_handler(_obj: 'svn_txdelta_window_handler_t', window: 'svn_txdelta_window_t', baton: 'void *') -> "svn_error_t *":
    """svn_txdelta_invoke_window_handler(svn_txdelta_window_handler_t _obj, svn_txdelta_window_t window, void * baton) -> svn_error_t"""
    return _delta.svn_txdelta_invoke_window_handler(_obj, window, baton)

def svn_txdelta_invoke_next_window_fn(*args) -> "svn_txdelta_window_t **":
    """svn_txdelta_invoke_next_window_fn(svn_txdelta_next_window_fn_t _obj, void * baton, apr_pool_t pool) -> svn_error_t"""
    return _delta.svn_txdelta_invoke_next_window_fn(*args)

def svn_txdelta_invoke_md5_digest_fn(_obj: 'svn_txdelta_md5_digest_fn_t', baton: 'void *') -> "unsigned char const *":
    """svn_txdelta_invoke_md5_digest_fn(svn_txdelta_md5_digest_fn_t _obj, void * baton) -> unsigned char const *"""
    return _delta.svn_txdelta_invoke_md5_digest_fn(_obj, baton)

def svn_txdelta_invoke_stream_open_func(*args) -> "svn_txdelta_stream_t **":
    """svn_txdelta_invoke_stream_open_func(svn_txdelta_stream_open_func_t _obj, void * baton, apr_pool_t result_pool, apr_pool_t scratch_pool) -> svn_error_t"""
    return _delta.svn_txdelta_invoke_stream_open_func(*args)

def svn_delta_invoke_path_driver_cb_func2(*args) -> "void **":
    """svn_delta_invoke_path_driver_cb_func2(svn_delta_path_driver_cb_func2_t _obj, svn_delta_editor_t editor, void * edit_baton, void * parent_baton, void * callback_baton, char const * relpath, apr_pool_t pool) -> svn_error_t"""
    return _delta.svn_delta_invoke_path_driver_cb_func2(*args)

def svn_delta_invoke_path_driver_cb_func(*args) -> "void **":
    """svn_delta_invoke_path_driver_cb_func(svn_delta_path_driver_cb_func_t _obj, void * parent_baton, void * callback_baton, char const * path, apr_pool_t pool) -> svn_error_t"""
    return _delta.svn_delta_invoke_path_driver_cb_func(*args)

def svn_file_invoke_rev_handler(*args) -> "svn_txdelta_window_handler_t *, void **":
    """svn_file_invoke_rev_handler(svn_file_rev_handler_t _obj, void * baton, char const * path, svn_revnum_t rev, apr_hash_t rev_props, svn_boolean_t result_of_merge, apr_array_header_t prop_diffs, apr_pool_t pool) -> svn_error_t"""
    return _delta.svn_file_invoke_rev_handler(*args)

def svn_file_invoke_rev_handler_old(*args) -> "svn_txdelta_window_handler_t *, void **":
    """svn_file_invoke_rev_handler_old(svn_file_rev_handler_old_t _obj, void * baton, char const * path, svn_revnum_t rev, apr_hash_t rev_props, apr_array_header_t prop_diffs, apr_pool_t pool) -> svn_error_t"""
    return _delta.svn_file_invoke_rev_handler_old(*args)
class svn_txdelta_window_handler_t(object):
    """Proxy of C svn_txdelta_window_handler_t struct."""

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    def set_parent_pool(self, parent_pool=None):
      """Create a new proxy object for TYPE"""
      import libsvn.core, weakref
      self.__dict__["_parent_pool"] = \
        parent_pool or libsvn.core.application_pool;
      if self.__dict__["_parent_pool"]:
        self.__dict__["_is_valid"] = weakref.ref(
          self.__dict__["_parent_pool"]._is_valid)

    def assert_valid(self):
      """Assert that this object is using valid pool memory"""
      if "_is_valid" in self.__dict__:
        assert self.__dict__["_is_valid"](), "Variable has already been deleted"

    def _retrieve_swig_value(self, name, value):
    # If we got back a different object than we have cached, we need to copy
    # all our metadata into it, so that it looks identical to the one
    # originally set.
      members = self.__dict__.get('_members')
      if members is not None and name in members:
        _copy_metadata_deep(value, members[name])

    # Verify that the new object is good
      _assert_valid_deep(value)

      return value

    # Attribute access must be intercepted to ensure that objects coming from
    # read attribute access match those that are set with write attribute access.
    # Specifically the metadata, such as the associated apr_pool object, should
    # match the originally assigned object.
    #
    # For classic classes it is enough to use __getattr__ to intercept swig
    # derived attributes. However, with new style classes SWIG makes use of
    # descriptors which mean that __getattr__ is never called. Therefore,
    # __getattribute__ must be used for the interception.

    if _newclass:
      def __getattribute__(self, name):
        """Manage access to all attributes of this object."""

    # Start by mimicing __getattr__ behavior: immediately return __dict__ or
    # items directly present in __dict__
        mydict = object.__getattribute__(self, '__dict__')

        if name == "__dict__":
          return mydict

        if name in mydict:
          return mydict[name]

        object.__getattribute__(self, 'assert_valid')()

        value = _get_instance_attr(self, name)
        fn = object.__getattribute__(self, '_retrieve_swig_value')
        return fn(name, value)
    else:
      def __getattr__(self, name):
        """Get an attribute from this object"""
        self.assert_valid()

        value = _swig_getattr(self, self.__class__, name)

        return self._retrieve_swig_value(name, value)

    def __setattr__(self, name, value):
      """Set an attribute on this object"""
      self.assert_valid()

    # Save a copy of the object, so that the garbage
    # collector won't kill the object while it's in
    # SWIG-land
      self.__dict__.setdefault("_members",{})[name] = value

      return _set_instance_attr(self, name, value)


    def __call__(self, *args):
      return svn_txdelta_invoke_window_handler(self, *args)

svn_txdelta_window_handler_t_swigregister = _delta.svn_txdelta_window_handler_t_swigregister
svn_txdelta_window_handler_t_swigregister(svn_txdelta_window_handler_t)

class svn_txdelta_next_window_fn_t(object):
    """Proxy of C svn_txdelta_next_window_fn_t struct."""

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    def set_parent_pool(self, parent_pool=None):
      """Create a new proxy object for TYPE"""
      import libsvn.core, weakref
      self.__dict__["_parent_pool"] = \
        parent_pool or libsvn.core.application_pool;
      if self.__dict__["_parent_pool"]:
        self.__dict__["_is_valid"] = weakref.ref(
          self.__dict__["_parent_pool"]._is_valid)

    def assert_valid(self):
      """Assert that this object is using valid pool memory"""
      if "_is_valid" in self.__dict__:
        assert self.__dict__["_is_valid"](), "Variable has already been deleted"

    def _retrieve_swig_value(self, name, value):
    # If we got back a different object than we have cached, we need to copy
    # all our metadata into it, so that it looks identical to the one
    # originally set.
      members = self.__dict__.get('_members')
      if members is not None and name in members:
        _copy_metadata_deep(value, members[name])

    # Verify that the new object is good
      _assert_valid_deep(value)

      return value

    # Attribute access must be intercepted to ensure that objects coming from
    # read attribute access match those that are set with write attribute access.
    # Specifically the metadata, such as the associated apr_pool object, should
    # match the originally assigned object.
    #
    # For classic classes it is enough to use __getattr__ to intercept swig
    # derived attributes. However, with new style classes SWIG makes use of
    # descriptors which mean that __getattr__ is never called. Therefore,
    # __getattribute__ must be used for the interception.

    if _newclass:
      def __getattribute__(self, name):
        """Manage access to all attributes of this object."""

    # Start by mimicing __getattr__ behavior: immediately return __dict__ or
    # items directly present in __dict__
        mydict = object.__getattribute__(self, '__dict__')

        if name == "__dict__":
          return mydict

        if name in mydict:
          return mydict[name]

        object.__getattribute__(self, 'assert_valid')()

        value = _get_instance_attr(self, name)
        fn = object.__getattribute__(self, '_retrieve_swig_value')
        return fn(name, value)
    else:
      def __getattr__(self, name):
        """Get an attribute from this object"""
        self.assert_valid()

        value = _swig_getattr(self, self.__class__, name)

        return self._retrieve_swig_value(name, value)

    def __setattr__(self, name, value):
      """Set an attribute on this object"""
      self.assert_valid()

    # Save a copy of the object, so that the garbage
    # collector won't kill the object while it's in
    # SWIG-land
      self.__dict__.setdefault("_members",{})[name] = value

      return _set_instance_attr(self, name, value)


    def __call__(self, *args):
      return svn_txdelta_invoke_next_window_fn(self, *args)

svn_txdelta_next_window_fn_t_swigregister = _delta.svn_txdelta_next_window_fn_t_swigregister
svn_txdelta_next_window_fn_t_swigregister(svn_txdelta_next_window_fn_t)

class svn_txdelta_md5_digest_fn_t(object):
    """Proxy of C svn_txdelta_md5_digest_fn_t struct."""

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    def set_parent_pool(self, parent_pool=None):
      """Create a new proxy object for TYPE"""
      import libsvn.core, weakref
      self.__dict__["_parent_pool"] = \
        parent_pool or libsvn.core.application_pool;
      if self.__dict__["_parent_pool"]:
        self.__dict__["_is_valid"] = weakref.ref(
          self.__dict__["_parent_pool"]._is_valid)

    def assert_valid(self):
      """Assert that this object is using valid pool memory"""
      if "_is_valid" in self.__dict__:
        assert self.__dict__["_is_valid"](), "Variable has already been deleted"

    def _retrieve_swig_value(self, name, value):
    # If we got back a different object than we have cached, we need to copy
    # all our metadata into it, so that it looks identical to the one
    # originally set.
      members = self.__dict__.get('_members')
      if members is not None and name in members:
        _copy_metadata_deep(value, members[name])

    # Verify that the new object is good
      _assert_valid_deep(value)

      return value

    # Attribute access must be intercepted to ensure that objects coming from
    # read attribute access match those that are set with write attribute access.
    # Specifically the metadata, such as the associated apr_pool object, should
    # match the originally assigned object.
    #
    # For classic classes it is enough to use __getattr__ to intercept swig
    # derived attributes. However, with new style classes SWIG makes use of
    # descriptors which mean that __getattr__ is never called. Therefore,
    # __getattribute__ must be used for the interception.

    if _newclass:
      def __getattribute__(self, name):
        """Manage access to all attributes of this object."""

    # Start by mimicing __getattr__ behavior: immediately return __dict__ or
    # items directly present in __dict__
        mydict = object.__getattribute__(self, '__dict__')

        if name == "__dict__":
          return mydict

        if name in mydict:
          return mydict[name]

        object.__getattribute__(self, 'assert_valid')()

        value = _get_instance_attr(self, name)
        fn = object.__getattribute__(self, '_retrieve_swig_value')
        return fn(name, value)
    else:
      def __getattr__(self, name):
        """Get an attribute from this object"""
        self.assert_valid()

        value = _swig_getattr(self, self.__class__, name)

        return self._retrieve_swig_value(name, value)

    def __setattr__(self, name, value):
      """Set an attribute on this object"""
      self.assert_valid()

    # Save a copy of the object, so that the garbage
    # collector won't kill the object while it's in
    # SWIG-land
      self.__dict__.setdefault("_members",{})[name] = value

      return _set_instance_attr(self, name, value)


    def __call__(self, *args):
      return svn_txdelta_invoke_md5_digest_fn(self, *args)

svn_txdelta_md5_digest_fn_t_swigregister = _delta.svn_txdelta_md5_digest_fn_t_swigregister
svn_txdelta_md5_digest_fn_t_swigregister(svn_txdelta_md5_digest_fn_t)

class svn_txdelta_stream_open_func_t(object):
    """Proxy of C svn_txdelta_stream_open_func_t struct."""

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    def set_parent_pool(self, parent_pool=None):
      """Create a new proxy object for TYPE"""
      import libsvn.core, weakref
      self.__dict__["_parent_pool"] = \
        parent_pool or libsvn.core.application_pool;
      if self.__dict__["_parent_pool"]:
        self.__dict__["_is_valid"] = weakref.ref(
          self.__dict__["_parent_pool"]._is_valid)

    def assert_valid(self):
      """Assert that this object is using valid pool memory"""
      if "_is_valid" in self.__dict__:
        assert self.__dict__["_is_valid"](), "Variable has already been deleted"

    def _retrieve_swig_value(self, name, value):
    # If we got back a different object than we have cached, we need to copy
    # all our metadata into it, so that it looks identical to the one
    # originally set.
      members = self.__dict__.get('_members')
      if members is not None and name in members:
        _copy_metadata_deep(value, members[name])

    # Verify that the new object is good
      _assert_valid_deep(value)

      return value

    # Attribute access must be intercepted to ensure that objects coming from
    # read attribute access match those that are set with write attribute access.
    # Specifically the metadata, such as the associated apr_pool object, should
    # match the originally assigned object.
    #
    # For classic classes it is enough to use __getattr__ to intercept swig
    # derived attributes. However, with new style classes SWIG makes use of
    # descriptors which mean that __getattr__ is never called. Therefore,
    # __getattribute__ must be used for the interception.

    if _newclass:
      def __getattribute__(self, name):
        """Manage access to all attributes of this object."""

    # Start by mimicing __getattr__ behavior: immediately return __dict__ or
    # items directly present in __dict__
        mydict = object.__getattribute__(self, '__dict__')

        if name == "__dict__":
          return mydict

        if name in mydict:
          return mydict[name]

        object.__getattribute__(self, 'assert_valid')()

        value = _get_instance_attr(self, name)
        fn = object.__getattribute__(self, '_retrieve_swig_value')
        return fn(name, value)
    else:
      def __getattr__(self, name):
        """Get an attribute from this object"""
        self.assert_valid()

        value = _swig_getattr(self, self.__class__, name)

        return self._retrieve_swig_value(name, value)

    def __setattr__(self, name, value):
      """Set an attribute on this object"""
      self.assert_valid()

    # Save a copy of the object, so that the garbage
    # collector won't kill the object while it's in
    # SWIG-land
      self.__dict__.setdefault("_members",{})[name] = value

      return _set_instance_attr(self, name, value)


    def __call__(self, *args):
      return svn_txdelta_invoke_stream_open_func(self, *args)

svn_txdelta_stream_open_func_t_swigregister = _delta.svn_txdelta_stream_open_func_t_swigregister
svn_txdelta_stream_open_func_t_swigregister(svn_txdelta_stream_open_func_t)

class svn_delta_path_driver_cb_func2_t(object):
    """Proxy of C svn_delta_path_driver_cb_func2_t struct."""

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    def set_parent_pool(self, parent_pool=None):
      """Create a new proxy object for TYPE"""
      import libsvn.core, weakref
      self.__dict__["_parent_pool"] = \
        parent_pool or libsvn.core.application_pool;
      if self.__dict__["_parent_pool"]:
        self.__dict__["_is_valid"] = weakref.ref(
          self.__dict__["_parent_pool"]._is_valid)

    def assert_valid(self):
      """Assert that this object is using valid pool memory"""
      if "_is_valid" in self.__dict__:
        assert self.__dict__["_is_valid"](), "Variable has already been deleted"

    def _retrieve_swig_value(self, name, value):
    # If we got back a different object than we have cached, we need to copy
    # all our metadata into it, so that it looks identical to the one
    # originally set.
      members = self.__dict__.get('_members')
      if members is not None and name in members:
        _copy_metadata_deep(value, members[name])

    # Verify that the new object is good
      _assert_valid_deep(value)

      return value

    # Attribute access must be intercepted to ensure that objects coming from
    # read attribute access match those that are set with write attribute access.
    # Specifically the metadata, such as the associated apr_pool object, should
    # match the originally assigned object.
    #
    # For classic classes it is enough to use __getattr__ to intercept swig
    # derived attributes. However, with new style classes SWIG makes use of
    # descriptors which mean that __getattr__ is never called. Therefore,
    # __getattribute__ must be used for the interception.

    if _newclass:
      def __getattribute__(self, name):
        """Manage access to all attributes of this object."""

    # Start by mimicing __getattr__ behavior: immediately return __dict__ or
    # items directly present in __dict__
        mydict = object.__getattribute__(self, '__dict__')

        if name == "__dict__":
          return mydict

        if name in mydict:
          return mydict[name]

        object.__getattribute__(self, 'assert_valid')()

        value = _get_instance_attr(self, name)
        fn = object.__getattribute__(self, '_retrieve_swig_value')
        return fn(name, value)
    else:
      def __getattr__(self, name):
        """Get an attribute from this object"""
        self.assert_valid()

        value = _swig_getattr(self, self.__class__, name)

        return self._retrieve_swig_value(name, value)

    def __setattr__(self, name, value):
      """Set an attribute on this object"""
      self.assert_valid()

    # Save a copy of the object, so that the garbage
    # collector won't kill the object while it's in
    # SWIG-land
      self.__dict__.setdefault("_members",{})[name] = value

      return _set_instance_attr(self, name, value)


    def __call__(self, *args):
      return svn_delta_invoke_path_driver_cb_func2(self, *args)

svn_delta_path_driver_cb_func2_t_swigregister = _delta.svn_delta_path_driver_cb_func2_t_swigregister
svn_delta_path_driver_cb_func2_t_swigregister(svn_delta_path_driver_cb_func2_t)

class svn_delta_path_driver_cb_func_t(object):
    """Proxy of C svn_delta_path_driver_cb_func_t struct."""

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    def set_parent_pool(self, parent_pool=None):
      """Create a new proxy object for TYPE"""
      import libsvn.core, weakref
      self.__dict__["_parent_pool"] = \
        parent_pool or libsvn.core.application_pool;
      if self.__dict__["_parent_pool"]:
        self.__dict__["_is_valid"] = weakref.ref(
          self.__dict__["_parent_pool"]._is_valid)

    def assert_valid(self):
      """Assert that this object is using valid pool memory"""
      if "_is_valid" in self.__dict__:
        assert self.__dict__["_is_valid"](), "Variable has already been deleted"

    def _retrieve_swig_value(self, name, value):
    # If we got back a different object than we have cached, we need to copy
    # all our metadata into it, so that it looks identical to the one
    # originally set.
      members = self.__dict__.get('_members')
      if members is not None and name in members:
        _copy_metadata_deep(value, members[name])

    # Verify that the new object is good
      _assert_valid_deep(value)

      return value

    # Attribute access must be intercepted to ensure that objects coming from
    # read attribute access match those that are set with write attribute access.
    # Specifically the metadata, such as the associated apr_pool object, should
    # match the originally assigned object.
    #
    # For classic classes it is enough to use __getattr__ to intercept swig
    # derived attributes. However, with new style classes SWIG makes use of
    # descriptors which mean that __getattr__ is never called. Therefore,
    # __getattribute__ must be used for the interception.

    if _newclass:
      def __getattribute__(self, name):
        """Manage access to all attributes of this object."""

    # Start by mimicing __getattr__ behavior: immediately return __dict__ or
    # items directly present in __dict__
        mydict = object.__getattribute__(self, '__dict__')

        if name == "__dict__":
          return mydict

        if name in mydict:
          return mydict[name]

        object.__getattribute__(self, 'assert_valid')()

        value = _get_instance_attr(self, name)
        fn = object.__getattribute__(self, '_retrieve_swig_value')
        return fn(name, value)
    else:
      def __getattr__(self, name):
        """Get an attribute from this object"""
        self.assert_valid()

        value = _swig_getattr(self, self.__class__, name)

        return self._retrieve_swig_value(name, value)

    def __setattr__(self, name, value):
      """Set an attribute on this object"""
      self.assert_valid()

    # Save a copy of the object, so that the garbage
    # collector won't kill the object while it's in
    # SWIG-land
      self.__dict__.setdefault("_members",{})[name] = value

      return _set_instance_attr(self, name, value)


    def __call__(self, *args):
      return svn_delta_invoke_path_driver_cb_func(self, *args)

svn_delta_path_driver_cb_func_t_swigregister = _delta.svn_delta_path_driver_cb_func_t_swigregister
svn_delta_path_driver_cb_func_t_swigregister(svn_delta_path_driver_cb_func_t)

class svn_file_rev_handler_t(object):
    """Proxy of C svn_file_rev_handler_t struct."""

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    def set_parent_pool(self, parent_pool=None):
      """Create a new proxy object for TYPE"""
      import libsvn.core, weakref
      self.__dict__["_parent_pool"] = \
        parent_pool or libsvn.core.application_pool;
      if self.__dict__["_parent_pool"]:
        self.__dict__["_is_valid"] = weakref.ref(
          self.__dict__["_parent_pool"]._is_valid)

    def assert_valid(self):
      """Assert that this object is using valid pool memory"""
      if "_is_valid" in self.__dict__:
        assert self.__dict__["_is_valid"](), "Variable has already been deleted"

    def _retrieve_swig_value(self, name, value):
    # If we got back a different object than we have cached, we need to copy
    # all our metadata into it, so that it looks identical to the one
    # originally set.
      members = self.__dict__.get('_members')
      if members is not None and name in members:
        _copy_metadata_deep(value, members[name])

    # Verify that the new object is good
      _assert_valid_deep(value)

      return value

    # Attribute access must be intercepted to ensure that objects coming from
    # read attribute access match those that are set with write attribute access.
    # Specifically the metadata, such as the associated apr_pool object, should
    # match the originally assigned object.
    #
    # For classic classes it is enough to use __getattr__ to intercept swig
    # derived attributes. However, with new style classes SWIG makes use of
    # descriptors which mean that __getattr__ is never called. Therefore,
    # __getattribute__ must be used for the interception.

    if _newclass:
      def __getattribute__(self, name):
        """Manage access to all attributes of this object."""

    # Start by mimicing __getattr__ behavior: immediately return __dict__ or
    # items directly present in __dict__
        mydict = object.__getattribute__(self, '__dict__')

        if name == "__dict__":
          return mydict

        if name in mydict:
          return mydict[name]

        object.__getattribute__(self, 'assert_valid')()

        value = _get_instance_attr(self, name)
        fn = object.__getattribute__(self, '_retrieve_swig_value')
        return fn(name, value)
    else:
      def __getattr__(self, name):
        """Get an attribute from this object"""
        self.assert_valid()

        value = _swig_getattr(self, self.__class__, name)

        return self._retrieve_swig_value(name, value)

    def __setattr__(self, name, value):
      """Set an attribute on this object"""
      self.assert_valid()

    # Save a copy of the object, so that the garbage
    # collector won't kill the object while it's in
    # SWIG-land
      self.__dict__.setdefault("_members",{})[name] = value

      return _set_instance_attr(self, name, value)


    def __call__(self, *args):
      return svn_file_invoke_rev_handler(self, *args)

svn_file_rev_handler_t_swigregister = _delta.svn_file_rev_handler_t_swigregister
svn_file_rev_handler_t_swigregister(svn_file_rev_handler_t)

class svn_file_rev_handler_old_t(object):
    """Proxy of C svn_file_rev_handler_old_t struct."""

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    def set_parent_pool(self, parent_pool=None):
      """Create a new proxy object for TYPE"""
      import libsvn.core, weakref
      self.__dict__["_parent_pool"] = \
        parent_pool or libsvn.core.application_pool;
      if self.__dict__["_parent_pool"]:
        self.__dict__["_is_valid"] = weakref.ref(
          self.__dict__["_parent_pool"]._is_valid)

    def assert_valid(self):
      """Assert that this object is using valid pool memory"""
      if "_is_valid" in self.__dict__:
        assert self.__dict__["_is_valid"](), "Variable has already been deleted"

    def _retrieve_swig_value(self, name, value):
    # If we got back a different object than we have cached, we need to copy
    # all our metadata into it, so that it looks identical to the one
    # originally set.
      members = self.__dict__.get('_members')
      if members is not None and name in members:
        _copy_metadata_deep(value, members[name])

    # Verify that the new object is good
      _assert_valid_deep(value)

      return value

    # Attribute access must be intercepted to ensure that objects coming from
    # read attribute access match those that are set with write attribute access.
    # Specifically the metadata, such as the associated apr_pool object, should
    # match the originally assigned object.
    #
    # For classic classes it is enough to use __getattr__ to intercept swig
    # derived attributes. However, with new style classes SWIG makes use of
    # descriptors which mean that __getattr__ is never called. Therefore,
    # __getattribute__ must be used for the interception.

    if _newclass:
      def __getattribute__(self, name):
        """Manage access to all attributes of this object."""

    # Start by mimicing __getattr__ behavior: immediately return __dict__ or
    # items directly present in __dict__
        mydict = object.__getattribute__(self, '__dict__')

        if name == "__dict__":
          return mydict

        if name in mydict:
          return mydict[name]

        object.__getattribute__(self, 'assert_valid')()

        value = _get_instance_attr(self, name)
        fn = object.__getattribute__(self, '_retrieve_swig_value')
        return fn(name, value)
    else:
      def __getattr__(self, name):
        """Get an attribute from this object"""
        self.assert_valid()

        value = _swig_getattr(self, self.__class__, name)

        return self._retrieve_swig_value(name, value)

    def __setattr__(self, name, value):
      """Set an attribute on this object"""
      self.assert_valid()

    # Save a copy of the object, so that the garbage
    # collector won't kill the object while it's in
    # SWIG-land
      self.__dict__.setdefault("_members",{})[name] = value

      return _set_instance_attr(self, name, value)


    def __call__(self, *args):
      return svn_file_invoke_rev_handler_old(self, *args)

svn_file_rev_handler_old_t_swigregister = _delta.svn_file_rev_handler_old_t_swigregister
svn_file_rev_handler_old_t_swigregister(svn_file_rev_handler_old_t)


# This function is for backwards compatibility only.
# Use svn_txdelta_window_t.ops instead.
svn_txdelta_window_t_ops_get = svn_txdelta_window_t._ops_get



