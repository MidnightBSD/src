# This file was automatically generated by SWIG (http://www.swig.org).
# Version 3.0.12
#
# Do not make changes to this file unless you know what you are doing--modify
# the SWIG interface file instead.


def _dll_paths():
    import os
    if hasattr(os, 'add_dll_directory'):  # Python 3.8+ on Windows
        cookies = []
        for path in os.environ.get('PATH', '').split(os.pathsep):
            if path and os.path.isabs(path):
                try:
                    cookie = os.add_dll_directory(path)
                except OSError:
                    continue
                else:
                    cookies.append(cookie)
        return cookies
    else:
        return ()

_dll_paths = _dll_paths()
try:
    from . import _fs
finally:
    _dll_path = None
    for _dll_path in _dll_paths:
        _dll_path.close()
    del _dll_paths, _dll_path

try:
    _swig_property = property
except NameError:
    pass  # Python < 2.2 doesn't have 'property'.

try:
    import builtins as __builtin__
except ImportError:
    import __builtin__

def _swig_setattr_nondynamic(self, class_type, name, value, static=1):
    if (name == "thisown"):
        return self.this.own(value)
    if (name == "this"):
        if type(value).__name__ == 'SwigPyObject':
            self.__dict__[name] = value
            return
    method = class_type.__swig_setmethods__.get(name, None)
    if method:
        return method(self, value)
    if (not static):
        object.__setattr__(self, name, value)
    else:
        raise AttributeError("You cannot add attributes to %s" % self)


def _swig_setattr(self, class_type, name, value):
    return _swig_setattr_nondynamic(self, class_type, name, value, 0)


def _swig_getattr(self, class_type, name):
    if (name == "thisown"):
        return self.this.own()
    method = class_type.__swig_getmethods__.get(name, None)
    if method:
        return method(self)
    raise AttributeError("'%s' object has no attribute '%s'" % (class_type.__name__, name))


def _swig_repr(self):
    try:
        strthis = "proxy of " + self.this.__repr__()
    except __builtin__.Exception:
        strthis = ""
    return "<%s.%s; %s >" % (self.__class__.__module__, self.__class__.__name__, strthis,)


def _swig_setattr_nondynamic_method(set):
    def set_attr(self, name, value):
        if (name == "thisown"):
            return self.this.own(value)
        if hasattr(self, name) or (name == "this"):
            set(self, name, value)
        else:
            raise AttributeError("You cannot add attributes to %s" % self)
    return set_attr



def _copy_metadata_deep(value, old_value):
  """Copy all attributes of old_value into value, recursively traversing
  lists and dicts if needed."""
  if value is None or old_value is None or value is old_value: return

  if isinstance(value, dict):
    for k in value:
      _copy_metadata_deep(value[k], old_value[k])
  elif isinstance(value, list):
    for v, old_v in zip(value, old_value):
      _copy_metadata_deep(v, old_v)
  else:
    try:
      value.__dict__.update(old_value.__dict__)
    except AttributeError:
      pass

def _assert_valid_deep(value):
  """Assert value's validity, recursively traversing lists and dicts."""
  if isinstance(value, dict):
    for k in value:
      _assert_valid_deep(value[k])
  elif isinstance(value, list):
    for v in value:
      _assert_valid_deep(v)
# Ensure that the passed in value isn't a type, which could have an
# assert_valid attribute, but it can not be called without an instance.
  elif type(value) != type:
    try:
      fn = value.assert_valid
    except AttributeError:
      pass
    else:
      fn()



  # SWIG classes generated with -modern do not define this variable
try:
  _newclass
except NameError:
  _newclass = 1
else:
  raise RuntimeError("Require -modern option, but _newclass is defined")

_get_instance_attr = object.__getattribute__
_set_instance_attr = _swig_setattr_nondynamic_method(object.__setattr__)


import libsvn.core
import libsvn.delta

def svn_fs_version() -> "svn_version_t const *":
    """svn_fs_version() -> svn_version_t const *"""
    return _fs.svn_fs_version()
SVN_FS_TYPE_BDB = _fs.SVN_FS_TYPE_BDB
SVN_FS_TYPE_FSFS = _fs.SVN_FS_TYPE_FSFS
SVN_FS_TYPE_FSX = _fs.SVN_FS_TYPE_FSX
SVN_FS_CONFIG_BDB_TXN_NOSYNC = _fs.SVN_FS_CONFIG_BDB_TXN_NOSYNC
SVN_FS_CONFIG_BDB_LOG_AUTOREMOVE = _fs.SVN_FS_CONFIG_BDB_LOG_AUTOREMOVE
SVN_FS_CONFIG_FSFS_CACHE_DELTAS = _fs.SVN_FS_CONFIG_FSFS_CACHE_DELTAS
SVN_FS_CONFIG_FSFS_CACHE_FULLTEXTS = _fs.SVN_FS_CONFIG_FSFS_CACHE_FULLTEXTS
SVN_FS_CONFIG_FSFS_CACHE_REVPROPS = _fs.SVN_FS_CONFIG_FSFS_CACHE_REVPROPS
SVN_FS_CONFIG_FSFS_CACHE_NS = _fs.SVN_FS_CONFIG_FSFS_CACHE_NS
SVN_FS_CONFIG_FSFS_CACHE_NODEPROPS = _fs.SVN_FS_CONFIG_FSFS_CACHE_NODEPROPS
SVN_FS_CONFIG_FSFS_BLOCK_READ = _fs.SVN_FS_CONFIG_FSFS_BLOCK_READ
SVN_FS_CONFIG_FSFS_SHARD_SIZE = _fs.SVN_FS_CONFIG_FSFS_SHARD_SIZE
SVN_FS_CONFIG_FSFS_LOG_ADDRESSING = _fs.SVN_FS_CONFIG_FSFS_LOG_ADDRESSING
SVN_FS_CONFIG_FS_TYPE = _fs.SVN_FS_CONFIG_FS_TYPE
SVN_FS_CONFIG_PRE_1_4_COMPATIBLE = _fs.SVN_FS_CONFIG_PRE_1_4_COMPATIBLE
SVN_FS_CONFIG_PRE_1_5_COMPATIBLE = _fs.SVN_FS_CONFIG_PRE_1_5_COMPATIBLE
SVN_FS_CONFIG_PRE_1_6_COMPATIBLE = _fs.SVN_FS_CONFIG_PRE_1_6_COMPATIBLE
SVN_FS_CONFIG_PRE_1_8_COMPATIBLE = _fs.SVN_FS_CONFIG_PRE_1_8_COMPATIBLE
SVN_FS_CONFIG_COMPATIBLE_VERSION = _fs.SVN_FS_CONFIG_COMPATIBLE_VERSION
SVN_FS_CONFIG_NO_FLUSH_TO_DISK = _fs.SVN_FS_CONFIG_NO_FLUSH_TO_DISK

def svn_fs_initialize(*args) -> "svn_error_t *":
    """svn_fs_initialize(apr_pool_t pool) -> svn_error_t"""
    return _fs.svn_fs_initialize(*args)

def svn_fs_create2(*args) -> "svn_fs_t **":
    """svn_fs_create2(char const * path, apr_hash_t fs_config, apr_pool_t result_pool, apr_pool_t scratch_pool) -> svn_error_t"""
    return _fs.svn_fs_create2(*args)

def svn_fs_create(*args) -> "svn_fs_t **":
    """svn_fs_create(char const * path, apr_hash_t fs_config, apr_pool_t pool) -> svn_error_t"""
    return _fs.svn_fs_create(*args)

def svn_fs_open2(*args) -> "svn_fs_t **":
    """svn_fs_open2(char const * path, apr_hash_t fs_config, apr_pool_t result_pool, apr_pool_t scratch_pool) -> svn_error_t"""
    return _fs.svn_fs_open2(*args)

def svn_fs_open(*args) -> "svn_fs_t **":
    """svn_fs_open(char const * path, apr_hash_t fs_config, apr_pool_t pool) -> svn_error_t"""
    return _fs.svn_fs_open(*args)
svn_fs_upgrade_pack_revprops = _fs.svn_fs_upgrade_pack_revprops
svn_fs_upgrade_cleanup_revprops = _fs.svn_fs_upgrade_cleanup_revprops
svn_fs_upgrade_format_bumped = _fs.svn_fs_upgrade_format_bumped

def svn_fs_upgrade2(*args) -> "svn_error_t *":
    """svn_fs_upgrade2(char const * path, svn_fs_upgrade_notify_t notify_func, void * notify_baton, svn_cancel_func_t cancel_func, apr_pool_t scratch_pool) -> svn_error_t"""
    return _fs.svn_fs_upgrade2(*args)

def svn_fs_upgrade(*args) -> "svn_error_t *":
    """svn_fs_upgrade(char const * path, apr_pool_t pool) -> svn_error_t"""
    return _fs.svn_fs_upgrade(*args)

def svn_fs_type(*args) -> "char const **":
    """svn_fs_type(char const * path, apr_pool_t pool) -> svn_error_t"""
    return _fs.svn_fs_type(*args)

def svn_fs_path(*args) -> "char const *":
    """svn_fs_path(svn_fs_t * fs, apr_pool_t pool) -> char const *"""
    return _fs.svn_fs_path(*args)

def svn_fs_config(*args) -> "apr_hash_t *":
    """svn_fs_config(svn_fs_t * fs, apr_pool_t pool) -> apr_hash_t"""
    return _fs.svn_fs_config(*args)

def svn_fs_delete_fs(*args) -> "svn_error_t *":
    """svn_fs_delete_fs(char const * path, apr_pool_t pool) -> svn_error_t"""
    return _fs.svn_fs_delete_fs(*args)

def svn_fs_hotcopy3(*args) -> "svn_error_t *":
    """svn_fs_hotcopy3(char const * src_path, char const * dest_path, svn_boolean_t clean, svn_boolean_t incremental, svn_fs_hotcopy_notify_t notify_func, void * notify_baton, svn_cancel_func_t cancel_func, apr_pool_t scratch_pool) -> svn_error_t"""
    return _fs.svn_fs_hotcopy3(*args)

def svn_fs_hotcopy2(*args) -> "svn_error_t *":
    """svn_fs_hotcopy2(char const * src_path, char const * dest_path, svn_boolean_t clean, svn_boolean_t incremental, svn_cancel_func_t cancel_func, apr_pool_t scratch_pool) -> svn_error_t"""
    return _fs.svn_fs_hotcopy2(*args)

def svn_fs_hotcopy(*args) -> "svn_error_t *":
    """svn_fs_hotcopy(char const * src_path, char const * dest_path, svn_boolean_t clean, apr_pool_t pool) -> svn_error_t"""
    return _fs.svn_fs_hotcopy(*args)

def svn_fs_recover(*args) -> "svn_error_t *":
    """svn_fs_recover(char const * path, svn_cancel_func_t cancel_func, apr_pool_t pool) -> svn_error_t"""
    return _fs.svn_fs_recover(*args)

def svn_fs_freeze(*args) -> "svn_error_t *":
    """svn_fs_freeze(svn_fs_t * fs, svn_fs_freeze_func_t freeze_func, apr_pool_t pool) -> svn_error_t"""
    return _fs.svn_fs_freeze(*args)

def svn_fs_berkeley_logfiles(*args) -> "apr_array_header_t **":
    """svn_fs_berkeley_logfiles(char const * path, svn_boolean_t only_unused, apr_pool_t pool) -> svn_error_t"""
    return _fs.svn_fs_berkeley_logfiles(*args)

def svn_fs_new(*args) -> "svn_fs_t *":
    """svn_fs_new(apr_hash_t fs_config, apr_pool_t pool) -> svn_fs_t *"""
    return _fs.svn_fs_new(*args)

def svn_fs_create_berkeley(fs: 'svn_fs_t *', path: 'char const *') -> "svn_error_t *":
    """svn_fs_create_berkeley(svn_fs_t * fs, char const * path) -> svn_error_t"""
    return _fs.svn_fs_create_berkeley(fs, path)

def svn_fs_open_berkeley(fs: 'svn_fs_t *', path: 'char const *') -> "svn_error_t *":
    """svn_fs_open_berkeley(svn_fs_t * fs, char const * path) -> svn_error_t"""
    return _fs.svn_fs_open_berkeley(fs, path)

def svn_fs_berkeley_path(*args) -> "char const *":
    """svn_fs_berkeley_path(svn_fs_t * fs, apr_pool_t pool) -> char const *"""
    return _fs.svn_fs_berkeley_path(*args)

def svn_fs_delete_berkeley(*args) -> "svn_error_t *":
    """svn_fs_delete_berkeley(char const * path, apr_pool_t pool) -> svn_error_t"""
    return _fs.svn_fs_delete_berkeley(*args)

def svn_fs_hotcopy_berkeley(*args) -> "svn_error_t *":
    """svn_fs_hotcopy_berkeley(char const * src_path, char const * dest_path, svn_boolean_t clean_logs, apr_pool_t pool) -> svn_error_t"""
    return _fs.svn_fs_hotcopy_berkeley(*args)

def svn_fs_berkeley_recover(*args) -> "svn_error_t *":
    """svn_fs_berkeley_recover(char const * path, apr_pool_t pool) -> svn_error_t"""
    return _fs.svn_fs_berkeley_recover(*args)

def svn_fs_create_access(*args) -> "svn_fs_access_t **":
    """svn_fs_create_access(char const * username, apr_pool_t pool) -> svn_error_t"""
    return _fs.svn_fs_create_access(*args)

def svn_fs_set_access(fs: 'svn_fs_t *', access_ctx: 'svn_fs_access_t *') -> "svn_error_t *":
    """svn_fs_set_access(svn_fs_t * fs, svn_fs_access_t * access_ctx) -> svn_error_t"""
    return _fs.svn_fs_set_access(fs, access_ctx)

def svn_fs_get_access(fs: 'svn_fs_t *') -> "svn_fs_access_t **":
    """svn_fs_get_access(svn_fs_t * fs) -> svn_error_t"""
    return _fs.svn_fs_get_access(fs)

def svn_fs_access_get_username(access_ctx: 'svn_fs_access_t *') -> "char const **":
    """svn_fs_access_get_username(svn_fs_access_t * access_ctx) -> svn_error_t"""
    return _fs.svn_fs_access_get_username(access_ctx)

def svn_fs_access_add_lock_token2(access_ctx: 'svn_fs_access_t *', path: 'char const *', token: 'char const *') -> "svn_error_t *":
    """svn_fs_access_add_lock_token2(svn_fs_access_t * access_ctx, char const * path, char const * token) -> svn_error_t"""
    return _fs.svn_fs_access_add_lock_token2(access_ctx, path, token)

def svn_fs_access_add_lock_token(access_ctx: 'svn_fs_access_t *', token: 'char const *') -> "svn_error_t *":
    """svn_fs_access_add_lock_token(svn_fs_access_t * access_ctx, char const * token) -> svn_error_t"""
    return _fs.svn_fs_access_add_lock_token(access_ctx, token)
svn_fs_node_unrelated = _fs.svn_fs_node_unrelated
svn_fs_node_unchanged = _fs.svn_fs_node_unchanged
svn_fs_node_common_ancestor = _fs.svn_fs_node_common_ancestor

def svn_fs_compare_ids(a: 'svn_fs_id_t const *', b: 'svn_fs_id_t const *') -> "int":
    """svn_fs_compare_ids(svn_fs_id_t const * a, svn_fs_id_t const * b) -> int"""
    return _fs.svn_fs_compare_ids(a, b)

def svn_fs_check_related(id1: 'svn_fs_id_t const *', id2: 'svn_fs_id_t const *') -> "svn_boolean_t":
    """svn_fs_check_related(svn_fs_id_t const * id1, svn_fs_id_t const * id2) -> svn_boolean_t"""
    return _fs.svn_fs_check_related(id1, id2)

def svn_fs_parse_id(*args) -> "svn_fs_id_t *":
    """svn_fs_parse_id(char const * data, apr_pool_t pool) -> svn_fs_id_t *"""
    return _fs.svn_fs_parse_id(*args)

def svn_fs_unparse_id(*args) -> "svn_string_t *":
    """svn_fs_unparse_id(svn_fs_id_t const * id, apr_pool_t pool) -> svn_string_t *"""
    return _fs.svn_fs_unparse_id(*args)
SVN_FS_TXN_CHECK_OOD = _fs.SVN_FS_TXN_CHECK_OOD
SVN_FS_TXN_CHECK_LOCKS = _fs.SVN_FS_TXN_CHECK_LOCKS
SVN_FS_TXN_CLIENT_DATE = _fs.SVN_FS_TXN_CLIENT_DATE

def svn_fs_begin_txn2(*args) -> "svn_fs_txn_t **":
    """svn_fs_begin_txn2(svn_fs_t * fs, svn_revnum_t rev, apr_uint32_t flags, apr_pool_t pool) -> svn_error_t"""
    return _fs.svn_fs_begin_txn2(*args)

def svn_fs_begin_txn(*args) -> "svn_fs_txn_t **":
    """svn_fs_begin_txn(svn_fs_t * fs, svn_revnum_t rev, apr_pool_t pool) -> svn_error_t"""
    return _fs.svn_fs_begin_txn(*args)

def svn_fs_commit_txn(*args) -> "svn_revnum_t *":
    """svn_fs_commit_txn(svn_fs_txn_t * txn, apr_pool_t pool) -> svn_error_t"""
    return _fs.svn_fs_commit_txn(*args)

def svn_fs_abort_txn(*args) -> "svn_error_t *":
    """svn_fs_abort_txn(svn_fs_txn_t * txn, apr_pool_t pool) -> svn_error_t"""
    return _fs.svn_fs_abort_txn(*args)

def svn_fs_purge_txn(*args) -> "svn_error_t *":
    """svn_fs_purge_txn(svn_fs_t * fs, char const * txn_id, apr_pool_t pool) -> svn_error_t"""
    return _fs.svn_fs_purge_txn(*args)

def svn_fs_txn_name(*args) -> "char const **":
    """svn_fs_txn_name(svn_fs_txn_t * txn, apr_pool_t pool) -> svn_error_t"""
    return _fs.svn_fs_txn_name(*args)

def svn_fs_txn_base_revision(txn: 'svn_fs_txn_t *') -> "svn_revnum_t":
    """svn_fs_txn_base_revision(svn_fs_txn_t * txn) -> svn_revnum_t"""
    return _fs.svn_fs_txn_base_revision(txn)

def svn_fs_open_txn(*args) -> "svn_fs_txn_t **":
    """svn_fs_open_txn(svn_fs_t * fs, char const * name, apr_pool_t pool) -> svn_error_t"""
    return _fs.svn_fs_open_txn(*args)

def svn_fs_list_transactions(*args) -> "apr_array_header_t **":
    """svn_fs_list_transactions(svn_fs_t * fs, apr_pool_t pool) -> svn_error_t"""
    return _fs.svn_fs_list_transactions(*args)

def svn_fs_txn_prop(*args) -> "svn_string_t **":
    """svn_fs_txn_prop(svn_fs_txn_t * txn, char const * propname, apr_pool_t pool) -> svn_error_t"""
    return _fs.svn_fs_txn_prop(*args)

def svn_fs_txn_proplist(*args) -> "apr_hash_t **":
    """svn_fs_txn_proplist(svn_fs_txn_t * txn, apr_pool_t pool) -> svn_error_t"""
    return _fs.svn_fs_txn_proplist(*args)

def svn_fs_change_txn_prop(*args) -> "svn_error_t *":
    """svn_fs_change_txn_prop(svn_fs_txn_t * txn, char const * name, svn_string_t const * value, apr_pool_t pool) -> svn_error_t"""
    return _fs.svn_fs_change_txn_prop(*args)

def svn_fs_change_txn_props(*args) -> "svn_error_t *":
    """svn_fs_change_txn_props(svn_fs_txn_t * txn, apr_array_header_t props, apr_pool_t pool) -> svn_error_t"""
    return _fs.svn_fs_change_txn_props(*args)

def svn_fs_revision_root(*args) -> "svn_fs_root_t **":
    """svn_fs_revision_root(svn_fs_t * fs, svn_revnum_t rev, apr_pool_t pool) -> svn_error_t"""
    return _fs.svn_fs_revision_root(*args)

def svn_fs_txn_root(*args) -> "svn_fs_root_t **":
    """svn_fs_txn_root(svn_fs_txn_t * txn, apr_pool_t pool) -> svn_error_t"""
    return _fs.svn_fs_txn_root(*args)

def svn_fs_close_root(root: 'svn_fs_root_t *') -> "void":
    """svn_fs_close_root(svn_fs_root_t * root)"""
    return _fs.svn_fs_close_root(root)

def svn_fs_root_fs(root: 'svn_fs_root_t *') -> "svn_fs_t *":
    """svn_fs_root_fs(svn_fs_root_t * root) -> svn_fs_t *"""
    return _fs.svn_fs_root_fs(root)

def svn_fs_is_txn_root(root: 'svn_fs_root_t *') -> "svn_boolean_t":
    """svn_fs_is_txn_root(svn_fs_root_t * root) -> svn_boolean_t"""
    return _fs.svn_fs_is_txn_root(root)

def svn_fs_is_revision_root(root: 'svn_fs_root_t *') -> "svn_boolean_t":
    """svn_fs_is_revision_root(svn_fs_root_t * root) -> svn_boolean_t"""
    return _fs.svn_fs_is_revision_root(root)

def svn_fs_txn_root_name(*args) -> "char const *":
    """svn_fs_txn_root_name(svn_fs_root_t * root, apr_pool_t pool) -> char const *"""
    return _fs.svn_fs_txn_root_name(*args)

def svn_fs_txn_root_base_revision(root: 'svn_fs_root_t *') -> "svn_revnum_t":
    """svn_fs_txn_root_base_revision(svn_fs_root_t * root) -> svn_revnum_t"""
    return _fs.svn_fs_txn_root_base_revision(root)

def svn_fs_revision_root_revision(root: 'svn_fs_root_t *') -> "svn_revnum_t":
    """svn_fs_revision_root_revision(svn_fs_root_t * root) -> svn_revnum_t"""
    return _fs.svn_fs_revision_root_revision(root)
svn_fs_path_change_modify = _fs.svn_fs_path_change_modify
svn_fs_path_change_add = _fs.svn_fs_path_change_add
svn_fs_path_change_delete = _fs.svn_fs_path_change_delete
svn_fs_path_change_replace = _fs.svn_fs_path_change_replace
svn_fs_path_change_reset = _fs.svn_fs_path_change_reset
class svn_fs_path_change3_t(object):
    """Proxy of C svn_fs_path_change3_t struct."""

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    path = _swig_property(_fs.svn_fs_path_change3_t_path_get, _fs.svn_fs_path_change3_t_path_set)
    change_kind = _swig_property(_fs.svn_fs_path_change3_t_change_kind_get, _fs.svn_fs_path_change3_t_change_kind_set)
    node_kind = _swig_property(_fs.svn_fs_path_change3_t_node_kind_get, _fs.svn_fs_path_change3_t_node_kind_set)
    text_mod = _swig_property(_fs.svn_fs_path_change3_t_text_mod_get, _fs.svn_fs_path_change3_t_text_mod_set)
    prop_mod = _swig_property(_fs.svn_fs_path_change3_t_prop_mod_get, _fs.svn_fs_path_change3_t_prop_mod_set)
    mergeinfo_mod = _swig_property(_fs.svn_fs_path_change3_t_mergeinfo_mod_get, _fs.svn_fs_path_change3_t_mergeinfo_mod_set)
    copyfrom_known = _swig_property(_fs.svn_fs_path_change3_t_copyfrom_known_get, _fs.svn_fs_path_change3_t_copyfrom_known_set)
    copyfrom_rev = _swig_property(_fs.svn_fs_path_change3_t_copyfrom_rev_get, _fs.svn_fs_path_change3_t_copyfrom_rev_set)
    copyfrom_path = _swig_property(_fs.svn_fs_path_change3_t_copyfrom_path_get, _fs.svn_fs_path_change3_t_copyfrom_path_set)
    def set_parent_pool(self, parent_pool=None):
      """Create a new proxy object for TYPE"""
      import libsvn.core, weakref
      self.__dict__["_parent_pool"] = \
        parent_pool or libsvn.core.application_pool;
      if self.__dict__["_parent_pool"]:
        self.__dict__["_is_valid"] = weakref.ref(
          self.__dict__["_parent_pool"]._is_valid)

    def assert_valid(self):
      """Assert that this object is using valid pool memory"""
      if "_is_valid" in self.__dict__:
        assert self.__dict__["_is_valid"](), "Variable has already been deleted"

    def _retrieve_swig_value(self, name, value):
    # If we got back a different object than we have cached, we need to copy
    # all our metadata into it, so that it looks identical to the one
    # originally set.
      members = self.__dict__.get('_members')
      if members is not None and name in members:
        _copy_metadata_deep(value, members[name])

    # Verify that the new object is good
      _assert_valid_deep(value)

      return value

    # Attribute access must be intercepted to ensure that objects coming from
    # read attribute access match those that are set with write attribute access.
    # Specifically the metadata, such as the associated apr_pool object, should
    # match the originally assigned object.
    #
    # For classic classes it is enough to use __getattr__ to intercept swig
    # derived attributes. However, with new style classes SWIG makes use of
    # descriptors which mean that __getattr__ is never called. Therefore,
    # __getattribute__ must be used for the interception.

    if _newclass:
      def __getattribute__(self, name):
        """Manage access to all attributes of this object."""

    # Start by mimicing __getattr__ behavior: immediately return __dict__ or
    # items directly present in __dict__
        mydict = object.__getattribute__(self, '__dict__')

        if name == "__dict__":
          return mydict

        if name in mydict:
          return mydict[name]

        object.__getattribute__(self, 'assert_valid')()

        value = _get_instance_attr(self, name)
        fn = object.__getattribute__(self, '_retrieve_swig_value')
        return fn(name, value)
    else:
      def __getattr__(self, name):
        """Get an attribute from this object"""
        self.assert_valid()

        value = _swig_getattr(self, self.__class__, name)

        return self._retrieve_swig_value(name, value)

    def __setattr__(self, name, value):
      """Set an attribute on this object"""
      self.assert_valid()

    # Save a copy of the object, so that the garbage
    # collector won't kill the object while it's in
    # SWIG-land
      self.__dict__.setdefault("_members",{})[name] = value

      return _set_instance_attr(self, name, value)

svn_fs_path_change3_t_swigregister = _fs.svn_fs_path_change3_t_swigregister
svn_fs_path_change3_t_swigregister(svn_fs_path_change3_t)

class svn_fs_path_change2_t(object):
    """Proxy of C svn_fs_path_change2_t struct."""

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    node_rev_id = _swig_property(_fs.svn_fs_path_change2_t_node_rev_id_get, _fs.svn_fs_path_change2_t_node_rev_id_set)
    change_kind = _swig_property(_fs.svn_fs_path_change2_t_change_kind_get, _fs.svn_fs_path_change2_t_change_kind_set)
    text_mod = _swig_property(_fs.svn_fs_path_change2_t_text_mod_get, _fs.svn_fs_path_change2_t_text_mod_set)
    prop_mod = _swig_property(_fs.svn_fs_path_change2_t_prop_mod_get, _fs.svn_fs_path_change2_t_prop_mod_set)
    node_kind = _swig_property(_fs.svn_fs_path_change2_t_node_kind_get, _fs.svn_fs_path_change2_t_node_kind_set)
    copyfrom_known = _swig_property(_fs.svn_fs_path_change2_t_copyfrom_known_get, _fs.svn_fs_path_change2_t_copyfrom_known_set)
    copyfrom_rev = _swig_property(_fs.svn_fs_path_change2_t_copyfrom_rev_get, _fs.svn_fs_path_change2_t_copyfrom_rev_set)
    copyfrom_path = _swig_property(_fs.svn_fs_path_change2_t_copyfrom_path_get, _fs.svn_fs_path_change2_t_copyfrom_path_set)
    mergeinfo_mod = _swig_property(_fs.svn_fs_path_change2_t_mergeinfo_mod_get, _fs.svn_fs_path_change2_t_mergeinfo_mod_set)
    def set_parent_pool(self, parent_pool=None):
      """Create a new proxy object for TYPE"""
      import libsvn.core, weakref
      self.__dict__["_parent_pool"] = \
        parent_pool or libsvn.core.application_pool;
      if self.__dict__["_parent_pool"]:
        self.__dict__["_is_valid"] = weakref.ref(
          self.__dict__["_parent_pool"]._is_valid)

    def assert_valid(self):
      """Assert that this object is using valid pool memory"""
      if "_is_valid" in self.__dict__:
        assert self.__dict__["_is_valid"](), "Variable has already been deleted"

    def _retrieve_swig_value(self, name, value):
    # If we got back a different object than we have cached, we need to copy
    # all our metadata into it, so that it looks identical to the one
    # originally set.
      members = self.__dict__.get('_members')
      if members is not None and name in members:
        _copy_metadata_deep(value, members[name])

    # Verify that the new object is good
      _assert_valid_deep(value)

      return value

    # Attribute access must be intercepted to ensure that objects coming from
    # read attribute access match those that are set with write attribute access.
    # Specifically the metadata, such as the associated apr_pool object, should
    # match the originally assigned object.
    #
    # For classic classes it is enough to use __getattr__ to intercept swig
    # derived attributes. However, with new style classes SWIG makes use of
    # descriptors which mean that __getattr__ is never called. Therefore,
    # __getattribute__ must be used for the interception.

    if _newclass:
      def __getattribute__(self, name):
        """Manage access to all attributes of this object."""

    # Start by mimicing __getattr__ behavior: immediately return __dict__ or
    # items directly present in __dict__
        mydict = object.__getattribute__(self, '__dict__')

        if name == "__dict__":
          return mydict

        if name in mydict:
          return mydict[name]

        object.__getattribute__(self, 'assert_valid')()

        value = _get_instance_attr(self, name)
        fn = object.__getattribute__(self, '_retrieve_swig_value')
        return fn(name, value)
    else:
      def __getattr__(self, name):
        """Get an attribute from this object"""
        self.assert_valid()

        value = _swig_getattr(self, self.__class__, name)

        return self._retrieve_swig_value(name, value)

    def __setattr__(self, name, value):
      """Set an attribute on this object"""
      self.assert_valid()

    # Save a copy of the object, so that the garbage
    # collector won't kill the object while it's in
    # SWIG-land
      self.__dict__.setdefault("_members",{})[name] = value

      return _set_instance_attr(self, name, value)

svn_fs_path_change2_t_swigregister = _fs.svn_fs_path_change2_t_swigregister
svn_fs_path_change2_t_swigregister(svn_fs_path_change2_t)

class svn_fs_path_change_t(object):
    """Proxy of C svn_fs_path_change_t struct."""

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    node_rev_id = _swig_property(_fs.svn_fs_path_change_t_node_rev_id_get, _fs.svn_fs_path_change_t_node_rev_id_set)
    change_kind = _swig_property(_fs.svn_fs_path_change_t_change_kind_get, _fs.svn_fs_path_change_t_change_kind_set)
    text_mod = _swig_property(_fs.svn_fs_path_change_t_text_mod_get, _fs.svn_fs_path_change_t_text_mod_set)
    prop_mod = _swig_property(_fs.svn_fs_path_change_t_prop_mod_get, _fs.svn_fs_path_change_t_prop_mod_set)
    def set_parent_pool(self, parent_pool=None):
      """Create a new proxy object for TYPE"""
      import libsvn.core, weakref
      self.__dict__["_parent_pool"] = \
        parent_pool or libsvn.core.application_pool;
      if self.__dict__["_parent_pool"]:
        self.__dict__["_is_valid"] = weakref.ref(
          self.__dict__["_parent_pool"]._is_valid)

    def assert_valid(self):
      """Assert that this object is using valid pool memory"""
      if "_is_valid" in self.__dict__:
        assert self.__dict__["_is_valid"](), "Variable has already been deleted"

    def _retrieve_swig_value(self, name, value):
    # If we got back a different object than we have cached, we need to copy
    # all our metadata into it, so that it looks identical to the one
    # originally set.
      members = self.__dict__.get('_members')
      if members is not None and name in members:
        _copy_metadata_deep(value, members[name])

    # Verify that the new object is good
      _assert_valid_deep(value)

      return value

    # Attribute access must be intercepted to ensure that objects coming from
    # read attribute access match those that are set with write attribute access.
    # Specifically the metadata, such as the associated apr_pool object, should
    # match the originally assigned object.
    #
    # For classic classes it is enough to use __getattr__ to intercept swig
    # derived attributes. However, with new style classes SWIG makes use of
    # descriptors which mean that __getattr__ is never called. Therefore,
    # __getattribute__ must be used for the interception.

    if _newclass:
      def __getattribute__(self, name):
        """Manage access to all attributes of this object."""

    # Start by mimicing __getattr__ behavior: immediately return __dict__ or
    # items directly present in __dict__
        mydict = object.__getattribute__(self, '__dict__')

        if name == "__dict__":
          return mydict

        if name in mydict:
          return mydict[name]

        object.__getattribute__(self, 'assert_valid')()

        value = _get_instance_attr(self, name)
        fn = object.__getattribute__(self, '_retrieve_swig_value')
        return fn(name, value)
    else:
      def __getattr__(self, name):
        """Get an attribute from this object"""
        self.assert_valid()

        value = _swig_getattr(self, self.__class__, name)

        return self._retrieve_swig_value(name, value)

    def __setattr__(self, name, value):
      """Set an attribute on this object"""
      self.assert_valid()

    # Save a copy of the object, so that the garbage
    # collector won't kill the object while it's in
    # SWIG-land
      self.__dict__.setdefault("_members",{})[name] = value

      return _set_instance_attr(self, name, value)

svn_fs_path_change_t_swigregister = _fs.svn_fs_path_change_t_swigregister
svn_fs_path_change_t_swigregister(svn_fs_path_change_t)


def svn_fs_path_change2_create(*args) -> "svn_fs_path_change2_t *":
    """svn_fs_path_change2_create(svn_fs_id_t const * node_rev_id, svn_fs_path_change_kind_t change_kind, apr_pool_t pool) -> svn_fs_path_change2_t"""
    return _fs.svn_fs_path_change2_create(*args)

def svn_fs_path_change3_create(*args) -> "svn_fs_path_change3_t *":
    """svn_fs_path_change3_create(svn_fs_path_change_kind_t change_kind, apr_pool_t result_pool) -> svn_fs_path_change3_t"""
    return _fs.svn_fs_path_change3_create(*args)

def svn_fs_path_change3_dup(*args) -> "svn_fs_path_change3_t *":
    """svn_fs_path_change3_dup(svn_fs_path_change3_t change, apr_pool_t result_pool) -> svn_fs_path_change3_t"""
    return _fs.svn_fs_path_change3_dup(*args)

def svn_fs_path_change_get(iterator: 'svn_fs_path_change_iterator_t *') -> "SWIGTYPE **":
    """svn_fs_path_change_get(svn_fs_path_change_iterator_t * iterator) -> svn_error_t"""
    return _fs.svn_fs_path_change_get(iterator)

def svn_fs_paths_changed3(*args) -> "SWIGTYPE **":
    """svn_fs_paths_changed3(svn_fs_root_t * root, apr_pool_t result_pool, apr_pool_t scratch_pool) -> svn_error_t"""
    return _fs.svn_fs_paths_changed3(*args)

def svn_fs_paths_changed2(*args) -> "apr_hash_t **":
    """svn_fs_paths_changed2(svn_fs_root_t * root, apr_pool_t pool) -> svn_error_t"""
    return _fs.svn_fs_paths_changed2(*args)

def svn_fs_paths_changed(*args) -> "apr_hash_t **":
    """svn_fs_paths_changed(svn_fs_root_t * root, apr_pool_t pool) -> svn_error_t"""
    return _fs.svn_fs_paths_changed(*args)

def svn_fs_check_path(*args) -> "svn_node_kind_t *":
    """svn_fs_check_path(svn_fs_root_t * root, char const * path, apr_pool_t pool) -> svn_error_t"""
    return _fs.svn_fs_check_path(*args)

def svn_fs_node_history2(*args) -> "svn_fs_history_t **":
    """svn_fs_node_history2(svn_fs_root_t * root, char const * path, apr_pool_t result_pool, apr_pool_t scratch_pool) -> svn_error_t"""
    return _fs.svn_fs_node_history2(*args)

def svn_fs_node_history(*args) -> "svn_fs_history_t **":
    """svn_fs_node_history(svn_fs_root_t * root, char const * path, apr_pool_t pool) -> svn_error_t"""
    return _fs.svn_fs_node_history(*args)

def svn_fs_history_prev2(*args) -> "svn_fs_history_t **":
    """svn_fs_history_prev2(svn_fs_history_t * history, svn_boolean_t cross_copies, apr_pool_t result_pool, apr_pool_t scratch_pool) -> svn_error_t"""
    return _fs.svn_fs_history_prev2(*args)

def svn_fs_history_prev(*args) -> "svn_fs_history_t **":
    """svn_fs_history_prev(svn_fs_history_t * history, svn_boolean_t cross_copies, apr_pool_t pool) -> svn_error_t"""
    return _fs.svn_fs_history_prev(*args)

def svn_fs_history_location(*args) -> "char const **, svn_revnum_t *":
    """svn_fs_history_location(svn_fs_history_t * history, apr_pool_t pool) -> svn_error_t"""
    return _fs.svn_fs_history_location(*args)

def svn_fs_is_dir(*args) -> "svn_boolean_t *":
    """svn_fs_is_dir(svn_fs_root_t * root, char const * path, apr_pool_t pool) -> svn_error_t"""
    return _fs.svn_fs_is_dir(*args)

def svn_fs_is_file(*args) -> "svn_boolean_t *":
    """svn_fs_is_file(svn_fs_root_t * root, char const * path, apr_pool_t pool) -> svn_error_t"""
    return _fs.svn_fs_is_file(*args)

def svn_fs_node_id(*args) -> "svn_fs_id_t **":
    """svn_fs_node_id(svn_fs_root_t * root, char const * path, apr_pool_t pool) -> svn_error_t"""
    return _fs.svn_fs_node_id(*args)

def svn_fs_node_relation(*args) -> "svn_error_t *":
    """svn_fs_node_relation(svn_fs_node_relation_t * relation, svn_fs_root_t * root_a, char const * path_a, svn_fs_root_t * root_b, char const * path_b, apr_pool_t scratch_pool) -> svn_error_t"""
    return _fs.svn_fs_node_relation(*args)

def svn_fs_node_created_rev(*args) -> "svn_revnum_t *":
    """svn_fs_node_created_rev(svn_fs_root_t * root, char const * path, apr_pool_t pool) -> svn_error_t"""
    return _fs.svn_fs_node_created_rev(*args)

def svn_fs_node_origin_rev(*args) -> "svn_revnum_t *":
    """svn_fs_node_origin_rev(svn_fs_root_t * root, char const * path, apr_pool_t pool) -> svn_error_t"""
    return _fs.svn_fs_node_origin_rev(*args)

def svn_fs_node_created_path(*args) -> "char const **":
    """svn_fs_node_created_path(svn_fs_root_t * root, char const * path, apr_pool_t pool) -> svn_error_t"""
    return _fs.svn_fs_node_created_path(*args)

def svn_fs_node_prop(*args) -> "svn_string_t **":
    """svn_fs_node_prop(svn_fs_root_t * root, char const * path, char const * propname, apr_pool_t pool) -> svn_error_t"""
    return _fs.svn_fs_node_prop(*args)

def svn_fs_node_proplist(*args) -> "apr_hash_t **":
    """svn_fs_node_proplist(svn_fs_root_t * root, char const * path, apr_pool_t pool) -> svn_error_t"""
    return _fs.svn_fs_node_proplist(*args)

def svn_fs_node_has_props(*args) -> "svn_boolean_t *":
    """svn_fs_node_has_props(svn_fs_root_t * root, char const * path, apr_pool_t scratch_pool) -> svn_error_t"""
    return _fs.svn_fs_node_has_props(*args)

def svn_fs_change_node_prop(*args) -> "svn_error_t *":
    """svn_fs_change_node_prop(svn_fs_root_t * root, char const * path, char const * name, svn_string_t const * value, apr_pool_t pool) -> svn_error_t"""
    return _fs.svn_fs_change_node_prop(*args)

def svn_fs_props_different(*args) -> "svn_boolean_t *":
    """svn_fs_props_different(svn_fs_root_t * root1, char const * path1, svn_fs_root_t * root2, char const * path2, apr_pool_t scratch_pool) -> svn_error_t"""
    return _fs.svn_fs_props_different(*args)

def svn_fs_props_changed(*args) -> "svn_boolean_t *":
    """svn_fs_props_changed(svn_fs_root_t * root1, char const * path1, svn_fs_root_t * root2, char const * path2, apr_pool_t pool) -> svn_error_t"""
    return _fs.svn_fs_props_changed(*args)

def svn_fs_copied_from(*args) -> "svn_revnum_t *, char const **":
    """svn_fs_copied_from(svn_fs_root_t * root, char const * path, apr_pool_t pool) -> svn_error_t"""
    return _fs.svn_fs_copied_from(*args)

def svn_fs_closest_copy(*args) -> "svn_fs_root_t **, char const **":
    """svn_fs_closest_copy(svn_fs_root_t * root, char const * path, apr_pool_t pool) -> svn_error_t"""
    return _fs.svn_fs_closest_copy(*args)

def svn_fs_get_mergeinfo3(*args) -> "svn_error_t *":
    """svn_fs_get_mergeinfo3(svn_fs_root_t * root, apr_array_header_t paths, svn_mergeinfo_inheritance_t inherit, svn_boolean_t include_descendants, svn_boolean_t adjust_inherited_mergeinfo, svn_fs_mergeinfo_receiver_t receiver, void * baton, apr_pool_t scratch_pool) -> svn_error_t"""
    return _fs.svn_fs_get_mergeinfo3(*args)

def svn_fs_get_mergeinfo2(*args) -> "apr_hash_t **":
    """svn_fs_get_mergeinfo2(svn_fs_root_t * root, apr_array_header_t paths, svn_mergeinfo_inheritance_t inherit, svn_boolean_t include_descendants, svn_boolean_t adjust_inherited_mergeinfo, apr_pool_t result_pool, apr_pool_t scratch_pool) -> svn_error_t"""
    return _fs.svn_fs_get_mergeinfo2(*args)

def svn_fs_get_mergeinfo(*args) -> "apr_hash_t **":
    """svn_fs_get_mergeinfo(svn_fs_root_t * root, apr_array_header_t paths, svn_mergeinfo_inheritance_t inherit, svn_boolean_t include_descendants, apr_pool_t pool) -> svn_error_t"""
    return _fs.svn_fs_get_mergeinfo(*args)

def svn_fs_merge(*args) -> "char const **":
    """svn_fs_merge(svn_fs_root_t * source_root, char const * source_path, svn_fs_root_t * target_root, char const * target_path, svn_fs_root_t * ancestor_root, char const * ancestor_path, apr_pool_t pool) -> svn_error_t"""
    return _fs.svn_fs_merge(*args)
class svn_fs_dirent_t(object):
    """Proxy of C svn_fs_dirent_t struct."""

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    name = _swig_property(_fs.svn_fs_dirent_t_name_get, _fs.svn_fs_dirent_t_name_set)
    id = _swig_property(_fs.svn_fs_dirent_t_id_get, _fs.svn_fs_dirent_t_id_set)
    kind = _swig_property(_fs.svn_fs_dirent_t_kind_get, _fs.svn_fs_dirent_t_kind_set)
    def set_parent_pool(self, parent_pool=None):
      """Create a new proxy object for TYPE"""
      import libsvn.core, weakref
      self.__dict__["_parent_pool"] = \
        parent_pool or libsvn.core.application_pool;
      if self.__dict__["_parent_pool"]:
        self.__dict__["_is_valid"] = weakref.ref(
          self.__dict__["_parent_pool"]._is_valid)

    def assert_valid(self):
      """Assert that this object is using valid pool memory"""
      if "_is_valid" in self.__dict__:
        assert self.__dict__["_is_valid"](), "Variable has already been deleted"

    def _retrieve_swig_value(self, name, value):
    # If we got back a different object than we have cached, we need to copy
    # all our metadata into it, so that it looks identical to the one
    # originally set.
      members = self.__dict__.get('_members')
      if members is not None and name in members:
        _copy_metadata_deep(value, members[name])

    # Verify that the new object is good
      _assert_valid_deep(value)

      return value

    # Attribute access must be intercepted to ensure that objects coming from
    # read attribute access match those that are set with write attribute access.
    # Specifically the metadata, such as the associated apr_pool object, should
    # match the originally assigned object.
    #
    # For classic classes it is enough to use __getattr__ to intercept swig
    # derived attributes. However, with new style classes SWIG makes use of
    # descriptors which mean that __getattr__ is never called. Therefore,
    # __getattribute__ must be used for the interception.

    if _newclass:
      def __getattribute__(self, name):
        """Manage access to all attributes of this object."""

    # Start by mimicing __getattr__ behavior: immediately return __dict__ or
    # items directly present in __dict__
        mydict = object.__getattribute__(self, '__dict__')

        if name == "__dict__":
          return mydict

        if name in mydict:
          return mydict[name]

        object.__getattribute__(self, 'assert_valid')()

        value = _get_instance_attr(self, name)
        fn = object.__getattribute__(self, '_retrieve_swig_value')
        return fn(name, value)
    else:
      def __getattr__(self, name):
        """Get an attribute from this object"""
        self.assert_valid()

        value = _swig_getattr(self, self.__class__, name)

        return self._retrieve_swig_value(name, value)

    def __setattr__(self, name, value):
      """Set an attribute on this object"""
      self.assert_valid()

    # Save a copy of the object, so that the garbage
    # collector won't kill the object while it's in
    # SWIG-land
      self.__dict__.setdefault("_members",{})[name] = value

      return _set_instance_attr(self, name, value)

svn_fs_dirent_t_swigregister = _fs.svn_fs_dirent_t_swigregister
svn_fs_dirent_t_swigregister(svn_fs_dirent_t)


def svn_fs_dir_entries(*args) -> "apr_hash_t **":
    """svn_fs_dir_entries(svn_fs_root_t * root, char const * path, apr_pool_t pool) -> svn_error_t"""
    return _fs.svn_fs_dir_entries(*args)

def svn_fs_dir_optimal_order(*args) -> "SWIGTYPE **":
    """svn_fs_dir_optimal_order(svn_fs_root_t * root, apr_hash_t entries, apr_pool_t result_pool, apr_pool_t scratch_pool) -> svn_error_t"""
    return _fs.svn_fs_dir_optimal_order(*args)

def svn_fs_make_dir(*args) -> "svn_error_t *":
    """svn_fs_make_dir(svn_fs_root_t * root, char const * path, apr_pool_t pool) -> svn_error_t"""
    return _fs.svn_fs_make_dir(*args)

def svn_fs_delete(*args) -> "svn_error_t *":
    """svn_fs_delete(svn_fs_root_t * root, char const * path, apr_pool_t pool) -> svn_error_t"""
    return _fs.svn_fs_delete(*args)

def svn_fs_copy(*args) -> "svn_error_t *":
    """svn_fs_copy(svn_fs_root_t * from_root, char const * from_path, svn_fs_root_t * to_root, char const * to_path, apr_pool_t pool) -> svn_error_t"""
    return _fs.svn_fs_copy(*args)

def svn_fs_revision_link(*args) -> "svn_error_t *":
    """svn_fs_revision_link(svn_fs_root_t * from_root, svn_fs_root_t * to_root, char const * path, apr_pool_t pool) -> svn_error_t"""
    return _fs.svn_fs_revision_link(*args)

def svn_fs_file_length(*args) -> "svn_filesize_t *":
    """svn_fs_file_length(svn_fs_root_t * root, char const * path, apr_pool_t pool) -> svn_error_t"""
    return _fs.svn_fs_file_length(*args)

def svn_fs_file_checksum(*args) -> "svn_checksum_t **":
    """svn_fs_file_checksum(svn_checksum_kind_t kind, svn_fs_root_t * root, char const * path, svn_boolean_t force, apr_pool_t pool) -> svn_error_t"""
    return _fs.svn_fs_file_checksum(*args)

def svn_fs_file_md5_checksum(*args) -> "unsigned char [ANY]":
    """svn_fs_file_md5_checksum(svn_fs_root_t * root, char const * path, apr_pool_t pool) -> svn_error_t"""
    return _fs.svn_fs_file_md5_checksum(*args)

def svn_fs_file_contents(*args) -> "svn_stream_t **":
    """svn_fs_file_contents(svn_fs_root_t * root, char const * path, apr_pool_t pool) -> svn_error_t"""
    return _fs.svn_fs_file_contents(*args)

def svn_fs_try_process_file_contents(*args) -> "svn_boolean_t *":
    """svn_fs_try_process_file_contents(svn_fs_root_t * root, char const * path, svn_fs_process_contents_func_t processor, void * baton, apr_pool_t pool) -> svn_error_t"""
    return _fs.svn_fs_try_process_file_contents(*args)

def svn_fs_make_file(*args) -> "svn_error_t *":
    """svn_fs_make_file(svn_fs_root_t * root, char const * path, apr_pool_t pool) -> svn_error_t"""
    return _fs.svn_fs_make_file(*args)

def svn_fs_apply_textdelta(*args) -> "svn_txdelta_window_handler_t *, void **":
    """svn_fs_apply_textdelta(svn_fs_root_t * root, char const * path, char const * base_checksum, char const * result_checksum, apr_pool_t pool) -> svn_error_t"""
    return _fs.svn_fs_apply_textdelta(*args)

def svn_fs_apply_text(*args) -> "svn_stream_t **":
    """svn_fs_apply_text(svn_fs_root_t * root, char const * path, char const * result_checksum, apr_pool_t pool) -> svn_error_t"""
    return _fs.svn_fs_apply_text(*args)

def svn_fs_contents_different(*args) -> "svn_boolean_t *":
    """svn_fs_contents_different(svn_fs_root_t * root1, char const * path1, svn_fs_root_t * root2, char const * path2, apr_pool_t scratch_pool) -> svn_error_t"""
    return _fs.svn_fs_contents_different(*args)

def svn_fs_contents_changed(*args) -> "svn_boolean_t *":
    """svn_fs_contents_changed(svn_fs_root_t * root1, char const * path1, svn_fs_root_t * root2, char const * path2, apr_pool_t pool) -> svn_error_t"""
    return _fs.svn_fs_contents_changed(*args)

def svn_fs_youngest_rev(*args) -> "svn_revnum_t *":
    """svn_fs_youngest_rev(svn_fs_t * fs, apr_pool_t pool) -> svn_error_t"""
    return _fs.svn_fs_youngest_rev(*args)

def svn_fs_info_format(*args) -> "int *, SWIGTYPE **":
    """svn_fs_info_format(svn_fs_t * fs, apr_pool_t result_pool, apr_pool_t scratch_pool) -> svn_error_t"""
    return _fs.svn_fs_info_format(*args)

def svn_fs_info_config_files(*args) -> "SWIGTYPE **":
    """svn_fs_info_config_files(svn_fs_t * fs, apr_pool_t result_pool, apr_pool_t scratch_pool) -> svn_error_t"""
    return _fs.svn_fs_info_config_files(*args)

def svn_fs_deltify_revision(*args) -> "svn_error_t *":
    """svn_fs_deltify_revision(svn_fs_t * fs, svn_revnum_t revision, apr_pool_t pool) -> svn_error_t"""
    return _fs.svn_fs_deltify_revision(*args)

def svn_fs_refresh_revision_props(*args) -> "svn_error_t *":
    """svn_fs_refresh_revision_props(svn_fs_t * fs, apr_pool_t scratch_pool) -> svn_error_t"""
    return _fs.svn_fs_refresh_revision_props(*args)

def svn_fs_revision_prop2(*args) -> "svn_string_t **":
    """svn_fs_revision_prop2(svn_fs_t * fs, svn_revnum_t rev, char const * propname, svn_boolean_t refresh, apr_pool_t result_pool, apr_pool_t scratch_pool) -> svn_error_t"""
    return _fs.svn_fs_revision_prop2(*args)

def svn_fs_revision_prop(*args) -> "svn_string_t **":
    """svn_fs_revision_prop(svn_fs_t * fs, svn_revnum_t rev, char const * propname, apr_pool_t pool) -> svn_error_t"""
    return _fs.svn_fs_revision_prop(*args)

def svn_fs_revision_proplist2(*args) -> "apr_hash_t **":
    """svn_fs_revision_proplist2(svn_fs_t * fs, svn_revnum_t rev, svn_boolean_t refresh, apr_pool_t result_pool, apr_pool_t scratch_pool) -> svn_error_t"""
    return _fs.svn_fs_revision_proplist2(*args)

def svn_fs_revision_proplist(*args) -> "apr_hash_t **":
    """svn_fs_revision_proplist(svn_fs_t * fs, svn_revnum_t rev, apr_pool_t pool) -> svn_error_t"""
    return _fs.svn_fs_revision_proplist(*args)

def svn_fs_change_rev_prop2(*args) -> "svn_string_t **":
    """svn_fs_change_rev_prop2(svn_fs_t * fs, svn_revnum_t rev, char const * name, svn_string_t const *const * old_value_p, svn_string_t const * value, apr_pool_t pool) -> svn_error_t"""
    return _fs.svn_fs_change_rev_prop2(*args)

def svn_fs_change_rev_prop(*args) -> "svn_error_t *":
    """svn_fs_change_rev_prop(svn_fs_t * fs, svn_revnum_t rev, char const * name, svn_string_t const * value, apr_pool_t pool) -> svn_error_t"""
    return _fs.svn_fs_change_rev_prop(*args)

def svn_fs_get_file_delta_stream(*args) -> "svn_txdelta_stream_t **":
    """svn_fs_get_file_delta_stream(svn_fs_root_t * source_root, char const * source_path, svn_fs_root_t * target_root, char const * target_path, apr_pool_t pool) -> svn_error_t"""
    return _fs.svn_fs_get_file_delta_stream(*args)

def svn_fs_get_uuid(*args) -> "char const **":
    """svn_fs_get_uuid(svn_fs_t * fs, apr_pool_t pool) -> svn_error_t"""
    return _fs.svn_fs_get_uuid(*args)

def svn_fs_set_uuid(*args) -> "svn_error_t *":
    """svn_fs_set_uuid(svn_fs_t * fs, char const * uuid, apr_pool_t pool) -> svn_error_t"""
    return _fs.svn_fs_set_uuid(*args)

def svn_fs_lock_target_create(*args) -> "svn_fs_lock_target_t *":
    """svn_fs_lock_target_create(char const * token, svn_revnum_t current_rev, apr_pool_t result_pool) -> svn_fs_lock_target_t *"""
    return _fs.svn_fs_lock_target_create(*args)

def svn_fs_lock_target_set_token(target: 'svn_fs_lock_target_t *', token: 'char const *') -> "void":
    """svn_fs_lock_target_set_token(svn_fs_lock_target_t * target, char const * token)"""
    return _fs.svn_fs_lock_target_set_token(target, token)

def svn_fs_lock_many(*args) -> "svn_error_t *":
    """svn_fs_lock_many(svn_fs_t * fs, apr_hash_t lock_targets, char const * comment, svn_boolean_t is_dav_comment, apr_time_t expiration_date, svn_boolean_t steal_lock, svn_fs_lock_callback_t lock_callback, apr_pool_t result_pool, apr_pool_t scratch_pool) -> svn_error_t"""
    return _fs.svn_fs_lock_many(*args)

def svn_fs_lock(*args) -> "svn_lock_t **":
    """svn_fs_lock(svn_fs_t * fs, char const * path, char const * token, char const * comment, svn_boolean_t is_dav_comment, apr_time_t expiration_date, svn_revnum_t current_rev, svn_boolean_t steal_lock, apr_pool_t pool) -> svn_error_t"""
    return _fs.svn_fs_lock(*args)

def svn_fs_generate_lock_token(*args) -> "char const **":
    """svn_fs_generate_lock_token(svn_fs_t * fs, apr_pool_t pool) -> svn_error_t"""
    return _fs.svn_fs_generate_lock_token(*args)

def svn_fs_unlock_many(*args) -> "svn_error_t *":
    """svn_fs_unlock_many(svn_fs_t * fs, apr_hash_t unlock_targets, svn_boolean_t break_lock, svn_fs_lock_callback_t lock_callback, apr_pool_t result_pool, apr_pool_t scratch_pool) -> svn_error_t"""
    return _fs.svn_fs_unlock_many(*args)

def svn_fs_unlock(*args) -> "svn_error_t *":
    """svn_fs_unlock(svn_fs_t * fs, char const * path, char const * token, svn_boolean_t break_lock, apr_pool_t pool) -> svn_error_t"""
    return _fs.svn_fs_unlock(*args)

def svn_fs_get_lock(*args) -> "svn_lock_t **":
    """svn_fs_get_lock(svn_fs_t * fs, char const * path, apr_pool_t pool) -> svn_error_t"""
    return _fs.svn_fs_get_lock(*args)

def svn_fs_get_locks2(*args) -> "svn_error_t *":
    """svn_fs_get_locks2(svn_fs_t * fs, char const * path, svn_depth_t depth, svn_fs_get_locks_callback_t get_locks_func, apr_pool_t pool) -> svn_error_t"""
    return _fs.svn_fs_get_locks2(*args)

def svn_fs_get_locks(*args) -> "svn_error_t *":
    """svn_fs_get_locks(svn_fs_t * fs, char const * path, svn_fs_get_locks_callback_t get_locks_func, apr_pool_t pool) -> svn_error_t"""
    return _fs.svn_fs_get_locks(*args)

def svn_fs_print_modules(*args) -> "svn_error_t *":
    """svn_fs_print_modules(svn_stringbuf_t * output, apr_pool_t pool) -> svn_error_t"""
    return _fs.svn_fs_print_modules(*args)
svn_fs_pack_notify_start = _fs.svn_fs_pack_notify_start
svn_fs_pack_notify_end = _fs.svn_fs_pack_notify_end
svn_fs_pack_notify_start_revprop = _fs.svn_fs_pack_notify_start_revprop
svn_fs_pack_notify_end_revprop = _fs.svn_fs_pack_notify_end_revprop
svn_fs_pack_notify_noop = _fs.svn_fs_pack_notify_noop

def svn_fs_pack(*args) -> "svn_error_t *":
    """svn_fs_pack(char const * db_path, svn_fs_pack_notify_t notify_func, void * notify_baton, svn_cancel_func_t cancel_func, apr_pool_t pool) -> svn_error_t"""
    return _fs.svn_fs_pack(*args)

def svn_fs_verify(*args) -> "svn_error_t *":
    """svn_fs_verify(char const * path, apr_hash_t fs_config, svn_revnum_t start, svn_revnum_t end, svn_fs_progress_notify_func_t notify_func, void * notify_baton, svn_cancel_func_t cancel_func, apr_pool_t scratch_pool) -> svn_error_t"""
    return _fs.svn_fs_verify(*args)

def svn_fs_verify_root(*args) -> "svn_error_t *":
    """svn_fs_verify_root(svn_fs_root_t * root, apr_pool_t scratch_pool) -> svn_error_t"""
    return _fs.svn_fs_verify_root(*args)
class svn_fs_fsfs_info_t(object):
    """Proxy of C svn_fs_fsfs_info_t struct."""

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    fs_type = _swig_property(_fs.svn_fs_fsfs_info_t_fs_type_get, _fs.svn_fs_fsfs_info_t_fs_type_set)
    shard_size = _swig_property(_fs.svn_fs_fsfs_info_t_shard_size_get, _fs.svn_fs_fsfs_info_t_shard_size_set)
    min_unpacked_rev = _swig_property(_fs.svn_fs_fsfs_info_t_min_unpacked_rev_get, _fs.svn_fs_fsfs_info_t_min_unpacked_rev_set)
    log_addressing = _swig_property(_fs.svn_fs_fsfs_info_t_log_addressing_get, _fs.svn_fs_fsfs_info_t_log_addressing_set)
    def set_parent_pool(self, parent_pool=None):
      """Create a new proxy object for TYPE"""
      import libsvn.core, weakref
      self.__dict__["_parent_pool"] = \
        parent_pool or libsvn.core.application_pool;
      if self.__dict__["_parent_pool"]:
        self.__dict__["_is_valid"] = weakref.ref(
          self.__dict__["_parent_pool"]._is_valid)

    def assert_valid(self):
      """Assert that this object is using valid pool memory"""
      if "_is_valid" in self.__dict__:
        assert self.__dict__["_is_valid"](), "Variable has already been deleted"

    def _retrieve_swig_value(self, name, value):
    # If we got back a different object than we have cached, we need to copy
    # all our metadata into it, so that it looks identical to the one
    # originally set.
      members = self.__dict__.get('_members')
      if members is not None and name in members:
        _copy_metadata_deep(value, members[name])

    # Verify that the new object is good
      _assert_valid_deep(value)

      return value

    # Attribute access must be intercepted to ensure that objects coming from
    # read attribute access match those that are set with write attribute access.
    # Specifically the metadata, such as the associated apr_pool object, should
    # match the originally assigned object.
    #
    # For classic classes it is enough to use __getattr__ to intercept swig
    # derived attributes. However, with new style classes SWIG makes use of
    # descriptors which mean that __getattr__ is never called. Therefore,
    # __getattribute__ must be used for the interception.

    if _newclass:
      def __getattribute__(self, name):
        """Manage access to all attributes of this object."""

    # Start by mimicing __getattr__ behavior: immediately return __dict__ or
    # items directly present in __dict__
        mydict = object.__getattribute__(self, '__dict__')

        if name == "__dict__":
          return mydict

        if name in mydict:
          return mydict[name]

        object.__getattribute__(self, 'assert_valid')()

        value = _get_instance_attr(self, name)
        fn = object.__getattribute__(self, '_retrieve_swig_value')
        return fn(name, value)
    else:
      def __getattr__(self, name):
        """Get an attribute from this object"""
        self.assert_valid()

        value = _swig_getattr(self, self.__class__, name)

        return self._retrieve_swig_value(name, value)

    def __setattr__(self, name, value):
      """Set an attribute on this object"""
      self.assert_valid()

    # Save a copy of the object, so that the garbage
    # collector won't kill the object while it's in
    # SWIG-land
      self.__dict__.setdefault("_members",{})[name] = value

      return _set_instance_attr(self, name, value)

svn_fs_fsfs_info_t_swigregister = _fs.svn_fs_fsfs_info_t_swigregister
svn_fs_fsfs_info_t_swigregister(svn_fs_fsfs_info_t)

class svn_fs_fsx_info_t(object):
    """Proxy of C svn_fs_fsx_info_t struct."""

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    fs_type = _swig_property(_fs.svn_fs_fsx_info_t_fs_type_get, _fs.svn_fs_fsx_info_t_fs_type_set)
    shard_size = _swig_property(_fs.svn_fs_fsx_info_t_shard_size_get, _fs.svn_fs_fsx_info_t_shard_size_set)
    min_unpacked_rev = _swig_property(_fs.svn_fs_fsx_info_t_min_unpacked_rev_get, _fs.svn_fs_fsx_info_t_min_unpacked_rev_set)
    def set_parent_pool(self, parent_pool=None):
      """Create a new proxy object for TYPE"""
      import libsvn.core, weakref
      self.__dict__["_parent_pool"] = \
        parent_pool or libsvn.core.application_pool;
      if self.__dict__["_parent_pool"]:
        self.__dict__["_is_valid"] = weakref.ref(
          self.__dict__["_parent_pool"]._is_valid)

    def assert_valid(self):
      """Assert that this object is using valid pool memory"""
      if "_is_valid" in self.__dict__:
        assert self.__dict__["_is_valid"](), "Variable has already been deleted"

    def _retrieve_swig_value(self, name, value):
    # If we got back a different object than we have cached, we need to copy
    # all our metadata into it, so that it looks identical to the one
    # originally set.
      members = self.__dict__.get('_members')
      if members is not None and name in members:
        _copy_metadata_deep(value, members[name])

    # Verify that the new object is good
      _assert_valid_deep(value)

      return value

    # Attribute access must be intercepted to ensure that objects coming from
    # read attribute access match those that are set with write attribute access.
    # Specifically the metadata, such as the associated apr_pool object, should
    # match the originally assigned object.
    #
    # For classic classes it is enough to use __getattr__ to intercept swig
    # derived attributes. However, with new style classes SWIG makes use of
    # descriptors which mean that __getattr__ is never called. Therefore,
    # __getattribute__ must be used for the interception.

    if _newclass:
      def __getattribute__(self, name):
        """Manage access to all attributes of this object."""

    # Start by mimicing __getattr__ behavior: immediately return __dict__ or
    # items directly present in __dict__
        mydict = object.__getattribute__(self, '__dict__')

        if name == "__dict__":
          return mydict

        if name in mydict:
          return mydict[name]

        object.__getattribute__(self, 'assert_valid')()

        value = _get_instance_attr(self, name)
        fn = object.__getattribute__(self, '_retrieve_swig_value')
        return fn(name, value)
    else:
      def __getattr__(self, name):
        """Get an attribute from this object"""
        self.assert_valid()

        value = _swig_getattr(self, self.__class__, name)

        return self._retrieve_swig_value(name, value)

    def __setattr__(self, name, value):
      """Set an attribute on this object"""
      self.assert_valid()

    # Save a copy of the object, so that the garbage
    # collector won't kill the object while it's in
    # SWIG-land
      self.__dict__.setdefault("_members",{})[name] = value

      return _set_instance_attr(self, name, value)

svn_fs_fsx_info_t_swigregister = _fs.svn_fs_fsx_info_t_swigregister
svn_fs_fsx_info_t_swigregister(svn_fs_fsx_info_t)

class svn_fs_info_placeholder_t(object):
    """Proxy of C svn_fs_info_placeholder_t struct."""

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    fs_type = _swig_property(_fs.svn_fs_info_placeholder_t_fs_type_get, _fs.svn_fs_info_placeholder_t_fs_type_set)
    def set_parent_pool(self, parent_pool=None):
      """Create a new proxy object for TYPE"""
      import libsvn.core, weakref
      self.__dict__["_parent_pool"] = \
        parent_pool or libsvn.core.application_pool;
      if self.__dict__["_parent_pool"]:
        self.__dict__["_is_valid"] = weakref.ref(
          self.__dict__["_parent_pool"]._is_valid)

    def assert_valid(self):
      """Assert that this object is using valid pool memory"""
      if "_is_valid" in self.__dict__:
        assert self.__dict__["_is_valid"](), "Variable has already been deleted"

    def _retrieve_swig_value(self, name, value):
    # If we got back a different object than we have cached, we need to copy
    # all our metadata into it, so that it looks identical to the one
    # originally set.
      members = self.__dict__.get('_members')
      if members is not None and name in members:
        _copy_metadata_deep(value, members[name])

    # Verify that the new object is good
      _assert_valid_deep(value)

      return value

    # Attribute access must be intercepted to ensure that objects coming from
    # read attribute access match those that are set with write attribute access.
    # Specifically the metadata, such as the associated apr_pool object, should
    # match the originally assigned object.
    #
    # For classic classes it is enough to use __getattr__ to intercept swig
    # derived attributes. However, with new style classes SWIG makes use of
    # descriptors which mean that __getattr__ is never called. Therefore,
    # __getattribute__ must be used for the interception.

    if _newclass:
      def __getattribute__(self, name):
        """Manage access to all attributes of this object."""

    # Start by mimicing __getattr__ behavior: immediately return __dict__ or
    # items directly present in __dict__
        mydict = object.__getattribute__(self, '__dict__')

        if name == "__dict__":
          return mydict

        if name in mydict:
          return mydict[name]

        object.__getattribute__(self, 'assert_valid')()

        value = _get_instance_attr(self, name)
        fn = object.__getattribute__(self, '_retrieve_swig_value')
        return fn(name, value)
    else:
      def __getattr__(self, name):
        """Get an attribute from this object"""
        self.assert_valid()

        value = _swig_getattr(self, self.__class__, name)

        return self._retrieve_swig_value(name, value)

    def __setattr__(self, name, value):
      """Set an attribute on this object"""
      self.assert_valid()

    # Save a copy of the object, so that the garbage
    # collector won't kill the object while it's in
    # SWIG-land
      self.__dict__.setdefault("_members",{})[name] = value

      return _set_instance_attr(self, name, value)

svn_fs_info_placeholder_t_swigregister = _fs.svn_fs_info_placeholder_t_swigregister
svn_fs_info_placeholder_t_swigregister(svn_fs_info_placeholder_t)


def svn_fs_info(*args) -> "SWIGTYPE **":
    """svn_fs_info(svn_fs_t * fs, apr_pool_t result_pool, apr_pool_t scratch_pool) -> svn_error_t"""
    return _fs.svn_fs_info(*args)

def svn_fs_info_dup(*args) -> "void *":
    """svn_fs_info_dup(void const * info, apr_pool_t result_pool, apr_pool_t scratch_pool) -> void *"""
    return _fs.svn_fs_info_dup(*args)
class svn_fs_ioctl_code_t(object):
    """Proxy of C svn_fs_ioctl_code_t struct."""

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    fs_type = _swig_property(_fs.svn_fs_ioctl_code_t_fs_type_get, _fs.svn_fs_ioctl_code_t_fs_type_set)
    code = _swig_property(_fs.svn_fs_ioctl_code_t_code_get, _fs.svn_fs_ioctl_code_t_code_set)
    def set_parent_pool(self, parent_pool=None):
      """Create a new proxy object for TYPE"""
      import libsvn.core, weakref
      self.__dict__["_parent_pool"] = \
        parent_pool or libsvn.core.application_pool;
      if self.__dict__["_parent_pool"]:
        self.__dict__["_is_valid"] = weakref.ref(
          self.__dict__["_parent_pool"]._is_valid)

    def assert_valid(self):
      """Assert that this object is using valid pool memory"""
      if "_is_valid" in self.__dict__:
        assert self.__dict__["_is_valid"](), "Variable has already been deleted"

    def _retrieve_swig_value(self, name, value):
    # If we got back a different object than we have cached, we need to copy
    # all our metadata into it, so that it looks identical to the one
    # originally set.
      members = self.__dict__.get('_members')
      if members is not None and name in members:
        _copy_metadata_deep(value, members[name])

    # Verify that the new object is good
      _assert_valid_deep(value)

      return value

    # Attribute access must be intercepted to ensure that objects coming from
    # read attribute access match those that are set with write attribute access.
    # Specifically the metadata, such as the associated apr_pool object, should
    # match the originally assigned object.
    #
    # For classic classes it is enough to use __getattr__ to intercept swig
    # derived attributes. However, with new style classes SWIG makes use of
    # descriptors which mean that __getattr__ is never called. Therefore,
    # __getattribute__ must be used for the interception.

    if _newclass:
      def __getattribute__(self, name):
        """Manage access to all attributes of this object."""

    # Start by mimicing __getattr__ behavior: immediately return __dict__ or
    # items directly present in __dict__
        mydict = object.__getattribute__(self, '__dict__')

        if name == "__dict__":
          return mydict

        if name in mydict:
          return mydict[name]

        object.__getattribute__(self, 'assert_valid')()

        value = _get_instance_attr(self, name)
        fn = object.__getattribute__(self, '_retrieve_swig_value')
        return fn(name, value)
    else:
      def __getattr__(self, name):
        """Get an attribute from this object"""
        self.assert_valid()

        value = _swig_getattr(self, self.__class__, name)

        return self._retrieve_swig_value(name, value)

    def __setattr__(self, name, value):
      """Set an attribute on this object"""
      self.assert_valid()

    # Save a copy of the object, so that the garbage
    # collector won't kill the object while it's in
    # SWIG-land
      self.__dict__.setdefault("_members",{})[name] = value

      return _set_instance_attr(self, name, value)

svn_fs_ioctl_code_t_swigregister = _fs.svn_fs_ioctl_code_t_swigregister
svn_fs_ioctl_code_t_swigregister(svn_fs_ioctl_code_t)


def svn_fs_ioctl(*args) -> "SWIGTYPE **":
    """svn_fs_ioctl(svn_fs_t * fs, svn_fs_ioctl_code_t ctlcode, void * input, svn_cancel_func_t cancel_func, apr_pool_t result_pool, apr_pool_t scratch_pool) -> svn_error_t"""
    return _fs.svn_fs_ioctl(*args)
class svn_fs_t(object):
    """Proxy of C svn_fs_t struct."""

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    def set_parent_pool(self, parent_pool=None):
      """Create a new proxy object for TYPE"""
      import libsvn.core, weakref
      self.__dict__["_parent_pool"] = \
        parent_pool or libsvn.core.application_pool;
      if self.__dict__["_parent_pool"]:
        self.__dict__["_is_valid"] = weakref.ref(
          self.__dict__["_parent_pool"]._is_valid)

    def assert_valid(self):
      """Assert that this object is using valid pool memory"""
      if "_is_valid" in self.__dict__:
        assert self.__dict__["_is_valid"](), "Variable has already been deleted"

    def _retrieve_swig_value(self, name, value):
    # If we got back a different object than we have cached, we need to copy
    # all our metadata into it, so that it looks identical to the one
    # originally set.
      members = self.__dict__.get('_members')
      if members is not None and name in members:
        _copy_metadata_deep(value, members[name])

    # Verify that the new object is good
      _assert_valid_deep(value)

      return value

    # Attribute access must be intercepted to ensure that objects coming from
    # read attribute access match those that are set with write attribute access.
    # Specifically the metadata, such as the associated apr_pool object, should
    # match the originally assigned object.
    #
    # For classic classes it is enough to use __getattr__ to intercept swig
    # derived attributes. However, with new style classes SWIG makes use of
    # descriptors which mean that __getattr__ is never called. Therefore,
    # __getattribute__ must be used for the interception.

    if _newclass:
      def __getattribute__(self, name):
        """Manage access to all attributes of this object."""

    # Start by mimicing __getattr__ behavior: immediately return __dict__ or
    # items directly present in __dict__
        mydict = object.__getattribute__(self, '__dict__')

        if name == "__dict__":
          return mydict

        if name in mydict:
          return mydict[name]

        object.__getattribute__(self, 'assert_valid')()

        value = _get_instance_attr(self, name)
        fn = object.__getattribute__(self, '_retrieve_swig_value')
        return fn(name, value)
    else:
      def __getattr__(self, name):
        """Get an attribute from this object"""
        self.assert_valid()

        value = _swig_getattr(self, self.__class__, name)

        return self._retrieve_swig_value(name, value)

    def __setattr__(self, name, value):
      """Set an attribute on this object"""
      self.assert_valid()

    # Save a copy of the object, so that the garbage
    # collector won't kill the object while it's in
    # SWIG-land
      self.__dict__.setdefault("_members",{})[name] = value

      return _set_instance_attr(self, name, value)

svn_fs_t_swigregister = _fs.svn_fs_t_swigregister
svn_fs_t_swigregister(svn_fs_t)

class svn_fs_access_t(object):
    """Proxy of C svn_fs_access_t struct."""

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    def set_parent_pool(self, parent_pool=None):
      """Create a new proxy object for TYPE"""
      import libsvn.core, weakref
      self.__dict__["_parent_pool"] = \
        parent_pool or libsvn.core.application_pool;
      if self.__dict__["_parent_pool"]:
        self.__dict__["_is_valid"] = weakref.ref(
          self.__dict__["_parent_pool"]._is_valid)

    def assert_valid(self):
      """Assert that this object is using valid pool memory"""
      if "_is_valid" in self.__dict__:
        assert self.__dict__["_is_valid"](), "Variable has already been deleted"

    def _retrieve_swig_value(self, name, value):
    # If we got back a different object than we have cached, we need to copy
    # all our metadata into it, so that it looks identical to the one
    # originally set.
      members = self.__dict__.get('_members')
      if members is not None and name in members:
        _copy_metadata_deep(value, members[name])

    # Verify that the new object is good
      _assert_valid_deep(value)

      return value

    # Attribute access must be intercepted to ensure that objects coming from
    # read attribute access match those that are set with write attribute access.
    # Specifically the metadata, such as the associated apr_pool object, should
    # match the originally assigned object.
    #
    # For classic classes it is enough to use __getattr__ to intercept swig
    # derived attributes. However, with new style classes SWIG makes use of
    # descriptors which mean that __getattr__ is never called. Therefore,
    # __getattribute__ must be used for the interception.

    if _newclass:
      def __getattribute__(self, name):
        """Manage access to all attributes of this object."""

    # Start by mimicing __getattr__ behavior: immediately return __dict__ or
    # items directly present in __dict__
        mydict = object.__getattribute__(self, '__dict__')

        if name == "__dict__":
          return mydict

        if name in mydict:
          return mydict[name]

        object.__getattribute__(self, 'assert_valid')()

        value = _get_instance_attr(self, name)
        fn = object.__getattribute__(self, '_retrieve_swig_value')
        return fn(name, value)
    else:
      def __getattr__(self, name):
        """Get an attribute from this object"""
        self.assert_valid()

        value = _swig_getattr(self, self.__class__, name)

        return self._retrieve_swig_value(name, value)

    def __setattr__(self, name, value):
      """Set an attribute on this object"""
      self.assert_valid()

    # Save a copy of the object, so that the garbage
    # collector won't kill the object while it's in
    # SWIG-land
      self.__dict__.setdefault("_members",{})[name] = value

      return _set_instance_attr(self, name, value)

svn_fs_access_t_swigregister = _fs.svn_fs_access_t_swigregister
svn_fs_access_t_swigregister(svn_fs_access_t)

class svn_fs_id_t(object):
    """Proxy of C svn_fs_id_t struct."""

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    def set_parent_pool(self, parent_pool=None):
      """Create a new proxy object for TYPE"""
      import libsvn.core, weakref
      self.__dict__["_parent_pool"] = \
        parent_pool or libsvn.core.application_pool;
      if self.__dict__["_parent_pool"]:
        self.__dict__["_is_valid"] = weakref.ref(
          self.__dict__["_parent_pool"]._is_valid)

    def assert_valid(self):
      """Assert that this object is using valid pool memory"""
      if "_is_valid" in self.__dict__:
        assert self.__dict__["_is_valid"](), "Variable has already been deleted"

    def _retrieve_swig_value(self, name, value):
    # If we got back a different object than we have cached, we need to copy
    # all our metadata into it, so that it looks identical to the one
    # originally set.
      members = self.__dict__.get('_members')
      if members is not None and name in members:
        _copy_metadata_deep(value, members[name])

    # Verify that the new object is good
      _assert_valid_deep(value)

      return value

    # Attribute access must be intercepted to ensure that objects coming from
    # read attribute access match those that are set with write attribute access.
    # Specifically the metadata, such as the associated apr_pool object, should
    # match the originally assigned object.
    #
    # For classic classes it is enough to use __getattr__ to intercept swig
    # derived attributes. However, with new style classes SWIG makes use of
    # descriptors which mean that __getattr__ is never called. Therefore,
    # __getattribute__ must be used for the interception.

    if _newclass:
      def __getattribute__(self, name):
        """Manage access to all attributes of this object."""

    # Start by mimicing __getattr__ behavior: immediately return __dict__ or
    # items directly present in __dict__
        mydict = object.__getattribute__(self, '__dict__')

        if name == "__dict__":
          return mydict

        if name in mydict:
          return mydict[name]

        object.__getattribute__(self, 'assert_valid')()

        value = _get_instance_attr(self, name)
        fn = object.__getattribute__(self, '_retrieve_swig_value')
        return fn(name, value)
    else:
      def __getattr__(self, name):
        """Get an attribute from this object"""
        self.assert_valid()

        value = _swig_getattr(self, self.__class__, name)

        return self._retrieve_swig_value(name, value)

    def __setattr__(self, name, value):
      """Set an attribute on this object"""
      self.assert_valid()

    # Save a copy of the object, so that the garbage
    # collector won't kill the object while it's in
    # SWIG-land
      self.__dict__.setdefault("_members",{})[name] = value

      return _set_instance_attr(self, name, value)

svn_fs_id_t_swigregister = _fs.svn_fs_id_t_swigregister
svn_fs_id_t_swigregister(svn_fs_id_t)

class svn_fs_txn_t(object):
    """Proxy of C svn_fs_txn_t struct."""

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    def set_parent_pool(self, parent_pool=None):
      """Create a new proxy object for TYPE"""
      import libsvn.core, weakref
      self.__dict__["_parent_pool"] = \
        parent_pool or libsvn.core.application_pool;
      if self.__dict__["_parent_pool"]:
        self.__dict__["_is_valid"] = weakref.ref(
          self.__dict__["_parent_pool"]._is_valid)

    def assert_valid(self):
      """Assert that this object is using valid pool memory"""
      if "_is_valid" in self.__dict__:
        assert self.__dict__["_is_valid"](), "Variable has already been deleted"

    def _retrieve_swig_value(self, name, value):
    # If we got back a different object than we have cached, we need to copy
    # all our metadata into it, so that it looks identical to the one
    # originally set.
      members = self.__dict__.get('_members')
      if members is not None and name in members:
        _copy_metadata_deep(value, members[name])

    # Verify that the new object is good
      _assert_valid_deep(value)

      return value

    # Attribute access must be intercepted to ensure that objects coming from
    # read attribute access match those that are set with write attribute access.
    # Specifically the metadata, such as the associated apr_pool object, should
    # match the originally assigned object.
    #
    # For classic classes it is enough to use __getattr__ to intercept swig
    # derived attributes. However, with new style classes SWIG makes use of
    # descriptors which mean that __getattr__ is never called. Therefore,
    # __getattribute__ must be used for the interception.

    if _newclass:
      def __getattribute__(self, name):
        """Manage access to all attributes of this object."""

    # Start by mimicing __getattr__ behavior: immediately return __dict__ or
    # items directly present in __dict__
        mydict = object.__getattribute__(self, '__dict__')

        if name == "__dict__":
          return mydict

        if name in mydict:
          return mydict[name]

        object.__getattribute__(self, 'assert_valid')()

        value = _get_instance_attr(self, name)
        fn = object.__getattribute__(self, '_retrieve_swig_value')
        return fn(name, value)
    else:
      def __getattr__(self, name):
        """Get an attribute from this object"""
        self.assert_valid()

        value = _swig_getattr(self, self.__class__, name)

        return self._retrieve_swig_value(name, value)

    def __setattr__(self, name, value):
      """Set an attribute on this object"""
      self.assert_valid()

    # Save a copy of the object, so that the garbage
    # collector won't kill the object while it's in
    # SWIG-land
      self.__dict__.setdefault("_members",{})[name] = value

      return _set_instance_attr(self, name, value)

svn_fs_txn_t_swigregister = _fs.svn_fs_txn_t_swigregister
svn_fs_txn_t_swigregister(svn_fs_txn_t)

class svn_fs_root_t(object):
    """Proxy of C svn_fs_root_t struct."""

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    def set_parent_pool(self, parent_pool=None):
      """Create a new proxy object for TYPE"""
      import libsvn.core, weakref
      self.__dict__["_parent_pool"] = \
        parent_pool or libsvn.core.application_pool;
      if self.__dict__["_parent_pool"]:
        self.__dict__["_is_valid"] = weakref.ref(
          self.__dict__["_parent_pool"]._is_valid)

    def assert_valid(self):
      """Assert that this object is using valid pool memory"""
      if "_is_valid" in self.__dict__:
        assert self.__dict__["_is_valid"](), "Variable has already been deleted"

    def _retrieve_swig_value(self, name, value):
    # If we got back a different object than we have cached, we need to copy
    # all our metadata into it, so that it looks identical to the one
    # originally set.
      members = self.__dict__.get('_members')
      if members is not None and name in members:
        _copy_metadata_deep(value, members[name])

    # Verify that the new object is good
      _assert_valid_deep(value)

      return value

    # Attribute access must be intercepted to ensure that objects coming from
    # read attribute access match those that are set with write attribute access.
    # Specifically the metadata, such as the associated apr_pool object, should
    # match the originally assigned object.
    #
    # For classic classes it is enough to use __getattr__ to intercept swig
    # derived attributes. However, with new style classes SWIG makes use of
    # descriptors which mean that __getattr__ is never called. Therefore,
    # __getattribute__ must be used for the interception.

    if _newclass:
      def __getattribute__(self, name):
        """Manage access to all attributes of this object."""

    # Start by mimicing __getattr__ behavior: immediately return __dict__ or
    # items directly present in __dict__
        mydict = object.__getattribute__(self, '__dict__')

        if name == "__dict__":
          return mydict

        if name in mydict:
          return mydict[name]

        object.__getattribute__(self, 'assert_valid')()

        value = _get_instance_attr(self, name)
        fn = object.__getattribute__(self, '_retrieve_swig_value')
        return fn(name, value)
    else:
      def __getattr__(self, name):
        """Get an attribute from this object"""
        self.assert_valid()

        value = _swig_getattr(self, self.__class__, name)

        return self._retrieve_swig_value(name, value)

    def __setattr__(self, name, value):
      """Set an attribute on this object"""
      self.assert_valid()

    # Save a copy of the object, so that the garbage
    # collector won't kill the object while it's in
    # SWIG-land
      self.__dict__.setdefault("_members",{})[name] = value

      return _set_instance_attr(self, name, value)

svn_fs_root_t_swigregister = _fs.svn_fs_root_t_swigregister
svn_fs_root_t_swigregister(svn_fs_root_t)

class svn_fs_path_change_iterator_t(object):
    """Proxy of C svn_fs_path_change_iterator_t struct."""

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    def set_parent_pool(self, parent_pool=None):
      """Create a new proxy object for TYPE"""
      import libsvn.core, weakref
      self.__dict__["_parent_pool"] = \
        parent_pool or libsvn.core.application_pool;
      if self.__dict__["_parent_pool"]:
        self.__dict__["_is_valid"] = weakref.ref(
          self.__dict__["_parent_pool"]._is_valid)

    def assert_valid(self):
      """Assert that this object is using valid pool memory"""
      if "_is_valid" in self.__dict__:
        assert self.__dict__["_is_valid"](), "Variable has already been deleted"

    def _retrieve_swig_value(self, name, value):
    # If we got back a different object than we have cached, we need to copy
    # all our metadata into it, so that it looks identical to the one
    # originally set.
      members = self.__dict__.get('_members')
      if members is not None and name in members:
        _copy_metadata_deep(value, members[name])

    # Verify that the new object is good
      _assert_valid_deep(value)

      return value

    # Attribute access must be intercepted to ensure that objects coming from
    # read attribute access match those that are set with write attribute access.
    # Specifically the metadata, such as the associated apr_pool object, should
    # match the originally assigned object.
    #
    # For classic classes it is enough to use __getattr__ to intercept swig
    # derived attributes. However, with new style classes SWIG makes use of
    # descriptors which mean that __getattr__ is never called. Therefore,
    # __getattribute__ must be used for the interception.

    if _newclass:
      def __getattribute__(self, name):
        """Manage access to all attributes of this object."""

    # Start by mimicing __getattr__ behavior: immediately return __dict__ or
    # items directly present in __dict__
        mydict = object.__getattribute__(self, '__dict__')

        if name == "__dict__":
          return mydict

        if name in mydict:
          return mydict[name]

        object.__getattribute__(self, 'assert_valid')()

        value = _get_instance_attr(self, name)
        fn = object.__getattribute__(self, '_retrieve_swig_value')
        return fn(name, value)
    else:
      def __getattr__(self, name):
        """Get an attribute from this object"""
        self.assert_valid()

        value = _swig_getattr(self, self.__class__, name)

        return self._retrieve_swig_value(name, value)

    def __setattr__(self, name, value):
      """Set an attribute on this object"""
      self.assert_valid()

    # Save a copy of the object, so that the garbage
    # collector won't kill the object while it's in
    # SWIG-land
      self.__dict__.setdefault("_members",{})[name] = value

      return _set_instance_attr(self, name, value)

svn_fs_path_change_iterator_t_swigregister = _fs.svn_fs_path_change_iterator_t_swigregister
svn_fs_path_change_iterator_t_swigregister(svn_fs_path_change_iterator_t)

class svn_fs_history_t(object):
    """Proxy of C svn_fs_history_t struct."""

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    def set_parent_pool(self, parent_pool=None):
      """Create a new proxy object for TYPE"""
      import libsvn.core, weakref
      self.__dict__["_parent_pool"] = \
        parent_pool or libsvn.core.application_pool;
      if self.__dict__["_parent_pool"]:
        self.__dict__["_is_valid"] = weakref.ref(
          self.__dict__["_parent_pool"]._is_valid)

    def assert_valid(self):
      """Assert that this object is using valid pool memory"""
      if "_is_valid" in self.__dict__:
        assert self.__dict__["_is_valid"](), "Variable has already been deleted"

    def _retrieve_swig_value(self, name, value):
    # If we got back a different object than we have cached, we need to copy
    # all our metadata into it, so that it looks identical to the one
    # originally set.
      members = self.__dict__.get('_members')
      if members is not None and name in members:
        _copy_metadata_deep(value, members[name])

    # Verify that the new object is good
      _assert_valid_deep(value)

      return value

    # Attribute access must be intercepted to ensure that objects coming from
    # read attribute access match those that are set with write attribute access.
    # Specifically the metadata, such as the associated apr_pool object, should
    # match the originally assigned object.
    #
    # For classic classes it is enough to use __getattr__ to intercept swig
    # derived attributes. However, with new style classes SWIG makes use of
    # descriptors which mean that __getattr__ is never called. Therefore,
    # __getattribute__ must be used for the interception.

    if _newclass:
      def __getattribute__(self, name):
        """Manage access to all attributes of this object."""

    # Start by mimicing __getattr__ behavior: immediately return __dict__ or
    # items directly present in __dict__
        mydict = object.__getattribute__(self, '__dict__')

        if name == "__dict__":
          return mydict

        if name in mydict:
          return mydict[name]

        object.__getattribute__(self, 'assert_valid')()

        value = _get_instance_attr(self, name)
        fn = object.__getattribute__(self, '_retrieve_swig_value')
        return fn(name, value)
    else:
      def __getattr__(self, name):
        """Get an attribute from this object"""
        self.assert_valid()

        value = _swig_getattr(self, self.__class__, name)

        return self._retrieve_swig_value(name, value)

    def __setattr__(self, name, value):
      """Set an attribute on this object"""
      self.assert_valid()

    # Save a copy of the object, so that the garbage
    # collector won't kill the object while it's in
    # SWIG-land
      self.__dict__.setdefault("_members",{})[name] = value

      return _set_instance_attr(self, name, value)

svn_fs_history_t_swigregister = _fs.svn_fs_history_t_swigregister
svn_fs_history_t_swigregister(svn_fs_history_t)

class svn_fs_lock_target_t(object):
    """Proxy of C svn_fs_lock_target_t struct."""

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    def set_parent_pool(self, parent_pool=None):
      """Create a new proxy object for TYPE"""
      import libsvn.core, weakref
      self.__dict__["_parent_pool"] = \
        parent_pool or libsvn.core.application_pool;
      if self.__dict__["_parent_pool"]:
        self.__dict__["_is_valid"] = weakref.ref(
          self.__dict__["_parent_pool"]._is_valid)

    def assert_valid(self):
      """Assert that this object is using valid pool memory"""
      if "_is_valid" in self.__dict__:
        assert self.__dict__["_is_valid"](), "Variable has already been deleted"

    def _retrieve_swig_value(self, name, value):
    # If we got back a different object than we have cached, we need to copy
    # all our metadata into it, so that it looks identical to the one
    # originally set.
      members = self.__dict__.get('_members')
      if members is not None and name in members:
        _copy_metadata_deep(value, members[name])

    # Verify that the new object is good
      _assert_valid_deep(value)

      return value

    # Attribute access must be intercepted to ensure that objects coming from
    # read attribute access match those that are set with write attribute access.
    # Specifically the metadata, such as the associated apr_pool object, should
    # match the originally assigned object.
    #
    # For classic classes it is enough to use __getattr__ to intercept swig
    # derived attributes. However, with new style classes SWIG makes use of
    # descriptors which mean that __getattr__ is never called. Therefore,
    # __getattribute__ must be used for the interception.

    if _newclass:
      def __getattribute__(self, name):
        """Manage access to all attributes of this object."""

    # Start by mimicing __getattr__ behavior: immediately return __dict__ or
    # items directly present in __dict__
        mydict = object.__getattribute__(self, '__dict__')

        if name == "__dict__":
          return mydict

        if name in mydict:
          return mydict[name]

        object.__getattribute__(self, 'assert_valid')()

        value = _get_instance_attr(self, name)
        fn = object.__getattribute__(self, '_retrieve_swig_value')
        return fn(name, value)
    else:
      def __getattr__(self, name):
        """Get an attribute from this object"""
        self.assert_valid()

        value = _swig_getattr(self, self.__class__, name)

        return self._retrieve_swig_value(name, value)

    def __setattr__(self, name, value):
      """Set an attribute on this object"""
      self.assert_valid()

    # Save a copy of the object, so that the garbage
    # collector won't kill the object while it's in
    # SWIG-land
      self.__dict__.setdefault("_members",{})[name] = value

      return _set_instance_attr(self, name, value)

svn_fs_lock_target_t_swigregister = _fs.svn_fs_lock_target_t_swigregister
svn_fs_lock_target_t_swigregister(svn_fs_lock_target_t)


def svn_fs_invoke_warning_callback(_obj: 'svn_fs_warning_callback_t', baton: 'void *', err: 'svn_error_t') -> "void":
    """svn_fs_invoke_warning_callback(svn_fs_warning_callback_t _obj, void * baton, svn_error_t err)"""
    return _fs.svn_fs_invoke_warning_callback(_obj, baton, err)

def svn_fs_invoke_upgrade_notify(*args) -> "svn_error_t *":
    """svn_fs_invoke_upgrade_notify(svn_fs_upgrade_notify_t _obj, void * baton, apr_uint64_t number, svn_fs_upgrade_notify_action_t action, apr_pool_t scratch_pool) -> svn_error_t"""
    return _fs.svn_fs_invoke_upgrade_notify(*args)

def svn_fs_invoke_progress_notify_func(*args) -> "void":
    """svn_fs_invoke_progress_notify_func(svn_fs_progress_notify_func_t _obj, svn_revnum_t revision, void * baton, apr_pool_t pool)"""
    return _fs.svn_fs_invoke_progress_notify_func(*args)

def svn_fs_invoke_hotcopy_notify(*args) -> "void":
    """svn_fs_invoke_hotcopy_notify(svn_fs_hotcopy_notify_t _obj, void * baton, svn_revnum_t start_revision, svn_revnum_t end_revision, apr_pool_t scratch_pool)"""
    return _fs.svn_fs_invoke_hotcopy_notify(*args)

def svn_fs_invoke_freeze_func(*args) -> "svn_error_t *":
    """svn_fs_invoke_freeze_func(svn_fs_freeze_func_t _obj, void * baton, apr_pool_t pool) -> svn_error_t"""
    return _fs.svn_fs_invoke_freeze_func(*args)

def svn_fs_invoke_mergeinfo_receiver(*args) -> "svn_error_t *":
    """svn_fs_invoke_mergeinfo_receiver(svn_fs_mergeinfo_receiver_t _obj, char const * path, apr_hash_t mergeinfo, void * baton, apr_pool_t scratch_pool) -> svn_error_t"""
    return _fs.svn_fs_invoke_mergeinfo_receiver(*args)

def svn_fs_invoke_process_contents_func(*args) -> "svn_error_t *":
    """svn_fs_invoke_process_contents_func(svn_fs_process_contents_func_t _obj, unsigned char const * contents, apr_size_t len, void * baton, apr_pool_t scratch_pool) -> svn_error_t"""
    return _fs.svn_fs_invoke_process_contents_func(*args)

def svn_fs_invoke_lock_callback(*args) -> "svn_error_t *":
    """svn_fs_invoke_lock_callback(svn_fs_lock_callback_t _obj, void * baton, char const * path, svn_lock_t lock, svn_error_t fs_err, apr_pool_t scratch_pool) -> svn_error_t"""
    return _fs.svn_fs_invoke_lock_callback(*args)

def svn_fs_invoke_get_locks_callback(*args) -> "svn_error_t *":
    """svn_fs_invoke_get_locks_callback(svn_fs_get_locks_callback_t _obj, void * baton, svn_lock_t lock, apr_pool_t pool) -> svn_error_t"""
    return _fs.svn_fs_invoke_get_locks_callback(*args)

def svn_fs_invoke_pack_notify(*args) -> "svn_error_t *":
    """svn_fs_invoke_pack_notify(svn_fs_pack_notify_t _obj, void * baton, apr_int64_t shard, svn_fs_pack_notify_action_t action, apr_pool_t pool) -> svn_error_t"""
    return _fs.svn_fs_invoke_pack_notify(*args)
class svn_fs_warning_callback_t(object):
    """Proxy of C svn_fs_warning_callback_t struct."""

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    def set_parent_pool(self, parent_pool=None):
      """Create a new proxy object for TYPE"""
      import libsvn.core, weakref
      self.__dict__["_parent_pool"] = \
        parent_pool or libsvn.core.application_pool;
      if self.__dict__["_parent_pool"]:
        self.__dict__["_is_valid"] = weakref.ref(
          self.__dict__["_parent_pool"]._is_valid)

    def assert_valid(self):
      """Assert that this object is using valid pool memory"""
      if "_is_valid" in self.__dict__:
        assert self.__dict__["_is_valid"](), "Variable has already been deleted"

    def _retrieve_swig_value(self, name, value):
    # If we got back a different object than we have cached, we need to copy
    # all our metadata into it, so that it looks identical to the one
    # originally set.
      members = self.__dict__.get('_members')
      if members is not None and name in members:
        _copy_metadata_deep(value, members[name])

    # Verify that the new object is good
      _assert_valid_deep(value)

      return value

    # Attribute access must be intercepted to ensure that objects coming from
    # read attribute access match those that are set with write attribute access.
    # Specifically the metadata, such as the associated apr_pool object, should
    # match the originally assigned object.
    #
    # For classic classes it is enough to use __getattr__ to intercept swig
    # derived attributes. However, with new style classes SWIG makes use of
    # descriptors which mean that __getattr__ is never called. Therefore,
    # __getattribute__ must be used for the interception.

    if _newclass:
      def __getattribute__(self, name):
        """Manage access to all attributes of this object."""

    # Start by mimicing __getattr__ behavior: immediately return __dict__ or
    # items directly present in __dict__
        mydict = object.__getattribute__(self, '__dict__')

        if name == "__dict__":
          return mydict

        if name in mydict:
          return mydict[name]

        object.__getattribute__(self, 'assert_valid')()

        value = _get_instance_attr(self, name)
        fn = object.__getattribute__(self, '_retrieve_swig_value')
        return fn(name, value)
    else:
      def __getattr__(self, name):
        """Get an attribute from this object"""
        self.assert_valid()

        value = _swig_getattr(self, self.__class__, name)

        return self._retrieve_swig_value(name, value)

    def __setattr__(self, name, value):
      """Set an attribute on this object"""
      self.assert_valid()

    # Save a copy of the object, so that the garbage
    # collector won't kill the object while it's in
    # SWIG-land
      self.__dict__.setdefault("_members",{})[name] = value

      return _set_instance_attr(self, name, value)


    def __call__(self, *args):
      return svn_fs_invoke_warning_callback(self, *args)

svn_fs_warning_callback_t_swigregister = _fs.svn_fs_warning_callback_t_swigregister
svn_fs_warning_callback_t_swigregister(svn_fs_warning_callback_t)

class svn_fs_upgrade_notify_t(object):
    """Proxy of C svn_fs_upgrade_notify_t struct."""

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    def set_parent_pool(self, parent_pool=None):
      """Create a new proxy object for TYPE"""
      import libsvn.core, weakref
      self.__dict__["_parent_pool"] = \
        parent_pool or libsvn.core.application_pool;
      if self.__dict__["_parent_pool"]:
        self.__dict__["_is_valid"] = weakref.ref(
          self.__dict__["_parent_pool"]._is_valid)

    def assert_valid(self):
      """Assert that this object is using valid pool memory"""
      if "_is_valid" in self.__dict__:
        assert self.__dict__["_is_valid"](), "Variable has already been deleted"

    def _retrieve_swig_value(self, name, value):
    # If we got back a different object than we have cached, we need to copy
    # all our metadata into it, so that it looks identical to the one
    # originally set.
      members = self.__dict__.get('_members')
      if members is not None and name in members:
        _copy_metadata_deep(value, members[name])

    # Verify that the new object is good
      _assert_valid_deep(value)

      return value

    # Attribute access must be intercepted to ensure that objects coming from
    # read attribute access match those that are set with write attribute access.
    # Specifically the metadata, such as the associated apr_pool object, should
    # match the originally assigned object.
    #
    # For classic classes it is enough to use __getattr__ to intercept swig
    # derived attributes. However, with new style classes SWIG makes use of
    # descriptors which mean that __getattr__ is never called. Therefore,
    # __getattribute__ must be used for the interception.

    if _newclass:
      def __getattribute__(self, name):
        """Manage access to all attributes of this object."""

    # Start by mimicing __getattr__ behavior: immediately return __dict__ or
    # items directly present in __dict__
        mydict = object.__getattribute__(self, '__dict__')

        if name == "__dict__":
          return mydict

        if name in mydict:
          return mydict[name]

        object.__getattribute__(self, 'assert_valid')()

        value = _get_instance_attr(self, name)
        fn = object.__getattribute__(self, '_retrieve_swig_value')
        return fn(name, value)
    else:
      def __getattr__(self, name):
        """Get an attribute from this object"""
        self.assert_valid()

        value = _swig_getattr(self, self.__class__, name)

        return self._retrieve_swig_value(name, value)

    def __setattr__(self, name, value):
      """Set an attribute on this object"""
      self.assert_valid()

    # Save a copy of the object, so that the garbage
    # collector won't kill the object while it's in
    # SWIG-land
      self.__dict__.setdefault("_members",{})[name] = value

      return _set_instance_attr(self, name, value)


    def __call__(self, *args):
      return svn_fs_invoke_upgrade_notify(self, *args)

svn_fs_upgrade_notify_t_swigregister = _fs.svn_fs_upgrade_notify_t_swigregister
svn_fs_upgrade_notify_t_swigregister(svn_fs_upgrade_notify_t)

class svn_fs_progress_notify_func_t(object):
    """Proxy of C svn_fs_progress_notify_func_t struct."""

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    def set_parent_pool(self, parent_pool=None):
      """Create a new proxy object for TYPE"""
      import libsvn.core, weakref
      self.__dict__["_parent_pool"] = \
        parent_pool or libsvn.core.application_pool;
      if self.__dict__["_parent_pool"]:
        self.__dict__["_is_valid"] = weakref.ref(
          self.__dict__["_parent_pool"]._is_valid)

    def assert_valid(self):
      """Assert that this object is using valid pool memory"""
      if "_is_valid" in self.__dict__:
        assert self.__dict__["_is_valid"](), "Variable has already been deleted"

    def _retrieve_swig_value(self, name, value):
    # If we got back a different object than we have cached, we need to copy
    # all our metadata into it, so that it looks identical to the one
    # originally set.
      members = self.__dict__.get('_members')
      if members is not None and name in members:
        _copy_metadata_deep(value, members[name])

    # Verify that the new object is good
      _assert_valid_deep(value)

      return value

    # Attribute access must be intercepted to ensure that objects coming from
    # read attribute access match those that are set with write attribute access.
    # Specifically the metadata, such as the associated apr_pool object, should
    # match the originally assigned object.
    #
    # For classic classes it is enough to use __getattr__ to intercept swig
    # derived attributes. However, with new style classes SWIG makes use of
    # descriptors which mean that __getattr__ is never called. Therefore,
    # __getattribute__ must be used for the interception.

    if _newclass:
      def __getattribute__(self, name):
        """Manage access to all attributes of this object."""

    # Start by mimicing __getattr__ behavior: immediately return __dict__ or
    # items directly present in __dict__
        mydict = object.__getattribute__(self, '__dict__')

        if name == "__dict__":
          return mydict

        if name in mydict:
          return mydict[name]

        object.__getattribute__(self, 'assert_valid')()

        value = _get_instance_attr(self, name)
        fn = object.__getattribute__(self, '_retrieve_swig_value')
        return fn(name, value)
    else:
      def __getattr__(self, name):
        """Get an attribute from this object"""
        self.assert_valid()

        value = _swig_getattr(self, self.__class__, name)

        return self._retrieve_swig_value(name, value)

    def __setattr__(self, name, value):
      """Set an attribute on this object"""
      self.assert_valid()

    # Save a copy of the object, so that the garbage
    # collector won't kill the object while it's in
    # SWIG-land
      self.__dict__.setdefault("_members",{})[name] = value

      return _set_instance_attr(self, name, value)


    def __call__(self, *args):
      return svn_fs_invoke_progress_notify_func(self, *args)

svn_fs_progress_notify_func_t_swigregister = _fs.svn_fs_progress_notify_func_t_swigregister
svn_fs_progress_notify_func_t_swigregister(svn_fs_progress_notify_func_t)

class svn_fs_hotcopy_notify_t(object):
    """Proxy of C svn_fs_hotcopy_notify_t struct."""

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    def set_parent_pool(self, parent_pool=None):
      """Create a new proxy object for TYPE"""
      import libsvn.core, weakref
      self.__dict__["_parent_pool"] = \
        parent_pool or libsvn.core.application_pool;
      if self.__dict__["_parent_pool"]:
        self.__dict__["_is_valid"] = weakref.ref(
          self.__dict__["_parent_pool"]._is_valid)

    def assert_valid(self):
      """Assert that this object is using valid pool memory"""
      if "_is_valid" in self.__dict__:
        assert self.__dict__["_is_valid"](), "Variable has already been deleted"

    def _retrieve_swig_value(self, name, value):
    # If we got back a different object than we have cached, we need to copy
    # all our metadata into it, so that it looks identical to the one
    # originally set.
      members = self.__dict__.get('_members')
      if members is not None and name in members:
        _copy_metadata_deep(value, members[name])

    # Verify that the new object is good
      _assert_valid_deep(value)

      return value

    # Attribute access must be intercepted to ensure that objects coming from
    # read attribute access match those that are set with write attribute access.
    # Specifically the metadata, such as the associated apr_pool object, should
    # match the originally assigned object.
    #
    # For classic classes it is enough to use __getattr__ to intercept swig
    # derived attributes. However, with new style classes SWIG makes use of
    # descriptors which mean that __getattr__ is never called. Therefore,
    # __getattribute__ must be used for the interception.

    if _newclass:
      def __getattribute__(self, name):
        """Manage access to all attributes of this object."""

    # Start by mimicing __getattr__ behavior: immediately return __dict__ or
    # items directly present in __dict__
        mydict = object.__getattribute__(self, '__dict__')

        if name == "__dict__":
          return mydict

        if name in mydict:
          return mydict[name]

        object.__getattribute__(self, 'assert_valid')()

        value = _get_instance_attr(self, name)
        fn = object.__getattribute__(self, '_retrieve_swig_value')
        return fn(name, value)
    else:
      def __getattr__(self, name):
        """Get an attribute from this object"""
        self.assert_valid()

        value = _swig_getattr(self, self.__class__, name)

        return self._retrieve_swig_value(name, value)

    def __setattr__(self, name, value):
      """Set an attribute on this object"""
      self.assert_valid()

    # Save a copy of the object, so that the garbage
    # collector won't kill the object while it's in
    # SWIG-land
      self.__dict__.setdefault("_members",{})[name] = value

      return _set_instance_attr(self, name, value)


    def __call__(self, *args):
      return svn_fs_invoke_hotcopy_notify(self, *args)

svn_fs_hotcopy_notify_t_swigregister = _fs.svn_fs_hotcopy_notify_t_swigregister
svn_fs_hotcopy_notify_t_swigregister(svn_fs_hotcopy_notify_t)

class svn_fs_freeze_func_t(object):
    """Proxy of C svn_fs_freeze_func_t struct."""

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    def set_parent_pool(self, parent_pool=None):
      """Create a new proxy object for TYPE"""
      import libsvn.core, weakref
      self.__dict__["_parent_pool"] = \
        parent_pool or libsvn.core.application_pool;
      if self.__dict__["_parent_pool"]:
        self.__dict__["_is_valid"] = weakref.ref(
          self.__dict__["_parent_pool"]._is_valid)

    def assert_valid(self):
      """Assert that this object is using valid pool memory"""
      if "_is_valid" in self.__dict__:
        assert self.__dict__["_is_valid"](), "Variable has already been deleted"

    def _retrieve_swig_value(self, name, value):
    # If we got back a different object than we have cached, we need to copy
    # all our metadata into it, so that it looks identical to the one
    # originally set.
      members = self.__dict__.get('_members')
      if members is not None and name in members:
        _copy_metadata_deep(value, members[name])

    # Verify that the new object is good
      _assert_valid_deep(value)

      return value

    # Attribute access must be intercepted to ensure that objects coming from
    # read attribute access match those that are set with write attribute access.
    # Specifically the metadata, such as the associated apr_pool object, should
    # match the originally assigned object.
    #
    # For classic classes it is enough to use __getattr__ to intercept swig
    # derived attributes. However, with new style classes SWIG makes use of
    # descriptors which mean that __getattr__ is never called. Therefore,
    # __getattribute__ must be used for the interception.

    if _newclass:
      def __getattribute__(self, name):
        """Manage access to all attributes of this object."""

    # Start by mimicing __getattr__ behavior: immediately return __dict__ or
    # items directly present in __dict__
        mydict = object.__getattribute__(self, '__dict__')

        if name == "__dict__":
          return mydict

        if name in mydict:
          return mydict[name]

        object.__getattribute__(self, 'assert_valid')()

        value = _get_instance_attr(self, name)
        fn = object.__getattribute__(self, '_retrieve_swig_value')
        return fn(name, value)
    else:
      def __getattr__(self, name):
        """Get an attribute from this object"""
        self.assert_valid()

        value = _swig_getattr(self, self.__class__, name)

        return self._retrieve_swig_value(name, value)

    def __setattr__(self, name, value):
      """Set an attribute on this object"""
      self.assert_valid()

    # Save a copy of the object, so that the garbage
    # collector won't kill the object while it's in
    # SWIG-land
      self.__dict__.setdefault("_members",{})[name] = value

      return _set_instance_attr(self, name, value)


    def __call__(self, *args):
      return svn_fs_invoke_freeze_func(self, *args)

svn_fs_freeze_func_t_swigregister = _fs.svn_fs_freeze_func_t_swigregister
svn_fs_freeze_func_t_swigregister(svn_fs_freeze_func_t)

class svn_fs_mergeinfo_receiver_t(object):
    """Proxy of C svn_fs_mergeinfo_receiver_t struct."""

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    def set_parent_pool(self, parent_pool=None):
      """Create a new proxy object for TYPE"""
      import libsvn.core, weakref
      self.__dict__["_parent_pool"] = \
        parent_pool or libsvn.core.application_pool;
      if self.__dict__["_parent_pool"]:
        self.__dict__["_is_valid"] = weakref.ref(
          self.__dict__["_parent_pool"]._is_valid)

    def assert_valid(self):
      """Assert that this object is using valid pool memory"""
      if "_is_valid" in self.__dict__:
        assert self.__dict__["_is_valid"](), "Variable has already been deleted"

    def _retrieve_swig_value(self, name, value):
    # If we got back a different object than we have cached, we need to copy
    # all our metadata into it, so that it looks identical to the one
    # originally set.
      members = self.__dict__.get('_members')
      if members is not None and name in members:
        _copy_metadata_deep(value, members[name])

    # Verify that the new object is good
      _assert_valid_deep(value)

      return value

    # Attribute access must be intercepted to ensure that objects coming from
    # read attribute access match those that are set with write attribute access.
    # Specifically the metadata, such as the associated apr_pool object, should
    # match the originally assigned object.
    #
    # For classic classes it is enough to use __getattr__ to intercept swig
    # derived attributes. However, with new style classes SWIG makes use of
    # descriptors which mean that __getattr__ is never called. Therefore,
    # __getattribute__ must be used for the interception.

    if _newclass:
      def __getattribute__(self, name):
        """Manage access to all attributes of this object."""

    # Start by mimicing __getattr__ behavior: immediately return __dict__ or
    # items directly present in __dict__
        mydict = object.__getattribute__(self, '__dict__')

        if name == "__dict__":
          return mydict

        if name in mydict:
          return mydict[name]

        object.__getattribute__(self, 'assert_valid')()

        value = _get_instance_attr(self, name)
        fn = object.__getattribute__(self, '_retrieve_swig_value')
        return fn(name, value)
    else:
      def __getattr__(self, name):
        """Get an attribute from this object"""
        self.assert_valid()

        value = _swig_getattr(self, self.__class__, name)

        return self._retrieve_swig_value(name, value)

    def __setattr__(self, name, value):
      """Set an attribute on this object"""
      self.assert_valid()

    # Save a copy of the object, so that the garbage
    # collector won't kill the object while it's in
    # SWIG-land
      self.__dict__.setdefault("_members",{})[name] = value

      return _set_instance_attr(self, name, value)


    def __call__(self, *args):
      return svn_fs_invoke_mergeinfo_receiver(self, *args)

svn_fs_mergeinfo_receiver_t_swigregister = _fs.svn_fs_mergeinfo_receiver_t_swigregister
svn_fs_mergeinfo_receiver_t_swigregister(svn_fs_mergeinfo_receiver_t)

class svn_fs_process_contents_func_t(object):
    """Proxy of C svn_fs_process_contents_func_t struct."""

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    def set_parent_pool(self, parent_pool=None):
      """Create a new proxy object for TYPE"""
      import libsvn.core, weakref
      self.__dict__["_parent_pool"] = \
        parent_pool or libsvn.core.application_pool;
      if self.__dict__["_parent_pool"]:
        self.__dict__["_is_valid"] = weakref.ref(
          self.__dict__["_parent_pool"]._is_valid)

    def assert_valid(self):
      """Assert that this object is using valid pool memory"""
      if "_is_valid" in self.__dict__:
        assert self.__dict__["_is_valid"](), "Variable has already been deleted"

    def _retrieve_swig_value(self, name, value):
    # If we got back a different object than we have cached, we need to copy
    # all our metadata into it, so that it looks identical to the one
    # originally set.
      members = self.__dict__.get('_members')
      if members is not None and name in members:
        _copy_metadata_deep(value, members[name])

    # Verify that the new object is good
      _assert_valid_deep(value)

      return value

    # Attribute access must be intercepted to ensure that objects coming from
    # read attribute access match those that are set with write attribute access.
    # Specifically the metadata, such as the associated apr_pool object, should
    # match the originally assigned object.
    #
    # For classic classes it is enough to use __getattr__ to intercept swig
    # derived attributes. However, with new style classes SWIG makes use of
    # descriptors which mean that __getattr__ is never called. Therefore,
    # __getattribute__ must be used for the interception.

    if _newclass:
      def __getattribute__(self, name):
        """Manage access to all attributes of this object."""

    # Start by mimicing __getattr__ behavior: immediately return __dict__ or
    # items directly present in __dict__
        mydict = object.__getattribute__(self, '__dict__')

        if name == "__dict__":
          return mydict

        if name in mydict:
          return mydict[name]

        object.__getattribute__(self, 'assert_valid')()

        value = _get_instance_attr(self, name)
        fn = object.__getattribute__(self, '_retrieve_swig_value')
        return fn(name, value)
    else:
      def __getattr__(self, name):
        """Get an attribute from this object"""
        self.assert_valid()

        value = _swig_getattr(self, self.__class__, name)

        return self._retrieve_swig_value(name, value)

    def __setattr__(self, name, value):
      """Set an attribute on this object"""
      self.assert_valid()

    # Save a copy of the object, so that the garbage
    # collector won't kill the object while it's in
    # SWIG-land
      self.__dict__.setdefault("_members",{})[name] = value

      return _set_instance_attr(self, name, value)


    def __call__(self, *args):
      return svn_fs_invoke_process_contents_func(self, *args)

svn_fs_process_contents_func_t_swigregister = _fs.svn_fs_process_contents_func_t_swigregister
svn_fs_process_contents_func_t_swigregister(svn_fs_process_contents_func_t)

class svn_fs_lock_callback_t(object):
    """Proxy of C svn_fs_lock_callback_t struct."""

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    def set_parent_pool(self, parent_pool=None):
      """Create a new proxy object for TYPE"""
      import libsvn.core, weakref
      self.__dict__["_parent_pool"] = \
        parent_pool or libsvn.core.application_pool;
      if self.__dict__["_parent_pool"]:
        self.__dict__["_is_valid"] = weakref.ref(
          self.__dict__["_parent_pool"]._is_valid)

    def assert_valid(self):
      """Assert that this object is using valid pool memory"""
      if "_is_valid" in self.__dict__:
        assert self.__dict__["_is_valid"](), "Variable has already been deleted"

    def _retrieve_swig_value(self, name, value):
    # If we got back a different object than we have cached, we need to copy
    # all our metadata into it, so that it looks identical to the one
    # originally set.
      members = self.__dict__.get('_members')
      if members is not None and name in members:
        _copy_metadata_deep(value, members[name])

    # Verify that the new object is good
      _assert_valid_deep(value)

      return value

    # Attribute access must be intercepted to ensure that objects coming from
    # read attribute access match those that are set with write attribute access.
    # Specifically the metadata, such as the associated apr_pool object, should
    # match the originally assigned object.
    #
    # For classic classes it is enough to use __getattr__ to intercept swig
    # derived attributes. However, with new style classes SWIG makes use of
    # descriptors which mean that __getattr__ is never called. Therefore,
    # __getattribute__ must be used for the interception.

    if _newclass:
      def __getattribute__(self, name):
        """Manage access to all attributes of this object."""

    # Start by mimicing __getattr__ behavior: immediately return __dict__ or
    # items directly present in __dict__
        mydict = object.__getattribute__(self, '__dict__')

        if name == "__dict__":
          return mydict

        if name in mydict:
          return mydict[name]

        object.__getattribute__(self, 'assert_valid')()

        value = _get_instance_attr(self, name)
        fn = object.__getattribute__(self, '_retrieve_swig_value')
        return fn(name, value)
    else:
      def __getattr__(self, name):
        """Get an attribute from this object"""
        self.assert_valid()

        value = _swig_getattr(self, self.__class__, name)

        return self._retrieve_swig_value(name, value)

    def __setattr__(self, name, value):
      """Set an attribute on this object"""
      self.assert_valid()

    # Save a copy of the object, so that the garbage
    # collector won't kill the object while it's in
    # SWIG-land
      self.__dict__.setdefault("_members",{})[name] = value

      return _set_instance_attr(self, name, value)


    def __call__(self, *args):
      return svn_fs_invoke_lock_callback(self, *args)

svn_fs_lock_callback_t_swigregister = _fs.svn_fs_lock_callback_t_swigregister
svn_fs_lock_callback_t_swigregister(svn_fs_lock_callback_t)

class svn_fs_get_locks_callback_t(object):
    """Proxy of C svn_fs_get_locks_callback_t struct."""

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    def set_parent_pool(self, parent_pool=None):
      """Create a new proxy object for TYPE"""
      import libsvn.core, weakref
      self.__dict__["_parent_pool"] = \
        parent_pool or libsvn.core.application_pool;
      if self.__dict__["_parent_pool"]:
        self.__dict__["_is_valid"] = weakref.ref(
          self.__dict__["_parent_pool"]._is_valid)

    def assert_valid(self):
      """Assert that this object is using valid pool memory"""
      if "_is_valid" in self.__dict__:
        assert self.__dict__["_is_valid"](), "Variable has already been deleted"

    def _retrieve_swig_value(self, name, value):
    # If we got back a different object than we have cached, we need to copy
    # all our metadata into it, so that it looks identical to the one
    # originally set.
      members = self.__dict__.get('_members')
      if members is not None and name in members:
        _copy_metadata_deep(value, members[name])

    # Verify that the new object is good
      _assert_valid_deep(value)

      return value

    # Attribute access must be intercepted to ensure that objects coming from
    # read attribute access match those that are set with write attribute access.
    # Specifically the metadata, such as the associated apr_pool object, should
    # match the originally assigned object.
    #
    # For classic classes it is enough to use __getattr__ to intercept swig
    # derived attributes. However, with new style classes SWIG makes use of
    # descriptors which mean that __getattr__ is never called. Therefore,
    # __getattribute__ must be used for the interception.

    if _newclass:
      def __getattribute__(self, name):
        """Manage access to all attributes of this object."""

    # Start by mimicing __getattr__ behavior: immediately return __dict__ or
    # items directly present in __dict__
        mydict = object.__getattribute__(self, '__dict__')

        if name == "__dict__":
          return mydict

        if name in mydict:
          return mydict[name]

        object.__getattribute__(self, 'assert_valid')()

        value = _get_instance_attr(self, name)
        fn = object.__getattribute__(self, '_retrieve_swig_value')
        return fn(name, value)
    else:
      def __getattr__(self, name):
        """Get an attribute from this object"""
        self.assert_valid()

        value = _swig_getattr(self, self.__class__, name)

        return self._retrieve_swig_value(name, value)

    def __setattr__(self, name, value):
      """Set an attribute on this object"""
      self.assert_valid()

    # Save a copy of the object, so that the garbage
    # collector won't kill the object while it's in
    # SWIG-land
      self.__dict__.setdefault("_members",{})[name] = value

      return _set_instance_attr(self, name, value)


    def __call__(self, *args):
      return svn_fs_invoke_get_locks_callback(self, *args)

svn_fs_get_locks_callback_t_swigregister = _fs.svn_fs_get_locks_callback_t_swigregister
svn_fs_get_locks_callback_t_swigregister(svn_fs_get_locks_callback_t)

class svn_fs_pack_notify_t(object):
    """Proxy of C svn_fs_pack_notify_t struct."""

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    def set_parent_pool(self, parent_pool=None):
      """Create a new proxy object for TYPE"""
      import libsvn.core, weakref
      self.__dict__["_parent_pool"] = \
        parent_pool or libsvn.core.application_pool;
      if self.__dict__["_parent_pool"]:
        self.__dict__["_is_valid"] = weakref.ref(
          self.__dict__["_parent_pool"]._is_valid)

    def assert_valid(self):
      """Assert that this object is using valid pool memory"""
      if "_is_valid" in self.__dict__:
        assert self.__dict__["_is_valid"](), "Variable has already been deleted"

    def _retrieve_swig_value(self, name, value):
    # If we got back a different object than we have cached, we need to copy
    # all our metadata into it, so that it looks identical to the one
    # originally set.
      members = self.__dict__.get('_members')
      if members is not None and name in members:
        _copy_metadata_deep(value, members[name])

    # Verify that the new object is good
      _assert_valid_deep(value)

      return value

    # Attribute access must be intercepted to ensure that objects coming from
    # read attribute access match those that are set with write attribute access.
    # Specifically the metadata, such as the associated apr_pool object, should
    # match the originally assigned object.
    #
    # For classic classes it is enough to use __getattr__ to intercept swig
    # derived attributes. However, with new style classes SWIG makes use of
    # descriptors which mean that __getattr__ is never called. Therefore,
    # __getattribute__ must be used for the interception.

    if _newclass:
      def __getattribute__(self, name):
        """Manage access to all attributes of this object."""

    # Start by mimicing __getattr__ behavior: immediately return __dict__ or
    # items directly present in __dict__
        mydict = object.__getattribute__(self, '__dict__')

        if name == "__dict__":
          return mydict

        if name in mydict:
          return mydict[name]

        object.__getattribute__(self, 'assert_valid')()

        value = _get_instance_attr(self, name)
        fn = object.__getattribute__(self, '_retrieve_swig_value')
        return fn(name, value)
    else:
      def __getattr__(self, name):
        """Get an attribute from this object"""
        self.assert_valid()

        value = _swig_getattr(self, self.__class__, name)

        return self._retrieve_swig_value(name, value)

    def __setattr__(self, name, value):
      """Set an attribute on this object"""
      self.assert_valid()

    # Save a copy of the object, so that the garbage
    # collector won't kill the object while it's in
    # SWIG-land
      self.__dict__.setdefault("_members",{})[name] = value

      return _set_instance_attr(self, name, value)


    def __call__(self, *args):
      return svn_fs_invoke_pack_notify(self, *args)

svn_fs_pack_notify_t_swigregister = _fs.svn_fs_pack_notify_t_swigregister
svn_fs_pack_notify_t_swigregister(svn_fs_pack_notify_t)



