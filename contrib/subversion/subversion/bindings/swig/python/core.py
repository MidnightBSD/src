# This file was automatically generated by SWIG (http://www.swig.org).
# Version 3.0.12
#
# Do not make changes to this file unless you know what you are doing--modify
# the SWIG interface file instead.


def _dll_paths():
    import os
    if hasattr(os, 'add_dll_directory'):  # Python 3.8+ on Windows
        cookies = []
        for path in os.environ.get('PATH', '').split(os.pathsep):
            if path and os.path.isabs(path):
                try:
                    cookie = os.add_dll_directory(path)
                except OSError:
                    continue
                else:
                    cookies.append(cookie)
        return cookies
    else:
        return ()

_dll_paths = _dll_paths()
try:
    from . import _core
finally:
    _dll_path = None
    for _dll_path in _dll_paths:
        _dll_path.close()
    del _dll_paths, _dll_path

try:
    _swig_property = property
except NameError:
    pass  # Python < 2.2 doesn't have 'property'.

try:
    import builtins as __builtin__
except ImportError:
    import __builtin__

def _swig_setattr_nondynamic(self, class_type, name, value, static=1):
    if (name == "thisown"):
        return self.this.own(value)
    if (name == "this"):
        if type(value).__name__ == 'SwigPyObject':
            self.__dict__[name] = value
            return
    method = class_type.__swig_setmethods__.get(name, None)
    if method:
        return method(self, value)
    if (not static):
        object.__setattr__(self, name, value)
    else:
        raise AttributeError("You cannot add attributes to %s" % self)


def _swig_setattr(self, class_type, name, value):
    return _swig_setattr_nondynamic(self, class_type, name, value, 0)


def _swig_getattr(self, class_type, name):
    if (name == "thisown"):
        return self.this.own()
    method = class_type.__swig_getmethods__.get(name, None)
    if method:
        return method(self)
    raise AttributeError("'%s' object has no attribute '%s'" % (class_type.__name__, name))


def _swig_repr(self):
    try:
        strthis = "proxy of " + self.this.__repr__()
    except __builtin__.Exception:
        strthis = ""
    return "<%s.%s; %s >" % (self.__class__.__module__, self.__class__.__name__, strthis,)


def _swig_setattr_nondynamic_method(set):
    def set_attr(self, name, value):
        if (name == "thisown"):
            return self.this.own(value)
        if hasattr(self, name) or (name == "this"):
            set(self, name, value)
        else:
            raise AttributeError("You cannot add attributes to %s" % self)
    return set_attr



def _copy_metadata_deep(value, old_value):
  """Copy all attributes of old_value into value, recursively traversing
  lists and dicts if needed."""
  if value is None or old_value is None or value is old_value: return

  if isinstance(value, dict):
    for k in value:
      _copy_metadata_deep(value[k], old_value[k])
  elif isinstance(value, list):
    for v, old_v in zip(value, old_value):
      _copy_metadata_deep(v, old_v)
  else:
    try:
      value.__dict__.update(old_value.__dict__)
    except AttributeError:
      pass

def _assert_valid_deep(value):
  """Assert value's validity, recursively traversing lists and dicts."""
  if isinstance(value, dict):
    for k in value:
      _assert_valid_deep(value[k])
  elif isinstance(value, list):
    for v in value:
      _assert_valid_deep(v)
# Ensure that the passed in value isn't a type, which could have an
# assert_valid attribute, but it can not be called without an instance.
  elif type(value) != type:
    try:
      fn = value.assert_valid
    except AttributeError:
      pass
    else:
      fn()



  # SWIG classes generated with -modern do not define this variable
try:
  _newclass
except NameError:
  _newclass = 1
else:
  raise RuntimeError("Require -modern option, but _newclass is defined")

_get_instance_attr = object.__getattribute__
_set_instance_attr = _swig_setattr_nondynamic_method(object.__setattr__)


SWIG_SVN_INVALID_REVNUM = _core.SWIG_SVN_INVALID_REVNUM
SWIG_SVN_IGNORED_REVNUM = _core.SWIG_SVN_IGNORED_REVNUM

def apr_initialize() -> "apr_status_t":
    """apr_initialize() -> apr_status_t"""
    return _core.apr_initialize()

def apr_terminate() -> "void":
    """apr_terminate()"""
    return _core.apr_terminate()

def apr_time_ansi_put(input: 'time_t') -> "apr_int64_t *":
    """apr_time_ansi_put(time_t input) -> apr_status_t"""
    return _core.apr_time_ansi_put(input)

def apr_pool_destroy(*args) -> "void":
    """apr_pool_destroy(apr_pool_t p)"""
    return _core.apr_pool_destroy(*args)

def apr_pool_clear(*args) -> "void":
    """apr_pool_clear(apr_pool_t p)"""
    return _core.apr_pool_clear(*args)

def apr_file_open_stdout(*args) -> "apr_file_t **":
    """apr_file_open_stdout(apr_pool_t pool) -> apr_status_t"""
    return _core.apr_file_open_stdout(*args)

def apr_file_open_stderr(*args) -> "apr_file_t **":
    """apr_file_open_stderr(apr_pool_t pool) -> apr_status_t"""
    return _core.apr_file_open_stderr(*args)
SVN_ERR_CATEGORY_SIZE = _core.SVN_ERR_CATEGORY_SIZE
SVN_WARNING = _core.SVN_WARNING
SVN_ERR_BAD_CONTAINING_POOL = _core.SVN_ERR_BAD_CONTAINING_POOL
SVN_ERR_BAD_FILENAME = _core.SVN_ERR_BAD_FILENAME
SVN_ERR_BAD_URL = _core.SVN_ERR_BAD_URL
SVN_ERR_BAD_DATE = _core.SVN_ERR_BAD_DATE
SVN_ERR_BAD_MIME_TYPE = _core.SVN_ERR_BAD_MIME_TYPE
SVN_ERR_BAD_PROPERTY_VALUE = _core.SVN_ERR_BAD_PROPERTY_VALUE
SVN_ERR_BAD_VERSION_FILE_FORMAT = _core.SVN_ERR_BAD_VERSION_FILE_FORMAT
SVN_ERR_BAD_RELATIVE_PATH = _core.SVN_ERR_BAD_RELATIVE_PATH
SVN_ERR_BAD_UUID = _core.SVN_ERR_BAD_UUID
SVN_ERR_BAD_CONFIG_VALUE = _core.SVN_ERR_BAD_CONFIG_VALUE
SVN_ERR_BAD_SERVER_SPECIFICATION = _core.SVN_ERR_BAD_SERVER_SPECIFICATION
SVN_ERR_BAD_CHECKSUM_KIND = _core.SVN_ERR_BAD_CHECKSUM_KIND
SVN_ERR_BAD_CHECKSUM_PARSE = _core.SVN_ERR_BAD_CHECKSUM_PARSE
SVN_ERR_BAD_TOKEN = _core.SVN_ERR_BAD_TOKEN
SVN_ERR_BAD_CHANGELIST_NAME = _core.SVN_ERR_BAD_CHANGELIST_NAME
SVN_ERR_BAD_ATOMIC = _core.SVN_ERR_BAD_ATOMIC
SVN_ERR_BAD_COMPRESSION_METHOD = _core.SVN_ERR_BAD_COMPRESSION_METHOD
SVN_ERR_BAD_PROPERTY_VALUE_EOL = _core.SVN_ERR_BAD_PROPERTY_VALUE_EOL
SVN_ERR_XML_ATTRIB_NOT_FOUND = _core.SVN_ERR_XML_ATTRIB_NOT_FOUND
SVN_ERR_XML_MISSING_ANCESTRY = _core.SVN_ERR_XML_MISSING_ANCESTRY
SVN_ERR_XML_UNKNOWN_ENCODING = _core.SVN_ERR_XML_UNKNOWN_ENCODING
SVN_ERR_XML_MALFORMED = _core.SVN_ERR_XML_MALFORMED
SVN_ERR_XML_UNESCAPABLE_DATA = _core.SVN_ERR_XML_UNESCAPABLE_DATA
SVN_ERR_XML_UNEXPECTED_ELEMENT = _core.SVN_ERR_XML_UNEXPECTED_ELEMENT
SVN_ERR_IO_INCONSISTENT_EOL = _core.SVN_ERR_IO_INCONSISTENT_EOL
SVN_ERR_IO_UNKNOWN_EOL = _core.SVN_ERR_IO_UNKNOWN_EOL
SVN_ERR_IO_CORRUPT_EOL = _core.SVN_ERR_IO_CORRUPT_EOL
SVN_ERR_IO_UNIQUE_NAMES_EXHAUSTED = _core.SVN_ERR_IO_UNIQUE_NAMES_EXHAUSTED
SVN_ERR_IO_PIPE_FRAME_ERROR = _core.SVN_ERR_IO_PIPE_FRAME_ERROR
SVN_ERR_IO_PIPE_READ_ERROR = _core.SVN_ERR_IO_PIPE_READ_ERROR
SVN_ERR_IO_WRITE_ERROR = _core.SVN_ERR_IO_WRITE_ERROR
SVN_ERR_IO_PIPE_WRITE_ERROR = _core.SVN_ERR_IO_PIPE_WRITE_ERROR
SVN_ERR_STREAM_UNEXPECTED_EOF = _core.SVN_ERR_STREAM_UNEXPECTED_EOF
SVN_ERR_STREAM_MALFORMED_DATA = _core.SVN_ERR_STREAM_MALFORMED_DATA
SVN_ERR_STREAM_UNRECOGNIZED_DATA = _core.SVN_ERR_STREAM_UNRECOGNIZED_DATA
SVN_ERR_STREAM_SEEK_NOT_SUPPORTED = _core.SVN_ERR_STREAM_SEEK_NOT_SUPPORTED
SVN_ERR_STREAM_NOT_SUPPORTED = _core.SVN_ERR_STREAM_NOT_SUPPORTED
SVN_ERR_NODE_UNKNOWN_KIND = _core.SVN_ERR_NODE_UNKNOWN_KIND
SVN_ERR_NODE_UNEXPECTED_KIND = _core.SVN_ERR_NODE_UNEXPECTED_KIND
SVN_ERR_ENTRY_NOT_FOUND = _core.SVN_ERR_ENTRY_NOT_FOUND
SVN_ERR_ENTRY_EXISTS = _core.SVN_ERR_ENTRY_EXISTS
SVN_ERR_ENTRY_MISSING_REVISION = _core.SVN_ERR_ENTRY_MISSING_REVISION
SVN_ERR_ENTRY_MISSING_URL = _core.SVN_ERR_ENTRY_MISSING_URL
SVN_ERR_ENTRY_ATTRIBUTE_INVALID = _core.SVN_ERR_ENTRY_ATTRIBUTE_INVALID
SVN_ERR_ENTRY_FORBIDDEN = _core.SVN_ERR_ENTRY_FORBIDDEN
SVN_ERR_WC_OBSTRUCTED_UPDATE = _core.SVN_ERR_WC_OBSTRUCTED_UPDATE
SVN_ERR_WC_UNWIND_MISMATCH = _core.SVN_ERR_WC_UNWIND_MISMATCH
SVN_ERR_WC_UNWIND_EMPTY = _core.SVN_ERR_WC_UNWIND_EMPTY
SVN_ERR_WC_UNWIND_NOT_EMPTY = _core.SVN_ERR_WC_UNWIND_NOT_EMPTY
SVN_ERR_WC_LOCKED = _core.SVN_ERR_WC_LOCKED
SVN_ERR_WC_NOT_LOCKED = _core.SVN_ERR_WC_NOT_LOCKED
SVN_ERR_WC_INVALID_LOCK = _core.SVN_ERR_WC_INVALID_LOCK
SVN_ERR_WC_NOT_WORKING_COPY = _core.SVN_ERR_WC_NOT_WORKING_COPY
SVN_ERR_WC_NOT_DIRECTORY = _core.SVN_ERR_WC_NOT_DIRECTORY
SVN_ERR_WC_NOT_FILE = _core.SVN_ERR_WC_NOT_FILE
SVN_ERR_WC_BAD_ADM_LOG = _core.SVN_ERR_WC_BAD_ADM_LOG
SVN_ERR_WC_PATH_NOT_FOUND = _core.SVN_ERR_WC_PATH_NOT_FOUND
SVN_ERR_WC_NOT_UP_TO_DATE = _core.SVN_ERR_WC_NOT_UP_TO_DATE
SVN_ERR_WC_LEFT_LOCAL_MOD = _core.SVN_ERR_WC_LEFT_LOCAL_MOD
SVN_ERR_WC_SCHEDULE_CONFLICT = _core.SVN_ERR_WC_SCHEDULE_CONFLICT
SVN_ERR_WC_PATH_FOUND = _core.SVN_ERR_WC_PATH_FOUND
SVN_ERR_WC_FOUND_CONFLICT = _core.SVN_ERR_WC_FOUND_CONFLICT
SVN_ERR_WC_CORRUPT = _core.SVN_ERR_WC_CORRUPT
SVN_ERR_WC_CORRUPT_TEXT_BASE = _core.SVN_ERR_WC_CORRUPT_TEXT_BASE
SVN_ERR_WC_NODE_KIND_CHANGE = _core.SVN_ERR_WC_NODE_KIND_CHANGE
SVN_ERR_WC_INVALID_OP_ON_CWD = _core.SVN_ERR_WC_INVALID_OP_ON_CWD
SVN_ERR_WC_BAD_ADM_LOG_START = _core.SVN_ERR_WC_BAD_ADM_LOG_START
SVN_ERR_WC_UNSUPPORTED_FORMAT = _core.SVN_ERR_WC_UNSUPPORTED_FORMAT
SVN_ERR_WC_BAD_PATH = _core.SVN_ERR_WC_BAD_PATH
SVN_ERR_WC_INVALID_SCHEDULE = _core.SVN_ERR_WC_INVALID_SCHEDULE
SVN_ERR_WC_INVALID_RELOCATION = _core.SVN_ERR_WC_INVALID_RELOCATION
SVN_ERR_WC_INVALID_SWITCH = _core.SVN_ERR_WC_INVALID_SWITCH
SVN_ERR_WC_MISMATCHED_CHANGELIST = _core.SVN_ERR_WC_MISMATCHED_CHANGELIST
SVN_ERR_WC_CONFLICT_RESOLVER_FAILURE = _core.SVN_ERR_WC_CONFLICT_RESOLVER_FAILURE
SVN_ERR_WC_COPYFROM_PATH_NOT_FOUND = _core.SVN_ERR_WC_COPYFROM_PATH_NOT_FOUND
SVN_ERR_WC_CHANGELIST_MOVE = _core.SVN_ERR_WC_CHANGELIST_MOVE
SVN_ERR_WC_CANNOT_DELETE_FILE_EXTERNAL = _core.SVN_ERR_WC_CANNOT_DELETE_FILE_EXTERNAL
SVN_ERR_WC_CANNOT_MOVE_FILE_EXTERNAL = _core.SVN_ERR_WC_CANNOT_MOVE_FILE_EXTERNAL
SVN_ERR_WC_DB_ERROR = _core.SVN_ERR_WC_DB_ERROR
SVN_ERR_WC_MISSING = _core.SVN_ERR_WC_MISSING
SVN_ERR_WC_NOT_SYMLINK = _core.SVN_ERR_WC_NOT_SYMLINK
SVN_ERR_WC_PATH_UNEXPECTED_STATUS = _core.SVN_ERR_WC_PATH_UNEXPECTED_STATUS
SVN_ERR_WC_UPGRADE_REQUIRED = _core.SVN_ERR_WC_UPGRADE_REQUIRED
SVN_ERR_WC_CLEANUP_REQUIRED = _core.SVN_ERR_WC_CLEANUP_REQUIRED
SVN_ERR_WC_INVALID_OPERATION_DEPTH = _core.SVN_ERR_WC_INVALID_OPERATION_DEPTH
SVN_ERR_WC_PATH_ACCESS_DENIED = _core.SVN_ERR_WC_PATH_ACCESS_DENIED
SVN_ERR_WC_MIXED_REVISIONS = _core.SVN_ERR_WC_MIXED_REVISIONS
SVN_ERR_WC_DUPLICATE_EXTERNALS_TARGET = _core.SVN_ERR_WC_DUPLICATE_EXTERNALS_TARGET
SVN_ERR_FS_GENERAL = _core.SVN_ERR_FS_GENERAL
SVN_ERR_FS_CLEANUP = _core.SVN_ERR_FS_CLEANUP
SVN_ERR_FS_ALREADY_OPEN = _core.SVN_ERR_FS_ALREADY_OPEN
SVN_ERR_FS_NOT_OPEN = _core.SVN_ERR_FS_NOT_OPEN
SVN_ERR_FS_CORRUPT = _core.SVN_ERR_FS_CORRUPT
SVN_ERR_FS_PATH_SYNTAX = _core.SVN_ERR_FS_PATH_SYNTAX
SVN_ERR_FS_NO_SUCH_REVISION = _core.SVN_ERR_FS_NO_SUCH_REVISION
SVN_ERR_FS_NO_SUCH_TRANSACTION = _core.SVN_ERR_FS_NO_SUCH_TRANSACTION
SVN_ERR_FS_NO_SUCH_ENTRY = _core.SVN_ERR_FS_NO_SUCH_ENTRY
SVN_ERR_FS_NO_SUCH_REPRESENTATION = _core.SVN_ERR_FS_NO_SUCH_REPRESENTATION
SVN_ERR_FS_NO_SUCH_STRING = _core.SVN_ERR_FS_NO_SUCH_STRING
SVN_ERR_FS_NO_SUCH_COPY = _core.SVN_ERR_FS_NO_SUCH_COPY
SVN_ERR_FS_TRANSACTION_NOT_MUTABLE = _core.SVN_ERR_FS_TRANSACTION_NOT_MUTABLE
SVN_ERR_FS_NOT_FOUND = _core.SVN_ERR_FS_NOT_FOUND
SVN_ERR_FS_ID_NOT_FOUND = _core.SVN_ERR_FS_ID_NOT_FOUND
SVN_ERR_FS_NOT_ID = _core.SVN_ERR_FS_NOT_ID
SVN_ERR_FS_NOT_DIRECTORY = _core.SVN_ERR_FS_NOT_DIRECTORY
SVN_ERR_FS_NOT_FILE = _core.SVN_ERR_FS_NOT_FILE
SVN_ERR_FS_NOT_SINGLE_PATH_COMPONENT = _core.SVN_ERR_FS_NOT_SINGLE_PATH_COMPONENT
SVN_ERR_FS_NOT_MUTABLE = _core.SVN_ERR_FS_NOT_MUTABLE
SVN_ERR_FS_ALREADY_EXISTS = _core.SVN_ERR_FS_ALREADY_EXISTS
SVN_ERR_FS_ROOT_DIR = _core.SVN_ERR_FS_ROOT_DIR
SVN_ERR_FS_NOT_TXN_ROOT = _core.SVN_ERR_FS_NOT_TXN_ROOT
SVN_ERR_FS_NOT_REVISION_ROOT = _core.SVN_ERR_FS_NOT_REVISION_ROOT
SVN_ERR_FS_CONFLICT = _core.SVN_ERR_FS_CONFLICT
SVN_ERR_FS_REP_CHANGED = _core.SVN_ERR_FS_REP_CHANGED
SVN_ERR_FS_REP_NOT_MUTABLE = _core.SVN_ERR_FS_REP_NOT_MUTABLE
SVN_ERR_FS_MALFORMED_SKEL = _core.SVN_ERR_FS_MALFORMED_SKEL
SVN_ERR_FS_TXN_OUT_OF_DATE = _core.SVN_ERR_FS_TXN_OUT_OF_DATE
SVN_ERR_FS_BERKELEY_DB = _core.SVN_ERR_FS_BERKELEY_DB
SVN_ERR_FS_BERKELEY_DB_DEADLOCK = _core.SVN_ERR_FS_BERKELEY_DB_DEADLOCK
SVN_ERR_FS_TRANSACTION_DEAD = _core.SVN_ERR_FS_TRANSACTION_DEAD
SVN_ERR_FS_TRANSACTION_NOT_DEAD = _core.SVN_ERR_FS_TRANSACTION_NOT_DEAD
SVN_ERR_FS_UNKNOWN_FS_TYPE = _core.SVN_ERR_FS_UNKNOWN_FS_TYPE
SVN_ERR_FS_NO_USER = _core.SVN_ERR_FS_NO_USER
SVN_ERR_FS_PATH_ALREADY_LOCKED = _core.SVN_ERR_FS_PATH_ALREADY_LOCKED
SVN_ERR_FS_PATH_NOT_LOCKED = _core.SVN_ERR_FS_PATH_NOT_LOCKED
SVN_ERR_FS_BAD_LOCK_TOKEN = _core.SVN_ERR_FS_BAD_LOCK_TOKEN
SVN_ERR_FS_NO_LOCK_TOKEN = _core.SVN_ERR_FS_NO_LOCK_TOKEN
SVN_ERR_FS_LOCK_OWNER_MISMATCH = _core.SVN_ERR_FS_LOCK_OWNER_MISMATCH
SVN_ERR_FS_NO_SUCH_LOCK = _core.SVN_ERR_FS_NO_SUCH_LOCK
SVN_ERR_FS_LOCK_EXPIRED = _core.SVN_ERR_FS_LOCK_EXPIRED
SVN_ERR_FS_OUT_OF_DATE = _core.SVN_ERR_FS_OUT_OF_DATE
SVN_ERR_FS_UNSUPPORTED_FORMAT = _core.SVN_ERR_FS_UNSUPPORTED_FORMAT
SVN_ERR_FS_REP_BEING_WRITTEN = _core.SVN_ERR_FS_REP_BEING_WRITTEN
SVN_ERR_FS_TXN_NAME_TOO_LONG = _core.SVN_ERR_FS_TXN_NAME_TOO_LONG
SVN_ERR_FS_NO_SUCH_NODE_ORIGIN = _core.SVN_ERR_FS_NO_SUCH_NODE_ORIGIN
SVN_ERR_FS_UNSUPPORTED_UPGRADE = _core.SVN_ERR_FS_UNSUPPORTED_UPGRADE
SVN_ERR_FS_NO_SUCH_CHECKSUM_REP = _core.SVN_ERR_FS_NO_SUCH_CHECKSUM_REP
SVN_ERR_FS_PROP_BASEVALUE_MISMATCH = _core.SVN_ERR_FS_PROP_BASEVALUE_MISMATCH
SVN_ERR_FS_INCORRECT_EDITOR_COMPLETION = _core.SVN_ERR_FS_INCORRECT_EDITOR_COMPLETION
SVN_ERR_FS_PACKED_REVPROP_READ_FAILURE = _core.SVN_ERR_FS_PACKED_REVPROP_READ_FAILURE
SVN_ERR_FS_REVPROP_CACHE_INIT_FAILURE = _core.SVN_ERR_FS_REVPROP_CACHE_INIT_FAILURE
SVN_ERR_FS_MALFORMED_TXN_ID = _core.SVN_ERR_FS_MALFORMED_TXN_ID
SVN_ERR_FS_INDEX_CORRUPTION = _core.SVN_ERR_FS_INDEX_CORRUPTION
SVN_ERR_FS_INDEX_REVISION = _core.SVN_ERR_FS_INDEX_REVISION
SVN_ERR_FS_INDEX_OVERFLOW = _core.SVN_ERR_FS_INDEX_OVERFLOW
SVN_ERR_FS_CONTAINER_INDEX = _core.SVN_ERR_FS_CONTAINER_INDEX
SVN_ERR_FS_INDEX_INCONSISTENT = _core.SVN_ERR_FS_INDEX_INCONSISTENT
SVN_ERR_FS_LOCK_OPERATION_FAILED = _core.SVN_ERR_FS_LOCK_OPERATION_FAILED
SVN_ERR_FS_UNSUPPORTED_TYPE = _core.SVN_ERR_FS_UNSUPPORTED_TYPE
SVN_ERR_FS_CONTAINER_SIZE = _core.SVN_ERR_FS_CONTAINER_SIZE
SVN_ERR_FS_MALFORMED_NODEREV_ID = _core.SVN_ERR_FS_MALFORMED_NODEREV_ID
SVN_ERR_FS_INVALID_GENERATION = _core.SVN_ERR_FS_INVALID_GENERATION
SVN_ERR_FS_CORRUPT_REVPROP_MANIFEST = _core.SVN_ERR_FS_CORRUPT_REVPROP_MANIFEST
SVN_ERR_FS_CORRUPT_PROPLIST = _core.SVN_ERR_FS_CORRUPT_PROPLIST
SVN_ERR_FS_AMBIGUOUS_CHECKSUM_REP = _core.SVN_ERR_FS_AMBIGUOUS_CHECKSUM_REP
SVN_ERR_FS_UNRECOGNIZED_IOCTL_CODE = _core.SVN_ERR_FS_UNRECOGNIZED_IOCTL_CODE
SVN_ERR_FS_REP_SHARING_NOT_ALLOWED = _core.SVN_ERR_FS_REP_SHARING_NOT_ALLOWED
SVN_ERR_FS_REP_SHARING_NOT_SUPPORTED = _core.SVN_ERR_FS_REP_SHARING_NOT_SUPPORTED
SVN_ERR_REPOS_LOCKED = _core.SVN_ERR_REPOS_LOCKED
SVN_ERR_REPOS_HOOK_FAILURE = _core.SVN_ERR_REPOS_HOOK_FAILURE
SVN_ERR_REPOS_BAD_ARGS = _core.SVN_ERR_REPOS_BAD_ARGS
SVN_ERR_REPOS_NO_DATA_FOR_REPORT = _core.SVN_ERR_REPOS_NO_DATA_FOR_REPORT
SVN_ERR_REPOS_BAD_REVISION_REPORT = _core.SVN_ERR_REPOS_BAD_REVISION_REPORT
SVN_ERR_REPOS_UNSUPPORTED_VERSION = _core.SVN_ERR_REPOS_UNSUPPORTED_VERSION
SVN_ERR_REPOS_DISABLED_FEATURE = _core.SVN_ERR_REPOS_DISABLED_FEATURE
SVN_ERR_REPOS_POST_COMMIT_HOOK_FAILED = _core.SVN_ERR_REPOS_POST_COMMIT_HOOK_FAILED
SVN_ERR_REPOS_POST_LOCK_HOOK_FAILED = _core.SVN_ERR_REPOS_POST_LOCK_HOOK_FAILED
SVN_ERR_REPOS_POST_UNLOCK_HOOK_FAILED = _core.SVN_ERR_REPOS_POST_UNLOCK_HOOK_FAILED
SVN_ERR_REPOS_UNSUPPORTED_UPGRADE = _core.SVN_ERR_REPOS_UNSUPPORTED_UPGRADE
SVN_ERR_RA_ILLEGAL_URL = _core.SVN_ERR_RA_ILLEGAL_URL
SVN_ERR_RA_NOT_AUTHORIZED = _core.SVN_ERR_RA_NOT_AUTHORIZED
SVN_ERR_RA_UNKNOWN_AUTH = _core.SVN_ERR_RA_UNKNOWN_AUTH
SVN_ERR_RA_NOT_IMPLEMENTED = _core.SVN_ERR_RA_NOT_IMPLEMENTED
SVN_ERR_RA_OUT_OF_DATE = _core.SVN_ERR_RA_OUT_OF_DATE
SVN_ERR_RA_NO_REPOS_UUID = _core.SVN_ERR_RA_NO_REPOS_UUID
SVN_ERR_RA_UNSUPPORTED_ABI_VERSION = _core.SVN_ERR_RA_UNSUPPORTED_ABI_VERSION
SVN_ERR_RA_NOT_LOCKED = _core.SVN_ERR_RA_NOT_LOCKED
SVN_ERR_RA_PARTIAL_REPLAY_NOT_SUPPORTED = _core.SVN_ERR_RA_PARTIAL_REPLAY_NOT_SUPPORTED
SVN_ERR_RA_UUID_MISMATCH = _core.SVN_ERR_RA_UUID_MISMATCH
SVN_ERR_RA_REPOS_ROOT_URL_MISMATCH = _core.SVN_ERR_RA_REPOS_ROOT_URL_MISMATCH
SVN_ERR_RA_SESSION_URL_MISMATCH = _core.SVN_ERR_RA_SESSION_URL_MISMATCH
SVN_ERR_RA_CANNOT_CREATE_TUNNEL = _core.SVN_ERR_RA_CANNOT_CREATE_TUNNEL
SVN_ERR_RA_CANNOT_CREATE_SESSION = _core.SVN_ERR_RA_CANNOT_CREATE_SESSION
SVN_ERR_RA_DAV_SOCK_INIT = _core.SVN_ERR_RA_DAV_SOCK_INIT
SVN_ERR_RA_DAV_CREATING_REQUEST = _core.SVN_ERR_RA_DAV_CREATING_REQUEST
SVN_ERR_RA_DAV_REQUEST_FAILED = _core.SVN_ERR_RA_DAV_REQUEST_FAILED
SVN_ERR_RA_DAV_OPTIONS_REQ_FAILED = _core.SVN_ERR_RA_DAV_OPTIONS_REQ_FAILED
SVN_ERR_RA_DAV_PROPS_NOT_FOUND = _core.SVN_ERR_RA_DAV_PROPS_NOT_FOUND
SVN_ERR_RA_DAV_ALREADY_EXISTS = _core.SVN_ERR_RA_DAV_ALREADY_EXISTS
SVN_ERR_RA_DAV_INVALID_CONFIG_VALUE = _core.SVN_ERR_RA_DAV_INVALID_CONFIG_VALUE
SVN_ERR_RA_DAV_PATH_NOT_FOUND = _core.SVN_ERR_RA_DAV_PATH_NOT_FOUND
SVN_ERR_RA_DAV_PROPPATCH_FAILED = _core.SVN_ERR_RA_DAV_PROPPATCH_FAILED
SVN_ERR_RA_DAV_MALFORMED_DATA = _core.SVN_ERR_RA_DAV_MALFORMED_DATA
SVN_ERR_RA_DAV_RESPONSE_HEADER_BADNESS = _core.SVN_ERR_RA_DAV_RESPONSE_HEADER_BADNESS
SVN_ERR_RA_DAV_RELOCATED = _core.SVN_ERR_RA_DAV_RELOCATED
SVN_ERR_RA_DAV_CONN_TIMEOUT = _core.SVN_ERR_RA_DAV_CONN_TIMEOUT
SVN_ERR_RA_DAV_FORBIDDEN = _core.SVN_ERR_RA_DAV_FORBIDDEN
SVN_ERR_RA_DAV_PRECONDITION_FAILED = _core.SVN_ERR_RA_DAV_PRECONDITION_FAILED
SVN_ERR_RA_DAV_METHOD_NOT_ALLOWED = _core.SVN_ERR_RA_DAV_METHOD_NOT_ALLOWED
SVN_ERR_RA_LOCAL_REPOS_NOT_FOUND = _core.SVN_ERR_RA_LOCAL_REPOS_NOT_FOUND
SVN_ERR_RA_LOCAL_REPOS_OPEN_FAILED = _core.SVN_ERR_RA_LOCAL_REPOS_OPEN_FAILED
SVN_ERR_SVNDIFF_INVALID_HEADER = _core.SVN_ERR_SVNDIFF_INVALID_HEADER
SVN_ERR_SVNDIFF_CORRUPT_WINDOW = _core.SVN_ERR_SVNDIFF_CORRUPT_WINDOW
SVN_ERR_SVNDIFF_BACKWARD_VIEW = _core.SVN_ERR_SVNDIFF_BACKWARD_VIEW
SVN_ERR_SVNDIFF_INVALID_OPS = _core.SVN_ERR_SVNDIFF_INVALID_OPS
SVN_ERR_SVNDIFF_UNEXPECTED_END = _core.SVN_ERR_SVNDIFF_UNEXPECTED_END
SVN_ERR_SVNDIFF_INVALID_COMPRESSED_DATA = _core.SVN_ERR_SVNDIFF_INVALID_COMPRESSED_DATA
SVN_ERR_APMOD_MISSING_PATH_TO_FS = _core.SVN_ERR_APMOD_MISSING_PATH_TO_FS
SVN_ERR_APMOD_MALFORMED_URI = _core.SVN_ERR_APMOD_MALFORMED_URI
SVN_ERR_APMOD_ACTIVITY_NOT_FOUND = _core.SVN_ERR_APMOD_ACTIVITY_NOT_FOUND
SVN_ERR_APMOD_BAD_BASELINE = _core.SVN_ERR_APMOD_BAD_BASELINE
SVN_ERR_APMOD_CONNECTION_ABORTED = _core.SVN_ERR_APMOD_CONNECTION_ABORTED
SVN_ERR_CLIENT_VERSIONED_PATH_REQUIRED = _core.SVN_ERR_CLIENT_VERSIONED_PATH_REQUIRED
SVN_ERR_CLIENT_RA_ACCESS_REQUIRED = _core.SVN_ERR_CLIENT_RA_ACCESS_REQUIRED
SVN_ERR_CLIENT_BAD_REVISION = _core.SVN_ERR_CLIENT_BAD_REVISION
SVN_ERR_CLIENT_DUPLICATE_COMMIT_URL = _core.SVN_ERR_CLIENT_DUPLICATE_COMMIT_URL
SVN_ERR_CLIENT_IS_BINARY_FILE = _core.SVN_ERR_CLIENT_IS_BINARY_FILE
SVN_ERR_CLIENT_INVALID_EXTERNALS_DESCRIPTION = _core.SVN_ERR_CLIENT_INVALID_EXTERNALS_DESCRIPTION
SVN_ERR_CLIENT_MODIFIED = _core.SVN_ERR_CLIENT_MODIFIED
SVN_ERR_CLIENT_IS_DIRECTORY = _core.SVN_ERR_CLIENT_IS_DIRECTORY
SVN_ERR_CLIENT_REVISION_RANGE = _core.SVN_ERR_CLIENT_REVISION_RANGE
SVN_ERR_CLIENT_INVALID_RELOCATION = _core.SVN_ERR_CLIENT_INVALID_RELOCATION
SVN_ERR_CLIENT_REVISION_AUTHOR_CONTAINS_NEWLINE = _core.SVN_ERR_CLIENT_REVISION_AUTHOR_CONTAINS_NEWLINE
SVN_ERR_CLIENT_PROPERTY_NAME = _core.SVN_ERR_CLIENT_PROPERTY_NAME
SVN_ERR_CLIENT_UNRELATED_RESOURCES = _core.SVN_ERR_CLIENT_UNRELATED_RESOURCES
SVN_ERR_CLIENT_MISSING_LOCK_TOKEN = _core.SVN_ERR_CLIENT_MISSING_LOCK_TOKEN
SVN_ERR_CLIENT_MULTIPLE_SOURCES_DISALLOWED = _core.SVN_ERR_CLIENT_MULTIPLE_SOURCES_DISALLOWED
SVN_ERR_CLIENT_NO_VERSIONED_PARENT = _core.SVN_ERR_CLIENT_NO_VERSIONED_PARENT
SVN_ERR_CLIENT_NOT_READY_TO_MERGE = _core.SVN_ERR_CLIENT_NOT_READY_TO_MERGE
SVN_ERR_CLIENT_FILE_EXTERNAL_OVERWRITE_VERSIONED = _core.SVN_ERR_CLIENT_FILE_EXTERNAL_OVERWRITE_VERSIONED
SVN_ERR_CLIENT_PATCH_BAD_STRIP_COUNT = _core.SVN_ERR_CLIENT_PATCH_BAD_STRIP_COUNT
SVN_ERR_CLIENT_CYCLE_DETECTED = _core.SVN_ERR_CLIENT_CYCLE_DETECTED
SVN_ERR_CLIENT_MERGE_UPDATE_REQUIRED = _core.SVN_ERR_CLIENT_MERGE_UPDATE_REQUIRED
SVN_ERR_CLIENT_INVALID_MERGEINFO_NO_MERGETRACKING = _core.SVN_ERR_CLIENT_INVALID_MERGEINFO_NO_MERGETRACKING
SVN_ERR_CLIENT_NO_LOCK_TOKEN = _core.SVN_ERR_CLIENT_NO_LOCK_TOKEN
SVN_ERR_CLIENT_FORBIDDEN_BY_SERVER = _core.SVN_ERR_CLIENT_FORBIDDEN_BY_SERVER
SVN_ERR_CLIENT_CONFLICT_OPTION_NOT_APPLICABLE = _core.SVN_ERR_CLIENT_CONFLICT_OPTION_NOT_APPLICABLE
SVN_ERR_BASE = _core.SVN_ERR_BASE
SVN_ERR_PLUGIN_LOAD_FAILURE = _core.SVN_ERR_PLUGIN_LOAD_FAILURE
SVN_ERR_MALFORMED_FILE = _core.SVN_ERR_MALFORMED_FILE
SVN_ERR_INCOMPLETE_DATA = _core.SVN_ERR_INCOMPLETE_DATA
SVN_ERR_INCORRECT_PARAMS = _core.SVN_ERR_INCORRECT_PARAMS
SVN_ERR_UNVERSIONED_RESOURCE = _core.SVN_ERR_UNVERSIONED_RESOURCE
SVN_ERR_TEST_FAILED = _core.SVN_ERR_TEST_FAILED
SVN_ERR_UNSUPPORTED_FEATURE = _core.SVN_ERR_UNSUPPORTED_FEATURE
SVN_ERR_BAD_PROP_KIND = _core.SVN_ERR_BAD_PROP_KIND
SVN_ERR_ILLEGAL_TARGET = _core.SVN_ERR_ILLEGAL_TARGET
SVN_ERR_DELTA_MD5_CHECKSUM_ABSENT = _core.SVN_ERR_DELTA_MD5_CHECKSUM_ABSENT
SVN_ERR_DIR_NOT_EMPTY = _core.SVN_ERR_DIR_NOT_EMPTY
SVN_ERR_EXTERNAL_PROGRAM = _core.SVN_ERR_EXTERNAL_PROGRAM
SVN_ERR_SWIG_PY_EXCEPTION_SET = _core.SVN_ERR_SWIG_PY_EXCEPTION_SET
SVN_ERR_CHECKSUM_MISMATCH = _core.SVN_ERR_CHECKSUM_MISMATCH
SVN_ERR_CANCELLED = _core.SVN_ERR_CANCELLED
SVN_ERR_INVALID_DIFF_OPTION = _core.SVN_ERR_INVALID_DIFF_OPTION
SVN_ERR_PROPERTY_NOT_FOUND = _core.SVN_ERR_PROPERTY_NOT_FOUND
SVN_ERR_NO_AUTH_FILE_PATH = _core.SVN_ERR_NO_AUTH_FILE_PATH
SVN_ERR_VERSION_MISMATCH = _core.SVN_ERR_VERSION_MISMATCH
SVN_ERR_MERGEINFO_PARSE_ERROR = _core.SVN_ERR_MERGEINFO_PARSE_ERROR
SVN_ERR_CEASE_INVOCATION = _core.SVN_ERR_CEASE_INVOCATION
SVN_ERR_REVNUM_PARSE_FAILURE = _core.SVN_ERR_REVNUM_PARSE_FAILURE
SVN_ERR_ITER_BREAK = _core.SVN_ERR_ITER_BREAK
SVN_ERR_UNKNOWN_CHANGELIST = _core.SVN_ERR_UNKNOWN_CHANGELIST
SVN_ERR_RESERVED_FILENAME_SPECIFIED = _core.SVN_ERR_RESERVED_FILENAME_SPECIFIED
SVN_ERR_UNKNOWN_CAPABILITY = _core.SVN_ERR_UNKNOWN_CAPABILITY
SVN_ERR_TEST_SKIPPED = _core.SVN_ERR_TEST_SKIPPED
SVN_ERR_NO_APR_MEMCACHE = _core.SVN_ERR_NO_APR_MEMCACHE
SVN_ERR_ATOMIC_INIT_FAILURE = _core.SVN_ERR_ATOMIC_INIT_FAILURE
SVN_ERR_SQLITE_ERROR = _core.SVN_ERR_SQLITE_ERROR
SVN_ERR_SQLITE_READONLY = _core.SVN_ERR_SQLITE_READONLY
SVN_ERR_SQLITE_UNSUPPORTED_SCHEMA = _core.SVN_ERR_SQLITE_UNSUPPORTED_SCHEMA
SVN_ERR_SQLITE_BUSY = _core.SVN_ERR_SQLITE_BUSY
SVN_ERR_SQLITE_RESETTING_FOR_ROLLBACK = _core.SVN_ERR_SQLITE_RESETTING_FOR_ROLLBACK
SVN_ERR_SQLITE_CONSTRAINT = _core.SVN_ERR_SQLITE_CONSTRAINT
SVN_ERR_TOO_MANY_MEMCACHED_SERVERS = _core.SVN_ERR_TOO_MANY_MEMCACHED_SERVERS
SVN_ERR_MALFORMED_VERSION_STRING = _core.SVN_ERR_MALFORMED_VERSION_STRING
SVN_ERR_CORRUPTED_ATOMIC_STORAGE = _core.SVN_ERR_CORRUPTED_ATOMIC_STORAGE
SVN_ERR_UTF8PROC_ERROR = _core.SVN_ERR_UTF8PROC_ERROR
SVN_ERR_UTF8_GLOB = _core.SVN_ERR_UTF8_GLOB
SVN_ERR_CORRUPT_PACKED_DATA = _core.SVN_ERR_CORRUPT_PACKED_DATA
SVN_ERR_COMPOSED_ERROR = _core.SVN_ERR_COMPOSED_ERROR
SVN_ERR_INVALID_INPUT = _core.SVN_ERR_INVALID_INPUT
SVN_ERR_SQLITE_ROLLBACK_FAILED = _core.SVN_ERR_SQLITE_ROLLBACK_FAILED
SVN_ERR_LZ4_COMPRESSION_FAILED = _core.SVN_ERR_LZ4_COMPRESSION_FAILED
SVN_ERR_LZ4_DECOMPRESSION_FAILED = _core.SVN_ERR_LZ4_DECOMPRESSION_FAILED
SVN_ERR_CANONICALIZATION_FAILED = _core.SVN_ERR_CANONICALIZATION_FAILED
SVN_ERR_CL_ARG_PARSING_ERROR = _core.SVN_ERR_CL_ARG_PARSING_ERROR
SVN_ERR_CL_INSUFFICIENT_ARGS = _core.SVN_ERR_CL_INSUFFICIENT_ARGS
SVN_ERR_CL_MUTUALLY_EXCLUSIVE_ARGS = _core.SVN_ERR_CL_MUTUALLY_EXCLUSIVE_ARGS
SVN_ERR_CL_ADM_DIR_RESERVED = _core.SVN_ERR_CL_ADM_DIR_RESERVED
SVN_ERR_CL_LOG_MESSAGE_IS_VERSIONED_FILE = _core.SVN_ERR_CL_LOG_MESSAGE_IS_VERSIONED_FILE
SVN_ERR_CL_LOG_MESSAGE_IS_PATHNAME = _core.SVN_ERR_CL_LOG_MESSAGE_IS_PATHNAME
SVN_ERR_CL_COMMIT_IN_ADDED_DIR = _core.SVN_ERR_CL_COMMIT_IN_ADDED_DIR
SVN_ERR_CL_NO_EXTERNAL_EDITOR = _core.SVN_ERR_CL_NO_EXTERNAL_EDITOR
SVN_ERR_CL_BAD_LOG_MESSAGE = _core.SVN_ERR_CL_BAD_LOG_MESSAGE
SVN_ERR_CL_UNNECESSARY_LOG_MESSAGE = _core.SVN_ERR_CL_UNNECESSARY_LOG_MESSAGE
SVN_ERR_CL_NO_EXTERNAL_MERGE_TOOL = _core.SVN_ERR_CL_NO_EXTERNAL_MERGE_TOOL
SVN_ERR_CL_ERROR_PROCESSING_EXTERNALS = _core.SVN_ERR_CL_ERROR_PROCESSING_EXTERNALS
SVN_ERR_CL_REPOS_VERIFY_FAILED = _core.SVN_ERR_CL_REPOS_VERIFY_FAILED
SVN_ERR_RA_SVN_CMD_ERR = _core.SVN_ERR_RA_SVN_CMD_ERR
SVN_ERR_RA_SVN_UNKNOWN_CMD = _core.SVN_ERR_RA_SVN_UNKNOWN_CMD
SVN_ERR_RA_SVN_CONNECTION_CLOSED = _core.SVN_ERR_RA_SVN_CONNECTION_CLOSED
SVN_ERR_RA_SVN_IO_ERROR = _core.SVN_ERR_RA_SVN_IO_ERROR
SVN_ERR_RA_SVN_MALFORMED_DATA = _core.SVN_ERR_RA_SVN_MALFORMED_DATA
SVN_ERR_RA_SVN_REPOS_NOT_FOUND = _core.SVN_ERR_RA_SVN_REPOS_NOT_FOUND
SVN_ERR_RA_SVN_BAD_VERSION = _core.SVN_ERR_RA_SVN_BAD_VERSION
SVN_ERR_RA_SVN_NO_MECHANISMS = _core.SVN_ERR_RA_SVN_NO_MECHANISMS
SVN_ERR_RA_SVN_EDIT_ABORTED = _core.SVN_ERR_RA_SVN_EDIT_ABORTED
SVN_ERR_RA_SVN_REQUEST_SIZE = _core.SVN_ERR_RA_SVN_REQUEST_SIZE
SVN_ERR_RA_SVN_RESPONSE_SIZE = _core.SVN_ERR_RA_SVN_RESPONSE_SIZE
SVN_ERR_AUTHN_CREDS_UNAVAILABLE = _core.SVN_ERR_AUTHN_CREDS_UNAVAILABLE
SVN_ERR_AUTHN_NO_PROVIDER = _core.SVN_ERR_AUTHN_NO_PROVIDER
SVN_ERR_AUTHN_PROVIDERS_EXHAUSTED = _core.SVN_ERR_AUTHN_PROVIDERS_EXHAUSTED
SVN_ERR_AUTHN_CREDS_NOT_SAVED = _core.SVN_ERR_AUTHN_CREDS_NOT_SAVED
SVN_ERR_AUTHN_FAILED = _core.SVN_ERR_AUTHN_FAILED
SVN_ERR_AUTHZ_ROOT_UNREADABLE = _core.SVN_ERR_AUTHZ_ROOT_UNREADABLE
SVN_ERR_AUTHZ_UNREADABLE = _core.SVN_ERR_AUTHZ_UNREADABLE
SVN_ERR_AUTHZ_PARTIALLY_READABLE = _core.SVN_ERR_AUTHZ_PARTIALLY_READABLE
SVN_ERR_AUTHZ_INVALID_CONFIG = _core.SVN_ERR_AUTHZ_INVALID_CONFIG
SVN_ERR_AUTHZ_UNWRITABLE = _core.SVN_ERR_AUTHZ_UNWRITABLE
SVN_ERR_DIFF_DATASOURCE_MODIFIED = _core.SVN_ERR_DIFF_DATASOURCE_MODIFIED
SVN_ERR_DIFF_UNEXPECTED_DATA = _core.SVN_ERR_DIFF_UNEXPECTED_DATA
SVN_ERR_RA_SERF_SSPI_INITIALISATION_FAILED = _core.SVN_ERR_RA_SERF_SSPI_INITIALISATION_FAILED
SVN_ERR_RA_SERF_SSL_CERT_UNTRUSTED = _core.SVN_ERR_RA_SERF_SSL_CERT_UNTRUSTED
SVN_ERR_RA_SERF_GSSAPI_INITIALISATION_FAILED = _core.SVN_ERR_RA_SERF_GSSAPI_INITIALISATION_FAILED
SVN_ERR_RA_SERF_WRAPPED_ERROR = _core.SVN_ERR_RA_SERF_WRAPPED_ERROR
SVN_ERR_RA_SERF_STREAM_BUCKET_READ_ERROR = _core.SVN_ERR_RA_SERF_STREAM_BUCKET_READ_ERROR
SVN_ERR_ASSERTION_FAIL = _core.SVN_ERR_ASSERTION_FAIL
SVN_ERR_ASSERTION_ONLY_TRACING_LINKS = _core.SVN_ERR_ASSERTION_ONLY_TRACING_LINKS
SVN_ERR_ASN1_OUT_OF_DATA = _core.SVN_ERR_ASN1_OUT_OF_DATA
SVN_ERR_ASN1_UNEXPECTED_TAG = _core.SVN_ERR_ASN1_UNEXPECTED_TAG
SVN_ERR_ASN1_INVALID_LENGTH = _core.SVN_ERR_ASN1_INVALID_LENGTH
SVN_ERR_ASN1_LENGTH_MISMATCH = _core.SVN_ERR_ASN1_LENGTH_MISMATCH
SVN_ERR_ASN1_INVALID_DATA = _core.SVN_ERR_ASN1_INVALID_DATA
SVN_ERR_X509_FEATURE_UNAVAILABLE = _core.SVN_ERR_X509_FEATURE_UNAVAILABLE
SVN_ERR_X509_CERT_INVALID_PEM = _core.SVN_ERR_X509_CERT_INVALID_PEM
SVN_ERR_X509_CERT_INVALID_FORMAT = _core.SVN_ERR_X509_CERT_INVALID_FORMAT
SVN_ERR_X509_CERT_INVALID_VERSION = _core.SVN_ERR_X509_CERT_INVALID_VERSION
SVN_ERR_X509_CERT_INVALID_SERIAL = _core.SVN_ERR_X509_CERT_INVALID_SERIAL
SVN_ERR_X509_CERT_INVALID_ALG = _core.SVN_ERR_X509_CERT_INVALID_ALG
SVN_ERR_X509_CERT_INVALID_NAME = _core.SVN_ERR_X509_CERT_INVALID_NAME
SVN_ERR_X509_CERT_INVALID_DATE = _core.SVN_ERR_X509_CERT_INVALID_DATE
SVN_ERR_X509_CERT_INVALID_PUBKEY = _core.SVN_ERR_X509_CERT_INVALID_PUBKEY
SVN_ERR_X509_CERT_INVALID_SIGNATURE = _core.SVN_ERR_X509_CERT_INVALID_SIGNATURE
SVN_ERR_X509_CERT_INVALID_EXTENSIONS = _core.SVN_ERR_X509_CERT_INVALID_EXTENSIONS
SVN_ERR_X509_CERT_UNKNOWN_VERSION = _core.SVN_ERR_X509_CERT_UNKNOWN_VERSION
SVN_ERR_X509_CERT_UNKNOWN_PK_ALG = _core.SVN_ERR_X509_CERT_UNKNOWN_PK_ALG
SVN_ERR_X509_CERT_SIG_MISMATCH = _core.SVN_ERR_X509_CERT_SIG_MISMATCH
SVN_ERR_X509_CERT_VERIFY_FAILED = _core.SVN_ERR_X509_CERT_VERIFY_FAILED
SVN_ERR_LAST = _core.SVN_ERR_LAST

def svn_time_to_cstring(*args) -> "char const *":
    """svn_time_to_cstring(apr_time_t when, apr_pool_t pool) -> char const *"""
    return _core.svn_time_to_cstring(*args)

def svn_time_from_cstring(*args) -> "apr_int64_t *":
    """svn_time_from_cstring(char const * data, apr_pool_t pool) -> svn_error_t"""
    return _core.svn_time_from_cstring(*args)

def svn_time_to_human_cstring(*args) -> "char const *":
    """svn_time_to_human_cstring(apr_time_t when, apr_pool_t pool) -> char const *"""
    return _core.svn_time_to_human_cstring(*args)

def svn_parse_date(*args) -> "svn_boolean_t *, apr_int64_t *":
    """svn_parse_date(char const * text, apr_time_t now, apr_pool_t pool) -> svn_error_t"""
    return _core.svn_parse_date(*args)

def svn_sleep_for_timestamps() -> "void":
    """svn_sleep_for_timestamps()"""
    return _core.svn_sleep_for_timestamps()
svn_node_none = _core.svn_node_none
svn_node_file = _core.svn_node_file
svn_node_dir = _core.svn_node_dir
svn_node_unknown = _core.svn_node_unknown
svn_node_symlink = _core.svn_node_symlink
svn_tristate_false = _core.svn_tristate_false
svn_tristate_true = _core.svn_tristate_true
svn_tristate_unknown = _core.svn_tristate_unknown
svn_depth_unknown = _core.svn_depth_unknown
svn_depth_exclude = _core.svn_depth_exclude
svn_depth_empty = _core.svn_depth_empty
svn_depth_files = _core.svn_depth_files
svn_depth_immediates = _core.svn_depth_immediates
svn_depth_infinity = _core.svn_depth_infinity
SVN_UNALIGNED_ACCESS_IS_OK = _core.SVN_UNALIGNED_ACCESS_IS_OK
TRUE = _core.TRUE
FALSE = _core.FALSE
class svn_error_t(object):
    """Proxy of C svn_error_t struct."""

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    apr_err = _swig_property(_core.svn_error_t_apr_err_get, _core.svn_error_t_apr_err_set)
    message = _swig_property(_core.svn_error_t_message_get)
    child = _swig_property(_core.svn_error_t_child_get, _core.svn_error_t_child_set)
    pool = _swig_property(_core.svn_error_t_pool_get, _core.svn_error_t_pool_set)
    file = _swig_property(_core.svn_error_t_file_get)
    line = _swig_property(_core.svn_error_t_line_get, _core.svn_error_t_line_set)
    def set_parent_pool(self, parent_pool=None):
      """Create a new proxy object for TYPE"""
      import libsvn.core, weakref
      self.__dict__["_parent_pool"] = \
        parent_pool or libsvn.core.application_pool;
      if self.__dict__["_parent_pool"]:
        self.__dict__["_is_valid"] = weakref.ref(
          self.__dict__["_parent_pool"]._is_valid)

    def assert_valid(self):
      """Assert that this object is using valid pool memory"""
      if "_is_valid" in self.__dict__:
        assert self.__dict__["_is_valid"](), "Variable has already been deleted"

    def _retrieve_swig_value(self, name, value):
    # If we got back a different object than we have cached, we need to copy
    # all our metadata into it, so that it looks identical to the one
    # originally set.
      members = self.__dict__.get('_members')
      if members is not None and name in members:
        _copy_metadata_deep(value, members[name])

    # Verify that the new object is good
      _assert_valid_deep(value)

      return value

    # Attribute access must be intercepted to ensure that objects coming from
    # read attribute access match those that are set with write attribute access.
    # Specifically the metadata, such as the associated apr_pool object, should
    # match the originally assigned object.
    #
    # For classic classes it is enough to use __getattr__ to intercept swig
    # derived attributes. However, with new style classes SWIG makes use of
    # descriptors which mean that __getattr__ is never called. Therefore,
    # __getattribute__ must be used for the interception.

    if _newclass:
      def __getattribute__(self, name):
        """Manage access to all attributes of this object."""

    # Start by mimicing __getattr__ behavior: immediately return __dict__ or
    # items directly present in __dict__
        mydict = object.__getattribute__(self, '__dict__')

        if name == "__dict__":
          return mydict

        if name in mydict:
          return mydict[name]

        object.__getattribute__(self, 'assert_valid')()

        value = _get_instance_attr(self, name)
        fn = object.__getattribute__(self, '_retrieve_swig_value')
        return fn(name, value)
    else:
      def __getattr__(self, name):
        """Get an attribute from this object"""
        self.assert_valid()

        value = _swig_getattr(self, self.__class__, name)

        return self._retrieve_swig_value(name, value)

    def __setattr__(self, name, value):
      """Set an attribute on this object"""
      self.assert_valid()

    # Save a copy of the object, so that the garbage
    # collector won't kill the object while it's in
    # SWIG-land
      self.__dict__.setdefault("_members",{})[name] = value

      return _set_instance_attr(self, name, value)


    def __init__(self):
        """__init__(svn_error_t self) -> svn_error_t"""
        this = _core.new_svn_error_t()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _core.delete_svn_error_t
    __del__ = lambda self: None
svn_error_t_swigregister = _core.svn_error_t_swigregister
svn_error_t_swigregister(svn_error_t)


def svn_node_kind_to_word(kind: 'svn_node_kind_t') -> "char const *":
    """svn_node_kind_to_word(svn_node_kind_t kind) -> char const *"""
    return _core.svn_node_kind_to_word(kind)

def svn_node_kind_from_word(word: 'char const *') -> "svn_node_kind_t":
    """svn_node_kind_from_word(char const * word) -> svn_node_kind_t"""
    return _core.svn_node_kind_from_word(word)

def svn_tristate__to_word(tristate: 'svn_tristate_t') -> "char const *":
    """svn_tristate__to_word(svn_tristate_t tristate) -> char const *"""
    return _core.svn_tristate__to_word(tristate)

def svn_tristate__from_word(word: 'char const *') -> "svn_tristate_t":
    """svn_tristate__from_word(char const * word) -> svn_tristate_t"""
    return _core.svn_tristate__from_word(word)

def svn_revnum_parse(str: 'char const *') -> "svn_revnum_t *, char const **":
    """svn_revnum_parse(char const * str) -> svn_error_t"""
    return _core.svn_revnum_parse(str)
SVN_REVNUM_T_FMT = _core.SVN_REVNUM_T_FMT
svn_nonrecursive = _core.svn_nonrecursive
svn_recursive = _core.svn_recursive

def svn_depth_to_word(depth: 'svn_depth_t') -> "char const *":
    """svn_depth_to_word(svn_depth_t depth) -> char const *"""
    return _core.svn_depth_to_word(depth)

def svn_depth_from_word(word: 'char const *') -> "svn_depth_t":
    """svn_depth_from_word(char const * word) -> svn_depth_t"""
    return _core.svn_depth_from_word(word)
SVN_DIRENT_KIND = _core.SVN_DIRENT_KIND
SVN_DIRENT_SIZE = _core.SVN_DIRENT_SIZE
SVN_DIRENT_HAS_PROPS = _core.SVN_DIRENT_HAS_PROPS
SVN_DIRENT_CREATED_REV = _core.SVN_DIRENT_CREATED_REV
SVN_DIRENT_TIME = _core.SVN_DIRENT_TIME
SVN_DIRENT_LAST_AUTHOR = _core.SVN_DIRENT_LAST_AUTHOR
class svn_dirent_t(object):
    """Proxy of C svn_dirent_t struct."""

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    kind = _swig_property(_core.svn_dirent_t_kind_get, _core.svn_dirent_t_kind_set)
    size = _swig_property(_core.svn_dirent_t_size_get, _core.svn_dirent_t_size_set)
    has_props = _swig_property(_core.svn_dirent_t_has_props_get, _core.svn_dirent_t_has_props_set)
    created_rev = _swig_property(_core.svn_dirent_t_created_rev_get, _core.svn_dirent_t_created_rev_set)
    time = _swig_property(_core.svn_dirent_t_time_get, _core.svn_dirent_t_time_set)
    last_author = _swig_property(_core.svn_dirent_t_last_author_get)
    def set_parent_pool(self, parent_pool=None):
      """Create a new proxy object for TYPE"""
      import libsvn.core, weakref
      self.__dict__["_parent_pool"] = \
        parent_pool or libsvn.core.application_pool;
      if self.__dict__["_parent_pool"]:
        self.__dict__["_is_valid"] = weakref.ref(
          self.__dict__["_parent_pool"]._is_valid)

    def assert_valid(self):
      """Assert that this object is using valid pool memory"""
      if "_is_valid" in self.__dict__:
        assert self.__dict__["_is_valid"](), "Variable has already been deleted"

    def _retrieve_swig_value(self, name, value):
    # If we got back a different object than we have cached, we need to copy
    # all our metadata into it, so that it looks identical to the one
    # originally set.
      members = self.__dict__.get('_members')
      if members is not None and name in members:
        _copy_metadata_deep(value, members[name])

    # Verify that the new object is good
      _assert_valid_deep(value)

      return value

    # Attribute access must be intercepted to ensure that objects coming from
    # read attribute access match those that are set with write attribute access.
    # Specifically the metadata, such as the associated apr_pool object, should
    # match the originally assigned object.
    #
    # For classic classes it is enough to use __getattr__ to intercept swig
    # derived attributes. However, with new style classes SWIG makes use of
    # descriptors which mean that __getattr__ is never called. Therefore,
    # __getattribute__ must be used for the interception.

    if _newclass:
      def __getattribute__(self, name):
        """Manage access to all attributes of this object."""

    # Start by mimicing __getattr__ behavior: immediately return __dict__ or
    # items directly present in __dict__
        mydict = object.__getattribute__(self, '__dict__')

        if name == "__dict__":
          return mydict

        if name in mydict:
          return mydict[name]

        object.__getattribute__(self, 'assert_valid')()

        value = _get_instance_attr(self, name)
        fn = object.__getattribute__(self, '_retrieve_swig_value')
        return fn(name, value)
    else:
      def __getattr__(self, name):
        """Get an attribute from this object"""
        self.assert_valid()

        value = _swig_getattr(self, self.__class__, name)

        return self._retrieve_swig_value(name, value)

    def __setattr__(self, name, value):
      """Set an attribute on this object"""
      self.assert_valid()

    # Save a copy of the object, so that the garbage
    # collector won't kill the object while it's in
    # SWIG-land
      self.__dict__.setdefault("_members",{})[name] = value

      return _set_instance_attr(self, name, value)


    def __init__(self):
        """__init__(svn_dirent_t self) -> svn_dirent_t"""
        this = _core.new_svn_dirent_t()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _core.delete_svn_dirent_t
    __del__ = lambda self: None
svn_dirent_t_swigregister = _core.svn_dirent_t_swigregister
svn_dirent_t_swigregister(svn_dirent_t)


def svn_dirent_dup(*args) -> "svn_dirent_t *":
    """svn_dirent_dup(svn_dirent_t dirent, apr_pool_t pool) -> svn_dirent_t"""
    return _core.svn_dirent_dup(*args)

def svn_dirent_create(*args) -> "svn_dirent_t *":
    """svn_dirent_create(apr_pool_t result_pool) -> svn_dirent_t"""
    return _core.svn_dirent_create(*args)
SVN_KEYWORD_MAX_LEN = _core.SVN_KEYWORD_MAX_LEN
SVN_KEYWORD_REVISION_LONG = _core.SVN_KEYWORD_REVISION_LONG
SVN_KEYWORD_REVISION_SHORT = _core.SVN_KEYWORD_REVISION_SHORT
SVN_KEYWORD_REVISION_MEDIUM = _core.SVN_KEYWORD_REVISION_MEDIUM
SVN_KEYWORD_DATE_LONG = _core.SVN_KEYWORD_DATE_LONG
SVN_KEYWORD_DATE_SHORT = _core.SVN_KEYWORD_DATE_SHORT
SVN_KEYWORD_AUTHOR_LONG = _core.SVN_KEYWORD_AUTHOR_LONG
SVN_KEYWORD_AUTHOR_SHORT = _core.SVN_KEYWORD_AUTHOR_SHORT
SVN_KEYWORD_URL_LONG = _core.SVN_KEYWORD_URL_LONG
SVN_KEYWORD_URL_SHORT = _core.SVN_KEYWORD_URL_SHORT
SVN_KEYWORD_ID = _core.SVN_KEYWORD_ID
SVN_KEYWORD_HEADER = _core.SVN_KEYWORD_HEADER
class svn_commit_info_t(object):
    """Proxy of C svn_commit_info_t struct."""

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    revision = _swig_property(_core.svn_commit_info_t_revision_get, _core.svn_commit_info_t_revision_set)
    date = _swig_property(_core.svn_commit_info_t_date_get, _core.svn_commit_info_t_date_set)
    author = _swig_property(_core.svn_commit_info_t_author_get, _core.svn_commit_info_t_author_set)
    post_commit_err = _swig_property(_core.svn_commit_info_t_post_commit_err_get, _core.svn_commit_info_t_post_commit_err_set)
    repos_root = _swig_property(_core.svn_commit_info_t_repos_root_get, _core.svn_commit_info_t_repos_root_set)
    def set_parent_pool(self, parent_pool=None):
      """Create a new proxy object for TYPE"""
      import libsvn.core, weakref
      self.__dict__["_parent_pool"] = \
        parent_pool or libsvn.core.application_pool;
      if self.__dict__["_parent_pool"]:
        self.__dict__["_is_valid"] = weakref.ref(
          self.__dict__["_parent_pool"]._is_valid)

    def assert_valid(self):
      """Assert that this object is using valid pool memory"""
      if "_is_valid" in self.__dict__:
        assert self.__dict__["_is_valid"](), "Variable has already been deleted"

    def _retrieve_swig_value(self, name, value):
    # If we got back a different object than we have cached, we need to copy
    # all our metadata into it, so that it looks identical to the one
    # originally set.
      members = self.__dict__.get('_members')
      if members is not None and name in members:
        _copy_metadata_deep(value, members[name])

    # Verify that the new object is good
      _assert_valid_deep(value)

      return value

    # Attribute access must be intercepted to ensure that objects coming from
    # read attribute access match those that are set with write attribute access.
    # Specifically the metadata, such as the associated apr_pool object, should
    # match the originally assigned object.
    #
    # For classic classes it is enough to use __getattr__ to intercept swig
    # derived attributes. However, with new style classes SWIG makes use of
    # descriptors which mean that __getattr__ is never called. Therefore,
    # __getattribute__ must be used for the interception.

    if _newclass:
      def __getattribute__(self, name):
        """Manage access to all attributes of this object."""

    # Start by mimicing __getattr__ behavior: immediately return __dict__ or
    # items directly present in __dict__
        mydict = object.__getattribute__(self, '__dict__')

        if name == "__dict__":
          return mydict

        if name in mydict:
          return mydict[name]

        object.__getattribute__(self, 'assert_valid')()

        value = _get_instance_attr(self, name)
        fn = object.__getattribute__(self, '_retrieve_swig_value')
        return fn(name, value)
    else:
      def __getattr__(self, name):
        """Get an attribute from this object"""
        self.assert_valid()

        value = _swig_getattr(self, self.__class__, name)

        return self._retrieve_swig_value(name, value)

    def __setattr__(self, name, value):
      """Set an attribute on this object"""
      self.assert_valid()

    # Save a copy of the object, so that the garbage
    # collector won't kill the object while it's in
    # SWIG-land
      self.__dict__.setdefault("_members",{})[name] = value

      return _set_instance_attr(self, name, value)


    def __init__(self):
        """__init__(svn_commit_info_t self) -> svn_commit_info_t"""
        this = _core.new_svn_commit_info_t()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _core.delete_svn_commit_info_t
    __del__ = lambda self: None
svn_commit_info_t_swigregister = _core.svn_commit_info_t_swigregister
svn_commit_info_t_swigregister(svn_commit_info_t)


def svn_create_commit_info(*args) -> "svn_commit_info_t *":
    """svn_create_commit_info(apr_pool_t pool) -> svn_commit_info_t"""
    return _core.svn_create_commit_info(*args)

def svn_commit_info_dup(*args) -> "svn_commit_info_t *":
    """svn_commit_info_dup(svn_commit_info_t src_commit_info, apr_pool_t pool) -> svn_commit_info_t"""
    return _core.svn_commit_info_dup(*args)
class svn_log_changed_path2_t(object):
    """Proxy of C svn_log_changed_path2_t struct."""

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    action = _swig_property(_core.svn_log_changed_path2_t_action_get, _core.svn_log_changed_path2_t_action_set)
    copyfrom_path = _swig_property(_core.svn_log_changed_path2_t_copyfrom_path_get, _core.svn_log_changed_path2_t_copyfrom_path_set)
    copyfrom_rev = _swig_property(_core.svn_log_changed_path2_t_copyfrom_rev_get, _core.svn_log_changed_path2_t_copyfrom_rev_set)
    node_kind = _swig_property(_core.svn_log_changed_path2_t_node_kind_get, _core.svn_log_changed_path2_t_node_kind_set)
    text_modified = _swig_property(_core.svn_log_changed_path2_t_text_modified_get, _core.svn_log_changed_path2_t_text_modified_set)
    props_modified = _swig_property(_core.svn_log_changed_path2_t_props_modified_get, _core.svn_log_changed_path2_t_props_modified_set)
    def set_parent_pool(self, parent_pool=None):
      """Create a new proxy object for TYPE"""
      import libsvn.core, weakref
      self.__dict__["_parent_pool"] = \
        parent_pool or libsvn.core.application_pool;
      if self.__dict__["_parent_pool"]:
        self.__dict__["_is_valid"] = weakref.ref(
          self.__dict__["_parent_pool"]._is_valid)

    def assert_valid(self):
      """Assert that this object is using valid pool memory"""
      if "_is_valid" in self.__dict__:
        assert self.__dict__["_is_valid"](), "Variable has already been deleted"

    def _retrieve_swig_value(self, name, value):
    # If we got back a different object than we have cached, we need to copy
    # all our metadata into it, so that it looks identical to the one
    # originally set.
      members = self.__dict__.get('_members')
      if members is not None and name in members:
        _copy_metadata_deep(value, members[name])

    # Verify that the new object is good
      _assert_valid_deep(value)

      return value

    # Attribute access must be intercepted to ensure that objects coming from
    # read attribute access match those that are set with write attribute access.
    # Specifically the metadata, such as the associated apr_pool object, should
    # match the originally assigned object.
    #
    # For classic classes it is enough to use __getattr__ to intercept swig
    # derived attributes. However, with new style classes SWIG makes use of
    # descriptors which mean that __getattr__ is never called. Therefore,
    # __getattribute__ must be used for the interception.

    if _newclass:
      def __getattribute__(self, name):
        """Manage access to all attributes of this object."""

    # Start by mimicing __getattr__ behavior: immediately return __dict__ or
    # items directly present in __dict__
        mydict = object.__getattribute__(self, '__dict__')

        if name == "__dict__":
          return mydict

        if name in mydict:
          return mydict[name]

        object.__getattribute__(self, 'assert_valid')()

        value = _get_instance_attr(self, name)
        fn = object.__getattribute__(self, '_retrieve_swig_value')
        return fn(name, value)
    else:
      def __getattr__(self, name):
        """Get an attribute from this object"""
        self.assert_valid()

        value = _swig_getattr(self, self.__class__, name)

        return self._retrieve_swig_value(name, value)

    def __setattr__(self, name, value):
      """Set an attribute on this object"""
      self.assert_valid()

    # Save a copy of the object, so that the garbage
    # collector won't kill the object while it's in
    # SWIG-land
      self.__dict__.setdefault("_members",{})[name] = value

      return _set_instance_attr(self, name, value)


    def __init__(self):
        """__init__(svn_log_changed_path2_t self) -> svn_log_changed_path2_t"""
        this = _core.new_svn_log_changed_path2_t()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _core.delete_svn_log_changed_path2_t
    __del__ = lambda self: None
svn_log_changed_path2_t_swigregister = _core.svn_log_changed_path2_t_swigregister
svn_log_changed_path2_t_swigregister(svn_log_changed_path2_t)


def svn_log_changed_path2_create(*args) -> "svn_log_changed_path2_t *":
    """svn_log_changed_path2_create(apr_pool_t pool) -> svn_log_changed_path2_t"""
    return _core.svn_log_changed_path2_create(*args)

def svn_log_changed_path2_dup(*args) -> "svn_log_changed_path2_t *":
    """svn_log_changed_path2_dup(svn_log_changed_path2_t changed_path, apr_pool_t pool) -> svn_log_changed_path2_t"""
    return _core.svn_log_changed_path2_dup(*args)
class svn_log_changed_path_t(object):
    """Proxy of C svn_log_changed_path_t struct."""

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    action = _swig_property(_core.svn_log_changed_path_t_action_get, _core.svn_log_changed_path_t_action_set)
    copyfrom_path = _swig_property(_core.svn_log_changed_path_t_copyfrom_path_get)
    copyfrom_rev = _swig_property(_core.svn_log_changed_path_t_copyfrom_rev_get, _core.svn_log_changed_path_t_copyfrom_rev_set)
    def set_parent_pool(self, parent_pool=None):
      """Create a new proxy object for TYPE"""
      import libsvn.core, weakref
      self.__dict__["_parent_pool"] = \
        parent_pool or libsvn.core.application_pool;
      if self.__dict__["_parent_pool"]:
        self.__dict__["_is_valid"] = weakref.ref(
          self.__dict__["_parent_pool"]._is_valid)

    def assert_valid(self):
      """Assert that this object is using valid pool memory"""
      if "_is_valid" in self.__dict__:
        assert self.__dict__["_is_valid"](), "Variable has already been deleted"

    def _retrieve_swig_value(self, name, value):
    # If we got back a different object than we have cached, we need to copy
    # all our metadata into it, so that it looks identical to the one
    # originally set.
      members = self.__dict__.get('_members')
      if members is not None and name in members:
        _copy_metadata_deep(value, members[name])

    # Verify that the new object is good
      _assert_valid_deep(value)

      return value

    # Attribute access must be intercepted to ensure that objects coming from
    # read attribute access match those that are set with write attribute access.
    # Specifically the metadata, such as the associated apr_pool object, should
    # match the originally assigned object.
    #
    # For classic classes it is enough to use __getattr__ to intercept swig
    # derived attributes. However, with new style classes SWIG makes use of
    # descriptors which mean that __getattr__ is never called. Therefore,
    # __getattribute__ must be used for the interception.

    if _newclass:
      def __getattribute__(self, name):
        """Manage access to all attributes of this object."""

    # Start by mimicing __getattr__ behavior: immediately return __dict__ or
    # items directly present in __dict__
        mydict = object.__getattribute__(self, '__dict__')

        if name == "__dict__":
          return mydict

        if name in mydict:
          return mydict[name]

        object.__getattribute__(self, 'assert_valid')()

        value = _get_instance_attr(self, name)
        fn = object.__getattribute__(self, '_retrieve_swig_value')
        return fn(name, value)
    else:
      def __getattr__(self, name):
        """Get an attribute from this object"""
        self.assert_valid()

        value = _swig_getattr(self, self.__class__, name)

        return self._retrieve_swig_value(name, value)

    def __setattr__(self, name, value):
      """Set an attribute on this object"""
      self.assert_valid()

    # Save a copy of the object, so that the garbage
    # collector won't kill the object while it's in
    # SWIG-land
      self.__dict__.setdefault("_members",{})[name] = value

      return _set_instance_attr(self, name, value)


    def __init__(self):
        """__init__(svn_log_changed_path_t self) -> svn_log_changed_path_t"""
        this = _core.new_svn_log_changed_path_t()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _core.delete_svn_log_changed_path_t
    __del__ = lambda self: None
svn_log_changed_path_t_swigregister = _core.svn_log_changed_path_t_swigregister
svn_log_changed_path_t_swigregister(svn_log_changed_path_t)


def svn_log_changed_path_dup(*args) -> "svn_log_changed_path_t *":
    """svn_log_changed_path_dup(svn_log_changed_path_t changed_path, apr_pool_t pool) -> svn_log_changed_path_t"""
    return _core.svn_log_changed_path_dup(*args)
class svn_log_entry_t(object):
    """Proxy of C svn_log_entry_t struct."""

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    changed_paths = _swig_property(_core.svn_log_entry_t_changed_paths_get, _core.svn_log_entry_t_changed_paths_set)
    revision = _swig_property(_core.svn_log_entry_t_revision_get, _core.svn_log_entry_t_revision_set)
    revprops = _swig_property(_core.svn_log_entry_t_revprops_get, _core.svn_log_entry_t_revprops_set)
    has_children = _swig_property(_core.svn_log_entry_t_has_children_get, _core.svn_log_entry_t_has_children_set)
    changed_paths2 = _swig_property(_core.svn_log_entry_t_changed_paths2_get, _core.svn_log_entry_t_changed_paths2_set)
    non_inheritable = _swig_property(_core.svn_log_entry_t_non_inheritable_get, _core.svn_log_entry_t_non_inheritable_set)
    subtractive_merge = _swig_property(_core.svn_log_entry_t_subtractive_merge_get, _core.svn_log_entry_t_subtractive_merge_set)
    def set_parent_pool(self, parent_pool=None):
      """Create a new proxy object for TYPE"""
      import libsvn.core, weakref
      self.__dict__["_parent_pool"] = \
        parent_pool or libsvn.core.application_pool;
      if self.__dict__["_parent_pool"]:
        self.__dict__["_is_valid"] = weakref.ref(
          self.__dict__["_parent_pool"]._is_valid)

    def assert_valid(self):
      """Assert that this object is using valid pool memory"""
      if "_is_valid" in self.__dict__:
        assert self.__dict__["_is_valid"](), "Variable has already been deleted"

    def _retrieve_swig_value(self, name, value):
    # If we got back a different object than we have cached, we need to copy
    # all our metadata into it, so that it looks identical to the one
    # originally set.
      members = self.__dict__.get('_members')
      if members is not None and name in members:
        _copy_metadata_deep(value, members[name])

    # Verify that the new object is good
      _assert_valid_deep(value)

      return value

    # Attribute access must be intercepted to ensure that objects coming from
    # read attribute access match those that are set with write attribute access.
    # Specifically the metadata, such as the associated apr_pool object, should
    # match the originally assigned object.
    #
    # For classic classes it is enough to use __getattr__ to intercept swig
    # derived attributes. However, with new style classes SWIG makes use of
    # descriptors which mean that __getattr__ is never called. Therefore,
    # __getattribute__ must be used for the interception.

    if _newclass:
      def __getattribute__(self, name):
        """Manage access to all attributes of this object."""

    # Start by mimicing __getattr__ behavior: immediately return __dict__ or
    # items directly present in __dict__
        mydict = object.__getattribute__(self, '__dict__')

        if name == "__dict__":
          return mydict

        if name in mydict:
          return mydict[name]

        object.__getattribute__(self, 'assert_valid')()

        value = _get_instance_attr(self, name)
        fn = object.__getattribute__(self, '_retrieve_swig_value')
        return fn(name, value)
    else:
      def __getattr__(self, name):
        """Get an attribute from this object"""
        self.assert_valid()

        value = _swig_getattr(self, self.__class__, name)

        return self._retrieve_swig_value(name, value)

    def __setattr__(self, name, value):
      """Set an attribute on this object"""
      self.assert_valid()

    # Save a copy of the object, so that the garbage
    # collector won't kill the object while it's in
    # SWIG-land
      self.__dict__.setdefault("_members",{})[name] = value

      return _set_instance_attr(self, name, value)


    def __init__(self):
        """__init__(svn_log_entry_t self) -> svn_log_entry_t"""
        this = _core.new_svn_log_entry_t()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _core.delete_svn_log_entry_t
    __del__ = lambda self: None
svn_log_entry_t_swigregister = _core.svn_log_entry_t_swigregister
svn_log_entry_t_swigregister(svn_log_entry_t)


def svn_log_entry_create(*args) -> "svn_log_entry_t *":
    """svn_log_entry_create(apr_pool_t pool) -> svn_log_entry_t"""
    return _core.svn_log_entry_create(*args)

def svn_log_entry_dup(*args) -> "svn_log_entry_t *":
    """svn_log_entry_dup(svn_log_entry_t log_entry, apr_pool_t pool) -> svn_log_entry_t"""
    return _core.svn_log_entry_dup(*args)
SVN_STREAM_CHUNK_SIZE = _core.SVN_STREAM_CHUNK_SIZE
SVN__STREAM_CHUNK_SIZE = _core.SVN__STREAM_CHUNK_SIZE

def svn_mime_type_validate(*args) -> "svn_error_t *":
    """svn_mime_type_validate(char const * mime_type, apr_pool_t pool) -> svn_error_t"""
    return _core.svn_mime_type_validate(*args)

def svn_mime_type_is_binary(mime_type: 'char const *') -> "svn_boolean_t":
    """svn_mime_type_is_binary(char const * mime_type) -> svn_boolean_t"""
    return _core.svn_mime_type_is_binary(mime_type)
class svn_lock_t(object):
    """Proxy of C svn_lock_t struct."""

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    path = _swig_property(_core.svn_lock_t_path_get, _core.svn_lock_t_path_set)
    token = _swig_property(_core.svn_lock_t_token_get, _core.svn_lock_t_token_set)
    owner = _swig_property(_core.svn_lock_t_owner_get, _core.svn_lock_t_owner_set)
    comment = _swig_property(_core.svn_lock_t_comment_get, _core.svn_lock_t_comment_set)
    is_dav_comment = _swig_property(_core.svn_lock_t_is_dav_comment_get, _core.svn_lock_t_is_dav_comment_set)
    creation_date = _swig_property(_core.svn_lock_t_creation_date_get, _core.svn_lock_t_creation_date_set)
    expiration_date = _swig_property(_core.svn_lock_t_expiration_date_get, _core.svn_lock_t_expiration_date_set)
    def set_parent_pool(self, parent_pool=None):
      """Create a new proxy object for TYPE"""
      import libsvn.core, weakref
      self.__dict__["_parent_pool"] = \
        parent_pool or libsvn.core.application_pool;
      if self.__dict__["_parent_pool"]:
        self.__dict__["_is_valid"] = weakref.ref(
          self.__dict__["_parent_pool"]._is_valid)

    def assert_valid(self):
      """Assert that this object is using valid pool memory"""
      if "_is_valid" in self.__dict__:
        assert self.__dict__["_is_valid"](), "Variable has already been deleted"

    def _retrieve_swig_value(self, name, value):
    # If we got back a different object than we have cached, we need to copy
    # all our metadata into it, so that it looks identical to the one
    # originally set.
      members = self.__dict__.get('_members')
      if members is not None and name in members:
        _copy_metadata_deep(value, members[name])

    # Verify that the new object is good
      _assert_valid_deep(value)

      return value

    # Attribute access must be intercepted to ensure that objects coming from
    # read attribute access match those that are set with write attribute access.
    # Specifically the metadata, such as the associated apr_pool object, should
    # match the originally assigned object.
    #
    # For classic classes it is enough to use __getattr__ to intercept swig
    # derived attributes. However, with new style classes SWIG makes use of
    # descriptors which mean that __getattr__ is never called. Therefore,
    # __getattribute__ must be used for the interception.

    if _newclass:
      def __getattribute__(self, name):
        """Manage access to all attributes of this object."""

    # Start by mimicing __getattr__ behavior: immediately return __dict__ or
    # items directly present in __dict__
        mydict = object.__getattribute__(self, '__dict__')

        if name == "__dict__":
          return mydict

        if name in mydict:
          return mydict[name]

        object.__getattribute__(self, 'assert_valid')()

        value = _get_instance_attr(self, name)
        fn = object.__getattribute__(self, '_retrieve_swig_value')
        return fn(name, value)
    else:
      def __getattr__(self, name):
        """Get an attribute from this object"""
        self.assert_valid()

        value = _swig_getattr(self, self.__class__, name)

        return self._retrieve_swig_value(name, value)

    def __setattr__(self, name, value):
      """Set an attribute on this object"""
      self.assert_valid()

    # Save a copy of the object, so that the garbage
    # collector won't kill the object while it's in
    # SWIG-land
      self.__dict__.setdefault("_members",{})[name] = value

      return _set_instance_attr(self, name, value)


    def __init__(self):
        """__init__(svn_lock_t self) -> svn_lock_t"""
        this = _core.new_svn_lock_t()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _core.delete_svn_lock_t
    __del__ = lambda self: None
svn_lock_t_swigregister = _core.svn_lock_t_swigregister
svn_lock_t_swigregister(svn_lock_t)


def svn_lock_create(*args) -> "svn_lock_t *":
    """svn_lock_create(apr_pool_t pool) -> svn_lock_t"""
    return _core.svn_lock_create(*args)

def svn_lock_dup(*args) -> "svn_lock_t *":
    """svn_lock_dup(svn_lock_t lock, apr_pool_t pool) -> svn_lock_t"""
    return _core.svn_lock_dup(*args)

def svn_uuid_generate(*args) -> "char const *":
    """svn_uuid_generate(apr_pool_t pool) -> char const *"""
    return _core.svn_uuid_generate(*args)
class svn_merge_range_t(object):
    """Proxy of C svn_merge_range_t struct."""

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    start = _swig_property(_core.svn_merge_range_t_start_get, _core.svn_merge_range_t_start_set)
    end = _swig_property(_core.svn_merge_range_t_end_get, _core.svn_merge_range_t_end_set)
    inheritable = _swig_property(_core.svn_merge_range_t_inheritable_get, _core.svn_merge_range_t_inheritable_set)
    def set_parent_pool(self, parent_pool=None):
      """Create a new proxy object for TYPE"""
      import libsvn.core, weakref
      self.__dict__["_parent_pool"] = \
        parent_pool or libsvn.core.application_pool;
      if self.__dict__["_parent_pool"]:
        self.__dict__["_is_valid"] = weakref.ref(
          self.__dict__["_parent_pool"]._is_valid)

    def assert_valid(self):
      """Assert that this object is using valid pool memory"""
      if "_is_valid" in self.__dict__:
        assert self.__dict__["_is_valid"](), "Variable has already been deleted"

    def _retrieve_swig_value(self, name, value):
    # If we got back a different object than we have cached, we need to copy
    # all our metadata into it, so that it looks identical to the one
    # originally set.
      members = self.__dict__.get('_members')
      if members is not None and name in members:
        _copy_metadata_deep(value, members[name])

    # Verify that the new object is good
      _assert_valid_deep(value)

      return value

    # Attribute access must be intercepted to ensure that objects coming from
    # read attribute access match those that are set with write attribute access.
    # Specifically the metadata, such as the associated apr_pool object, should
    # match the originally assigned object.
    #
    # For classic classes it is enough to use __getattr__ to intercept swig
    # derived attributes. However, with new style classes SWIG makes use of
    # descriptors which mean that __getattr__ is never called. Therefore,
    # __getattribute__ must be used for the interception.

    if _newclass:
      def __getattribute__(self, name):
        """Manage access to all attributes of this object."""

    # Start by mimicing __getattr__ behavior: immediately return __dict__ or
    # items directly present in __dict__
        mydict = object.__getattribute__(self, '__dict__')

        if name == "__dict__":
          return mydict

        if name in mydict:
          return mydict[name]

        object.__getattribute__(self, 'assert_valid')()

        value = _get_instance_attr(self, name)
        fn = object.__getattribute__(self, '_retrieve_swig_value')
        return fn(name, value)
    else:
      def __getattr__(self, name):
        """Get an attribute from this object"""
        self.assert_valid()

        value = _swig_getattr(self, self.__class__, name)

        return self._retrieve_swig_value(name, value)

    def __setattr__(self, name, value):
      """Set an attribute on this object"""
      self.assert_valid()

    # Save a copy of the object, so that the garbage
    # collector won't kill the object while it's in
    # SWIG-land
      self.__dict__.setdefault("_members",{})[name] = value

      return _set_instance_attr(self, name, value)


    def __init__(self):
        """__init__(svn_merge_range_t self) -> svn_merge_range_t"""
        this = _core.new_svn_merge_range_t()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _core.delete_svn_merge_range_t
    __del__ = lambda self: None
svn_merge_range_t_swigregister = _core.svn_merge_range_t_swigregister
svn_merge_range_t_swigregister(svn_merge_range_t)


def svn_merge_range_dup(*args) -> "svn_merge_range_t *":
    """svn_merge_range_dup(svn_merge_range_t range, apr_pool_t pool) -> svn_merge_range_t"""
    return _core.svn_merge_range_dup(*args)

def svn_merge_range_contains_rev(range: 'svn_merge_range_t', rev: 'svn_revnum_t') -> "svn_boolean_t":
    """svn_merge_range_contains_rev(svn_merge_range_t range, svn_revnum_t rev) -> svn_boolean_t"""
    return _core.svn_merge_range_contains_rev(range, rev)
class svn_location_segment_t(object):
    """Proxy of C svn_location_segment_t struct."""

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    range_start = _swig_property(_core.svn_location_segment_t_range_start_get, _core.svn_location_segment_t_range_start_set)
    range_end = _swig_property(_core.svn_location_segment_t_range_end_get, _core.svn_location_segment_t_range_end_set)
    path = _swig_property(_core.svn_location_segment_t_path_get, _core.svn_location_segment_t_path_set)
    def set_parent_pool(self, parent_pool=None):
      """Create a new proxy object for TYPE"""
      import libsvn.core, weakref
      self.__dict__["_parent_pool"] = \
        parent_pool or libsvn.core.application_pool;
      if self.__dict__["_parent_pool"]:
        self.__dict__["_is_valid"] = weakref.ref(
          self.__dict__["_parent_pool"]._is_valid)

    def assert_valid(self):
      """Assert that this object is using valid pool memory"""
      if "_is_valid" in self.__dict__:
        assert self.__dict__["_is_valid"](), "Variable has already been deleted"

    def _retrieve_swig_value(self, name, value):
    # If we got back a different object than we have cached, we need to copy
    # all our metadata into it, so that it looks identical to the one
    # originally set.
      members = self.__dict__.get('_members')
      if members is not None and name in members:
        _copy_metadata_deep(value, members[name])

    # Verify that the new object is good
      _assert_valid_deep(value)

      return value

    # Attribute access must be intercepted to ensure that objects coming from
    # read attribute access match those that are set with write attribute access.
    # Specifically the metadata, such as the associated apr_pool object, should
    # match the originally assigned object.
    #
    # For classic classes it is enough to use __getattr__ to intercept swig
    # derived attributes. However, with new style classes SWIG makes use of
    # descriptors which mean that __getattr__ is never called. Therefore,
    # __getattribute__ must be used for the interception.

    if _newclass:
      def __getattribute__(self, name):
        """Manage access to all attributes of this object."""

    # Start by mimicing __getattr__ behavior: immediately return __dict__ or
    # items directly present in __dict__
        mydict = object.__getattribute__(self, '__dict__')

        if name == "__dict__":
          return mydict

        if name in mydict:
          return mydict[name]

        object.__getattribute__(self, 'assert_valid')()

        value = _get_instance_attr(self, name)
        fn = object.__getattribute__(self, '_retrieve_swig_value')
        return fn(name, value)
    else:
      def __getattr__(self, name):
        """Get an attribute from this object"""
        self.assert_valid()

        value = _swig_getattr(self, self.__class__, name)

        return self._retrieve_swig_value(name, value)

    def __setattr__(self, name, value):
      """Set an attribute on this object"""
      self.assert_valid()

    # Save a copy of the object, so that the garbage
    # collector won't kill the object while it's in
    # SWIG-land
      self.__dict__.setdefault("_members",{})[name] = value

      return _set_instance_attr(self, name, value)


    def __init__(self):
        """__init__(svn_location_segment_t self) -> svn_location_segment_t"""
        this = _core.new_svn_location_segment_t()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _core.delete_svn_location_segment_t
    __del__ = lambda self: None
svn_location_segment_t_swigregister = _core.svn_location_segment_t_swigregister
svn_location_segment_t_swigregister(svn_location_segment_t)


def svn_location_segment_dup(*args) -> "svn_location_segment_t *":
    """svn_location_segment_dup(svn_location_segment_t segment, apr_pool_t pool) -> svn_location_segment_t"""
    return _core.svn_location_segment_dup(*args)
class svn_version_t(object):
    """Proxy of C svn_version_t struct."""

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    def set_parent_pool(self, parent_pool=None):
      """Create a new proxy object for TYPE"""
      import libsvn.core, weakref
      self.__dict__["_parent_pool"] = \
        parent_pool or libsvn.core.application_pool;
      if self.__dict__["_parent_pool"]:
        self.__dict__["_is_valid"] = weakref.ref(
          self.__dict__["_parent_pool"]._is_valid)

    def assert_valid(self):
      """Assert that this object is using valid pool memory"""
      if "_is_valid" in self.__dict__:
        assert self.__dict__["_is_valid"](), "Variable has already been deleted"

    def _retrieve_swig_value(self, name, value):
    # If we got back a different object than we have cached, we need to copy
    # all our metadata into it, so that it looks identical to the one
    # originally set.
      members = self.__dict__.get('_members')
      if members is not None and name in members:
        _copy_metadata_deep(value, members[name])

    # Verify that the new object is good
      _assert_valid_deep(value)

      return value

    # Attribute access must be intercepted to ensure that objects coming from
    # read attribute access match those that are set with write attribute access.
    # Specifically the metadata, such as the associated apr_pool object, should
    # match the originally assigned object.
    #
    # For classic classes it is enough to use __getattr__ to intercept swig
    # derived attributes. However, with new style classes SWIG makes use of
    # descriptors which mean that __getattr__ is never called. Therefore,
    # __getattribute__ must be used for the interception.

    if _newclass:
      def __getattribute__(self, name):
        """Manage access to all attributes of this object."""

    # Start by mimicing __getattr__ behavior: immediately return __dict__ or
    # items directly present in __dict__
        mydict = object.__getattribute__(self, '__dict__')

        if name == "__dict__":
          return mydict

        if name in mydict:
          return mydict[name]

        object.__getattribute__(self, 'assert_valid')()

        value = _get_instance_attr(self, name)
        fn = object.__getattribute__(self, '_retrieve_swig_value')
        return fn(name, value)
    else:
      def __getattr__(self, name):
        """Get an attribute from this object"""
        self.assert_valid()

        value = _swig_getattr(self, self.__class__, name)

        return self._retrieve_swig_value(name, value)

    def __setattr__(self, name, value):
      """Set an attribute on this object"""
      self.assert_valid()

    # Save a copy of the object, so that the garbage
    # collector won't kill the object while it's in
    # SWIG-land
      self.__dict__.setdefault("_members",{})[name] = value

      return _set_instance_attr(self, name, value)

svn_version_t_swigregister = _core.svn_version_t_swigregister
svn_version_t_swigregister(svn_version_t)


def svn_log_invoke_entry_receiver(*args) -> "svn_error_t *":
    """svn_log_invoke_entry_receiver(svn_log_entry_receiver_t _obj, void * baton, svn_log_entry_t log_entry, apr_pool_t pool) -> svn_error_t"""
    return _core.svn_log_invoke_entry_receiver(*args)

def svn_log_invoke_message_receiver(*args) -> "svn_error_t *":
    """svn_log_invoke_message_receiver(svn_log_message_receiver_t _obj, void * baton, apr_hash_t changed_paths, svn_revnum_t revision, char const * author, char const * date, char const * message, apr_pool_t pool) -> svn_error_t"""
    return _core.svn_log_invoke_message_receiver(*args)

def svn_commit_invoke_callback2(*args) -> "svn_error_t *":
    """svn_commit_invoke_callback2(svn_commit_callback2_t _obj, svn_commit_info_t commit_info, void * baton, apr_pool_t pool) -> svn_error_t"""
    return _core.svn_commit_invoke_callback2(*args)

def svn_commit_invoke_callback(_obj: 'svn_commit_callback_t', new_revision: 'svn_revnum_t', date: 'char const *', author: 'char const *', baton: 'void *') -> "svn_error_t *":
    """svn_commit_invoke_callback(svn_commit_callback_t _obj, svn_revnum_t new_revision, char const * date, char const * author, void * baton) -> svn_error_t"""
    return _core.svn_commit_invoke_callback(_obj, new_revision, date, author, baton)

def svn_cancel_invoke_func(_obj: 'svn_cancel_func_t', cancel_baton: 'void *') -> "svn_error_t *":
    """svn_cancel_invoke_func(svn_cancel_func_t _obj, void * cancel_baton) -> svn_error_t"""
    return _core.svn_cancel_invoke_func(_obj, cancel_baton)

def svn_location_invoke_segment_receiver(*args) -> "svn_error_t *":
    """svn_location_invoke_segment_receiver(svn_location_segment_receiver_t _obj, svn_location_segment_t segment, void * baton, apr_pool_t pool) -> svn_error_t"""
    return _core.svn_location_invoke_segment_receiver(*args)
class svn_log_entry_receiver_t(object):
    """Proxy of C svn_log_entry_receiver_t struct."""

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    def set_parent_pool(self, parent_pool=None):
      """Create a new proxy object for TYPE"""
      import libsvn.core, weakref
      self.__dict__["_parent_pool"] = \
        parent_pool or libsvn.core.application_pool;
      if self.__dict__["_parent_pool"]:
        self.__dict__["_is_valid"] = weakref.ref(
          self.__dict__["_parent_pool"]._is_valid)

    def assert_valid(self):
      """Assert that this object is using valid pool memory"""
      if "_is_valid" in self.__dict__:
        assert self.__dict__["_is_valid"](), "Variable has already been deleted"

    def _retrieve_swig_value(self, name, value):
    # If we got back a different object than we have cached, we need to copy
    # all our metadata into it, so that it looks identical to the one
    # originally set.
      members = self.__dict__.get('_members')
      if members is not None and name in members:
        _copy_metadata_deep(value, members[name])

    # Verify that the new object is good
      _assert_valid_deep(value)

      return value

    # Attribute access must be intercepted to ensure that objects coming from
    # read attribute access match those that are set with write attribute access.
    # Specifically the metadata, such as the associated apr_pool object, should
    # match the originally assigned object.
    #
    # For classic classes it is enough to use __getattr__ to intercept swig
    # derived attributes. However, with new style classes SWIG makes use of
    # descriptors which mean that __getattr__ is never called. Therefore,
    # __getattribute__ must be used for the interception.

    if _newclass:
      def __getattribute__(self, name):
        """Manage access to all attributes of this object."""

    # Start by mimicing __getattr__ behavior: immediately return __dict__ or
    # items directly present in __dict__
        mydict = object.__getattribute__(self, '__dict__')

        if name == "__dict__":
          return mydict

        if name in mydict:
          return mydict[name]

        object.__getattribute__(self, 'assert_valid')()

        value = _get_instance_attr(self, name)
        fn = object.__getattribute__(self, '_retrieve_swig_value')
        return fn(name, value)
    else:
      def __getattr__(self, name):
        """Get an attribute from this object"""
        self.assert_valid()

        value = _swig_getattr(self, self.__class__, name)

        return self._retrieve_swig_value(name, value)

    def __setattr__(self, name, value):
      """Set an attribute on this object"""
      self.assert_valid()

    # Save a copy of the object, so that the garbage
    # collector won't kill the object while it's in
    # SWIG-land
      self.__dict__.setdefault("_members",{})[name] = value

      return _set_instance_attr(self, name, value)


    def __call__(self, *args):
      return svn_log_invoke_entry_receiver(self, *args)

svn_log_entry_receiver_t_swigregister = _core.svn_log_entry_receiver_t_swigregister
svn_log_entry_receiver_t_swigregister(svn_log_entry_receiver_t)

class svn_log_message_receiver_t(object):
    """Proxy of C svn_log_message_receiver_t struct."""

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    def set_parent_pool(self, parent_pool=None):
      """Create a new proxy object for TYPE"""
      import libsvn.core, weakref
      self.__dict__["_parent_pool"] = \
        parent_pool or libsvn.core.application_pool;
      if self.__dict__["_parent_pool"]:
        self.__dict__["_is_valid"] = weakref.ref(
          self.__dict__["_parent_pool"]._is_valid)

    def assert_valid(self):
      """Assert that this object is using valid pool memory"""
      if "_is_valid" in self.__dict__:
        assert self.__dict__["_is_valid"](), "Variable has already been deleted"

    def _retrieve_swig_value(self, name, value):
    # If we got back a different object than we have cached, we need to copy
    # all our metadata into it, so that it looks identical to the one
    # originally set.
      members = self.__dict__.get('_members')
      if members is not None and name in members:
        _copy_metadata_deep(value, members[name])

    # Verify that the new object is good
      _assert_valid_deep(value)

      return value

    # Attribute access must be intercepted to ensure that objects coming from
    # read attribute access match those that are set with write attribute access.
    # Specifically the metadata, such as the associated apr_pool object, should
    # match the originally assigned object.
    #
    # For classic classes it is enough to use __getattr__ to intercept swig
    # derived attributes. However, with new style classes SWIG makes use of
    # descriptors which mean that __getattr__ is never called. Therefore,
    # __getattribute__ must be used for the interception.

    if _newclass:
      def __getattribute__(self, name):
        """Manage access to all attributes of this object."""

    # Start by mimicing __getattr__ behavior: immediately return __dict__ or
    # items directly present in __dict__
        mydict = object.__getattribute__(self, '__dict__')

        if name == "__dict__":
          return mydict

        if name in mydict:
          return mydict[name]

        object.__getattribute__(self, 'assert_valid')()

        value = _get_instance_attr(self, name)
        fn = object.__getattribute__(self, '_retrieve_swig_value')
        return fn(name, value)
    else:
      def __getattr__(self, name):
        """Get an attribute from this object"""
        self.assert_valid()

        value = _swig_getattr(self, self.__class__, name)

        return self._retrieve_swig_value(name, value)

    def __setattr__(self, name, value):
      """Set an attribute on this object"""
      self.assert_valid()

    # Save a copy of the object, so that the garbage
    # collector won't kill the object while it's in
    # SWIG-land
      self.__dict__.setdefault("_members",{})[name] = value

      return _set_instance_attr(self, name, value)


    def __call__(self, *args):
      return svn_log_invoke_message_receiver(self, *args)

svn_log_message_receiver_t_swigregister = _core.svn_log_message_receiver_t_swigregister
svn_log_message_receiver_t_swigregister(svn_log_message_receiver_t)

class svn_commit_callback2_t(object):
    """Proxy of C svn_commit_callback2_t struct."""

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    def set_parent_pool(self, parent_pool=None):
      """Create a new proxy object for TYPE"""
      import libsvn.core, weakref
      self.__dict__["_parent_pool"] = \
        parent_pool or libsvn.core.application_pool;
      if self.__dict__["_parent_pool"]:
        self.__dict__["_is_valid"] = weakref.ref(
          self.__dict__["_parent_pool"]._is_valid)

    def assert_valid(self):
      """Assert that this object is using valid pool memory"""
      if "_is_valid" in self.__dict__:
        assert self.__dict__["_is_valid"](), "Variable has already been deleted"

    def _retrieve_swig_value(self, name, value):
    # If we got back a different object than we have cached, we need to copy
    # all our metadata into it, so that it looks identical to the one
    # originally set.
      members = self.__dict__.get('_members')
      if members is not None and name in members:
        _copy_metadata_deep(value, members[name])

    # Verify that the new object is good
      _assert_valid_deep(value)

      return value

    # Attribute access must be intercepted to ensure that objects coming from
    # read attribute access match those that are set with write attribute access.
    # Specifically the metadata, such as the associated apr_pool object, should
    # match the originally assigned object.
    #
    # For classic classes it is enough to use __getattr__ to intercept swig
    # derived attributes. However, with new style classes SWIG makes use of
    # descriptors which mean that __getattr__ is never called. Therefore,
    # __getattribute__ must be used for the interception.

    if _newclass:
      def __getattribute__(self, name):
        """Manage access to all attributes of this object."""

    # Start by mimicing __getattr__ behavior: immediately return __dict__ or
    # items directly present in __dict__
        mydict = object.__getattribute__(self, '__dict__')

        if name == "__dict__":
          return mydict

        if name in mydict:
          return mydict[name]

        object.__getattribute__(self, 'assert_valid')()

        value = _get_instance_attr(self, name)
        fn = object.__getattribute__(self, '_retrieve_swig_value')
        return fn(name, value)
    else:
      def __getattr__(self, name):
        """Get an attribute from this object"""
        self.assert_valid()

        value = _swig_getattr(self, self.__class__, name)

        return self._retrieve_swig_value(name, value)

    def __setattr__(self, name, value):
      """Set an attribute on this object"""
      self.assert_valid()

    # Save a copy of the object, so that the garbage
    # collector won't kill the object while it's in
    # SWIG-land
      self.__dict__.setdefault("_members",{})[name] = value

      return _set_instance_attr(self, name, value)


    def __call__(self, *args):
      return svn_commit_invoke_callback2(self, *args)

svn_commit_callback2_t_swigregister = _core.svn_commit_callback2_t_swigregister
svn_commit_callback2_t_swigregister(svn_commit_callback2_t)

class svn_commit_callback_t(object):
    """Proxy of C svn_commit_callback_t struct."""

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    def set_parent_pool(self, parent_pool=None):
      """Create a new proxy object for TYPE"""
      import libsvn.core, weakref
      self.__dict__["_parent_pool"] = \
        parent_pool or libsvn.core.application_pool;
      if self.__dict__["_parent_pool"]:
        self.__dict__["_is_valid"] = weakref.ref(
          self.__dict__["_parent_pool"]._is_valid)

    def assert_valid(self):
      """Assert that this object is using valid pool memory"""
      if "_is_valid" in self.__dict__:
        assert self.__dict__["_is_valid"](), "Variable has already been deleted"

    def _retrieve_swig_value(self, name, value):
    # If we got back a different object than we have cached, we need to copy
    # all our metadata into it, so that it looks identical to the one
    # originally set.
      members = self.__dict__.get('_members')
      if members is not None and name in members:
        _copy_metadata_deep(value, members[name])

    # Verify that the new object is good
      _assert_valid_deep(value)

      return value

    # Attribute access must be intercepted to ensure that objects coming from
    # read attribute access match those that are set with write attribute access.
    # Specifically the metadata, such as the associated apr_pool object, should
    # match the originally assigned object.
    #
    # For classic classes it is enough to use __getattr__ to intercept swig
    # derived attributes. However, with new style classes SWIG makes use of
    # descriptors which mean that __getattr__ is never called. Therefore,
    # __getattribute__ must be used for the interception.

    if _newclass:
      def __getattribute__(self, name):
        """Manage access to all attributes of this object."""

    # Start by mimicing __getattr__ behavior: immediately return __dict__ or
    # items directly present in __dict__
        mydict = object.__getattribute__(self, '__dict__')

        if name == "__dict__":
          return mydict

        if name in mydict:
          return mydict[name]

        object.__getattribute__(self, 'assert_valid')()

        value = _get_instance_attr(self, name)
        fn = object.__getattribute__(self, '_retrieve_swig_value')
        return fn(name, value)
    else:
      def __getattr__(self, name):
        """Get an attribute from this object"""
        self.assert_valid()

        value = _swig_getattr(self, self.__class__, name)

        return self._retrieve_swig_value(name, value)

    def __setattr__(self, name, value):
      """Set an attribute on this object"""
      self.assert_valid()

    # Save a copy of the object, so that the garbage
    # collector won't kill the object while it's in
    # SWIG-land
      self.__dict__.setdefault("_members",{})[name] = value

      return _set_instance_attr(self, name, value)


    def __call__(self, *args):
      return svn_commit_invoke_callback(self, *args)

svn_commit_callback_t_swigregister = _core.svn_commit_callback_t_swigregister
svn_commit_callback_t_swigregister(svn_commit_callback_t)

class svn_cancel_func_t(object):
    """Proxy of C svn_cancel_func_t struct."""

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    def set_parent_pool(self, parent_pool=None):
      """Create a new proxy object for TYPE"""
      import libsvn.core, weakref
      self.__dict__["_parent_pool"] = \
        parent_pool or libsvn.core.application_pool;
      if self.__dict__["_parent_pool"]:
        self.__dict__["_is_valid"] = weakref.ref(
          self.__dict__["_parent_pool"]._is_valid)

    def assert_valid(self):
      """Assert that this object is using valid pool memory"""
      if "_is_valid" in self.__dict__:
        assert self.__dict__["_is_valid"](), "Variable has already been deleted"

    def _retrieve_swig_value(self, name, value):
    # If we got back a different object than we have cached, we need to copy
    # all our metadata into it, so that it looks identical to the one
    # originally set.
      members = self.__dict__.get('_members')
      if members is not None and name in members:
        _copy_metadata_deep(value, members[name])

    # Verify that the new object is good
      _assert_valid_deep(value)

      return value

    # Attribute access must be intercepted to ensure that objects coming from
    # read attribute access match those that are set with write attribute access.
    # Specifically the metadata, such as the associated apr_pool object, should
    # match the originally assigned object.
    #
    # For classic classes it is enough to use __getattr__ to intercept swig
    # derived attributes. However, with new style classes SWIG makes use of
    # descriptors which mean that __getattr__ is never called. Therefore,
    # __getattribute__ must be used for the interception.

    if _newclass:
      def __getattribute__(self, name):
        """Manage access to all attributes of this object."""

    # Start by mimicing __getattr__ behavior: immediately return __dict__ or
    # items directly present in __dict__
        mydict = object.__getattribute__(self, '__dict__')

        if name == "__dict__":
          return mydict

        if name in mydict:
          return mydict[name]

        object.__getattribute__(self, 'assert_valid')()

        value = _get_instance_attr(self, name)
        fn = object.__getattribute__(self, '_retrieve_swig_value')
        return fn(name, value)
    else:
      def __getattr__(self, name):
        """Get an attribute from this object"""
        self.assert_valid()

        value = _swig_getattr(self, self.__class__, name)

        return self._retrieve_swig_value(name, value)

    def __setattr__(self, name, value):
      """Set an attribute on this object"""
      self.assert_valid()

    # Save a copy of the object, so that the garbage
    # collector won't kill the object while it's in
    # SWIG-land
      self.__dict__.setdefault("_members",{})[name] = value

      return _set_instance_attr(self, name, value)


    def __call__(self, *args):
      return svn_cancel_invoke_func(self, *args)

svn_cancel_func_t_swigregister = _core.svn_cancel_func_t_swigregister
svn_cancel_func_t_swigregister(svn_cancel_func_t)

class svn_location_segment_receiver_t(object):
    """Proxy of C svn_location_segment_receiver_t struct."""

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    def set_parent_pool(self, parent_pool=None):
      """Create a new proxy object for TYPE"""
      import libsvn.core, weakref
      self.__dict__["_parent_pool"] = \
        parent_pool or libsvn.core.application_pool;
      if self.__dict__["_parent_pool"]:
        self.__dict__["_is_valid"] = weakref.ref(
          self.__dict__["_parent_pool"]._is_valid)

    def assert_valid(self):
      """Assert that this object is using valid pool memory"""
      if "_is_valid" in self.__dict__:
        assert self.__dict__["_is_valid"](), "Variable has already been deleted"

    def _retrieve_swig_value(self, name, value):
    # If we got back a different object than we have cached, we need to copy
    # all our metadata into it, so that it looks identical to the one
    # originally set.
      members = self.__dict__.get('_members')
      if members is not None and name in members:
        _copy_metadata_deep(value, members[name])

    # Verify that the new object is good
      _assert_valid_deep(value)

      return value

    # Attribute access must be intercepted to ensure that objects coming from
    # read attribute access match those that are set with write attribute access.
    # Specifically the metadata, such as the associated apr_pool object, should
    # match the originally assigned object.
    #
    # For classic classes it is enough to use __getattr__ to intercept swig
    # derived attributes. However, with new style classes SWIG makes use of
    # descriptors which mean that __getattr__ is never called. Therefore,
    # __getattribute__ must be used for the interception.

    if _newclass:
      def __getattribute__(self, name):
        """Manage access to all attributes of this object."""

    # Start by mimicing __getattr__ behavior: immediately return __dict__ or
    # items directly present in __dict__
        mydict = object.__getattribute__(self, '__dict__')

        if name == "__dict__":
          return mydict

        if name in mydict:
          return mydict[name]

        object.__getattribute__(self, 'assert_valid')()

        value = _get_instance_attr(self, name)
        fn = object.__getattribute__(self, '_retrieve_swig_value')
        return fn(name, value)
    else:
      def __getattr__(self, name):
        """Get an attribute from this object"""
        self.assert_valid()

        value = _swig_getattr(self, self.__class__, name)

        return self._retrieve_swig_value(name, value)

    def __setattr__(self, name, value):
      """Set an attribute on this object"""
      self.assert_valid()

    # Save a copy of the object, so that the garbage
    # collector won't kill the object while it's in
    # SWIG-land
      self.__dict__.setdefault("_members",{})[name] = value

      return _set_instance_attr(self, name, value)


    def __call__(self, *args):
      return svn_location_invoke_segment_receiver(self, *args)

svn_location_segment_receiver_t_swigregister = _core.svn_location_segment_receiver_t_swigregister
svn_location_segment_receiver_t_swigregister(svn_location_segment_receiver_t)

SVN_ALLOCATOR_RECOMMENDED_MAX_FREE = _core.SVN_ALLOCATOR_RECOMMENDED_MAX_FREE

def svn_pool_create(*args) -> "apr_pool_t *":
    """svn_pool_create(apr_pool_t parent_pool, apr_allocator_t * allocator) -> apr_pool_t"""
    return _core.svn_pool_create(*args)

def svn_pool_create_allocator(thread_safe: 'svn_boolean_t') -> "apr_allocator_t *":
    """svn_pool_create_allocator(svn_boolean_t thread_safe) -> apr_allocator_t *"""
    return _core.svn_pool_create_allocator(thread_safe)
SVN_VER_MAJOR = _core.SVN_VER_MAJOR
SVN_VER_MINOR = _core.SVN_VER_MINOR
SVN_VER_PATCH = _core.SVN_VER_PATCH
SVN_VER_MICRO = _core.SVN_VER_MICRO
SVN_VER_LIBRARY = _core.SVN_VER_LIBRARY
SVN_VER_TAG = _core.SVN_VER_TAG
SVN_VER_NUMTAG = _core.SVN_VER_NUMTAG
SVN_VER_REVISION = _core.SVN_VER_REVISION
SVN_VER_NUM = _core.SVN_VER_NUM
SVN_VER_NUMBER = _core.SVN_VER_NUMBER
SVN_VERSION = _core.SVN_VERSION

def svn_ver_compatible(my_version: 'svn_version_t const *', lib_version: 'svn_version_t const *') -> "svn_boolean_t":
    """svn_ver_compatible(svn_version_t const * my_version, svn_version_t const * lib_version) -> svn_boolean_t"""
    return _core.svn_ver_compatible(my_version, lib_version)

def svn_ver_equal(my_version: 'svn_version_t const *', lib_version: 'svn_version_t const *') -> "svn_boolean_t":
    """svn_ver_equal(svn_version_t const * my_version, svn_version_t const * lib_version) -> svn_boolean_t"""
    return _core.svn_ver_equal(my_version, lib_version)
class svn_version_checklist_t(object):
    """Proxy of C svn_version_checklist_t struct."""

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    label = _swig_property(_core.svn_version_checklist_t_label_get, _core.svn_version_checklist_t_label_set)
    version_query = _swig_property(_core.svn_version_checklist_t_version_query_get, _core.svn_version_checklist_t_version_query_set)
    def set_parent_pool(self, parent_pool=None):
      """Create a new proxy object for TYPE"""
      import libsvn.core, weakref
      self.__dict__["_parent_pool"] = \
        parent_pool or libsvn.core.application_pool;
      if self.__dict__["_parent_pool"]:
        self.__dict__["_is_valid"] = weakref.ref(
          self.__dict__["_parent_pool"]._is_valid)

    def assert_valid(self):
      """Assert that this object is using valid pool memory"""
      if "_is_valid" in self.__dict__:
        assert self.__dict__["_is_valid"](), "Variable has already been deleted"

    def _retrieve_swig_value(self, name, value):
    # If we got back a different object than we have cached, we need to copy
    # all our metadata into it, so that it looks identical to the one
    # originally set.
      members = self.__dict__.get('_members')
      if members is not None and name in members:
        _copy_metadata_deep(value, members[name])

    # Verify that the new object is good
      _assert_valid_deep(value)

      return value

    # Attribute access must be intercepted to ensure that objects coming from
    # read attribute access match those that are set with write attribute access.
    # Specifically the metadata, such as the associated apr_pool object, should
    # match the originally assigned object.
    #
    # For classic classes it is enough to use __getattr__ to intercept swig
    # derived attributes. However, with new style classes SWIG makes use of
    # descriptors which mean that __getattr__ is never called. Therefore,
    # __getattribute__ must be used for the interception.

    if _newclass:
      def __getattribute__(self, name):
        """Manage access to all attributes of this object."""

    # Start by mimicing __getattr__ behavior: immediately return __dict__ or
    # items directly present in __dict__
        mydict = object.__getattribute__(self, '__dict__')

        if name == "__dict__":
          return mydict

        if name in mydict:
          return mydict[name]

        object.__getattribute__(self, 'assert_valid')()

        value = _get_instance_attr(self, name)
        fn = object.__getattribute__(self, '_retrieve_swig_value')
        return fn(name, value)
    else:
      def __getattr__(self, name):
        """Get an attribute from this object"""
        self.assert_valid()

        value = _swig_getattr(self, self.__class__, name)

        return self._retrieve_swig_value(name, value)

    def __setattr__(self, name, value):
      """Set an attribute on this object"""
      self.assert_valid()

    # Save a copy of the object, so that the garbage
    # collector won't kill the object while it's in
    # SWIG-land
      self.__dict__.setdefault("_members",{})[name] = value

      return _set_instance_attr(self, name, value)


    def version_query(self, *args):
      return svn_version_checklist_invoke_version_query(self, *args)


    def __init__(self):
        """__init__(svn_version_checklist_t self) -> svn_version_checklist_t"""
        this = _core.new_svn_version_checklist_t()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _core.delete_svn_version_checklist_t
    __del__ = lambda self: None
svn_version_checklist_t_swigregister = _core.svn_version_checklist_t_swigregister
svn_version_checklist_t_swigregister(svn_version_checklist_t)


def svn_ver_check_list2(my_version: 'svn_version_t const *', checklist: 'svn_version_checklist_t', comparator: 'svn_boolean_t (*)(svn_version_t const *,svn_version_t const *)') -> "svn_error_t *":
    """svn_ver_check_list2(svn_version_t const * my_version, svn_version_checklist_t checklist, svn_boolean_t (*)(svn_version_t const *,svn_version_t const *) comparator) -> svn_error_t"""
    return _core.svn_ver_check_list2(my_version, checklist, comparator)

def svn_ver_check_list(my_version: 'svn_version_t const *', checklist: 'svn_version_checklist_t') -> "svn_error_t *":
    """svn_ver_check_list(svn_version_t const * my_version, svn_version_checklist_t checklist) -> svn_error_t"""
    return _core.svn_ver_check_list(my_version, checklist)

def svn_subr_version() -> "svn_version_t const *":
    """svn_subr_version() -> svn_version_t const *"""
    return _core.svn_subr_version()

def svn_version_extended(*args) -> "svn_version_extended_t const *":
    """svn_version_extended(svn_boolean_t verbose, apr_pool_t pool) -> svn_version_extended_t const *"""
    return _core.svn_version_extended(*args)

def svn_version_ext_build_date(ext_info: 'svn_version_extended_t const *') -> "char const *":
    """svn_version_ext_build_date(svn_version_extended_t const * ext_info) -> char const *"""
    return _core.svn_version_ext_build_date(ext_info)

def svn_version_ext_build_time(ext_info: 'svn_version_extended_t const *') -> "char const *":
    """svn_version_ext_build_time(svn_version_extended_t const * ext_info) -> char const *"""
    return _core.svn_version_ext_build_time(ext_info)

def svn_version_ext_build_host(ext_info: 'svn_version_extended_t const *') -> "char const *":
    """svn_version_ext_build_host(svn_version_extended_t const * ext_info) -> char const *"""
    return _core.svn_version_ext_build_host(ext_info)

def svn_version_ext_copyright(ext_info: 'svn_version_extended_t const *') -> "char const *":
    """svn_version_ext_copyright(svn_version_extended_t const * ext_info) -> char const *"""
    return _core.svn_version_ext_copyright(ext_info)

def svn_version_ext_runtime_host(ext_info: 'svn_version_extended_t const *') -> "char const *":
    """svn_version_ext_runtime_host(svn_version_extended_t const * ext_info) -> char const *"""
    return _core.svn_version_ext_runtime_host(ext_info)

def svn_version_ext_runtime_osname(ext_info: 'svn_version_extended_t const *') -> "char const *":
    """svn_version_ext_runtime_osname(svn_version_extended_t const * ext_info) -> char const *"""
    return _core.svn_version_ext_runtime_osname(ext_info)
class svn_version_ext_linked_lib_t(object):
    """Proxy of C svn_version_ext_linked_lib_t struct."""

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    name = _swig_property(_core.svn_version_ext_linked_lib_t_name_get, _core.svn_version_ext_linked_lib_t_name_set)
    compiled_version = _swig_property(_core.svn_version_ext_linked_lib_t_compiled_version_get, _core.svn_version_ext_linked_lib_t_compiled_version_set)
    runtime_version = _swig_property(_core.svn_version_ext_linked_lib_t_runtime_version_get, _core.svn_version_ext_linked_lib_t_runtime_version_set)
    def set_parent_pool(self, parent_pool=None):
      """Create a new proxy object for TYPE"""
      import libsvn.core, weakref
      self.__dict__["_parent_pool"] = \
        parent_pool or libsvn.core.application_pool;
      if self.__dict__["_parent_pool"]:
        self.__dict__["_is_valid"] = weakref.ref(
          self.__dict__["_parent_pool"]._is_valid)

    def assert_valid(self):
      """Assert that this object is using valid pool memory"""
      if "_is_valid" in self.__dict__:
        assert self.__dict__["_is_valid"](), "Variable has already been deleted"

    def _retrieve_swig_value(self, name, value):
    # If we got back a different object than we have cached, we need to copy
    # all our metadata into it, so that it looks identical to the one
    # originally set.
      members = self.__dict__.get('_members')
      if members is not None and name in members:
        _copy_metadata_deep(value, members[name])

    # Verify that the new object is good
      _assert_valid_deep(value)

      return value

    # Attribute access must be intercepted to ensure that objects coming from
    # read attribute access match those that are set with write attribute access.
    # Specifically the metadata, such as the associated apr_pool object, should
    # match the originally assigned object.
    #
    # For classic classes it is enough to use __getattr__ to intercept swig
    # derived attributes. However, with new style classes SWIG makes use of
    # descriptors which mean that __getattr__ is never called. Therefore,
    # __getattribute__ must be used for the interception.

    if _newclass:
      def __getattribute__(self, name):
        """Manage access to all attributes of this object."""

    # Start by mimicing __getattr__ behavior: immediately return __dict__ or
    # items directly present in __dict__
        mydict = object.__getattribute__(self, '__dict__')

        if name == "__dict__":
          return mydict

        if name in mydict:
          return mydict[name]

        object.__getattribute__(self, 'assert_valid')()

        value = _get_instance_attr(self, name)
        fn = object.__getattribute__(self, '_retrieve_swig_value')
        return fn(name, value)
    else:
      def __getattr__(self, name):
        """Get an attribute from this object"""
        self.assert_valid()

        value = _swig_getattr(self, self.__class__, name)

        return self._retrieve_swig_value(name, value)

    def __setattr__(self, name, value):
      """Set an attribute on this object"""
      self.assert_valid()

    # Save a copy of the object, so that the garbage
    # collector won't kill the object while it's in
    # SWIG-land
      self.__dict__.setdefault("_members",{})[name] = value

      return _set_instance_attr(self, name, value)


    def __init__(self):
        """__init__(svn_version_ext_linked_lib_t self) -> svn_version_ext_linked_lib_t"""
        this = _core.new_svn_version_ext_linked_lib_t()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _core.delete_svn_version_ext_linked_lib_t
    __del__ = lambda self: None
svn_version_ext_linked_lib_t_swigregister = _core.svn_version_ext_linked_lib_t_swigregister
svn_version_ext_linked_lib_t_swigregister(svn_version_ext_linked_lib_t)


def svn_version_ext_linked_libs(ext_info: 'svn_version_extended_t const *') -> "apr_array_header_t const *":
    """svn_version_ext_linked_libs(svn_version_extended_t const * ext_info) -> apr_array_header_t"""
    return _core.svn_version_ext_linked_libs(ext_info)
class svn_version_ext_loaded_lib_t(object):
    """Proxy of C svn_version_ext_loaded_lib_t struct."""

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    name = _swig_property(_core.svn_version_ext_loaded_lib_t_name_get, _core.svn_version_ext_loaded_lib_t_name_set)
    version = _swig_property(_core.svn_version_ext_loaded_lib_t_version_get, _core.svn_version_ext_loaded_lib_t_version_set)
    def set_parent_pool(self, parent_pool=None):
      """Create a new proxy object for TYPE"""
      import libsvn.core, weakref
      self.__dict__["_parent_pool"] = \
        parent_pool or libsvn.core.application_pool;
      if self.__dict__["_parent_pool"]:
        self.__dict__["_is_valid"] = weakref.ref(
          self.__dict__["_parent_pool"]._is_valid)

    def assert_valid(self):
      """Assert that this object is using valid pool memory"""
      if "_is_valid" in self.__dict__:
        assert self.__dict__["_is_valid"](), "Variable has already been deleted"

    def _retrieve_swig_value(self, name, value):
    # If we got back a different object than we have cached, we need to copy
    # all our metadata into it, so that it looks identical to the one
    # originally set.
      members = self.__dict__.get('_members')
      if members is not None and name in members:
        _copy_metadata_deep(value, members[name])

    # Verify that the new object is good
      _assert_valid_deep(value)

      return value

    # Attribute access must be intercepted to ensure that objects coming from
    # read attribute access match those that are set with write attribute access.
    # Specifically the metadata, such as the associated apr_pool object, should
    # match the originally assigned object.
    #
    # For classic classes it is enough to use __getattr__ to intercept swig
    # derived attributes. However, with new style classes SWIG makes use of
    # descriptors which mean that __getattr__ is never called. Therefore,
    # __getattribute__ must be used for the interception.

    if _newclass:
      def __getattribute__(self, name):
        """Manage access to all attributes of this object."""

    # Start by mimicing __getattr__ behavior: immediately return __dict__ or
    # items directly present in __dict__
        mydict = object.__getattribute__(self, '__dict__')

        if name == "__dict__":
          return mydict

        if name in mydict:
          return mydict[name]

        object.__getattribute__(self, 'assert_valid')()

        value = _get_instance_attr(self, name)
        fn = object.__getattribute__(self, '_retrieve_swig_value')
        return fn(name, value)
    else:
      def __getattr__(self, name):
        """Get an attribute from this object"""
        self.assert_valid()

        value = _swig_getattr(self, self.__class__, name)

        return self._retrieve_swig_value(name, value)

    def __setattr__(self, name, value):
      """Set an attribute on this object"""
      self.assert_valid()

    # Save a copy of the object, so that the garbage
    # collector won't kill the object while it's in
    # SWIG-land
      self.__dict__.setdefault("_members",{})[name] = value

      return _set_instance_attr(self, name, value)


    def __init__(self):
        """__init__(svn_version_ext_loaded_lib_t self) -> svn_version_ext_loaded_lib_t"""
        this = _core.new_svn_version_ext_loaded_lib_t()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _core.delete_svn_version_ext_loaded_lib_t
    __del__ = lambda self: None
svn_version_ext_loaded_lib_t_swigregister = _core.svn_version_ext_loaded_lib_t_swigregister
svn_version_ext_loaded_lib_t_swigregister(svn_version_ext_loaded_lib_t)


def svn_version_ext_loaded_libs(ext_info: 'svn_version_extended_t const *') -> "apr_array_header_t const *":
    """svn_version_ext_loaded_libs(svn_version_extended_t const * ext_info) -> apr_array_header_t"""
    return _core.svn_version_ext_loaded_libs(ext_info)
class svn_version_extended_t(object):
    """Proxy of C svn_version_extended_t struct."""

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    def set_parent_pool(self, parent_pool=None):
      """Create a new proxy object for TYPE"""
      import libsvn.core, weakref
      self.__dict__["_parent_pool"] = \
        parent_pool or libsvn.core.application_pool;
      if self.__dict__["_parent_pool"]:
        self.__dict__["_is_valid"] = weakref.ref(
          self.__dict__["_parent_pool"]._is_valid)

    def assert_valid(self):
      """Assert that this object is using valid pool memory"""
      if "_is_valid" in self.__dict__:
        assert self.__dict__["_is_valid"](), "Variable has already been deleted"

    def _retrieve_swig_value(self, name, value):
    # If we got back a different object than we have cached, we need to copy
    # all our metadata into it, so that it looks identical to the one
    # originally set.
      members = self.__dict__.get('_members')
      if members is not None and name in members:
        _copy_metadata_deep(value, members[name])

    # Verify that the new object is good
      _assert_valid_deep(value)

      return value

    # Attribute access must be intercepted to ensure that objects coming from
    # read attribute access match those that are set with write attribute access.
    # Specifically the metadata, such as the associated apr_pool object, should
    # match the originally assigned object.
    #
    # For classic classes it is enough to use __getattr__ to intercept swig
    # derived attributes. However, with new style classes SWIG makes use of
    # descriptors which mean that __getattr__ is never called. Therefore,
    # __getattribute__ must be used for the interception.

    if _newclass:
      def __getattribute__(self, name):
        """Manage access to all attributes of this object."""

    # Start by mimicing __getattr__ behavior: immediately return __dict__ or
    # items directly present in __dict__
        mydict = object.__getattribute__(self, '__dict__')

        if name == "__dict__":
          return mydict

        if name in mydict:
          return mydict[name]

        object.__getattribute__(self, 'assert_valid')()

        value = _get_instance_attr(self, name)
        fn = object.__getattribute__(self, '_retrieve_swig_value')
        return fn(name, value)
    else:
      def __getattr__(self, name):
        """Get an attribute from this object"""
        self.assert_valid()

        value = _swig_getattr(self, self.__class__, name)

        return self._retrieve_swig_value(name, value)

    def __setattr__(self, name, value):
      """Set an attribute on this object"""
      self.assert_valid()

    # Save a copy of the object, so that the garbage
    # collector won't kill the object while it's in
    # SWIG-land
      self.__dict__.setdefault("_members",{})[name] = value

      return _set_instance_attr(self, name, value)

svn_version_extended_t_swigregister = _core.svn_version_extended_t_swigregister
svn_version_extended_t_swigregister(svn_version_extended_t)


def svn_version_checklist_invoke_version_query(_obj: 'svn_version_checklist_t') -> "svn_version_t const *":
    """svn_version_checklist_invoke_version_query(svn_version_checklist_t _obj) -> svn_version_t const *"""
    return _core.svn_version_checklist_invoke_version_query(_obj)

def svn_version_invoke_func(_obj: 'svn_version_func_t') -> "svn_version_t const *":
    """svn_version_invoke_func(svn_version_func_t _obj) -> svn_version_t const *"""
    return _core.svn_version_invoke_func(_obj)
class svn_version_func_t(object):
    """Proxy of C svn_version_func_t struct."""

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    def set_parent_pool(self, parent_pool=None):
      """Create a new proxy object for TYPE"""
      import libsvn.core, weakref
      self.__dict__["_parent_pool"] = \
        parent_pool or libsvn.core.application_pool;
      if self.__dict__["_parent_pool"]:
        self.__dict__["_is_valid"] = weakref.ref(
          self.__dict__["_parent_pool"]._is_valid)

    def assert_valid(self):
      """Assert that this object is using valid pool memory"""
      if "_is_valid" in self.__dict__:
        assert self.__dict__["_is_valid"](), "Variable has already been deleted"

    def _retrieve_swig_value(self, name, value):
    # If we got back a different object than we have cached, we need to copy
    # all our metadata into it, so that it looks identical to the one
    # originally set.
      members = self.__dict__.get('_members')
      if members is not None and name in members:
        _copy_metadata_deep(value, members[name])

    # Verify that the new object is good
      _assert_valid_deep(value)

      return value

    # Attribute access must be intercepted to ensure that objects coming from
    # read attribute access match those that are set with write attribute access.
    # Specifically the metadata, such as the associated apr_pool object, should
    # match the originally assigned object.
    #
    # For classic classes it is enough to use __getattr__ to intercept swig
    # derived attributes. However, with new style classes SWIG makes use of
    # descriptors which mean that __getattr__ is never called. Therefore,
    # __getattribute__ must be used for the interception.

    if _newclass:
      def __getattribute__(self, name):
        """Manage access to all attributes of this object."""

    # Start by mimicing __getattr__ behavior: immediately return __dict__ or
    # items directly present in __dict__
        mydict = object.__getattribute__(self, '__dict__')

        if name == "__dict__":
          return mydict

        if name in mydict:
          return mydict[name]

        object.__getattribute__(self, 'assert_valid')()

        value = _get_instance_attr(self, name)
        fn = object.__getattribute__(self, '_retrieve_swig_value')
        return fn(name, value)
    else:
      def __getattr__(self, name):
        """Get an attribute from this object"""
        self.assert_valid()

        value = _swig_getattr(self, self.__class__, name)

        return self._retrieve_swig_value(name, value)

    def __setattr__(self, name, value):
      """Set an attribute on this object"""
      self.assert_valid()

    # Save a copy of the object, so that the garbage
    # collector won't kill the object while it's in
    # SWIG-land
      self.__dict__.setdefault("_members",{})[name] = value

      return _set_instance_attr(self, name, value)


    def __call__(self, *args):
      return svn_version_invoke_func(self, *args)

svn_version_func_t_swigregister = _core.svn_version_func_t_swigregister
svn_version_func_t_swigregister(svn_version_func_t)


def svn_prop_dup(*args) -> "svn_prop_t *":
    """svn_prop_dup(svn_prop_t const * prop, apr_pool_t pool) -> svn_prop_t *"""
    return _core.svn_prop_dup(*args)

def svn_prop_array_dup(*args) -> "apr_array_header_t *":
    """svn_prop_array_dup(apr_array_header_t array, apr_pool_t pool) -> apr_array_header_t"""
    return _core.svn_prop_array_dup(*args)
class svn_prop_inherited_item_t(object):
    """Proxy of C svn_prop_inherited_item_t struct."""

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    path_or_url = _swig_property(_core.svn_prop_inherited_item_t_path_or_url_get, _core.svn_prop_inherited_item_t_path_or_url_set)
    prop_hash = _swig_property(_core.svn_prop_inherited_item_t_prop_hash_get, _core.svn_prop_inherited_item_t_prop_hash_set)
    def set_parent_pool(self, parent_pool=None):
      """Create a new proxy object for TYPE"""
      import libsvn.core, weakref
      self.__dict__["_parent_pool"] = \
        parent_pool or libsvn.core.application_pool;
      if self.__dict__["_parent_pool"]:
        self.__dict__["_is_valid"] = weakref.ref(
          self.__dict__["_parent_pool"]._is_valid)

    def assert_valid(self):
      """Assert that this object is using valid pool memory"""
      if "_is_valid" in self.__dict__:
        assert self.__dict__["_is_valid"](), "Variable has already been deleted"

    def _retrieve_swig_value(self, name, value):
    # If we got back a different object than we have cached, we need to copy
    # all our metadata into it, so that it looks identical to the one
    # originally set.
      members = self.__dict__.get('_members')
      if members is not None and name in members:
        _copy_metadata_deep(value, members[name])

    # Verify that the new object is good
      _assert_valid_deep(value)

      return value

    # Attribute access must be intercepted to ensure that objects coming from
    # read attribute access match those that are set with write attribute access.
    # Specifically the metadata, such as the associated apr_pool object, should
    # match the originally assigned object.
    #
    # For classic classes it is enough to use __getattr__ to intercept swig
    # derived attributes. However, with new style classes SWIG makes use of
    # descriptors which mean that __getattr__ is never called. Therefore,
    # __getattribute__ must be used for the interception.

    if _newclass:
      def __getattribute__(self, name):
        """Manage access to all attributes of this object."""

    # Start by mimicing __getattr__ behavior: immediately return __dict__ or
    # items directly present in __dict__
        mydict = object.__getattribute__(self, '__dict__')

        if name == "__dict__":
          return mydict

        if name in mydict:
          return mydict[name]

        object.__getattribute__(self, 'assert_valid')()

        value = _get_instance_attr(self, name)
        fn = object.__getattribute__(self, '_retrieve_swig_value')
        return fn(name, value)
    else:
      def __getattr__(self, name):
        """Get an attribute from this object"""
        self.assert_valid()

        value = _swig_getattr(self, self.__class__, name)

        return self._retrieve_swig_value(name, value)

    def __setattr__(self, name, value):
      """Set an attribute on this object"""
      self.assert_valid()

    # Save a copy of the object, so that the garbage
    # collector won't kill the object while it's in
    # SWIG-land
      self.__dict__.setdefault("_members",{})[name] = value

      return _set_instance_attr(self, name, value)


    def __init__(self):
        """__init__(svn_prop_inherited_item_t self) -> svn_prop_inherited_item_t"""
        this = _core.new_svn_prop_inherited_item_t()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _core.delete_svn_prop_inherited_item_t
    __del__ = lambda self: None
svn_prop_inherited_item_t_swigregister = _core.svn_prop_inherited_item_t_swigregister
svn_prop_inherited_item_t_swigregister(svn_prop_inherited_item_t)


def svn_prop_hash_to_array(*args) -> "apr_array_header_t *":
    """svn_prop_hash_to_array(apr_hash_t hash, apr_pool_t pool) -> apr_array_header_t"""
    return _core.svn_prop_hash_to_array(*args)

def svn_prop_array_to_hash(*args) -> "apr_hash_t *":
    """svn_prop_array_to_hash(apr_array_header_t properties, apr_pool_t result) -> apr_hash_t"""
    return _core.svn_prop_array_to_hash(*args)

def svn_prop_hash_dup(*args) -> "apr_hash_t *":
    """svn_prop_hash_dup(apr_hash_t hash, apr_pool_t pool) -> apr_hash_t"""
    return _core.svn_prop_hash_dup(*args)

def svn_prop_get_value(properties: 'apr_hash_t', prop_name: 'char const *') -> "char const *":
    """svn_prop_get_value(apr_hash_t properties, char const * prop_name) -> char const *"""
    return _core.svn_prop_get_value(properties, prop_name)
svn_prop_entry_kind = _core.svn_prop_entry_kind
svn_prop_wc_kind = _core.svn_prop_wc_kind
svn_prop_regular_kind = _core.svn_prop_regular_kind

def svn_property_kind2(prop_name: 'char const *') -> "svn_prop_kind_t":
    """svn_property_kind2(char const * prop_name) -> svn_prop_kind_t"""
    return _core.svn_property_kind2(prop_name)

def svn_property_kind(prop_name: 'char const *') -> "int *":
    """svn_property_kind(char const * prop_name) -> svn_prop_kind_t"""
    return _core.svn_property_kind(prop_name)

def svn_prop_is_svn_prop(prop_name: 'char const *') -> "svn_boolean_t":
    """svn_prop_is_svn_prop(char const * prop_name) -> svn_boolean_t"""
    return _core.svn_prop_is_svn_prop(prop_name)

def svn_prop_has_svn_prop(*args) -> "svn_boolean_t":
    """svn_prop_has_svn_prop(apr_hash_t props, apr_pool_t pool) -> svn_boolean_t"""
    return _core.svn_prop_has_svn_prop(*args)

def svn_prop_is_boolean(prop_name: 'char const *') -> "svn_boolean_t":
    """svn_prop_is_boolean(char const * prop_name) -> svn_boolean_t"""
    return _core.svn_prop_is_boolean(prop_name)

def svn_prop_is_known_svn_rev_prop(prop_name: 'char const *') -> "svn_boolean_t":
    """svn_prop_is_known_svn_rev_prop(char const * prop_name) -> svn_boolean_t"""
    return _core.svn_prop_is_known_svn_rev_prop(prop_name)

def svn_prop_is_known_svn_node_prop(prop_name: 'char const *') -> "svn_boolean_t":
    """svn_prop_is_known_svn_node_prop(char const * prop_name) -> svn_boolean_t"""
    return _core.svn_prop_is_known_svn_node_prop(prop_name)

def svn_prop_is_known_svn_file_prop(prop_name: 'char const *') -> "svn_boolean_t":
    """svn_prop_is_known_svn_file_prop(char const * prop_name) -> svn_boolean_t"""
    return _core.svn_prop_is_known_svn_file_prop(prop_name)

def svn_prop_is_known_svn_dir_prop(prop_name: 'char const *') -> "svn_boolean_t":
    """svn_prop_is_known_svn_dir_prop(char const * prop_name) -> svn_boolean_t"""
    return _core.svn_prop_is_known_svn_dir_prop(prop_name)

def svn_prop_needs_translation(prop_name: 'char const *') -> "svn_boolean_t":
    """svn_prop_needs_translation(char const * prop_name) -> svn_boolean_t"""
    return _core.svn_prop_needs_translation(prop_name)

def svn_categorize_props(*args) -> "apr_array_header_t **, apr_array_header_t **, apr_array_header_t **":
    """svn_categorize_props(apr_array_header_t proplist, apr_pool_t pool) -> svn_error_t"""
    return _core.svn_categorize_props(*args)

def svn_prop_diffs(*args) -> "apr_array_header_t **":
    """svn_prop_diffs(apr_hash_t target_props, apr_hash_t source_props, apr_pool_t pool) -> svn_error_t"""
    return _core.svn_prop_diffs(*args)

def svn_prop_name_is_valid(prop_name: 'char const *') -> "svn_boolean_t":
    """svn_prop_name_is_valid(char const * prop_name) -> svn_boolean_t"""
    return _core.svn_prop_name_is_valid(prop_name)
SVN_PROP_PREFIX = _core.SVN_PROP_PREFIX
SVN_PROP_BOOLEAN_TRUE = _core.SVN_PROP_BOOLEAN_TRUE
SVN_PROP_MIME_TYPE = _core.SVN_PROP_MIME_TYPE
SVN_PROP_IGNORE = _core.SVN_PROP_IGNORE
SVN_PROP_EOL_STYLE = _core.SVN_PROP_EOL_STYLE
SVN_PROP_KEYWORDS = _core.SVN_PROP_KEYWORDS
SVN_PROP_EXECUTABLE = _core.SVN_PROP_EXECUTABLE
SVN_PROP_EXECUTABLE_VALUE = _core.SVN_PROP_EXECUTABLE_VALUE
SVN_PROP_NEEDS_LOCK = _core.SVN_PROP_NEEDS_LOCK
SVN_PROP_NEEDS_LOCK_VALUE = _core.SVN_PROP_NEEDS_LOCK_VALUE
SVN_PROP_SPECIAL = _core.SVN_PROP_SPECIAL
SVN_PROP_SPECIAL_VALUE = _core.SVN_PROP_SPECIAL_VALUE
SVN_PROP_EXTERNALS = _core.SVN_PROP_EXTERNALS
SVN_PROP_MERGEINFO = _core.SVN_PROP_MERGEINFO
SVN_PROP_INHERITABLE_AUTO_PROPS = _core.SVN_PROP_INHERITABLE_AUTO_PROPS
SVN_PROP_INHERITABLE_IGNORES = _core.SVN_PROP_INHERITABLE_IGNORES
SVN_PROP_TEXT_TIME = _core.SVN_PROP_TEXT_TIME
SVN_PROP_OWNER = _core.SVN_PROP_OWNER
SVN_PROP_GROUP = _core.SVN_PROP_GROUP
SVN_PROP_UNIX_MODE = _core.SVN_PROP_UNIX_MODE
SVN_PROP_WC_PREFIX = _core.SVN_PROP_WC_PREFIX
SVN_PROP_ENTRY_PREFIX = _core.SVN_PROP_ENTRY_PREFIX
SVN_PROP_ENTRY_COMMITTED_REV = _core.SVN_PROP_ENTRY_COMMITTED_REV
SVN_PROP_ENTRY_COMMITTED_DATE = _core.SVN_PROP_ENTRY_COMMITTED_DATE
SVN_PROP_ENTRY_LAST_AUTHOR = _core.SVN_PROP_ENTRY_LAST_AUTHOR
SVN_PROP_ENTRY_UUID = _core.SVN_PROP_ENTRY_UUID
SVN_PROP_ENTRY_LOCK_TOKEN = _core.SVN_PROP_ENTRY_LOCK_TOKEN
SVN_PROP_CUSTOM_PREFIX = _core.SVN_PROP_CUSTOM_PREFIX
SVN_PROP_REVISION_AUTHOR = _core.SVN_PROP_REVISION_AUTHOR
SVN_PROP_REVISION_LOG = _core.SVN_PROP_REVISION_LOG
SVN_PROP_REVISION_DATE = _core.SVN_PROP_REVISION_DATE
SVN_PROP_REVISION_ORIG_DATE = _core.SVN_PROP_REVISION_ORIG_DATE
SVN_PROP_REVISION_AUTOVERSIONED = _core.SVN_PROP_REVISION_AUTOVERSIONED
SVNSYNC_PROP_PREFIX = _core.SVNSYNC_PROP_PREFIX
SVNSYNC_PROP_LOCK = _core.SVNSYNC_PROP_LOCK
SVNSYNC_PROP_FROM_URL = _core.SVNSYNC_PROP_FROM_URL
SVNSYNC_PROP_FROM_UUID = _core.SVNSYNC_PROP_FROM_UUID
SVNSYNC_PROP_LAST_MERGED_REV = _core.SVNSYNC_PROP_LAST_MERGED_REV
SVNSYNC_PROP_CURRENTLY_COPYING = _core.SVNSYNC_PROP_CURRENTLY_COPYING
SVN_PROP_TXN_PREFIX = _core.SVN_PROP_TXN_PREFIX
SVN_PROP_TXN_CLIENT_COMPAT_VERSION = _core.SVN_PROP_TXN_CLIENT_COMPAT_VERSION
SVN_PROP_TXN_USER_AGENT = _core.SVN_PROP_TXN_USER_AGENT
SVN_PROP_REVISION_PREFIX = _core.SVN_PROP_REVISION_PREFIX
svn_opt_revision_unspecified = _core.svn_opt_revision_unspecified
svn_opt_revision_number = _core.svn_opt_revision_number
svn_opt_revision_date = _core.svn_opt_revision_date
svn_opt_revision_committed = _core.svn_opt_revision_committed
svn_opt_revision_previous = _core.svn_opt_revision_previous
svn_opt_revision_base = _core.svn_opt_revision_base
svn_opt_revision_working = _core.svn_opt_revision_working
svn_opt_revision_head = _core.svn_opt_revision_head
SVN_OPT_MAX_ALIASES = _core.SVN_OPT_MAX_ALIASES
SVN_OPT_MAX_OPTIONS = _core.SVN_OPT_MAX_OPTIONS
SVN_OPT_MAX_PARAGRAPHS = _core.SVN_OPT_MAX_PARAGRAPHS
SVN_OPT_FIRST_LONGOPT_ID = _core.SVN_OPT_FIRST_LONGOPT_ID
class svn_opt_subcommand_desc3_t(object):
    """Proxy of C svn_opt_subcommand_desc3_t struct."""

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    name = _swig_property(_core.svn_opt_subcommand_desc3_t_name_get, _core.svn_opt_subcommand_desc3_t_name_set)
    cmd_func = _swig_property(_core.svn_opt_subcommand_desc3_t_cmd_func_get, _core.svn_opt_subcommand_desc3_t_cmd_func_set)
    aliases = _swig_property(_core.svn_opt_subcommand_desc3_t_aliases_get, _core.svn_opt_subcommand_desc3_t_aliases_set)
    help = _swig_property(_core.svn_opt_subcommand_desc3_t_help_get, _core.svn_opt_subcommand_desc3_t_help_set)
    valid_options = _swig_property(_core.svn_opt_subcommand_desc3_t_valid_options_get, _core.svn_opt_subcommand_desc3_t_valid_options_set)
    desc_overrides = _swig_property(_core.svn_opt_subcommand_desc3_t_desc_overrides_get)
    def set_parent_pool(self, parent_pool=None):
      """Create a new proxy object for TYPE"""
      import libsvn.core, weakref
      self.__dict__["_parent_pool"] = \
        parent_pool or libsvn.core.application_pool;
      if self.__dict__["_parent_pool"]:
        self.__dict__["_is_valid"] = weakref.ref(
          self.__dict__["_parent_pool"]._is_valid)

    def assert_valid(self):
      """Assert that this object is using valid pool memory"""
      if "_is_valid" in self.__dict__:
        assert self.__dict__["_is_valid"](), "Variable has already been deleted"

    def _retrieve_swig_value(self, name, value):
    # If we got back a different object than we have cached, we need to copy
    # all our metadata into it, so that it looks identical to the one
    # originally set.
      members = self.__dict__.get('_members')
      if members is not None and name in members:
        _copy_metadata_deep(value, members[name])

    # Verify that the new object is good
      _assert_valid_deep(value)

      return value

    # Attribute access must be intercepted to ensure that objects coming from
    # read attribute access match those that are set with write attribute access.
    # Specifically the metadata, such as the associated apr_pool object, should
    # match the originally assigned object.
    #
    # For classic classes it is enough to use __getattr__ to intercept swig
    # derived attributes. However, with new style classes SWIG makes use of
    # descriptors which mean that __getattr__ is never called. Therefore,
    # __getattribute__ must be used for the interception.

    if _newclass:
      def __getattribute__(self, name):
        """Manage access to all attributes of this object."""

    # Start by mimicing __getattr__ behavior: immediately return __dict__ or
    # items directly present in __dict__
        mydict = object.__getattribute__(self, '__dict__')

        if name == "__dict__":
          return mydict

        if name in mydict:
          return mydict[name]

        object.__getattribute__(self, 'assert_valid')()

        value = _get_instance_attr(self, name)
        fn = object.__getattribute__(self, '_retrieve_swig_value')
        return fn(name, value)
    else:
      def __getattr__(self, name):
        """Get an attribute from this object"""
        self.assert_valid()

        value = _swig_getattr(self, self.__class__, name)

        return self._retrieve_swig_value(name, value)

    def __setattr__(self, name, value):
      """Set an attribute on this object"""
      self.assert_valid()

    # Save a copy of the object, so that the garbage
    # collector won't kill the object while it's in
    # SWIG-land
      self.__dict__.setdefault("_members",{})[name] = value

      return _set_instance_attr(self, name, value)


    def __init__(self):
        """__init__(svn_opt_subcommand_desc3_t self) -> svn_opt_subcommand_desc3_t"""
        this = _core.new_svn_opt_subcommand_desc3_t()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _core.delete_svn_opt_subcommand_desc3_t
    __del__ = lambda self: None
svn_opt_subcommand_desc3_t_swigregister = _core.svn_opt_subcommand_desc3_t_swigregister
svn_opt_subcommand_desc3_t_swigregister(svn_opt_subcommand_desc3_t)

class svn_opt_subcommand_desc3_t_desc_overrides(object):
    """Proxy of C svn_opt_subcommand_desc3_t_desc_overrides struct."""

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    optch = _swig_property(_core.svn_opt_subcommand_desc3_t_desc_overrides_optch_get, _core.svn_opt_subcommand_desc3_t_desc_overrides_optch_set)
    desc = _swig_property(_core.svn_opt_subcommand_desc3_t_desc_overrides_desc_get, _core.svn_opt_subcommand_desc3_t_desc_overrides_desc_set)

    def __init__(self):
        """__init__(svn_opt_subcommand_desc3_t_desc_overrides self) -> svn_opt_subcommand_desc3_t_desc_overrides"""
        this = _core.new_svn_opt_subcommand_desc3_t_desc_overrides()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _core.delete_svn_opt_subcommand_desc3_t_desc_overrides
    __del__ = lambda self: None
svn_opt_subcommand_desc3_t_desc_overrides_swigregister = _core.svn_opt_subcommand_desc3_t_desc_overrides_swigregister
svn_opt_subcommand_desc3_t_desc_overrides_swigregister(svn_opt_subcommand_desc3_t_desc_overrides)

class svn_opt_subcommand_desc2_t(object):
    """Proxy of C svn_opt_subcommand_desc2_t struct."""

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    name = _swig_property(_core.svn_opt_subcommand_desc2_t_name_get, _core.svn_opt_subcommand_desc2_t_name_set)
    cmd_func = _swig_property(_core.svn_opt_subcommand_desc2_t_cmd_func_get, _core.svn_opt_subcommand_desc2_t_cmd_func_set)
    aliases = _swig_property(_core.svn_opt_subcommand_desc2_t_aliases_get, _core.svn_opt_subcommand_desc2_t_aliases_set)
    help = _swig_property(_core.svn_opt_subcommand_desc2_t_help_get, _core.svn_opt_subcommand_desc2_t_help_set)
    valid_options = _swig_property(_core.svn_opt_subcommand_desc2_t_valid_options_get, _core.svn_opt_subcommand_desc2_t_valid_options_set)
    desc_overrides = _swig_property(_core.svn_opt_subcommand_desc2_t_desc_overrides_get)
    def set_parent_pool(self, parent_pool=None):
      """Create a new proxy object for TYPE"""
      import libsvn.core, weakref
      self.__dict__["_parent_pool"] = \
        parent_pool or libsvn.core.application_pool;
      if self.__dict__["_parent_pool"]:
        self.__dict__["_is_valid"] = weakref.ref(
          self.__dict__["_parent_pool"]._is_valid)

    def assert_valid(self):
      """Assert that this object is using valid pool memory"""
      if "_is_valid" in self.__dict__:
        assert self.__dict__["_is_valid"](), "Variable has already been deleted"

    def _retrieve_swig_value(self, name, value):
    # If we got back a different object than we have cached, we need to copy
    # all our metadata into it, so that it looks identical to the one
    # originally set.
      members = self.__dict__.get('_members')
      if members is not None and name in members:
        _copy_metadata_deep(value, members[name])

    # Verify that the new object is good
      _assert_valid_deep(value)

      return value

    # Attribute access must be intercepted to ensure that objects coming from
    # read attribute access match those that are set with write attribute access.
    # Specifically the metadata, such as the associated apr_pool object, should
    # match the originally assigned object.
    #
    # For classic classes it is enough to use __getattr__ to intercept swig
    # derived attributes. However, with new style classes SWIG makes use of
    # descriptors which mean that __getattr__ is never called. Therefore,
    # __getattribute__ must be used for the interception.

    if _newclass:
      def __getattribute__(self, name):
        """Manage access to all attributes of this object."""

    # Start by mimicing __getattr__ behavior: immediately return __dict__ or
    # items directly present in __dict__
        mydict = object.__getattribute__(self, '__dict__')

        if name == "__dict__":
          return mydict

        if name in mydict:
          return mydict[name]

        object.__getattribute__(self, 'assert_valid')()

        value = _get_instance_attr(self, name)
        fn = object.__getattribute__(self, '_retrieve_swig_value')
        return fn(name, value)
    else:
      def __getattr__(self, name):
        """Get an attribute from this object"""
        self.assert_valid()

        value = _swig_getattr(self, self.__class__, name)

        return self._retrieve_swig_value(name, value)

    def __setattr__(self, name, value):
      """Set an attribute on this object"""
      self.assert_valid()

    # Save a copy of the object, so that the garbage
    # collector won't kill the object while it's in
    # SWIG-land
      self.__dict__.setdefault("_members",{})[name] = value

      return _set_instance_attr(self, name, value)


    def __init__(self):
        """__init__(svn_opt_subcommand_desc2_t self) -> svn_opt_subcommand_desc2_t"""
        this = _core.new_svn_opt_subcommand_desc2_t()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _core.delete_svn_opt_subcommand_desc2_t
    __del__ = lambda self: None
svn_opt_subcommand_desc2_t_swigregister = _core.svn_opt_subcommand_desc2_t_swigregister
svn_opt_subcommand_desc2_t_swigregister(svn_opt_subcommand_desc2_t)

class svn_opt_subcommand_desc2_t_desc_overrides(object):
    """Proxy of C svn_opt_subcommand_desc2_t_desc_overrides struct."""

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    optch = _swig_property(_core.svn_opt_subcommand_desc2_t_desc_overrides_optch_get, _core.svn_opt_subcommand_desc2_t_desc_overrides_optch_set)
    desc = _swig_property(_core.svn_opt_subcommand_desc2_t_desc_overrides_desc_get, _core.svn_opt_subcommand_desc2_t_desc_overrides_desc_set)

    def __init__(self):
        """__init__(svn_opt_subcommand_desc2_t_desc_overrides self) -> svn_opt_subcommand_desc2_t_desc_overrides"""
        this = _core.new_svn_opt_subcommand_desc2_t_desc_overrides()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _core.delete_svn_opt_subcommand_desc2_t_desc_overrides
    __del__ = lambda self: None
svn_opt_subcommand_desc2_t_desc_overrides_swigregister = _core.svn_opt_subcommand_desc2_t_desc_overrides_swigregister
svn_opt_subcommand_desc2_t_desc_overrides_swigregister(svn_opt_subcommand_desc2_t_desc_overrides)

class svn_opt_subcommand_desc_t(object):
    """Proxy of C svn_opt_subcommand_desc_t struct."""

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    name = _swig_property(_core.svn_opt_subcommand_desc_t_name_get, _core.svn_opt_subcommand_desc_t_name_set)
    cmd_func = _swig_property(_core.svn_opt_subcommand_desc_t_cmd_func_get, _core.svn_opt_subcommand_desc_t_cmd_func_set)
    aliases = _swig_property(_core.svn_opt_subcommand_desc_t_aliases_get, _core.svn_opt_subcommand_desc_t_aliases_set)
    help = _swig_property(_core.svn_opt_subcommand_desc_t_help_get, _core.svn_opt_subcommand_desc_t_help_set)
    valid_options = _swig_property(_core.svn_opt_subcommand_desc_t_valid_options_get, _core.svn_opt_subcommand_desc_t_valid_options_set)
    def set_parent_pool(self, parent_pool=None):
      """Create a new proxy object for TYPE"""
      import libsvn.core, weakref
      self.__dict__["_parent_pool"] = \
        parent_pool or libsvn.core.application_pool;
      if self.__dict__["_parent_pool"]:
        self.__dict__["_is_valid"] = weakref.ref(
          self.__dict__["_parent_pool"]._is_valid)

    def assert_valid(self):
      """Assert that this object is using valid pool memory"""
      if "_is_valid" in self.__dict__:
        assert self.__dict__["_is_valid"](), "Variable has already been deleted"

    def _retrieve_swig_value(self, name, value):
    # If we got back a different object than we have cached, we need to copy
    # all our metadata into it, so that it looks identical to the one
    # originally set.
      members = self.__dict__.get('_members')
      if members is not None and name in members:
        _copy_metadata_deep(value, members[name])

    # Verify that the new object is good
      _assert_valid_deep(value)

      return value

    # Attribute access must be intercepted to ensure that objects coming from
    # read attribute access match those that are set with write attribute access.
    # Specifically the metadata, such as the associated apr_pool object, should
    # match the originally assigned object.
    #
    # For classic classes it is enough to use __getattr__ to intercept swig
    # derived attributes. However, with new style classes SWIG makes use of
    # descriptors which mean that __getattr__ is never called. Therefore,
    # __getattribute__ must be used for the interception.

    if _newclass:
      def __getattribute__(self, name):
        """Manage access to all attributes of this object."""

    # Start by mimicing __getattr__ behavior: immediately return __dict__ or
    # items directly present in __dict__
        mydict = object.__getattribute__(self, '__dict__')

        if name == "__dict__":
          return mydict

        if name in mydict:
          return mydict[name]

        object.__getattribute__(self, 'assert_valid')()

        value = _get_instance_attr(self, name)
        fn = object.__getattribute__(self, '_retrieve_swig_value')
        return fn(name, value)
    else:
      def __getattr__(self, name):
        """Get an attribute from this object"""
        self.assert_valid()

        value = _swig_getattr(self, self.__class__, name)

        return self._retrieve_swig_value(name, value)

    def __setattr__(self, name, value):
      """Set an attribute on this object"""
      self.assert_valid()

    # Save a copy of the object, so that the garbage
    # collector won't kill the object while it's in
    # SWIG-land
      self.__dict__.setdefault("_members",{})[name] = value

      return _set_instance_attr(self, name, value)


    def __init__(self):
        """__init__(svn_opt_subcommand_desc_t self) -> svn_opt_subcommand_desc_t"""
        this = _core.new_svn_opt_subcommand_desc_t()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _core.delete_svn_opt_subcommand_desc_t
    __del__ = lambda self: None
svn_opt_subcommand_desc_t_swigregister = _core.svn_opt_subcommand_desc_t_swigregister
svn_opt_subcommand_desc_t_swigregister(svn_opt_subcommand_desc_t)


def svn_opt_get_canonical_subcommand3(table: 'svn_opt_subcommand_desc3_t', cmd_name: 'char const *') -> "svn_opt_subcommand_desc3_t const *":
    """svn_opt_get_canonical_subcommand3(svn_opt_subcommand_desc3_t table, char const * cmd_name) -> svn_opt_subcommand_desc3_t"""
    return _core.svn_opt_get_canonical_subcommand3(table, cmd_name)

def svn_opt_get_canonical_subcommand2(table: 'svn_opt_subcommand_desc2_t', cmd_name: 'char const *') -> "svn_opt_subcommand_desc2_t const *":
    """svn_opt_get_canonical_subcommand2(svn_opt_subcommand_desc2_t table, char const * cmd_name) -> svn_opt_subcommand_desc2_t"""
    return _core.svn_opt_get_canonical_subcommand2(table, cmd_name)

def svn_opt_get_canonical_subcommand(table: 'svn_opt_subcommand_desc_t', cmd_name: 'char const *') -> "svn_opt_subcommand_desc_t const *":
    """svn_opt_get_canonical_subcommand(svn_opt_subcommand_desc_t table, char const * cmd_name) -> svn_opt_subcommand_desc_t"""
    return _core.svn_opt_get_canonical_subcommand(table, cmd_name)

def svn_opt_get_option_from_code3(*args) -> "apr_getopt_option_t const *":
    """svn_opt_get_option_from_code3(int code, apr_getopt_option_t const * option_table, svn_opt_subcommand_desc3_t command, apr_pool_t pool) -> apr_getopt_option_t const *"""
    return _core.svn_opt_get_option_from_code3(*args)

def svn_opt_get_option_from_code2(*args) -> "apr_getopt_option_t const *":
    """svn_opt_get_option_from_code2(int code, apr_getopt_option_t const * option_table, svn_opt_subcommand_desc2_t command, apr_pool_t pool) -> apr_getopt_option_t const *"""
    return _core.svn_opt_get_option_from_code2(*args)

def svn_opt_get_option_from_code(code: 'int', option_table: 'apr_getopt_option_t const *') -> "apr_getopt_option_t const *":
    """svn_opt_get_option_from_code(int code, apr_getopt_option_t const * option_table) -> apr_getopt_option_t const *"""
    return _core.svn_opt_get_option_from_code(code, option_table)

def svn_opt_subcommand_takes_option4(command: 'svn_opt_subcommand_desc3_t', option_code: 'int') -> "int *":
    """svn_opt_subcommand_takes_option4(svn_opt_subcommand_desc3_t command, int option_code) -> svn_boolean_t"""
    return _core.svn_opt_subcommand_takes_option4(command, option_code)

def svn_opt_subcommand_takes_option3(command: 'svn_opt_subcommand_desc2_t', option_code: 'int') -> "int *":
    """svn_opt_subcommand_takes_option3(svn_opt_subcommand_desc2_t command, int option_code) -> svn_boolean_t"""
    return _core.svn_opt_subcommand_takes_option3(command, option_code)

def svn_opt_subcommand_takes_option2(command: 'svn_opt_subcommand_desc2_t', option_code: 'int') -> "svn_boolean_t":
    """svn_opt_subcommand_takes_option2(svn_opt_subcommand_desc2_t command, int option_code) -> svn_boolean_t"""
    return _core.svn_opt_subcommand_takes_option2(command, option_code)

def svn_opt_subcommand_takes_option(command: 'svn_opt_subcommand_desc_t', option_code: 'int') -> "svn_boolean_t":
    """svn_opt_subcommand_takes_option(svn_opt_subcommand_desc_t command, int option_code) -> svn_boolean_t"""
    return _core.svn_opt_subcommand_takes_option(command, option_code)

def svn_opt_print_generic_help3(*args) -> "void":
    """svn_opt_print_generic_help3(char const * header, svn_opt_subcommand_desc3_t cmd_table, apr_getopt_option_t const * opt_table, char const * footer, apr_pool_t pool, FILE * stream)"""
    return _core.svn_opt_print_generic_help3(*args)

def svn_opt_print_generic_help2(*args) -> "void":
    """svn_opt_print_generic_help2(char const * header, svn_opt_subcommand_desc2_t cmd_table, apr_getopt_option_t const * opt_table, char const * footer, apr_pool_t pool, FILE * stream)"""
    return _core.svn_opt_print_generic_help2(*args)

def svn_opt_format_option(*args) -> "char const **":
    """svn_opt_format_option(apr_getopt_option_t const * opt, svn_boolean_t doc, apr_pool_t pool)"""
    return _core.svn_opt_format_option(*args)

def svn_opt_subcommand_help4(*args) -> "int *":
    """svn_opt_subcommand_help4(char const * subcommand, svn_opt_subcommand_desc3_t table, apr_getopt_option_t const * options_table, apr_pool_t pool)"""
    return _core.svn_opt_subcommand_help4(*args)

def svn_opt_subcommand_help3(*args) -> "int *":
    """svn_opt_subcommand_help3(char const * subcommand, svn_opt_subcommand_desc2_t table, apr_getopt_option_t const * options_table, apr_pool_t pool)"""
    return _core.svn_opt_subcommand_help3(*args)

def svn_opt_subcommand_help2(*args) -> "void":
    """svn_opt_subcommand_help2(char const * subcommand, svn_opt_subcommand_desc2_t table, apr_getopt_option_t const * options_table, apr_pool_t pool)"""
    return _core.svn_opt_subcommand_help2(*args)

def svn_opt_subcommand_help(*args) -> "void":
    """svn_opt_subcommand_help(char const * subcommand, svn_opt_subcommand_desc_t table, apr_getopt_option_t const * options_table, apr_pool_t pool)"""
    return _core.svn_opt_subcommand_help(*args)
class svn_opt_revision_value_t(object):
    """Proxy of C svn_opt_revision_value_t struct."""

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    number = _swig_property(_core.svn_opt_revision_value_t_number_get, _core.svn_opt_revision_value_t_number_set)
    date = _swig_property(_core.svn_opt_revision_value_t_date_get, _core.svn_opt_revision_value_t_date_set)
    def set_parent_pool(self, parent_pool=None):
      """Create a new proxy object for TYPE"""
      import libsvn.core, weakref
      self.__dict__["_parent_pool"] = \
        parent_pool or libsvn.core.application_pool;
      if self.__dict__["_parent_pool"]:
        self.__dict__["_is_valid"] = weakref.ref(
          self.__dict__["_parent_pool"]._is_valid)

    def assert_valid(self):
      """Assert that this object is using valid pool memory"""
      if "_is_valid" in self.__dict__:
        assert self.__dict__["_is_valid"](), "Variable has already been deleted"

    def _retrieve_swig_value(self, name, value):
    # If we got back a different object than we have cached, we need to copy
    # all our metadata into it, so that it looks identical to the one
    # originally set.
      members = self.__dict__.get('_members')
      if members is not None and name in members:
        _copy_metadata_deep(value, members[name])

    # Verify that the new object is good
      _assert_valid_deep(value)

      return value

    # Attribute access must be intercepted to ensure that objects coming from
    # read attribute access match those that are set with write attribute access.
    # Specifically the metadata, such as the associated apr_pool object, should
    # match the originally assigned object.
    #
    # For classic classes it is enough to use __getattr__ to intercept swig
    # derived attributes. However, with new style classes SWIG makes use of
    # descriptors which mean that __getattr__ is never called. Therefore,
    # __getattribute__ must be used for the interception.

    if _newclass:
      def __getattribute__(self, name):
        """Manage access to all attributes of this object."""

    # Start by mimicing __getattr__ behavior: immediately return __dict__ or
    # items directly present in __dict__
        mydict = object.__getattribute__(self, '__dict__')

        if name == "__dict__":
          return mydict

        if name in mydict:
          return mydict[name]

        object.__getattribute__(self, 'assert_valid')()

        value = _get_instance_attr(self, name)
        fn = object.__getattribute__(self, '_retrieve_swig_value')
        return fn(name, value)
    else:
      def __getattr__(self, name):
        """Get an attribute from this object"""
        self.assert_valid()

        value = _swig_getattr(self, self.__class__, name)

        return self._retrieve_swig_value(name, value)

    def __setattr__(self, name, value):
      """Set an attribute on this object"""
      self.assert_valid()

    # Save a copy of the object, so that the garbage
    # collector won't kill the object while it's in
    # SWIG-land
      self.__dict__.setdefault("_members",{})[name] = value

      return _set_instance_attr(self, name, value)


    def __init__(self):
        """__init__(svn_opt_revision_value_t self) -> svn_opt_revision_value_t"""
        this = _core.new_svn_opt_revision_value_t()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _core.delete_svn_opt_revision_value_t
    __del__ = lambda self: None
svn_opt_revision_value_t_swigregister = _core.svn_opt_revision_value_t_swigregister
svn_opt_revision_value_t_swigregister(svn_opt_revision_value_t)

class svn_opt_revision_t(object):
    """Proxy of C svn_opt_revision_t struct."""

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    kind = _swig_property(_core.svn_opt_revision_t_kind_get, _core.svn_opt_revision_t_kind_set)
    value = _swig_property(_core.svn_opt_revision_t_value_get, _core.svn_opt_revision_t_value_set)
    def set_parent_pool(self, parent_pool=None):
      """Create a new proxy object for TYPE"""
      import libsvn.core, weakref
      self.__dict__["_parent_pool"] = \
        parent_pool or libsvn.core.application_pool;
      if self.__dict__["_parent_pool"]:
        self.__dict__["_is_valid"] = weakref.ref(
          self.__dict__["_parent_pool"]._is_valid)

    def assert_valid(self):
      """Assert that this object is using valid pool memory"""
      if "_is_valid" in self.__dict__:
        assert self.__dict__["_is_valid"](), "Variable has already been deleted"

    def _retrieve_swig_value(self, name, value):
    # If we got back a different object than we have cached, we need to copy
    # all our metadata into it, so that it looks identical to the one
    # originally set.
      members = self.__dict__.get('_members')
      if members is not None and name in members:
        _copy_metadata_deep(value, members[name])

    # Verify that the new object is good
      _assert_valid_deep(value)

      return value

    # Attribute access must be intercepted to ensure that objects coming from
    # read attribute access match those that are set with write attribute access.
    # Specifically the metadata, such as the associated apr_pool object, should
    # match the originally assigned object.
    #
    # For classic classes it is enough to use __getattr__ to intercept swig
    # derived attributes. However, with new style classes SWIG makes use of
    # descriptors which mean that __getattr__ is never called. Therefore,
    # __getattribute__ must be used for the interception.

    if _newclass:
      def __getattribute__(self, name):
        """Manage access to all attributes of this object."""

    # Start by mimicing __getattr__ behavior: immediately return __dict__ or
    # items directly present in __dict__
        mydict = object.__getattribute__(self, '__dict__')

        if name == "__dict__":
          return mydict

        if name in mydict:
          return mydict[name]

        object.__getattribute__(self, 'assert_valid')()

        value = _get_instance_attr(self, name)
        fn = object.__getattribute__(self, '_retrieve_swig_value')
        return fn(name, value)
    else:
      def __getattr__(self, name):
        """Get an attribute from this object"""
        self.assert_valid()

        value = _swig_getattr(self, self.__class__, name)

        return self._retrieve_swig_value(name, value)

    def __setattr__(self, name, value):
      """Set an attribute on this object"""
      self.assert_valid()

    # Save a copy of the object, so that the garbage
    # collector won't kill the object while it's in
    # SWIG-land
      self.__dict__.setdefault("_members",{})[name] = value

      return _set_instance_attr(self, name, value)


    def __init__(self):
        """__init__(svn_opt_revision_t self) -> svn_opt_revision_t"""
        this = _core.new_svn_opt_revision_t()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _core.delete_svn_opt_revision_t
    __del__ = lambda self: None
svn_opt_revision_t_swigregister = _core.svn_opt_revision_t_swigregister
svn_opt_revision_t_swigregister(svn_opt_revision_t)

class svn_opt_revision_range_t(object):
    """Proxy of C svn_opt_revision_range_t struct."""

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    start = _swig_property(_core.svn_opt_revision_range_t_start_get, _core.svn_opt_revision_range_t_start_set)
    end = _swig_property(_core.svn_opt_revision_range_t_end_get, _core.svn_opt_revision_range_t_end_set)
    def set_parent_pool(self, parent_pool=None):
      """Create a new proxy object for TYPE"""
      import libsvn.core, weakref
      self.__dict__["_parent_pool"] = \
        parent_pool or libsvn.core.application_pool;
      if self.__dict__["_parent_pool"]:
        self.__dict__["_is_valid"] = weakref.ref(
          self.__dict__["_parent_pool"]._is_valid)

    def assert_valid(self):
      """Assert that this object is using valid pool memory"""
      if "_is_valid" in self.__dict__:
        assert self.__dict__["_is_valid"](), "Variable has already been deleted"

    def _retrieve_swig_value(self, name, value):
    # If we got back a different object than we have cached, we need to copy
    # all our metadata into it, so that it looks identical to the one
    # originally set.
      members = self.__dict__.get('_members')
      if members is not None and name in members:
        _copy_metadata_deep(value, members[name])

    # Verify that the new object is good
      _assert_valid_deep(value)

      return value

    # Attribute access must be intercepted to ensure that objects coming from
    # read attribute access match those that are set with write attribute access.
    # Specifically the metadata, such as the associated apr_pool object, should
    # match the originally assigned object.
    #
    # For classic classes it is enough to use __getattr__ to intercept swig
    # derived attributes. However, with new style classes SWIG makes use of
    # descriptors which mean that __getattr__ is never called. Therefore,
    # __getattribute__ must be used for the interception.

    if _newclass:
      def __getattribute__(self, name):
        """Manage access to all attributes of this object."""

    # Start by mimicing __getattr__ behavior: immediately return __dict__ or
    # items directly present in __dict__
        mydict = object.__getattribute__(self, '__dict__')

        if name == "__dict__":
          return mydict

        if name in mydict:
          return mydict[name]

        object.__getattribute__(self, 'assert_valid')()

        value = _get_instance_attr(self, name)
        fn = object.__getattribute__(self, '_retrieve_swig_value')
        return fn(name, value)
    else:
      def __getattr__(self, name):
        """Get an attribute from this object"""
        self.assert_valid()

        value = _swig_getattr(self, self.__class__, name)

        return self._retrieve_swig_value(name, value)

    def __setattr__(self, name, value):
      """Set an attribute on this object"""
      self.assert_valid()

    # Save a copy of the object, so that the garbage
    # collector won't kill the object while it's in
    # SWIG-land
      self.__dict__.setdefault("_members",{})[name] = value

      return _set_instance_attr(self, name, value)


    def __init__(self):
        """__init__(svn_opt_revision_range_t self) -> svn_opt_revision_range_t"""
        this = _core.new_svn_opt_revision_range_t()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _core.delete_svn_opt_revision_range_t
    __del__ = lambda self: None
svn_opt_revision_range_t_swigregister = _core.svn_opt_revision_range_t_swigregister
svn_opt_revision_range_t_swigregister(svn_opt_revision_range_t)


def svn_opt_parse_revision(*args) -> "int":
    """svn_opt_parse_revision(svn_opt_revision_t start_revision, svn_opt_revision_t end_revision, char const * arg, apr_pool_t pool) -> int"""
    return _core.svn_opt_parse_revision(*args)

def svn_opt_parse_revision_to_range(*args) -> "int":
    """svn_opt_parse_revision_to_range(apr_array_header_t opt_ranges, char const * arg, apr_pool_t pool) -> int"""
    return _core.svn_opt_parse_revision_to_range(*args)

def svn_opt_resolve_revisions(*args) -> "svn_error_t *":
    """svn_opt_resolve_revisions(svn_opt_revision_t peg_rev, svn_opt_revision_t op_rev, svn_boolean_t is_url, svn_boolean_t notice_local_mods, apr_pool_t pool) -> svn_error_t"""
    return _core.svn_opt_resolve_revisions(*args)

def svn_opt_args_to_target_array3(*args) -> "apr_array_header_t **":
    """svn_opt_args_to_target_array3(apr_getopt_t * os, apr_array_header_t known_targets, apr_pool_t pool) -> svn_error_t"""
    return _core.svn_opt_args_to_target_array3(*args)

def svn_opt_args_to_target_array2(*args) -> "apr_array_header_t **":
    """svn_opt_args_to_target_array2(apr_getopt_t * os, apr_array_header_t known_targets, apr_pool_t pool) -> svn_error_t"""
    return _core.svn_opt_args_to_target_array2(*args)

def svn_opt_parse_revprop(*args) -> "apr_hash_t **":
    """svn_opt_parse_revprop(char const * revprop_spec, apr_pool_t pool) -> svn_error_t"""
    return _core.svn_opt_parse_revprop(*args)

def svn_opt_push_implicit_dot_target(*args) -> "void":
    """svn_opt_push_implicit_dot_target(apr_array_header_t targets, apr_pool_t pool)"""
    return _core.svn_opt_push_implicit_dot_target(*args)

def svn_opt_parse_num_args(*args) -> "apr_array_header_t **":
    """svn_opt_parse_num_args(apr_getopt_t * os, int num_args, apr_pool_t pool) -> svn_error_t"""
    return _core.svn_opt_parse_num_args(*args)

def svn_opt_parse_all_args(*args) -> "apr_array_header_t **":
    """svn_opt_parse_all_args(apr_getopt_t * os, apr_pool_t pool) -> svn_error_t"""
    return _core.svn_opt_parse_all_args(*args)

def svn_opt_parse_path(*args) -> "char const **":
    """svn_opt_parse_path(svn_opt_revision_t rev, char const * path, apr_pool_t pool) -> svn_error_t"""
    return _core.svn_opt_parse_path(*args)

def svn_opt_print_help5(*args) -> "int *":
    """svn_opt_print_help5(apr_getopt_t * os, char const * pgm_name, svn_boolean_t print_version, svn_boolean_t quiet, svn_boolean_t verbose, char const * version_footer, char const * header, svn_opt_subcommand_desc3_t cmd_table, apr_getopt_option_t const * option_table, char const * footer, apr_pool_t pool) -> svn_error_t"""
    return _core.svn_opt_print_help5(*args)

def svn_opt_print_help4(*args) -> "int *":
    """svn_opt_print_help4(apr_getopt_t * os, char const * pgm_name, svn_boolean_t print_version, svn_boolean_t quiet, svn_boolean_t verbose, char const * version_footer, char const * header, svn_opt_subcommand_desc2_t cmd_table, apr_getopt_option_t const * option_table, char const * footer, apr_pool_t pool) -> svn_error_t"""
    return _core.svn_opt_print_help4(*args)

def svn_opt_print_help3(*args) -> "int *":
    """svn_opt_print_help3(apr_getopt_t * os, char const * pgm_name, svn_boolean_t print_version, svn_boolean_t quiet, char const * version_footer, char const * header, svn_opt_subcommand_desc2_t cmd_table, apr_getopt_option_t const * option_table, char const * footer, apr_pool_t pool) -> svn_error_t"""
    return _core.svn_opt_print_help3(*args)

def svn_opt_print_help2(*args) -> "svn_error_t *":
    """svn_opt_print_help2(apr_getopt_t * os, char const * pgm_name, svn_boolean_t print_version, svn_boolean_t quiet, char const * version_footer, char const * header, svn_opt_subcommand_desc2_t cmd_table, apr_getopt_option_t const * option_table, char const * footer, apr_pool_t pool) -> svn_error_t"""
    return _core.svn_opt_print_help2(*args)

def svn_opt_print_help(*args) -> "svn_error_t *":
    """svn_opt_print_help(apr_getopt_t * os, char const * pgm_name, svn_boolean_t print_version, svn_boolean_t quiet, char const * version_footer, char const * header, svn_opt_subcommand_desc_t cmd_table, apr_getopt_option_t const * option_table, char const * footer, apr_pool_t pool) -> svn_error_t"""
    return _core.svn_opt_print_help(*args)

def svn_cmdline_init(progname: 'char const *', error_stream: 'FILE *') -> "int":
    """svn_cmdline_init(char const * progname, FILE * error_stream) -> int"""
    return _core.svn_cmdline_init(progname, error_stream)

def svn_cmdline_create_auth_baton2(*args) -> "svn_auth_baton_t **":
    """svn_cmdline_create_auth_baton2(svn_boolean_t non_interactive, char const * username, char const * password, char const * config_dir, svn_boolean_t no_auth_cache, svn_boolean_t trust_server_cert_unknown_ca, svn_boolean_t trust_server_cert_cn_mismatch, svn_boolean_t trust_server_cert_expired, svn_boolean_t trust_server_cert_not_yet_valid, svn_boolean_t trust_server_cert_other_failure, svn_config_t * cfg, svn_cancel_func_t cancel_func, apr_pool_t pool) -> svn_error_t"""
    return _core.svn_cmdline_create_auth_baton2(*args)

def svn_cmdline_create_auth_baton(*args) -> "svn_auth_baton_t **":
    """svn_cmdline_create_auth_baton(svn_boolean_t non_interactive, char const * username, char const * password, char const * config_dir, svn_boolean_t no_auth_cache, svn_boolean_t trust_server_cert, svn_config_t * cfg, svn_cancel_func_t cancel_func, apr_pool_t pool) -> svn_error_t"""
    return _core.svn_cmdline_create_auth_baton(*args)
class svn_auth_provider_t(object):
    """Proxy of C svn_auth_provider_t struct."""

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    cred_kind = _swig_property(_core.svn_auth_provider_t_cred_kind_get, _core.svn_auth_provider_t_cred_kind_set)
    first_credentials = _swig_property(_core.svn_auth_provider_t_first_credentials_get, _core.svn_auth_provider_t_first_credentials_set)
    next_credentials = _swig_property(_core.svn_auth_provider_t_next_credentials_get, _core.svn_auth_provider_t_next_credentials_set)
    save_credentials = _swig_property(_core.svn_auth_provider_t_save_credentials_get, _core.svn_auth_provider_t_save_credentials_set)
    def set_parent_pool(self, parent_pool=None):
      """Create a new proxy object for TYPE"""
      import libsvn.core, weakref
      self.__dict__["_parent_pool"] = \
        parent_pool or libsvn.core.application_pool;
      if self.__dict__["_parent_pool"]:
        self.__dict__["_is_valid"] = weakref.ref(
          self.__dict__["_parent_pool"]._is_valid)

    def assert_valid(self):
      """Assert that this object is using valid pool memory"""
      if "_is_valid" in self.__dict__:
        assert self.__dict__["_is_valid"](), "Variable has already been deleted"

    def _retrieve_swig_value(self, name, value):
    # If we got back a different object than we have cached, we need to copy
    # all our metadata into it, so that it looks identical to the one
    # originally set.
      members = self.__dict__.get('_members')
      if members is not None and name in members:
        _copy_metadata_deep(value, members[name])

    # Verify that the new object is good
      _assert_valid_deep(value)

      return value

    # Attribute access must be intercepted to ensure that objects coming from
    # read attribute access match those that are set with write attribute access.
    # Specifically the metadata, such as the associated apr_pool object, should
    # match the originally assigned object.
    #
    # For classic classes it is enough to use __getattr__ to intercept swig
    # derived attributes. However, with new style classes SWIG makes use of
    # descriptors which mean that __getattr__ is never called. Therefore,
    # __getattribute__ must be used for the interception.

    if _newclass:
      def __getattribute__(self, name):
        """Manage access to all attributes of this object."""

    # Start by mimicing __getattr__ behavior: immediately return __dict__ or
    # items directly present in __dict__
        mydict = object.__getattribute__(self, '__dict__')

        if name == "__dict__":
          return mydict

        if name in mydict:
          return mydict[name]

        object.__getattribute__(self, 'assert_valid')()

        value = _get_instance_attr(self, name)
        fn = object.__getattribute__(self, '_retrieve_swig_value')
        return fn(name, value)
    else:
      def __getattr__(self, name):
        """Get an attribute from this object"""
        self.assert_valid()

        value = _swig_getattr(self, self.__class__, name)

        return self._retrieve_swig_value(name, value)

    def __setattr__(self, name, value):
      """Set an attribute on this object"""
      self.assert_valid()

    # Save a copy of the object, so that the garbage
    # collector won't kill the object while it's in
    # SWIG-land
      self.__dict__.setdefault("_members",{})[name] = value

      return _set_instance_attr(self, name, value)


    def first_credentials(self, *args):
      return svn_auth_provider_invoke_first_credentials(self, *args)


    def next_credentials(self, *args):
      return svn_auth_provider_invoke_next_credentials(self, *args)


    def save_credentials(self, *args):
      return svn_auth_provider_invoke_save_credentials(self, *args)


    def __init__(self):
        """__init__(svn_auth_provider_t self) -> svn_auth_provider_t"""
        this = _core.new_svn_auth_provider_t()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _core.delete_svn_auth_provider_t
    __del__ = lambda self: None
svn_auth_provider_t_swigregister = _core.svn_auth_provider_t_swigregister
svn_auth_provider_t_swigregister(svn_auth_provider_t)

class svn_auth_provider_object_t(object):
    """Proxy of C svn_auth_provider_object_t struct."""

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    vtable = _swig_property(_core.svn_auth_provider_object_t_vtable_get, _core.svn_auth_provider_object_t_vtable_set)
    provider_baton = _swig_property(_core.svn_auth_provider_object_t_provider_baton_get, _core.svn_auth_provider_object_t_provider_baton_set)
    def set_parent_pool(self, parent_pool=None):
      """Create a new proxy object for TYPE"""
      import libsvn.core, weakref
      self.__dict__["_parent_pool"] = \
        parent_pool or libsvn.core.application_pool;
      if self.__dict__["_parent_pool"]:
        self.__dict__["_is_valid"] = weakref.ref(
          self.__dict__["_parent_pool"]._is_valid)

    def assert_valid(self):
      """Assert that this object is using valid pool memory"""
      if "_is_valid" in self.__dict__:
        assert self.__dict__["_is_valid"](), "Variable has already been deleted"

    def _retrieve_swig_value(self, name, value):
    # If we got back a different object than we have cached, we need to copy
    # all our metadata into it, so that it looks identical to the one
    # originally set.
      members = self.__dict__.get('_members')
      if members is not None and name in members:
        _copy_metadata_deep(value, members[name])

    # Verify that the new object is good
      _assert_valid_deep(value)

      return value

    # Attribute access must be intercepted to ensure that objects coming from
    # read attribute access match those that are set with write attribute access.
    # Specifically the metadata, such as the associated apr_pool object, should
    # match the originally assigned object.
    #
    # For classic classes it is enough to use __getattr__ to intercept swig
    # derived attributes. However, with new style classes SWIG makes use of
    # descriptors which mean that __getattr__ is never called. Therefore,
    # __getattribute__ must be used for the interception.

    if _newclass:
      def __getattribute__(self, name):
        """Manage access to all attributes of this object."""

    # Start by mimicing __getattr__ behavior: immediately return __dict__ or
    # items directly present in __dict__
        mydict = object.__getattribute__(self, '__dict__')

        if name == "__dict__":
          return mydict

        if name in mydict:
          return mydict[name]

        object.__getattribute__(self, 'assert_valid')()

        value = _get_instance_attr(self, name)
        fn = object.__getattribute__(self, '_retrieve_swig_value')
        return fn(name, value)
    else:
      def __getattr__(self, name):
        """Get an attribute from this object"""
        self.assert_valid()

        value = _swig_getattr(self, self.__class__, name)

        return self._retrieve_swig_value(name, value)

    def __setattr__(self, name, value):
      """Set an attribute on this object"""
      self.assert_valid()

    # Save a copy of the object, so that the garbage
    # collector won't kill the object while it's in
    # SWIG-land
      self.__dict__.setdefault("_members",{})[name] = value

      return _set_instance_attr(self, name, value)


    def __init__(self):
        """__init__(svn_auth_provider_object_t self) -> svn_auth_provider_object_t"""
        this = _core.new_svn_auth_provider_object_t()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _core.delete_svn_auth_provider_object_t
    __del__ = lambda self: None
svn_auth_provider_object_t_swigregister = _core.svn_auth_provider_object_t_swigregister
svn_auth_provider_object_t_swigregister(svn_auth_provider_object_t)

SVN_AUTH_CRED_SIMPLE = _core.SVN_AUTH_CRED_SIMPLE
class svn_auth_cred_simple_t(object):
    """Proxy of C svn_auth_cred_simple_t struct."""

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    username = _swig_property(_core.svn_auth_cred_simple_t_username_get, _core.svn_auth_cred_simple_t_username_set)
    password = _swig_property(_core.svn_auth_cred_simple_t_password_get, _core.svn_auth_cred_simple_t_password_set)
    may_save = _swig_property(_core.svn_auth_cred_simple_t_may_save_get, _core.svn_auth_cred_simple_t_may_save_set)
    def set_parent_pool(self, parent_pool=None):
      """Create a new proxy object for TYPE"""
      import libsvn.core, weakref
      self.__dict__["_parent_pool"] = \
        parent_pool or libsvn.core.application_pool;
      if self.__dict__["_parent_pool"]:
        self.__dict__["_is_valid"] = weakref.ref(
          self.__dict__["_parent_pool"]._is_valid)

    def assert_valid(self):
      """Assert that this object is using valid pool memory"""
      if "_is_valid" in self.__dict__:
        assert self.__dict__["_is_valid"](), "Variable has already been deleted"

    def _retrieve_swig_value(self, name, value):
    # If we got back a different object than we have cached, we need to copy
    # all our metadata into it, so that it looks identical to the one
    # originally set.
      members = self.__dict__.get('_members')
      if members is not None and name in members:
        _copy_metadata_deep(value, members[name])

    # Verify that the new object is good
      _assert_valid_deep(value)

      return value

    # Attribute access must be intercepted to ensure that objects coming from
    # read attribute access match those that are set with write attribute access.
    # Specifically the metadata, such as the associated apr_pool object, should
    # match the originally assigned object.
    #
    # For classic classes it is enough to use __getattr__ to intercept swig
    # derived attributes. However, with new style classes SWIG makes use of
    # descriptors which mean that __getattr__ is never called. Therefore,
    # __getattribute__ must be used for the interception.

    if _newclass:
      def __getattribute__(self, name):
        """Manage access to all attributes of this object."""

    # Start by mimicing __getattr__ behavior: immediately return __dict__ or
    # items directly present in __dict__
        mydict = object.__getattribute__(self, '__dict__')

        if name == "__dict__":
          return mydict

        if name in mydict:
          return mydict[name]

        object.__getattribute__(self, 'assert_valid')()

        value = _get_instance_attr(self, name)
        fn = object.__getattribute__(self, '_retrieve_swig_value')
        return fn(name, value)
    else:
      def __getattr__(self, name):
        """Get an attribute from this object"""
        self.assert_valid()

        value = _swig_getattr(self, self.__class__, name)

        return self._retrieve_swig_value(name, value)

    def __setattr__(self, name, value):
      """Set an attribute on this object"""
      self.assert_valid()

    # Save a copy of the object, so that the garbage
    # collector won't kill the object while it's in
    # SWIG-land
      self.__dict__.setdefault("_members",{})[name] = value

      return _set_instance_attr(self, name, value)


    def __init__(self):
        """__init__(svn_auth_cred_simple_t self) -> svn_auth_cred_simple_t"""
        this = _core.new_svn_auth_cred_simple_t()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _core.delete_svn_auth_cred_simple_t
    __del__ = lambda self: None
svn_auth_cred_simple_t_swigregister = _core.svn_auth_cred_simple_t_swigregister
svn_auth_cred_simple_t_swigregister(svn_auth_cred_simple_t)

SVN_AUTH_CRED_USERNAME = _core.SVN_AUTH_CRED_USERNAME
class svn_auth_cred_username_t(object):
    """Proxy of C svn_auth_cred_username_t struct."""

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    username = _swig_property(_core.svn_auth_cred_username_t_username_get, _core.svn_auth_cred_username_t_username_set)
    may_save = _swig_property(_core.svn_auth_cred_username_t_may_save_get, _core.svn_auth_cred_username_t_may_save_set)
    def set_parent_pool(self, parent_pool=None):
      """Create a new proxy object for TYPE"""
      import libsvn.core, weakref
      self.__dict__["_parent_pool"] = \
        parent_pool or libsvn.core.application_pool;
      if self.__dict__["_parent_pool"]:
        self.__dict__["_is_valid"] = weakref.ref(
          self.__dict__["_parent_pool"]._is_valid)

    def assert_valid(self):
      """Assert that this object is using valid pool memory"""
      if "_is_valid" in self.__dict__:
        assert self.__dict__["_is_valid"](), "Variable has already been deleted"

    def _retrieve_swig_value(self, name, value):
    # If we got back a different object than we have cached, we need to copy
    # all our metadata into it, so that it looks identical to the one
    # originally set.
      members = self.__dict__.get('_members')
      if members is not None and name in members:
        _copy_metadata_deep(value, members[name])

    # Verify that the new object is good
      _assert_valid_deep(value)

      return value

    # Attribute access must be intercepted to ensure that objects coming from
    # read attribute access match those that are set with write attribute access.
    # Specifically the metadata, such as the associated apr_pool object, should
    # match the originally assigned object.
    #
    # For classic classes it is enough to use __getattr__ to intercept swig
    # derived attributes. However, with new style classes SWIG makes use of
    # descriptors which mean that __getattr__ is never called. Therefore,
    # __getattribute__ must be used for the interception.

    if _newclass:
      def __getattribute__(self, name):
        """Manage access to all attributes of this object."""

    # Start by mimicing __getattr__ behavior: immediately return __dict__ or
    # items directly present in __dict__
        mydict = object.__getattribute__(self, '__dict__')

        if name == "__dict__":
          return mydict

        if name in mydict:
          return mydict[name]

        object.__getattribute__(self, 'assert_valid')()

        value = _get_instance_attr(self, name)
        fn = object.__getattribute__(self, '_retrieve_swig_value')
        return fn(name, value)
    else:
      def __getattr__(self, name):
        """Get an attribute from this object"""
        self.assert_valid()

        value = _swig_getattr(self, self.__class__, name)

        return self._retrieve_swig_value(name, value)

    def __setattr__(self, name, value):
      """Set an attribute on this object"""
      self.assert_valid()

    # Save a copy of the object, so that the garbage
    # collector won't kill the object while it's in
    # SWIG-land
      self.__dict__.setdefault("_members",{})[name] = value

      return _set_instance_attr(self, name, value)


    def __init__(self):
        """__init__(svn_auth_cred_username_t self) -> svn_auth_cred_username_t"""
        this = _core.new_svn_auth_cred_username_t()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _core.delete_svn_auth_cred_username_t
    __del__ = lambda self: None
svn_auth_cred_username_t_swigregister = _core.svn_auth_cred_username_t_swigregister
svn_auth_cred_username_t_swigregister(svn_auth_cred_username_t)

SVN_AUTH_CRED_SSL_CLIENT_CERT = _core.SVN_AUTH_CRED_SSL_CLIENT_CERT
class svn_auth_cred_ssl_client_cert_t(object):
    """Proxy of C svn_auth_cred_ssl_client_cert_t struct."""

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    cert_file = _swig_property(_core.svn_auth_cred_ssl_client_cert_t_cert_file_get, _core.svn_auth_cred_ssl_client_cert_t_cert_file_set)
    may_save = _swig_property(_core.svn_auth_cred_ssl_client_cert_t_may_save_get, _core.svn_auth_cred_ssl_client_cert_t_may_save_set)
    def set_parent_pool(self, parent_pool=None):
      """Create a new proxy object for TYPE"""
      import libsvn.core, weakref
      self.__dict__["_parent_pool"] = \
        parent_pool or libsvn.core.application_pool;
      if self.__dict__["_parent_pool"]:
        self.__dict__["_is_valid"] = weakref.ref(
          self.__dict__["_parent_pool"]._is_valid)

    def assert_valid(self):
      """Assert that this object is using valid pool memory"""
      if "_is_valid" in self.__dict__:
        assert self.__dict__["_is_valid"](), "Variable has already been deleted"

    def _retrieve_swig_value(self, name, value):
    # If we got back a different object than we have cached, we need to copy
    # all our metadata into it, so that it looks identical to the one
    # originally set.
      members = self.__dict__.get('_members')
      if members is not None and name in members:
        _copy_metadata_deep(value, members[name])

    # Verify that the new object is good
      _assert_valid_deep(value)

      return value

    # Attribute access must be intercepted to ensure that objects coming from
    # read attribute access match those that are set with write attribute access.
    # Specifically the metadata, such as the associated apr_pool object, should
    # match the originally assigned object.
    #
    # For classic classes it is enough to use __getattr__ to intercept swig
    # derived attributes. However, with new style classes SWIG makes use of
    # descriptors which mean that __getattr__ is never called. Therefore,
    # __getattribute__ must be used for the interception.

    if _newclass:
      def __getattribute__(self, name):
        """Manage access to all attributes of this object."""

    # Start by mimicing __getattr__ behavior: immediately return __dict__ or
    # items directly present in __dict__
        mydict = object.__getattribute__(self, '__dict__')

        if name == "__dict__":
          return mydict

        if name in mydict:
          return mydict[name]

        object.__getattribute__(self, 'assert_valid')()

        value = _get_instance_attr(self, name)
        fn = object.__getattribute__(self, '_retrieve_swig_value')
        return fn(name, value)
    else:
      def __getattr__(self, name):
        """Get an attribute from this object"""
        self.assert_valid()

        value = _swig_getattr(self, self.__class__, name)

        return self._retrieve_swig_value(name, value)

    def __setattr__(self, name, value):
      """Set an attribute on this object"""
      self.assert_valid()

    # Save a copy of the object, so that the garbage
    # collector won't kill the object while it's in
    # SWIG-land
      self.__dict__.setdefault("_members",{})[name] = value

      return _set_instance_attr(self, name, value)


    def __init__(self):
        """__init__(svn_auth_cred_ssl_client_cert_t self) -> svn_auth_cred_ssl_client_cert_t"""
        this = _core.new_svn_auth_cred_ssl_client_cert_t()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _core.delete_svn_auth_cred_ssl_client_cert_t
    __del__ = lambda self: None
svn_auth_cred_ssl_client_cert_t_swigregister = _core.svn_auth_cred_ssl_client_cert_t_swigregister
svn_auth_cred_ssl_client_cert_t_swigregister(svn_auth_cred_ssl_client_cert_t)

SVN_AUTH_CRED_SSL_CLIENT_CERT_PW = _core.SVN_AUTH_CRED_SSL_CLIENT_CERT_PW
class svn_auth_cred_ssl_client_cert_pw_t(object):
    """Proxy of C svn_auth_cred_ssl_client_cert_pw_t struct."""

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    password = _swig_property(_core.svn_auth_cred_ssl_client_cert_pw_t_password_get, _core.svn_auth_cred_ssl_client_cert_pw_t_password_set)
    may_save = _swig_property(_core.svn_auth_cred_ssl_client_cert_pw_t_may_save_get, _core.svn_auth_cred_ssl_client_cert_pw_t_may_save_set)
    def set_parent_pool(self, parent_pool=None):
      """Create a new proxy object for TYPE"""
      import libsvn.core, weakref
      self.__dict__["_parent_pool"] = \
        parent_pool or libsvn.core.application_pool;
      if self.__dict__["_parent_pool"]:
        self.__dict__["_is_valid"] = weakref.ref(
          self.__dict__["_parent_pool"]._is_valid)

    def assert_valid(self):
      """Assert that this object is using valid pool memory"""
      if "_is_valid" in self.__dict__:
        assert self.__dict__["_is_valid"](), "Variable has already been deleted"

    def _retrieve_swig_value(self, name, value):
    # If we got back a different object than we have cached, we need to copy
    # all our metadata into it, so that it looks identical to the one
    # originally set.
      members = self.__dict__.get('_members')
      if members is not None and name in members:
        _copy_metadata_deep(value, members[name])

    # Verify that the new object is good
      _assert_valid_deep(value)

      return value

    # Attribute access must be intercepted to ensure that objects coming from
    # read attribute access match those that are set with write attribute access.
    # Specifically the metadata, such as the associated apr_pool object, should
    # match the originally assigned object.
    #
    # For classic classes it is enough to use __getattr__ to intercept swig
    # derived attributes. However, with new style classes SWIG makes use of
    # descriptors which mean that __getattr__ is never called. Therefore,
    # __getattribute__ must be used for the interception.

    if _newclass:
      def __getattribute__(self, name):
        """Manage access to all attributes of this object."""

    # Start by mimicing __getattr__ behavior: immediately return __dict__ or
    # items directly present in __dict__
        mydict = object.__getattribute__(self, '__dict__')

        if name == "__dict__":
          return mydict

        if name in mydict:
          return mydict[name]

        object.__getattribute__(self, 'assert_valid')()

        value = _get_instance_attr(self, name)
        fn = object.__getattribute__(self, '_retrieve_swig_value')
        return fn(name, value)
    else:
      def __getattr__(self, name):
        """Get an attribute from this object"""
        self.assert_valid()

        value = _swig_getattr(self, self.__class__, name)

        return self._retrieve_swig_value(name, value)

    def __setattr__(self, name, value):
      """Set an attribute on this object"""
      self.assert_valid()

    # Save a copy of the object, so that the garbage
    # collector won't kill the object while it's in
    # SWIG-land
      self.__dict__.setdefault("_members",{})[name] = value

      return _set_instance_attr(self, name, value)


    def __init__(self):
        """__init__(svn_auth_cred_ssl_client_cert_pw_t self) -> svn_auth_cred_ssl_client_cert_pw_t"""
        this = _core.new_svn_auth_cred_ssl_client_cert_pw_t()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _core.delete_svn_auth_cred_ssl_client_cert_pw_t
    __del__ = lambda self: None
svn_auth_cred_ssl_client_cert_pw_t_swigregister = _core.svn_auth_cred_ssl_client_cert_pw_t_swigregister
svn_auth_cred_ssl_client_cert_pw_t_swigregister(svn_auth_cred_ssl_client_cert_pw_t)

SVN_AUTH_CRED_SSL_SERVER_TRUST = _core.SVN_AUTH_CRED_SSL_SERVER_TRUST
class svn_auth_ssl_server_cert_info_t(object):
    """Proxy of C svn_auth_ssl_server_cert_info_t struct."""

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    hostname = _swig_property(_core.svn_auth_ssl_server_cert_info_t_hostname_get, _core.svn_auth_ssl_server_cert_info_t_hostname_set)
    fingerprint = _swig_property(_core.svn_auth_ssl_server_cert_info_t_fingerprint_get, _core.svn_auth_ssl_server_cert_info_t_fingerprint_set)
    valid_from = _swig_property(_core.svn_auth_ssl_server_cert_info_t_valid_from_get, _core.svn_auth_ssl_server_cert_info_t_valid_from_set)
    valid_until = _swig_property(_core.svn_auth_ssl_server_cert_info_t_valid_until_get, _core.svn_auth_ssl_server_cert_info_t_valid_until_set)
    issuer_dname = _swig_property(_core.svn_auth_ssl_server_cert_info_t_issuer_dname_get, _core.svn_auth_ssl_server_cert_info_t_issuer_dname_set)
    ascii_cert = _swig_property(_core.svn_auth_ssl_server_cert_info_t_ascii_cert_get, _core.svn_auth_ssl_server_cert_info_t_ascii_cert_set)
    def set_parent_pool(self, parent_pool=None):
      """Create a new proxy object for TYPE"""
      import libsvn.core, weakref
      self.__dict__["_parent_pool"] = \
        parent_pool or libsvn.core.application_pool;
      if self.__dict__["_parent_pool"]:
        self.__dict__["_is_valid"] = weakref.ref(
          self.__dict__["_parent_pool"]._is_valid)

    def assert_valid(self):
      """Assert that this object is using valid pool memory"""
      if "_is_valid" in self.__dict__:
        assert self.__dict__["_is_valid"](), "Variable has already been deleted"

    def _retrieve_swig_value(self, name, value):
    # If we got back a different object than we have cached, we need to copy
    # all our metadata into it, so that it looks identical to the one
    # originally set.
      members = self.__dict__.get('_members')
      if members is not None and name in members:
        _copy_metadata_deep(value, members[name])

    # Verify that the new object is good
      _assert_valid_deep(value)

      return value

    # Attribute access must be intercepted to ensure that objects coming from
    # read attribute access match those that are set with write attribute access.
    # Specifically the metadata, such as the associated apr_pool object, should
    # match the originally assigned object.
    #
    # For classic classes it is enough to use __getattr__ to intercept swig
    # derived attributes. However, with new style classes SWIG makes use of
    # descriptors which mean that __getattr__ is never called. Therefore,
    # __getattribute__ must be used for the interception.

    if _newclass:
      def __getattribute__(self, name):
        """Manage access to all attributes of this object."""

    # Start by mimicing __getattr__ behavior: immediately return __dict__ or
    # items directly present in __dict__
        mydict = object.__getattribute__(self, '__dict__')

        if name == "__dict__":
          return mydict

        if name in mydict:
          return mydict[name]

        object.__getattribute__(self, 'assert_valid')()

        value = _get_instance_attr(self, name)
        fn = object.__getattribute__(self, '_retrieve_swig_value')
        return fn(name, value)
    else:
      def __getattr__(self, name):
        """Get an attribute from this object"""
        self.assert_valid()

        value = _swig_getattr(self, self.__class__, name)

        return self._retrieve_swig_value(name, value)

    def __setattr__(self, name, value):
      """Set an attribute on this object"""
      self.assert_valid()

    # Save a copy of the object, so that the garbage
    # collector won't kill the object while it's in
    # SWIG-land
      self.__dict__.setdefault("_members",{})[name] = value

      return _set_instance_attr(self, name, value)


    def __init__(self):
        """__init__(svn_auth_ssl_server_cert_info_t self) -> svn_auth_ssl_server_cert_info_t"""
        this = _core.new_svn_auth_ssl_server_cert_info_t()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _core.delete_svn_auth_ssl_server_cert_info_t
    __del__ = lambda self: None
svn_auth_ssl_server_cert_info_t_swigregister = _core.svn_auth_ssl_server_cert_info_t_swigregister
svn_auth_ssl_server_cert_info_t_swigregister(svn_auth_ssl_server_cert_info_t)


def svn_auth_ssl_server_cert_info_dup(*args) -> "svn_auth_ssl_server_cert_info_t *":
    """svn_auth_ssl_server_cert_info_dup(svn_auth_ssl_server_cert_info_t info, apr_pool_t pool) -> svn_auth_ssl_server_cert_info_t"""
    return _core.svn_auth_ssl_server_cert_info_dup(*args)
class svn_auth_cred_ssl_server_trust_t(object):
    """Proxy of C svn_auth_cred_ssl_server_trust_t struct."""

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    may_save = _swig_property(_core.svn_auth_cred_ssl_server_trust_t_may_save_get, _core.svn_auth_cred_ssl_server_trust_t_may_save_set)
    accepted_failures = _swig_property(_core.svn_auth_cred_ssl_server_trust_t_accepted_failures_get, _core.svn_auth_cred_ssl_server_trust_t_accepted_failures_set)
    def set_parent_pool(self, parent_pool=None):
      """Create a new proxy object for TYPE"""
      import libsvn.core, weakref
      self.__dict__["_parent_pool"] = \
        parent_pool or libsvn.core.application_pool;
      if self.__dict__["_parent_pool"]:
        self.__dict__["_is_valid"] = weakref.ref(
          self.__dict__["_parent_pool"]._is_valid)

    def assert_valid(self):
      """Assert that this object is using valid pool memory"""
      if "_is_valid" in self.__dict__:
        assert self.__dict__["_is_valid"](), "Variable has already been deleted"

    def _retrieve_swig_value(self, name, value):
    # If we got back a different object than we have cached, we need to copy
    # all our metadata into it, so that it looks identical to the one
    # originally set.
      members = self.__dict__.get('_members')
      if members is not None and name in members:
        _copy_metadata_deep(value, members[name])

    # Verify that the new object is good
      _assert_valid_deep(value)

      return value

    # Attribute access must be intercepted to ensure that objects coming from
    # read attribute access match those that are set with write attribute access.
    # Specifically the metadata, such as the associated apr_pool object, should
    # match the originally assigned object.
    #
    # For classic classes it is enough to use __getattr__ to intercept swig
    # derived attributes. However, with new style classes SWIG makes use of
    # descriptors which mean that __getattr__ is never called. Therefore,
    # __getattribute__ must be used for the interception.

    if _newclass:
      def __getattribute__(self, name):
        """Manage access to all attributes of this object."""

    # Start by mimicing __getattr__ behavior: immediately return __dict__ or
    # items directly present in __dict__
        mydict = object.__getattribute__(self, '__dict__')

        if name == "__dict__":
          return mydict

        if name in mydict:
          return mydict[name]

        object.__getattribute__(self, 'assert_valid')()

        value = _get_instance_attr(self, name)
        fn = object.__getattribute__(self, '_retrieve_swig_value')
        return fn(name, value)
    else:
      def __getattr__(self, name):
        """Get an attribute from this object"""
        self.assert_valid()

        value = _swig_getattr(self, self.__class__, name)

        return self._retrieve_swig_value(name, value)

    def __setattr__(self, name, value):
      """Set an attribute on this object"""
      self.assert_valid()

    # Save a copy of the object, so that the garbage
    # collector won't kill the object while it's in
    # SWIG-land
      self.__dict__.setdefault("_members",{})[name] = value

      return _set_instance_attr(self, name, value)


    def __init__(self):
        """__init__(svn_auth_cred_ssl_server_trust_t self) -> svn_auth_cred_ssl_server_trust_t"""
        this = _core.new_svn_auth_cred_ssl_server_trust_t()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _core.delete_svn_auth_cred_ssl_server_trust_t
    __del__ = lambda self: None
svn_auth_cred_ssl_server_trust_t_swigregister = _core.svn_auth_cred_ssl_server_trust_t_swigregister
svn_auth_cred_ssl_server_trust_t_swigregister(svn_auth_cred_ssl_server_trust_t)

SVN_AUTH_SSL_NOTYETVALID = _core.SVN_AUTH_SSL_NOTYETVALID
SVN_AUTH_SSL_EXPIRED = _core.SVN_AUTH_SSL_EXPIRED
SVN_AUTH_SSL_CNMISMATCH = _core.SVN_AUTH_SSL_CNMISMATCH
SVN_AUTH_SSL_UNKNOWNCA = _core.SVN_AUTH_SSL_UNKNOWNCA
SVN_AUTH_SSL_OTHER = _core.SVN_AUTH_SSL_OTHER

def svn_auth_open(*args) -> "svn_auth_baton_t **":
    """svn_auth_open(apr_array_header_t providers, apr_pool_t pool)"""
    val = _core.svn_auth_open(*args)

    val.__dict__["_deps"] = list(args[0])


    return val

def svn_auth_set_parameter(auth_baton: 'svn_auth_baton_t *', name: 'char const *', value: 'void const *') -> "void":
    """svn_auth_set_parameter(svn_auth_baton_t * auth_baton, char const * name, void const * value)"""
    return _core.svn_auth_set_parameter(auth_baton, name, value)
SVN_AUTH_PARAM_PREFIX = _core.SVN_AUTH_PARAM_PREFIX
SVN_AUTH_PARAM_DEFAULT_USERNAME = _core.SVN_AUTH_PARAM_DEFAULT_USERNAME
SVN_AUTH_PARAM_DEFAULT_PASSWORD = _core.SVN_AUTH_PARAM_DEFAULT_PASSWORD
SVN_AUTH_PARAM_NON_INTERACTIVE = _core.SVN_AUTH_PARAM_NON_INTERACTIVE
SVN_AUTH_PARAM_DONT_STORE_PASSWORDS = _core.SVN_AUTH_PARAM_DONT_STORE_PASSWORDS
SVN_AUTH_PARAM_STORE_PLAINTEXT_PASSWORDS = _core.SVN_AUTH_PARAM_STORE_PLAINTEXT_PASSWORDS
SVN_AUTH_PARAM_DONT_STORE_SSL_CLIENT_CERT_PP = _core.SVN_AUTH_PARAM_DONT_STORE_SSL_CLIENT_CERT_PP
SVN_AUTH_PARAM_STORE_SSL_CLIENT_CERT_PP_PLAINTEXT = _core.SVN_AUTH_PARAM_STORE_SSL_CLIENT_CERT_PP_PLAINTEXT
SVN_AUTH_PARAM_NO_AUTH_CACHE = _core.SVN_AUTH_PARAM_NO_AUTH_CACHE
SVN_AUTH_PARAM_SSL_SERVER_FAILURES = _core.SVN_AUTH_PARAM_SSL_SERVER_FAILURES
SVN_AUTH_PARAM_SSL_SERVER_CERT_INFO = _core.SVN_AUTH_PARAM_SSL_SERVER_CERT_INFO
SVN_AUTH_PARAM_CONFIG_CATEGORY_CONFIG = _core.SVN_AUTH_PARAM_CONFIG_CATEGORY_CONFIG
SVN_AUTH_PARAM_CONFIG_CATEGORY_SERVERS = _core.SVN_AUTH_PARAM_CONFIG_CATEGORY_SERVERS
SVN_AUTH_PARAM_CONFIG = _core.SVN_AUTH_PARAM_CONFIG
SVN_AUTH_PARAM_SERVER_GROUP = _core.SVN_AUTH_PARAM_SERVER_GROUP
SVN_AUTH_PARAM_CONFIG_DIR = _core.SVN_AUTH_PARAM_CONFIG_DIR

def svn_auth_first_credentials(*args) -> "void **, svn_auth_iterstate_t **":
    """svn_auth_first_credentials(char const * cred_kind, char const * realmstring, svn_auth_baton_t * auth_baton, apr_pool_t pool) -> svn_error_t"""
    return _core.svn_auth_first_credentials(*args)

def svn_auth_next_credentials(*args) -> "void **":
    """svn_auth_next_credentials(svn_auth_iterstate_t * state, apr_pool_t pool) -> svn_error_t"""
    return _core.svn_auth_next_credentials(*args)

def svn_auth_save_credentials(*args) -> "svn_error_t *":
    """svn_auth_save_credentials(svn_auth_iterstate_t * state, apr_pool_t pool) -> svn_error_t"""
    return _core.svn_auth_save_credentials(*args)

def svn_auth_forget_credentials(*args) -> "svn_error_t *":
    """svn_auth_forget_credentials(svn_auth_baton_t * auth_baton, char const * cred_kind, char const * realmstring, apr_pool_t pool) -> svn_error_t"""
    return _core.svn_auth_forget_credentials(*args)

def svn_auth_get_simple_prompt_provider(*args) -> "svn_auth_provider_object_t **":
    """svn_auth_get_simple_prompt_provider(svn_auth_simple_prompt_func_t prompt_func, int retry_limit, apr_pool_t pool)"""
    return _core.svn_auth_get_simple_prompt_provider(*args)

def svn_auth_get_username_prompt_provider(*args) -> "svn_auth_provider_object_t **":
    """svn_auth_get_username_prompt_provider(svn_auth_username_prompt_func_t prompt_func, int retry_limit, apr_pool_t pool)"""
    return _core.svn_auth_get_username_prompt_provider(*args)

def svn_auth_get_simple_provider2(*args) -> "svn_auth_provider_object_t **":
    """svn_auth_get_simple_provider2(svn_auth_plaintext_prompt_func_t plaintext_prompt_func, void * prompt_baton, apr_pool_t pool)"""
    return _core.svn_auth_get_simple_provider2(*args)

def svn_auth_get_simple_provider(*args) -> "svn_auth_provider_object_t **":
    """svn_auth_get_simple_provider(apr_pool_t pool)"""
    return _core.svn_auth_get_simple_provider(*args)

def svn_auth_get_platform_specific_provider(*args) -> "svn_auth_provider_object_t **":
    """svn_auth_get_platform_specific_provider(char const * provider_name, char const * provider_type, apr_pool_t pool) -> svn_error_t"""
    return _core.svn_auth_get_platform_specific_provider(*args)

def svn_auth_get_platform_specific_client_providers(*args) -> "apr_array_header_t **":
    """svn_auth_get_platform_specific_client_providers(svn_config_t * config, apr_pool_t pool) -> svn_error_t"""
    return _core.svn_auth_get_platform_specific_client_providers(*args)
SVN_AUTH_PARAM_GNOME_KEYRING_UNLOCK_PROMPT_FUNC = _core.SVN_AUTH_PARAM_GNOME_KEYRING_UNLOCK_PROMPT_FUNC
SVN_AUTH_PARAM_GNOME_KEYRING_UNLOCK_PROMPT_BATON = _core.SVN_AUTH_PARAM_GNOME_KEYRING_UNLOCK_PROMPT_BATON

def svn_auth_get_username_provider(*args) -> "svn_auth_provider_object_t **":
    """svn_auth_get_username_provider(apr_pool_t pool)"""
    return _core.svn_auth_get_username_provider(*args)

def svn_auth_get_ssl_server_trust_file_provider(*args) -> "svn_auth_provider_object_t **":
    """svn_auth_get_ssl_server_trust_file_provider(apr_pool_t pool)"""
    return _core.svn_auth_get_ssl_server_trust_file_provider(*args)

def svn_auth_get_ssl_client_cert_file_provider(*args) -> "svn_auth_provider_object_t **":
    """svn_auth_get_ssl_client_cert_file_provider(apr_pool_t pool)"""
    return _core.svn_auth_get_ssl_client_cert_file_provider(*args)

def svn_auth_get_ssl_client_cert_pw_file_provider2(*args) -> "svn_auth_provider_object_t **":
    """svn_auth_get_ssl_client_cert_pw_file_provider2(svn_auth_plaintext_passphrase_prompt_func_t plaintext_passphrase_prompt_func, void * prompt_baton, apr_pool_t pool)"""
    return _core.svn_auth_get_ssl_client_cert_pw_file_provider2(*args)

def svn_auth_get_ssl_client_cert_pw_file_provider(*args) -> "svn_auth_provider_object_t **":
    """svn_auth_get_ssl_client_cert_pw_file_provider(apr_pool_t pool)"""
    return _core.svn_auth_get_ssl_client_cert_pw_file_provider(*args)

def svn_auth_get_ssl_server_trust_prompt_provider(*args) -> "svn_auth_provider_object_t **":
    """svn_auth_get_ssl_server_trust_prompt_provider(svn_auth_ssl_server_trust_prompt_func_t prompt_func, apr_pool_t pool)"""
    return _core.svn_auth_get_ssl_server_trust_prompt_provider(*args)

def svn_auth_get_ssl_client_cert_prompt_provider(*args) -> "svn_auth_provider_object_t **":
    """svn_auth_get_ssl_client_cert_prompt_provider(svn_auth_ssl_client_cert_prompt_func_t prompt_func, int retry_limit, apr_pool_t pool)"""
    return _core.svn_auth_get_ssl_client_cert_prompt_provider(*args)

def svn_auth_get_ssl_client_cert_pw_prompt_provider(*args) -> "svn_auth_provider_object_t **":
    """svn_auth_get_ssl_client_cert_pw_prompt_provider(svn_auth_ssl_client_cert_pw_prompt_func_t prompt_func, int retry_limit, apr_pool_t pool)"""
    return _core.svn_auth_get_ssl_client_cert_pw_prompt_provider(*args)
class svn_auth_baton_t(object):
    """Proxy of C svn_auth_baton_t struct."""

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    def set_parent_pool(self, parent_pool=None):
      """Create a new proxy object for TYPE"""
      import libsvn.core, weakref
      self.__dict__["_parent_pool"] = \
        parent_pool or libsvn.core.application_pool;
      if self.__dict__["_parent_pool"]:
        self.__dict__["_is_valid"] = weakref.ref(
          self.__dict__["_parent_pool"]._is_valid)

    def assert_valid(self):
      """Assert that this object is using valid pool memory"""
      if "_is_valid" in self.__dict__:
        assert self.__dict__["_is_valid"](), "Variable has already been deleted"

    def _retrieve_swig_value(self, name, value):
    # If we got back a different object than we have cached, we need to copy
    # all our metadata into it, so that it looks identical to the one
    # originally set.
      members = self.__dict__.get('_members')
      if members is not None and name in members:
        _copy_metadata_deep(value, members[name])

    # Verify that the new object is good
      _assert_valid_deep(value)

      return value

    # Attribute access must be intercepted to ensure that objects coming from
    # read attribute access match those that are set with write attribute access.
    # Specifically the metadata, such as the associated apr_pool object, should
    # match the originally assigned object.
    #
    # For classic classes it is enough to use __getattr__ to intercept swig
    # derived attributes. However, with new style classes SWIG makes use of
    # descriptors which mean that __getattr__ is never called. Therefore,
    # __getattribute__ must be used for the interception.

    if _newclass:
      def __getattribute__(self, name):
        """Manage access to all attributes of this object."""

    # Start by mimicing __getattr__ behavior: immediately return __dict__ or
    # items directly present in __dict__
        mydict = object.__getattribute__(self, '__dict__')

        if name == "__dict__":
          return mydict

        if name in mydict:
          return mydict[name]

        object.__getattribute__(self, 'assert_valid')()

        value = _get_instance_attr(self, name)
        fn = object.__getattribute__(self, '_retrieve_swig_value')
        return fn(name, value)
    else:
      def __getattr__(self, name):
        """Get an attribute from this object"""
        self.assert_valid()

        value = _swig_getattr(self, self.__class__, name)

        return self._retrieve_swig_value(name, value)

    def __setattr__(self, name, value):
      """Set an attribute on this object"""
      self.assert_valid()

    # Save a copy of the object, so that the garbage
    # collector won't kill the object while it's in
    # SWIG-land
      self.__dict__.setdefault("_members",{})[name] = value

      return _set_instance_attr(self, name, value)

svn_auth_baton_t_swigregister = _core.svn_auth_baton_t_swigregister
svn_auth_baton_t_swigregister(svn_auth_baton_t)

class svn_auth_iterstate_t(object):
    """Proxy of C svn_auth_iterstate_t struct."""

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    def set_parent_pool(self, parent_pool=None):
      """Create a new proxy object for TYPE"""
      import libsvn.core, weakref
      self.__dict__["_parent_pool"] = \
        parent_pool or libsvn.core.application_pool;
      if self.__dict__["_parent_pool"]:
        self.__dict__["_is_valid"] = weakref.ref(
          self.__dict__["_parent_pool"]._is_valid)

    def assert_valid(self):
      """Assert that this object is using valid pool memory"""
      if "_is_valid" in self.__dict__:
        assert self.__dict__["_is_valid"](), "Variable has already been deleted"

    def _retrieve_swig_value(self, name, value):
    # If we got back a different object than we have cached, we need to copy
    # all our metadata into it, so that it looks identical to the one
    # originally set.
      members = self.__dict__.get('_members')
      if members is not None and name in members:
        _copy_metadata_deep(value, members[name])

    # Verify that the new object is good
      _assert_valid_deep(value)

      return value

    # Attribute access must be intercepted to ensure that objects coming from
    # read attribute access match those that are set with write attribute access.
    # Specifically the metadata, such as the associated apr_pool object, should
    # match the originally assigned object.
    #
    # For classic classes it is enough to use __getattr__ to intercept swig
    # derived attributes. However, with new style classes SWIG makes use of
    # descriptors which mean that __getattr__ is never called. Therefore,
    # __getattribute__ must be used for the interception.

    if _newclass:
      def __getattribute__(self, name):
        """Manage access to all attributes of this object."""

    # Start by mimicing __getattr__ behavior: immediately return __dict__ or
    # items directly present in __dict__
        mydict = object.__getattribute__(self, '__dict__')

        if name == "__dict__":
          return mydict

        if name in mydict:
          return mydict[name]

        object.__getattribute__(self, 'assert_valid')()

        value = _get_instance_attr(self, name)
        fn = object.__getattribute__(self, '_retrieve_swig_value')
        return fn(name, value)
    else:
      def __getattr__(self, name):
        """Get an attribute from this object"""
        self.assert_valid()

        value = _swig_getattr(self, self.__class__, name)

        return self._retrieve_swig_value(name, value)

    def __setattr__(self, name, value):
      """Set an attribute on this object"""
      self.assert_valid()

    # Save a copy of the object, so that the garbage
    # collector won't kill the object while it's in
    # SWIG-land
      self.__dict__.setdefault("_members",{})[name] = value

      return _set_instance_attr(self, name, value)

svn_auth_iterstate_t_swigregister = _core.svn_auth_iterstate_t_swigregister
svn_auth_iterstate_t_swigregister(svn_auth_iterstate_t)


def svn_auth_provider_invoke_first_credentials(*args) -> "void **, void **":
    """svn_auth_provider_invoke_first_credentials(svn_auth_provider_t _obj, void * provider_baton, apr_hash_t parameters, char const * realmstring, apr_pool_t pool) -> svn_error_t"""
    return _core.svn_auth_provider_invoke_first_credentials(*args)

def svn_auth_provider_invoke_next_credentials(*args) -> "void **":
    """svn_auth_provider_invoke_next_credentials(svn_auth_provider_t _obj, void * iter_baton, void * provider_baton, apr_hash_t parameters, char const * realmstring, apr_pool_t pool) -> svn_error_t"""
    return _core.svn_auth_provider_invoke_next_credentials(*args)

def svn_auth_provider_invoke_save_credentials(*args) -> "svn_boolean_t *":
    """svn_auth_provider_invoke_save_credentials(svn_auth_provider_t _obj, void * credentials, void * provider_baton, apr_hash_t parameters, char const * realmstring, apr_pool_t pool) -> svn_error_t"""
    return _core.svn_auth_provider_invoke_save_credentials(*args)

def svn_auth_invoke_simple_provider_func(*args) -> "svn_auth_provider_object_t **":
    """svn_auth_invoke_simple_provider_func(svn_auth_simple_provider_func_t _obj, apr_pool_t pool)"""
    return _core.svn_auth_invoke_simple_provider_func(*args)

def svn_auth_invoke_ssl_client_cert_pw_provider_func(*args) -> "svn_auth_provider_object_t **":
    """svn_auth_invoke_ssl_client_cert_pw_provider_func(svn_auth_ssl_client_cert_pw_provider_func_t _obj, apr_pool_t pool)"""
    return _core.svn_auth_invoke_ssl_client_cert_pw_provider_func(*args)

def svn_auth_invoke_simple_prompt_func(*args) -> "svn_auth_cred_simple_t **":
    """svn_auth_invoke_simple_prompt_func(svn_auth_simple_prompt_func_t _obj, void * baton, char const * realm, char const * username, svn_boolean_t may_save, apr_pool_t pool) -> svn_error_t"""
    return _core.svn_auth_invoke_simple_prompt_func(*args)

def svn_auth_invoke_username_prompt_func(*args) -> "svn_auth_cred_username_t **":
    """svn_auth_invoke_username_prompt_func(svn_auth_username_prompt_func_t _obj, void * baton, char const * realm, svn_boolean_t may_save, apr_pool_t pool) -> svn_error_t"""
    return _core.svn_auth_invoke_username_prompt_func(*args)

def svn_auth_invoke_ssl_server_trust_prompt_func(*args) -> "svn_auth_cred_ssl_server_trust_t **":
    """svn_auth_invoke_ssl_server_trust_prompt_func(svn_auth_ssl_server_trust_prompt_func_t _obj, void * baton, char const * realm, apr_uint32_t failures, svn_auth_ssl_server_cert_info_t cert_info, svn_boolean_t may_save, apr_pool_t pool) -> svn_error_t"""
    return _core.svn_auth_invoke_ssl_server_trust_prompt_func(*args)

def svn_auth_invoke_ssl_client_cert_prompt_func(*args) -> "svn_auth_cred_ssl_client_cert_t **":
    """svn_auth_invoke_ssl_client_cert_prompt_func(svn_auth_ssl_client_cert_prompt_func_t _obj, void * baton, char const * realm, svn_boolean_t may_save, apr_pool_t pool) -> svn_error_t"""
    return _core.svn_auth_invoke_ssl_client_cert_prompt_func(*args)

def svn_auth_invoke_ssl_client_cert_pw_prompt_func(*args) -> "svn_auth_cred_ssl_client_cert_pw_t **":
    """svn_auth_invoke_ssl_client_cert_pw_prompt_func(svn_auth_ssl_client_cert_pw_prompt_func_t _obj, void * baton, char const * realm, svn_boolean_t may_save, apr_pool_t pool) -> svn_error_t"""
    return _core.svn_auth_invoke_ssl_client_cert_pw_prompt_func(*args)

def svn_auth_invoke_plaintext_prompt_func(*args) -> "svn_boolean_t *":
    """svn_auth_invoke_plaintext_prompt_func(svn_auth_plaintext_prompt_func_t _obj, char const * realmstring, void * baton, apr_pool_t pool) -> svn_error_t"""
    return _core.svn_auth_invoke_plaintext_prompt_func(*args)

def svn_auth_invoke_plaintext_passphrase_prompt_func(*args) -> "svn_boolean_t *":
    """svn_auth_invoke_plaintext_passphrase_prompt_func(svn_auth_plaintext_passphrase_prompt_func_t _obj, char const * realmstring, void * baton, apr_pool_t pool) -> svn_error_t"""
    return _core.svn_auth_invoke_plaintext_passphrase_prompt_func(*args)
class svn_auth_simple_provider_func_t(object):
    """Proxy of C svn_auth_simple_provider_func_t struct."""

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    def set_parent_pool(self, parent_pool=None):
      """Create a new proxy object for TYPE"""
      import libsvn.core, weakref
      self.__dict__["_parent_pool"] = \
        parent_pool or libsvn.core.application_pool;
      if self.__dict__["_parent_pool"]:
        self.__dict__["_is_valid"] = weakref.ref(
          self.__dict__["_parent_pool"]._is_valid)

    def assert_valid(self):
      """Assert that this object is using valid pool memory"""
      if "_is_valid" in self.__dict__:
        assert self.__dict__["_is_valid"](), "Variable has already been deleted"

    def _retrieve_swig_value(self, name, value):
    # If we got back a different object than we have cached, we need to copy
    # all our metadata into it, so that it looks identical to the one
    # originally set.
      members = self.__dict__.get('_members')
      if members is not None and name in members:
        _copy_metadata_deep(value, members[name])

    # Verify that the new object is good
      _assert_valid_deep(value)

      return value

    # Attribute access must be intercepted to ensure that objects coming from
    # read attribute access match those that are set with write attribute access.
    # Specifically the metadata, such as the associated apr_pool object, should
    # match the originally assigned object.
    #
    # For classic classes it is enough to use __getattr__ to intercept swig
    # derived attributes. However, with new style classes SWIG makes use of
    # descriptors which mean that __getattr__ is never called. Therefore,
    # __getattribute__ must be used for the interception.

    if _newclass:
      def __getattribute__(self, name):
        """Manage access to all attributes of this object."""

    # Start by mimicing __getattr__ behavior: immediately return __dict__ or
    # items directly present in __dict__
        mydict = object.__getattribute__(self, '__dict__')

        if name == "__dict__":
          return mydict

        if name in mydict:
          return mydict[name]

        object.__getattribute__(self, 'assert_valid')()

        value = _get_instance_attr(self, name)
        fn = object.__getattribute__(self, '_retrieve_swig_value')
        return fn(name, value)
    else:
      def __getattr__(self, name):
        """Get an attribute from this object"""
        self.assert_valid()

        value = _swig_getattr(self, self.__class__, name)

        return self._retrieve_swig_value(name, value)

    def __setattr__(self, name, value):
      """Set an attribute on this object"""
      self.assert_valid()

    # Save a copy of the object, so that the garbage
    # collector won't kill the object while it's in
    # SWIG-land
      self.__dict__.setdefault("_members",{})[name] = value

      return _set_instance_attr(self, name, value)


    def __call__(self, *args):
      return svn_auth_invoke_simple_provider_func(self, *args)

svn_auth_simple_provider_func_t_swigregister = _core.svn_auth_simple_provider_func_t_swigregister
svn_auth_simple_provider_func_t_swigregister(svn_auth_simple_provider_func_t)

class svn_auth_ssl_client_cert_pw_provider_func_t(object):
    """Proxy of C svn_auth_ssl_client_cert_pw_provider_func_t struct."""

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    def set_parent_pool(self, parent_pool=None):
      """Create a new proxy object for TYPE"""
      import libsvn.core, weakref
      self.__dict__["_parent_pool"] = \
        parent_pool or libsvn.core.application_pool;
      if self.__dict__["_parent_pool"]:
        self.__dict__["_is_valid"] = weakref.ref(
          self.__dict__["_parent_pool"]._is_valid)

    def assert_valid(self):
      """Assert that this object is using valid pool memory"""
      if "_is_valid" in self.__dict__:
        assert self.__dict__["_is_valid"](), "Variable has already been deleted"

    def _retrieve_swig_value(self, name, value):
    # If we got back a different object than we have cached, we need to copy
    # all our metadata into it, so that it looks identical to the one
    # originally set.
      members = self.__dict__.get('_members')
      if members is not None and name in members:
        _copy_metadata_deep(value, members[name])

    # Verify that the new object is good
      _assert_valid_deep(value)

      return value

    # Attribute access must be intercepted to ensure that objects coming from
    # read attribute access match those that are set with write attribute access.
    # Specifically the metadata, such as the associated apr_pool object, should
    # match the originally assigned object.
    #
    # For classic classes it is enough to use __getattr__ to intercept swig
    # derived attributes. However, with new style classes SWIG makes use of
    # descriptors which mean that __getattr__ is never called. Therefore,
    # __getattribute__ must be used for the interception.

    if _newclass:
      def __getattribute__(self, name):
        """Manage access to all attributes of this object."""

    # Start by mimicing __getattr__ behavior: immediately return __dict__ or
    # items directly present in __dict__
        mydict = object.__getattribute__(self, '__dict__')

        if name == "__dict__":
          return mydict

        if name in mydict:
          return mydict[name]

        object.__getattribute__(self, 'assert_valid')()

        value = _get_instance_attr(self, name)
        fn = object.__getattribute__(self, '_retrieve_swig_value')
        return fn(name, value)
    else:
      def __getattr__(self, name):
        """Get an attribute from this object"""
        self.assert_valid()

        value = _swig_getattr(self, self.__class__, name)

        return self._retrieve_swig_value(name, value)

    def __setattr__(self, name, value):
      """Set an attribute on this object"""
      self.assert_valid()

    # Save a copy of the object, so that the garbage
    # collector won't kill the object while it's in
    # SWIG-land
      self.__dict__.setdefault("_members",{})[name] = value

      return _set_instance_attr(self, name, value)


    def __call__(self, *args):
      return svn_auth_invoke_ssl_client_cert_pw_provider_func(self, *args)

svn_auth_ssl_client_cert_pw_provider_func_t_swigregister = _core.svn_auth_ssl_client_cert_pw_provider_func_t_swigregister
svn_auth_ssl_client_cert_pw_provider_func_t_swigregister(svn_auth_ssl_client_cert_pw_provider_func_t)

class svn_auth_simple_prompt_func_t(object):
    """Proxy of C svn_auth_simple_prompt_func_t struct."""

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    def set_parent_pool(self, parent_pool=None):
      """Create a new proxy object for TYPE"""
      import libsvn.core, weakref
      self.__dict__["_parent_pool"] = \
        parent_pool or libsvn.core.application_pool;
      if self.__dict__["_parent_pool"]:
        self.__dict__["_is_valid"] = weakref.ref(
          self.__dict__["_parent_pool"]._is_valid)

    def assert_valid(self):
      """Assert that this object is using valid pool memory"""
      if "_is_valid" in self.__dict__:
        assert self.__dict__["_is_valid"](), "Variable has already been deleted"

    def _retrieve_swig_value(self, name, value):
    # If we got back a different object than we have cached, we need to copy
    # all our metadata into it, so that it looks identical to the one
    # originally set.
      members = self.__dict__.get('_members')
      if members is not None and name in members:
        _copy_metadata_deep(value, members[name])

    # Verify that the new object is good
      _assert_valid_deep(value)

      return value

    # Attribute access must be intercepted to ensure that objects coming from
    # read attribute access match those that are set with write attribute access.
    # Specifically the metadata, such as the associated apr_pool object, should
    # match the originally assigned object.
    #
    # For classic classes it is enough to use __getattr__ to intercept swig
    # derived attributes. However, with new style classes SWIG makes use of
    # descriptors which mean that __getattr__ is never called. Therefore,
    # __getattribute__ must be used for the interception.

    if _newclass:
      def __getattribute__(self, name):
        """Manage access to all attributes of this object."""

    # Start by mimicing __getattr__ behavior: immediately return __dict__ or
    # items directly present in __dict__
        mydict = object.__getattribute__(self, '__dict__')

        if name == "__dict__":
          return mydict

        if name in mydict:
          return mydict[name]

        object.__getattribute__(self, 'assert_valid')()

        value = _get_instance_attr(self, name)
        fn = object.__getattribute__(self, '_retrieve_swig_value')
        return fn(name, value)
    else:
      def __getattr__(self, name):
        """Get an attribute from this object"""
        self.assert_valid()

        value = _swig_getattr(self, self.__class__, name)

        return self._retrieve_swig_value(name, value)

    def __setattr__(self, name, value):
      """Set an attribute on this object"""
      self.assert_valid()

    # Save a copy of the object, so that the garbage
    # collector won't kill the object while it's in
    # SWIG-land
      self.__dict__.setdefault("_members",{})[name] = value

      return _set_instance_attr(self, name, value)


    def __call__(self, *args):
      return svn_auth_invoke_simple_prompt_func(self, *args)

svn_auth_simple_prompt_func_t_swigregister = _core.svn_auth_simple_prompt_func_t_swigregister
svn_auth_simple_prompt_func_t_swigregister(svn_auth_simple_prompt_func_t)

class svn_auth_username_prompt_func_t(object):
    """Proxy of C svn_auth_username_prompt_func_t struct."""

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    def set_parent_pool(self, parent_pool=None):
      """Create a new proxy object for TYPE"""
      import libsvn.core, weakref
      self.__dict__["_parent_pool"] = \
        parent_pool or libsvn.core.application_pool;
      if self.__dict__["_parent_pool"]:
        self.__dict__["_is_valid"] = weakref.ref(
          self.__dict__["_parent_pool"]._is_valid)

    def assert_valid(self):
      """Assert that this object is using valid pool memory"""
      if "_is_valid" in self.__dict__:
        assert self.__dict__["_is_valid"](), "Variable has already been deleted"

    def _retrieve_swig_value(self, name, value):
    # If we got back a different object than we have cached, we need to copy
    # all our metadata into it, so that it looks identical to the one
    # originally set.
      members = self.__dict__.get('_members')
      if members is not None and name in members:
        _copy_metadata_deep(value, members[name])

    # Verify that the new object is good
      _assert_valid_deep(value)

      return value

    # Attribute access must be intercepted to ensure that objects coming from
    # read attribute access match those that are set with write attribute access.
    # Specifically the metadata, such as the associated apr_pool object, should
    # match the originally assigned object.
    #
    # For classic classes it is enough to use __getattr__ to intercept swig
    # derived attributes. However, with new style classes SWIG makes use of
    # descriptors which mean that __getattr__ is never called. Therefore,
    # __getattribute__ must be used for the interception.

    if _newclass:
      def __getattribute__(self, name):
        """Manage access to all attributes of this object."""

    # Start by mimicing __getattr__ behavior: immediately return __dict__ or
    # items directly present in __dict__
        mydict = object.__getattribute__(self, '__dict__')

        if name == "__dict__":
          return mydict

        if name in mydict:
          return mydict[name]

        object.__getattribute__(self, 'assert_valid')()

        value = _get_instance_attr(self, name)
        fn = object.__getattribute__(self, '_retrieve_swig_value')
        return fn(name, value)
    else:
      def __getattr__(self, name):
        """Get an attribute from this object"""
        self.assert_valid()

        value = _swig_getattr(self, self.__class__, name)

        return self._retrieve_swig_value(name, value)

    def __setattr__(self, name, value):
      """Set an attribute on this object"""
      self.assert_valid()

    # Save a copy of the object, so that the garbage
    # collector won't kill the object while it's in
    # SWIG-land
      self.__dict__.setdefault("_members",{})[name] = value

      return _set_instance_attr(self, name, value)


    def __call__(self, *args):
      return svn_auth_invoke_username_prompt_func(self, *args)

svn_auth_username_prompt_func_t_swigregister = _core.svn_auth_username_prompt_func_t_swigregister
svn_auth_username_prompt_func_t_swigregister(svn_auth_username_prompt_func_t)

class svn_auth_ssl_server_trust_prompt_func_t(object):
    """Proxy of C svn_auth_ssl_server_trust_prompt_func_t struct."""

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    def set_parent_pool(self, parent_pool=None):
      """Create a new proxy object for TYPE"""
      import libsvn.core, weakref
      self.__dict__["_parent_pool"] = \
        parent_pool or libsvn.core.application_pool;
      if self.__dict__["_parent_pool"]:
        self.__dict__["_is_valid"] = weakref.ref(
          self.__dict__["_parent_pool"]._is_valid)

    def assert_valid(self):
      """Assert that this object is using valid pool memory"""
      if "_is_valid" in self.__dict__:
        assert self.__dict__["_is_valid"](), "Variable has already been deleted"

    def _retrieve_swig_value(self, name, value):
    # If we got back a different object than we have cached, we need to copy
    # all our metadata into it, so that it looks identical to the one
    # originally set.
      members = self.__dict__.get('_members')
      if members is not None and name in members:
        _copy_metadata_deep(value, members[name])

    # Verify that the new object is good
      _assert_valid_deep(value)

      return value

    # Attribute access must be intercepted to ensure that objects coming from
    # read attribute access match those that are set with write attribute access.
    # Specifically the metadata, such as the associated apr_pool object, should
    # match the originally assigned object.
    #
    # For classic classes it is enough to use __getattr__ to intercept swig
    # derived attributes. However, with new style classes SWIG makes use of
    # descriptors which mean that __getattr__ is never called. Therefore,
    # __getattribute__ must be used for the interception.

    if _newclass:
      def __getattribute__(self, name):
        """Manage access to all attributes of this object."""

    # Start by mimicing __getattr__ behavior: immediately return __dict__ or
    # items directly present in __dict__
        mydict = object.__getattribute__(self, '__dict__')

        if name == "__dict__":
          return mydict

        if name in mydict:
          return mydict[name]

        object.__getattribute__(self, 'assert_valid')()

        value = _get_instance_attr(self, name)
        fn = object.__getattribute__(self, '_retrieve_swig_value')
        return fn(name, value)
    else:
      def __getattr__(self, name):
        """Get an attribute from this object"""
        self.assert_valid()

        value = _swig_getattr(self, self.__class__, name)

        return self._retrieve_swig_value(name, value)

    def __setattr__(self, name, value):
      """Set an attribute on this object"""
      self.assert_valid()

    # Save a copy of the object, so that the garbage
    # collector won't kill the object while it's in
    # SWIG-land
      self.__dict__.setdefault("_members",{})[name] = value

      return _set_instance_attr(self, name, value)


    def __call__(self, *args):
      return svn_auth_invoke_ssl_server_trust_prompt_func(self, *args)

svn_auth_ssl_server_trust_prompt_func_t_swigregister = _core.svn_auth_ssl_server_trust_prompt_func_t_swigregister
svn_auth_ssl_server_trust_prompt_func_t_swigregister(svn_auth_ssl_server_trust_prompt_func_t)

class svn_auth_ssl_client_cert_prompt_func_t(object):
    """Proxy of C svn_auth_ssl_client_cert_prompt_func_t struct."""

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    def set_parent_pool(self, parent_pool=None):
      """Create a new proxy object for TYPE"""
      import libsvn.core, weakref
      self.__dict__["_parent_pool"] = \
        parent_pool or libsvn.core.application_pool;
      if self.__dict__["_parent_pool"]:
        self.__dict__["_is_valid"] = weakref.ref(
          self.__dict__["_parent_pool"]._is_valid)

    def assert_valid(self):
      """Assert that this object is using valid pool memory"""
      if "_is_valid" in self.__dict__:
        assert self.__dict__["_is_valid"](), "Variable has already been deleted"

    def _retrieve_swig_value(self, name, value):
    # If we got back a different object than we have cached, we need to copy
    # all our metadata into it, so that it looks identical to the one
    # originally set.
      members = self.__dict__.get('_members')
      if members is not None and name in members:
        _copy_metadata_deep(value, members[name])

    # Verify that the new object is good
      _assert_valid_deep(value)

      return value

    # Attribute access must be intercepted to ensure that objects coming from
    # read attribute access match those that are set with write attribute access.
    # Specifically the metadata, such as the associated apr_pool object, should
    # match the originally assigned object.
    #
    # For classic classes it is enough to use __getattr__ to intercept swig
    # derived attributes. However, with new style classes SWIG makes use of
    # descriptors which mean that __getattr__ is never called. Therefore,
    # __getattribute__ must be used for the interception.

    if _newclass:
      def __getattribute__(self, name):
        """Manage access to all attributes of this object."""

    # Start by mimicing __getattr__ behavior: immediately return __dict__ or
    # items directly present in __dict__
        mydict = object.__getattribute__(self, '__dict__')

        if name == "__dict__":
          return mydict

        if name in mydict:
          return mydict[name]

        object.__getattribute__(self, 'assert_valid')()

        value = _get_instance_attr(self, name)
        fn = object.__getattribute__(self, '_retrieve_swig_value')
        return fn(name, value)
    else:
      def __getattr__(self, name):
        """Get an attribute from this object"""
        self.assert_valid()

        value = _swig_getattr(self, self.__class__, name)

        return self._retrieve_swig_value(name, value)

    def __setattr__(self, name, value):
      """Set an attribute on this object"""
      self.assert_valid()

    # Save a copy of the object, so that the garbage
    # collector won't kill the object while it's in
    # SWIG-land
      self.__dict__.setdefault("_members",{})[name] = value

      return _set_instance_attr(self, name, value)


    def __call__(self, *args):
      return svn_auth_invoke_ssl_client_cert_prompt_func(self, *args)

svn_auth_ssl_client_cert_prompt_func_t_swigregister = _core.svn_auth_ssl_client_cert_prompt_func_t_swigregister
svn_auth_ssl_client_cert_prompt_func_t_swigregister(svn_auth_ssl_client_cert_prompt_func_t)

class svn_auth_ssl_client_cert_pw_prompt_func_t(object):
    """Proxy of C svn_auth_ssl_client_cert_pw_prompt_func_t struct."""

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    def set_parent_pool(self, parent_pool=None):
      """Create a new proxy object for TYPE"""
      import libsvn.core, weakref
      self.__dict__["_parent_pool"] = \
        parent_pool or libsvn.core.application_pool;
      if self.__dict__["_parent_pool"]:
        self.__dict__["_is_valid"] = weakref.ref(
          self.__dict__["_parent_pool"]._is_valid)

    def assert_valid(self):
      """Assert that this object is using valid pool memory"""
      if "_is_valid" in self.__dict__:
        assert self.__dict__["_is_valid"](), "Variable has already been deleted"

    def _retrieve_swig_value(self, name, value):
    # If we got back a different object than we have cached, we need to copy
    # all our metadata into it, so that it looks identical to the one
    # originally set.
      members = self.__dict__.get('_members')
      if members is not None and name in members:
        _copy_metadata_deep(value, members[name])

    # Verify that the new object is good
      _assert_valid_deep(value)

      return value

    # Attribute access must be intercepted to ensure that objects coming from
    # read attribute access match those that are set with write attribute access.
    # Specifically the metadata, such as the associated apr_pool object, should
    # match the originally assigned object.
    #
    # For classic classes it is enough to use __getattr__ to intercept swig
    # derived attributes. However, with new style classes SWIG makes use of
    # descriptors which mean that __getattr__ is never called. Therefore,
    # __getattribute__ must be used for the interception.

    if _newclass:
      def __getattribute__(self, name):
        """Manage access to all attributes of this object."""

    # Start by mimicing __getattr__ behavior: immediately return __dict__ or
    # items directly present in __dict__
        mydict = object.__getattribute__(self, '__dict__')

        if name == "__dict__":
          return mydict

        if name in mydict:
          return mydict[name]

        object.__getattribute__(self, 'assert_valid')()

        value = _get_instance_attr(self, name)
        fn = object.__getattribute__(self, '_retrieve_swig_value')
        return fn(name, value)
    else:
      def __getattr__(self, name):
        """Get an attribute from this object"""
        self.assert_valid()

        value = _swig_getattr(self, self.__class__, name)

        return self._retrieve_swig_value(name, value)

    def __setattr__(self, name, value):
      """Set an attribute on this object"""
      self.assert_valid()

    # Save a copy of the object, so that the garbage
    # collector won't kill the object while it's in
    # SWIG-land
      self.__dict__.setdefault("_members",{})[name] = value

      return _set_instance_attr(self, name, value)


    def __call__(self, *args):
      return svn_auth_invoke_ssl_client_cert_pw_prompt_func(self, *args)

svn_auth_ssl_client_cert_pw_prompt_func_t_swigregister = _core.svn_auth_ssl_client_cert_pw_prompt_func_t_swigregister
svn_auth_ssl_client_cert_pw_prompt_func_t_swigregister(svn_auth_ssl_client_cert_pw_prompt_func_t)

class svn_auth_plaintext_prompt_func_t(object):
    """Proxy of C svn_auth_plaintext_prompt_func_t struct."""

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    def set_parent_pool(self, parent_pool=None):
      """Create a new proxy object for TYPE"""
      import libsvn.core, weakref
      self.__dict__["_parent_pool"] = \
        parent_pool or libsvn.core.application_pool;
      if self.__dict__["_parent_pool"]:
        self.__dict__["_is_valid"] = weakref.ref(
          self.__dict__["_parent_pool"]._is_valid)

    def assert_valid(self):
      """Assert that this object is using valid pool memory"""
      if "_is_valid" in self.__dict__:
        assert self.__dict__["_is_valid"](), "Variable has already been deleted"

    def _retrieve_swig_value(self, name, value):
    # If we got back a different object than we have cached, we need to copy
    # all our metadata into it, so that it looks identical to the one
    # originally set.
      members = self.__dict__.get('_members')
      if members is not None and name in members:
        _copy_metadata_deep(value, members[name])

    # Verify that the new object is good
      _assert_valid_deep(value)

      return value

    # Attribute access must be intercepted to ensure that objects coming from
    # read attribute access match those that are set with write attribute access.
    # Specifically the metadata, such as the associated apr_pool object, should
    # match the originally assigned object.
    #
    # For classic classes it is enough to use __getattr__ to intercept swig
    # derived attributes. However, with new style classes SWIG makes use of
    # descriptors which mean that __getattr__ is never called. Therefore,
    # __getattribute__ must be used for the interception.

    if _newclass:
      def __getattribute__(self, name):
        """Manage access to all attributes of this object."""

    # Start by mimicing __getattr__ behavior: immediately return __dict__ or
    # items directly present in __dict__
        mydict = object.__getattribute__(self, '__dict__')

        if name == "__dict__":
          return mydict

        if name in mydict:
          return mydict[name]

        object.__getattribute__(self, 'assert_valid')()

        value = _get_instance_attr(self, name)
        fn = object.__getattribute__(self, '_retrieve_swig_value')
        return fn(name, value)
    else:
      def __getattr__(self, name):
        """Get an attribute from this object"""
        self.assert_valid()

        value = _swig_getattr(self, self.__class__, name)

        return self._retrieve_swig_value(name, value)

    def __setattr__(self, name, value):
      """Set an attribute on this object"""
      self.assert_valid()

    # Save a copy of the object, so that the garbage
    # collector won't kill the object while it's in
    # SWIG-land
      self.__dict__.setdefault("_members",{})[name] = value

      return _set_instance_attr(self, name, value)


    def __call__(self, *args):
      return svn_auth_invoke_plaintext_prompt_func(self, *args)

svn_auth_plaintext_prompt_func_t_swigregister = _core.svn_auth_plaintext_prompt_func_t_swigregister
svn_auth_plaintext_prompt_func_t_swigregister(svn_auth_plaintext_prompt_func_t)

class svn_auth_plaintext_passphrase_prompt_func_t(object):
    """Proxy of C svn_auth_plaintext_passphrase_prompt_func_t struct."""

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    def set_parent_pool(self, parent_pool=None):
      """Create a new proxy object for TYPE"""
      import libsvn.core, weakref
      self.__dict__["_parent_pool"] = \
        parent_pool or libsvn.core.application_pool;
      if self.__dict__["_parent_pool"]:
        self.__dict__["_is_valid"] = weakref.ref(
          self.__dict__["_parent_pool"]._is_valid)

    def assert_valid(self):
      """Assert that this object is using valid pool memory"""
      if "_is_valid" in self.__dict__:
        assert self.__dict__["_is_valid"](), "Variable has already been deleted"

    def _retrieve_swig_value(self, name, value):
    # If we got back a different object than we have cached, we need to copy
    # all our metadata into it, so that it looks identical to the one
    # originally set.
      members = self.__dict__.get('_members')
      if members is not None and name in members:
        _copy_metadata_deep(value, members[name])

    # Verify that the new object is good
      _assert_valid_deep(value)

      return value

    # Attribute access must be intercepted to ensure that objects coming from
    # read attribute access match those that are set with write attribute access.
    # Specifically the metadata, such as the associated apr_pool object, should
    # match the originally assigned object.
    #
    # For classic classes it is enough to use __getattr__ to intercept swig
    # derived attributes. However, with new style classes SWIG makes use of
    # descriptors which mean that __getattr__ is never called. Therefore,
    # __getattribute__ must be used for the interception.

    if _newclass:
      def __getattribute__(self, name):
        """Manage access to all attributes of this object."""

    # Start by mimicing __getattr__ behavior: immediately return __dict__ or
    # items directly present in __dict__
        mydict = object.__getattribute__(self, '__dict__')

        if name == "__dict__":
          return mydict

        if name in mydict:
          return mydict[name]

        object.__getattribute__(self, 'assert_valid')()

        value = _get_instance_attr(self, name)
        fn = object.__getattribute__(self, '_retrieve_swig_value')
        return fn(name, value)
    else:
      def __getattr__(self, name):
        """Get an attribute from this object"""
        self.assert_valid()

        value = _swig_getattr(self, self.__class__, name)

        return self._retrieve_swig_value(name, value)

    def __setattr__(self, name, value):
      """Set an attribute on this object"""
      self.assert_valid()

    # Save a copy of the object, so that the garbage
    # collector won't kill the object while it's in
    # SWIG-land
      self.__dict__.setdefault("_members",{})[name] = value

      return _set_instance_attr(self, name, value)


    def __call__(self, *args):
      return svn_auth_invoke_plaintext_passphrase_prompt_func(self, *args)

svn_auth_plaintext_passphrase_prompt_func_t_swigregister = _core.svn_auth_plaintext_passphrase_prompt_func_t_swigregister
svn_auth_plaintext_passphrase_prompt_func_t_swigregister(svn_auth_plaintext_passphrase_prompt_func_t)

class svn_auth_gnome_keyring_unlock_prompt_func_t(object):
    """Proxy of C svn_auth_gnome_keyring_unlock_prompt_func_t struct."""

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    def set_parent_pool(self, parent_pool=None):
      """Create a new proxy object for TYPE"""
      import libsvn.core, weakref
      self.__dict__["_parent_pool"] = \
        parent_pool or libsvn.core.application_pool;
      if self.__dict__["_parent_pool"]:
        self.__dict__["_is_valid"] = weakref.ref(
          self.__dict__["_parent_pool"]._is_valid)

    def assert_valid(self):
      """Assert that this object is using valid pool memory"""
      if "_is_valid" in self.__dict__:
        assert self.__dict__["_is_valid"](), "Variable has already been deleted"

    def _retrieve_swig_value(self, name, value):
    # If we got back a different object than we have cached, we need to copy
    # all our metadata into it, so that it looks identical to the one
    # originally set.
      members = self.__dict__.get('_members')
      if members is not None and name in members:
        _copy_metadata_deep(value, members[name])

    # Verify that the new object is good
      _assert_valid_deep(value)

      return value

    # Attribute access must be intercepted to ensure that objects coming from
    # read attribute access match those that are set with write attribute access.
    # Specifically the metadata, such as the associated apr_pool object, should
    # match the originally assigned object.
    #
    # For classic classes it is enough to use __getattr__ to intercept swig
    # derived attributes. However, with new style classes SWIG makes use of
    # descriptors which mean that __getattr__ is never called. Therefore,
    # __getattribute__ must be used for the interception.

    if _newclass:
      def __getattribute__(self, name):
        """Manage access to all attributes of this object."""

    # Start by mimicing __getattr__ behavior: immediately return __dict__ or
    # items directly present in __dict__
        mydict = object.__getattribute__(self, '__dict__')

        if name == "__dict__":
          return mydict

        if name in mydict:
          return mydict[name]

        object.__getattribute__(self, 'assert_valid')()

        value = _get_instance_attr(self, name)
        fn = object.__getattribute__(self, '_retrieve_swig_value')
        return fn(name, value)
    else:
      def __getattr__(self, name):
        """Get an attribute from this object"""
        self.assert_valid()

        value = _swig_getattr(self, self.__class__, name)

        return self._retrieve_swig_value(name, value)

    def __setattr__(self, name, value):
      """Set an attribute on this object"""
      self.assert_valid()

    # Save a copy of the object, so that the garbage
    # collector won't kill the object while it's in
    # SWIG-land
      self.__dict__.setdefault("_members",{})[name] = value

      return _set_instance_attr(self, name, value)


    def __call__(self, *args):
      return svn_auth_invoke_gnome_keyring_unlock_prompt_func(self, *args)

svn_auth_gnome_keyring_unlock_prompt_func_t_swigregister = _core.svn_auth_gnome_keyring_unlock_prompt_func_t_swigregister
svn_auth_gnome_keyring_unlock_prompt_func_t_swigregister(svn_auth_gnome_keyring_unlock_prompt_func_t)

SVN_CONFIG_CATEGORY_SERVERS = _core.SVN_CONFIG_CATEGORY_SERVERS
SVN_CONFIG_SECTION_GROUPS = _core.SVN_CONFIG_SECTION_GROUPS
SVN_CONFIG_SECTION_GLOBAL = _core.SVN_CONFIG_SECTION_GLOBAL
SVN_CONFIG_OPTION_HTTP_PROXY_HOST = _core.SVN_CONFIG_OPTION_HTTP_PROXY_HOST
SVN_CONFIG_OPTION_HTTP_PROXY_PORT = _core.SVN_CONFIG_OPTION_HTTP_PROXY_PORT
SVN_CONFIG_OPTION_HTTP_PROXY_USERNAME = _core.SVN_CONFIG_OPTION_HTTP_PROXY_USERNAME
SVN_CONFIG_OPTION_HTTP_PROXY_PASSWORD = _core.SVN_CONFIG_OPTION_HTTP_PROXY_PASSWORD
SVN_CONFIG_OPTION_HTTP_PROXY_EXCEPTIONS = _core.SVN_CONFIG_OPTION_HTTP_PROXY_EXCEPTIONS
SVN_CONFIG_OPTION_HTTP_TIMEOUT = _core.SVN_CONFIG_OPTION_HTTP_TIMEOUT
SVN_CONFIG_OPTION_HTTP_COMPRESSION = _core.SVN_CONFIG_OPTION_HTTP_COMPRESSION
SVN_CONFIG_OPTION_NEON_DEBUG_MASK = _core.SVN_CONFIG_OPTION_NEON_DEBUG_MASK
SVN_CONFIG_OPTION_HTTP_AUTH_TYPES = _core.SVN_CONFIG_OPTION_HTTP_AUTH_TYPES
SVN_CONFIG_OPTION_SSL_AUTHORITY_FILES = _core.SVN_CONFIG_OPTION_SSL_AUTHORITY_FILES
SVN_CONFIG_OPTION_SSL_TRUST_DEFAULT_CA = _core.SVN_CONFIG_OPTION_SSL_TRUST_DEFAULT_CA
SVN_CONFIG_OPTION_SSL_CLIENT_CERT_FILE = _core.SVN_CONFIG_OPTION_SSL_CLIENT_CERT_FILE
SVN_CONFIG_OPTION_SSL_CLIENT_CERT_PASSWORD = _core.SVN_CONFIG_OPTION_SSL_CLIENT_CERT_PASSWORD
SVN_CONFIG_OPTION_SSL_PKCS11_PROVIDER = _core.SVN_CONFIG_OPTION_SSL_PKCS11_PROVIDER
SVN_CONFIG_OPTION_HTTP_LIBRARY = _core.SVN_CONFIG_OPTION_HTTP_LIBRARY
SVN_CONFIG_OPTION_STORE_PASSWORDS = _core.SVN_CONFIG_OPTION_STORE_PASSWORDS
SVN_CONFIG_OPTION_STORE_PLAINTEXT_PASSWORDS = _core.SVN_CONFIG_OPTION_STORE_PLAINTEXT_PASSWORDS
SVN_CONFIG_OPTION_STORE_AUTH_CREDS = _core.SVN_CONFIG_OPTION_STORE_AUTH_CREDS
SVN_CONFIG_OPTION_STORE_SSL_CLIENT_CERT_PP = _core.SVN_CONFIG_OPTION_STORE_SSL_CLIENT_CERT_PP
SVN_CONFIG_OPTION_STORE_SSL_CLIENT_CERT_PP_PLAINTEXT = _core.SVN_CONFIG_OPTION_STORE_SSL_CLIENT_CERT_PP_PLAINTEXT
SVN_CONFIG_OPTION_USERNAME = _core.SVN_CONFIG_OPTION_USERNAME
SVN_CONFIG_OPTION_HTTP_BULK_UPDATES = _core.SVN_CONFIG_OPTION_HTTP_BULK_UPDATES
SVN_CONFIG_OPTION_HTTP_MAX_CONNECTIONS = _core.SVN_CONFIG_OPTION_HTTP_MAX_CONNECTIONS
SVN_CONFIG_OPTION_HTTP_CHUNKED_REQUESTS = _core.SVN_CONFIG_OPTION_HTTP_CHUNKED_REQUESTS
SVN_CONFIG_OPTION_SERF_LOG_COMPONENTS = _core.SVN_CONFIG_OPTION_SERF_LOG_COMPONENTS
SVN_CONFIG_OPTION_SERF_LOG_LEVEL = _core.SVN_CONFIG_OPTION_SERF_LOG_LEVEL
SVN_CONFIG_CATEGORY_CONFIG = _core.SVN_CONFIG_CATEGORY_CONFIG
SVN_CONFIG_SECTION_AUTH = _core.SVN_CONFIG_SECTION_AUTH
SVN_CONFIG_OPTION_PASSWORD_STORES = _core.SVN_CONFIG_OPTION_PASSWORD_STORES
SVN_CONFIG_OPTION_KWALLET_WALLET = _core.SVN_CONFIG_OPTION_KWALLET_WALLET
SVN_CONFIG_OPTION_KWALLET_SVN_APPLICATION_NAME_WITH_PID = _core.SVN_CONFIG_OPTION_KWALLET_SVN_APPLICATION_NAME_WITH_PID
SVN_CONFIG_OPTION_SSL_CLIENT_CERT_FILE_PROMPT = _core.SVN_CONFIG_OPTION_SSL_CLIENT_CERT_FILE_PROMPT
SVN_CONFIG_SECTION_HELPERS = _core.SVN_CONFIG_SECTION_HELPERS
SVN_CONFIG_OPTION_EDITOR_CMD = _core.SVN_CONFIG_OPTION_EDITOR_CMD
SVN_CONFIG_OPTION_DIFF_CMD = _core.SVN_CONFIG_OPTION_DIFF_CMD
SVN_CONFIG_OPTION_DIFF_EXTENSIONS = _core.SVN_CONFIG_OPTION_DIFF_EXTENSIONS
SVN_CONFIG_OPTION_DIFF3_CMD = _core.SVN_CONFIG_OPTION_DIFF3_CMD
SVN_CONFIG_OPTION_DIFF3_HAS_PROGRAM_ARG = _core.SVN_CONFIG_OPTION_DIFF3_HAS_PROGRAM_ARG
SVN_CONFIG_OPTION_MERGE_TOOL_CMD = _core.SVN_CONFIG_OPTION_MERGE_TOOL_CMD
SVN_CONFIG_SECTION_MISCELLANY = _core.SVN_CONFIG_SECTION_MISCELLANY
SVN_CONFIG_OPTION_GLOBAL_IGNORES = _core.SVN_CONFIG_OPTION_GLOBAL_IGNORES
SVN_CONFIG_OPTION_LOG_ENCODING = _core.SVN_CONFIG_OPTION_LOG_ENCODING
SVN_CONFIG_OPTION_USE_COMMIT_TIMES = _core.SVN_CONFIG_OPTION_USE_COMMIT_TIMES
SVN_CONFIG_OPTION_TEMPLATE_ROOT = _core.SVN_CONFIG_OPTION_TEMPLATE_ROOT
SVN_CONFIG_OPTION_ENABLE_AUTO_PROPS = _core.SVN_CONFIG_OPTION_ENABLE_AUTO_PROPS
SVN_CONFIG_OPTION_ENABLE_MAGIC_FILE = _core.SVN_CONFIG_OPTION_ENABLE_MAGIC_FILE
SVN_CONFIG_OPTION_NO_UNLOCK = _core.SVN_CONFIG_OPTION_NO_UNLOCK
SVN_CONFIG_OPTION_MIMETYPES_FILE = _core.SVN_CONFIG_OPTION_MIMETYPES_FILE
SVN_CONFIG_OPTION_PRESERVED_CF_EXTS = _core.SVN_CONFIG_OPTION_PRESERVED_CF_EXTS
SVN_CONFIG_OPTION_INTERACTIVE_CONFLICTS = _core.SVN_CONFIG_OPTION_INTERACTIVE_CONFLICTS
SVN_CONFIG_OPTION_MEMORY_CACHE_SIZE = _core.SVN_CONFIG_OPTION_MEMORY_CACHE_SIZE
SVN_CONFIG_OPTION_DIFF_IGNORE_CONTENT_TYPE = _core.SVN_CONFIG_OPTION_DIFF_IGNORE_CONTENT_TYPE
SVN_CONFIG_SECTION_TUNNELS = _core.SVN_CONFIG_SECTION_TUNNELS
SVN_CONFIG_SECTION_AUTO_PROPS = _core.SVN_CONFIG_SECTION_AUTO_PROPS
SVN_CONFIG_SECTION_WORKING_COPY = _core.SVN_CONFIG_SECTION_WORKING_COPY
SVN_CONFIG_OPTION_SQLITE_EXCLUSIVE = _core.SVN_CONFIG_OPTION_SQLITE_EXCLUSIVE
SVN_CONFIG_OPTION_SQLITE_EXCLUSIVE_CLIENTS = _core.SVN_CONFIG_OPTION_SQLITE_EXCLUSIVE_CLIENTS
SVN_CONFIG_OPTION_SQLITE_BUSY_TIMEOUT = _core.SVN_CONFIG_OPTION_SQLITE_BUSY_TIMEOUT
SVN_CONFIG_SECTION_GENERAL = _core.SVN_CONFIG_SECTION_GENERAL
SVN_CONFIG_OPTION_ANON_ACCESS = _core.SVN_CONFIG_OPTION_ANON_ACCESS
SVN_CONFIG_OPTION_AUTH_ACCESS = _core.SVN_CONFIG_OPTION_AUTH_ACCESS
SVN_CONFIG_OPTION_PASSWORD_DB = _core.SVN_CONFIG_OPTION_PASSWORD_DB
SVN_CONFIG_OPTION_REALM = _core.SVN_CONFIG_OPTION_REALM
SVN_CONFIG_OPTION_AUTHZ_DB = _core.SVN_CONFIG_OPTION_AUTHZ_DB
SVN_CONFIG_OPTION_GROUPS_DB = _core.SVN_CONFIG_OPTION_GROUPS_DB
SVN_CONFIG_OPTION_FORCE_USERNAME_CASE = _core.SVN_CONFIG_OPTION_FORCE_USERNAME_CASE
SVN_CONFIG_OPTION_HOOKS_ENV = _core.SVN_CONFIG_OPTION_HOOKS_ENV
SVN_CONFIG_SECTION_SASL = _core.SVN_CONFIG_SECTION_SASL
SVN_CONFIG_OPTION_USE_SASL = _core.SVN_CONFIG_OPTION_USE_SASL
SVN_CONFIG_OPTION_MIN_SSF = _core.SVN_CONFIG_OPTION_MIN_SSF
SVN_CONFIG_OPTION_MAX_SSF = _core.SVN_CONFIG_OPTION_MAX_SSF
SVN_CONFIG_SECTION_USERS = _core.SVN_CONFIG_SECTION_USERS
SVN_CONFIG__DEFAULT_GLOBAL_IGNORES_LINE_1 = _core.SVN_CONFIG__DEFAULT_GLOBAL_IGNORES_LINE_1
SVN_CONFIG__DEFAULT_GLOBAL_IGNORES_LINE_2 = _core.SVN_CONFIG__DEFAULT_GLOBAL_IGNORES_LINE_2
SVN_CONFIG_DEFAULT_GLOBAL_IGNORES = _core.SVN_CONFIG_DEFAULT_GLOBAL_IGNORES
SVN_CONFIG_TRUE = _core.SVN_CONFIG_TRUE
SVN_CONFIG_FALSE = _core.SVN_CONFIG_FALSE
SVN_CONFIG_ASK = _core.SVN_CONFIG_ASK
SVN_CONFIG_DEFAULT_OPTION_STORE_PASSWORDS = _core.SVN_CONFIG_DEFAULT_OPTION_STORE_PASSWORDS
SVN_CONFIG_DEFAULT_OPTION_STORE_PLAINTEXT_PASSWORDS = _core.SVN_CONFIG_DEFAULT_OPTION_STORE_PLAINTEXT_PASSWORDS
SVN_CONFIG_DEFAULT_OPTION_STORE_AUTH_CREDS = _core.SVN_CONFIG_DEFAULT_OPTION_STORE_AUTH_CREDS
SVN_CONFIG_DEFAULT_OPTION_STORE_SSL_CLIENT_CERT_PP = _core.SVN_CONFIG_DEFAULT_OPTION_STORE_SSL_CLIENT_CERT_PP
SVN_CONFIG_DEFAULT_OPTION_STORE_SSL_CLIENT_CERT_PP_PLAINTEXT = _core.SVN_CONFIG_DEFAULT_OPTION_STORE_SSL_CLIENT_CERT_PP_PLAINTEXT
SVN_CONFIG_DEFAULT_OPTION_HTTP_MAX_CONNECTIONS = _core.SVN_CONFIG_DEFAULT_OPTION_HTTP_MAX_CONNECTIONS

def svn_config_get_config(*args) -> "apr_hash_t **":
    """svn_config_get_config(char const * config_dir, apr_pool_t pool) -> svn_error_t"""
    return _core.svn_config_get_config(*args)

def svn_config_create2(*args) -> "svn_config_t **":
    """svn_config_create2(svn_boolean_t section_names_case_sensitive, svn_boolean_t option_names_case_sensitive, apr_pool_t result_pool) -> svn_error_t"""
    return _core.svn_config_create2(*args)

def svn_config_create(*args) -> "svn_config_t **":
    """svn_config_create(svn_boolean_t section_names_case_sensitive, apr_pool_t result_pool) -> svn_error_t"""
    return _core.svn_config_create(*args)

def svn_config_read3(*args) -> "svn_config_t **":
    """svn_config_read3(char const * file, svn_boolean_t must_exist, svn_boolean_t section_names_case_sensitive, svn_boolean_t option_names_case_sensitive, apr_pool_t result_pool) -> svn_error_t"""
    return _core.svn_config_read3(*args)

def svn_config_read2(*args) -> "svn_config_t **":
    """svn_config_read2(char const * file, svn_boolean_t must_exist, svn_boolean_t section_names_case_sensitive, apr_pool_t result_pool) -> svn_error_t"""
    return _core.svn_config_read2(*args)

def svn_config_read(*args) -> "svn_config_t **":
    """svn_config_read(char const * file, svn_boolean_t must_exist, apr_pool_t result_pool) -> svn_error_t"""
    return _core.svn_config_read(*args)

def svn_config_parse(*args) -> "svn_config_t **":
    """svn_config_parse(svn_stream_t * stream, svn_boolean_t section_names_case_sensitive, svn_boolean_t option_names_case_sensitive, apr_pool_t result_pool) -> svn_error_t"""
    return _core.svn_config_parse(*args)

def svn_config_merge(cfg: 'svn_config_t *', file: 'char const *', must_exist: 'svn_boolean_t') -> "svn_error_t *":
    """svn_config_merge(svn_config_t * cfg, char const * file, svn_boolean_t must_exist) -> svn_error_t"""
    return _core.svn_config_merge(cfg, file, must_exist)

def svn_config_get(cfg: 'svn_config_t *', section: 'char const *', option: 'char const *', default_value: 'char const *') -> "char const **":
    """svn_config_get(svn_config_t * cfg, char const * section, char const * option, char const * default_value)"""
    return _core.svn_config_get(cfg, section, option, default_value)

def svn_config_set(cfg: 'svn_config_t *', section: 'char const *', option: 'char const *', value: 'char const *') -> "void":
    """svn_config_set(svn_config_t * cfg, char const * section, char const * option, char const * value)"""
    return _core.svn_config_set(cfg, section, option, value)

def svn_config_get_bool(cfg: 'svn_config_t *', section: 'char const *', option: 'char const *', default_value: 'svn_boolean_t') -> "svn_boolean_t *":
    """svn_config_get_bool(svn_config_t * cfg, char const * section, char const * option, svn_boolean_t default_value) -> svn_error_t"""
    return _core.svn_config_get_bool(cfg, section, option, default_value)

def svn_config_set_bool(cfg: 'svn_config_t *', section: 'char const *', option: 'char const *', value: 'svn_boolean_t') -> "void":
    """svn_config_set_bool(svn_config_t * cfg, char const * section, char const * option, svn_boolean_t value)"""
    return _core.svn_config_set_bool(cfg, section, option, value)

def svn_config_get_int64(cfg: 'svn_config_t *', section: 'char const *', option: 'char const *', default_value: 'apr_int64_t') -> "apr_int64_t *":
    """svn_config_get_int64(svn_config_t * cfg, char const * section, char const * option, apr_int64_t default_value) -> svn_error_t"""
    return _core.svn_config_get_int64(cfg, section, option, default_value)

def svn_config_set_int64(cfg: 'svn_config_t *', section: 'char const *', option: 'char const *', value: 'apr_int64_t') -> "void":
    """svn_config_set_int64(svn_config_t * cfg, char const * section, char const * option, apr_int64_t value)"""
    return _core.svn_config_set_int64(cfg, section, option, value)

def svn_config_get_yes_no_ask(cfg: 'svn_config_t *', section: 'char const *', option: 'char const *', default_value: 'char const *') -> "char const **":
    """svn_config_get_yes_no_ask(svn_config_t * cfg, char const * section, char const * option, char const * default_value) -> svn_error_t"""
    return _core.svn_config_get_yes_no_ask(cfg, section, option, default_value)

def svn_config_get_tristate(cfg: 'svn_config_t *', valuep: 'svn_tristate_t *', section: 'char const *', option: 'char const *', unknown_value: 'char const *', default_value: 'svn_tristate_t') -> "svn_error_t *":
    """svn_config_get_tristate(svn_config_t * cfg, svn_tristate_t * valuep, char const * section, char const * option, char const * unknown_value, svn_tristate_t default_value) -> svn_error_t"""
    return _core.svn_config_get_tristate(cfg, valuep, section, option, unknown_value, default_value)

def svn_config_enumerate_sections(cfg: 'svn_config_t *', callback: 'svn_config_section_enumerator_t', baton: 'void *') -> "int":
    """svn_config_enumerate_sections(svn_config_t * cfg, svn_config_section_enumerator_t callback, void * baton) -> int"""
    return _core.svn_config_enumerate_sections(cfg, callback, baton)

def svn_config_enumerate_sections2(*args) -> "int":
    """svn_config_enumerate_sections2(svn_config_t * cfg, svn_config_section_enumerator2_t callback, apr_pool_t pool) -> int"""
    return _core.svn_config_enumerate_sections2(*args)

def svn_config_enumerate(cfg: 'svn_config_t *', section: 'char const *', callback: 'svn_config_enumerator_t', baton: 'void *') -> "int":
    """svn_config_enumerate(svn_config_t * cfg, char const * section, svn_config_enumerator_t callback, void * baton) -> int"""
    return _core.svn_config_enumerate(cfg, section, callback, baton)

def svn_config_enumerate2(*args) -> "int":
    """svn_config_enumerate2(svn_config_t * cfg, char const * section, svn_config_enumerator2_t callback, apr_pool_t pool) -> int"""
    return _core.svn_config_enumerate2(*args)

def svn_config_has_section(cfg: 'svn_config_t *', section: 'char const *') -> "svn_boolean_t":
    """svn_config_has_section(svn_config_t * cfg, char const * section) -> svn_boolean_t"""
    return _core.svn_config_has_section(cfg, section)

def svn_config_find_group(*args) -> "char const *":
    """svn_config_find_group(svn_config_t * cfg, char const * key, char const * master_section, apr_pool_t pool) -> char const *"""
    return _core.svn_config_find_group(*args)

def svn_config_get_server_setting(cfg: 'svn_config_t *', server_group: 'char const *', option_name: 'char const *', default_value: 'char const *') -> "char const *":
    """svn_config_get_server_setting(svn_config_t * cfg, char const * server_group, char const * option_name, char const * default_value) -> char const *"""
    return _core.svn_config_get_server_setting(cfg, server_group, option_name, default_value)

def svn_config_get_server_setting_int(*args) -> "apr_int64_t *":
    """svn_config_get_server_setting_int(svn_config_t * cfg, char const * server_group, char const * option_name, apr_int64_t default_value, apr_pool_t pool) -> svn_error_t"""
    return _core.svn_config_get_server_setting_int(*args)

def svn_config_get_server_setting_bool(cfg: 'svn_config_t *', server_group: 'char const *', option_name: 'char const *', default_value: 'svn_boolean_t') -> "svn_boolean_t *":
    """svn_config_get_server_setting_bool(svn_config_t * cfg, char const * server_group, char const * option_name, svn_boolean_t default_value) -> svn_error_t"""
    return _core.svn_config_get_server_setting_bool(cfg, server_group, option_name, default_value)

def svn_config_ensure(*args) -> "svn_error_t *":
    """svn_config_ensure(char const * config_dir, apr_pool_t pool) -> svn_error_t"""
    return _core.svn_config_ensure(*args)
SVN_CONFIG_REALMSTRING_KEY = _core.SVN_CONFIG_REALMSTRING_KEY
SVN_CONFIG_AUTHN_USERNAME_KEY = _core.SVN_CONFIG_AUTHN_USERNAME_KEY
SVN_CONFIG_AUTHN_PASSWORD_KEY = _core.SVN_CONFIG_AUTHN_PASSWORD_KEY
SVN_CONFIG_AUTHN_PASSPHRASE_KEY = _core.SVN_CONFIG_AUTHN_PASSPHRASE_KEY
SVN_CONFIG_AUTHN_PASSTYPE_KEY = _core.SVN_CONFIG_AUTHN_PASSTYPE_KEY
SVN_CONFIG_AUTHN_ASCII_CERT_KEY = _core.SVN_CONFIG_AUTHN_ASCII_CERT_KEY
SVN_CONFIG_AUTHN_FAILURES_KEY = _core.SVN_CONFIG_AUTHN_FAILURES_KEY

def svn_config_read_auth_data(*args) -> "apr_hash_t **":
    """svn_config_read_auth_data(char const * cred_kind, char const * realmstring, char const * config_dir, apr_pool_t pool) -> svn_error_t"""
    return _core.svn_config_read_auth_data(*args)

def svn_config_write_auth_data(*args) -> "svn_error_t *":
    """svn_config_write_auth_data(apr_hash_t hash, char const * cred_kind, char const * realmstring, char const * config_dir, apr_pool_t pool) -> svn_error_t"""
    return _core.svn_config_write_auth_data(*args)

def svn_config_walk_auth_data(*args) -> "svn_error_t *":
    """svn_config_walk_auth_data(char const * config_dir, svn_config_auth_walk_func_t walk_func, apr_pool_t scratch_pool) -> svn_error_t"""
    return _core.svn_config_walk_auth_data(*args)

def svn_config_get_user_config_path(*args) -> "char const **":
    """svn_config_get_user_config_path(char const * config_dir, char const * fname, apr_pool_t pool) -> svn_error_t"""
    return _core.svn_config_get_user_config_path(*args)

def svn_config_dup(*args) -> "svn_config_t **":
    """svn_config_dup(svn_config_t const * src, apr_pool_t pool) -> svn_error_t"""
    return _core.svn_config_dup(*args)

def svn_config_copy_config(*args) -> "apr_hash_t **":
    """svn_config_copy_config(apr_hash_t src_hash, apr_pool_t pool) -> svn_error_t"""
    return _core.svn_config_copy_config(*args)
class svn_config_t(object):
    """Proxy of C svn_config_t struct."""

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    def set_parent_pool(self, parent_pool=None):
      """Create a new proxy object for TYPE"""
      import libsvn.core, weakref
      self.__dict__["_parent_pool"] = \
        parent_pool or libsvn.core.application_pool;
      if self.__dict__["_parent_pool"]:
        self.__dict__["_is_valid"] = weakref.ref(
          self.__dict__["_parent_pool"]._is_valid)

    def assert_valid(self):
      """Assert that this object is using valid pool memory"""
      if "_is_valid" in self.__dict__:
        assert self.__dict__["_is_valid"](), "Variable has already been deleted"

    def _retrieve_swig_value(self, name, value):
    # If we got back a different object than we have cached, we need to copy
    # all our metadata into it, so that it looks identical to the one
    # originally set.
      members = self.__dict__.get('_members')
      if members is not None and name in members:
        _copy_metadata_deep(value, members[name])

    # Verify that the new object is good
      _assert_valid_deep(value)

      return value

    # Attribute access must be intercepted to ensure that objects coming from
    # read attribute access match those that are set with write attribute access.
    # Specifically the metadata, such as the associated apr_pool object, should
    # match the originally assigned object.
    #
    # For classic classes it is enough to use __getattr__ to intercept swig
    # derived attributes. However, with new style classes SWIG makes use of
    # descriptors which mean that __getattr__ is never called. Therefore,
    # __getattribute__ must be used for the interception.

    if _newclass:
      def __getattribute__(self, name):
        """Manage access to all attributes of this object."""

    # Start by mimicing __getattr__ behavior: immediately return __dict__ or
    # items directly present in __dict__
        mydict = object.__getattribute__(self, '__dict__')

        if name == "__dict__":
          return mydict

        if name in mydict:
          return mydict[name]

        object.__getattribute__(self, 'assert_valid')()

        value = _get_instance_attr(self, name)
        fn = object.__getattribute__(self, '_retrieve_swig_value')
        return fn(name, value)
    else:
      def __getattr__(self, name):
        """Get an attribute from this object"""
        self.assert_valid()

        value = _swig_getattr(self, self.__class__, name)

        return self._retrieve_swig_value(name, value)

    def __setattr__(self, name, value):
      """Set an attribute on this object"""
      self.assert_valid()

    # Save a copy of the object, so that the garbage
    # collector won't kill the object while it's in
    # SWIG-land
      self.__dict__.setdefault("_members",{})[name] = value

      return _set_instance_attr(self, name, value)

svn_config_t_swigregister = _core.svn_config_t_swigregister
svn_config_t_swigregister(svn_config_t)


def svn_config_invoke_section_enumerator(_obj: 'svn_config_section_enumerator_t', name: 'char const *', baton: 'void *') -> "svn_boolean_t":
    """svn_config_invoke_section_enumerator(svn_config_section_enumerator_t _obj, char const * name, void * baton) -> svn_boolean_t"""
    return _core.svn_config_invoke_section_enumerator(_obj, name, baton)

def svn_config_invoke_section_enumerator2(*args) -> "svn_boolean_t":
    """svn_config_invoke_section_enumerator2(svn_config_section_enumerator2_t _obj, char const * name, void * baton, apr_pool_t pool) -> svn_boolean_t"""
    return _core.svn_config_invoke_section_enumerator2(*args)

def svn_config_invoke_enumerator(_obj: 'svn_config_enumerator_t', name: 'char const *', value: 'char const *', baton: 'void *') -> "svn_boolean_t":
    """svn_config_invoke_enumerator(svn_config_enumerator_t _obj, char const * name, char const * value, void * baton) -> svn_boolean_t"""
    return _core.svn_config_invoke_enumerator(_obj, name, value, baton)

def svn_config_invoke_enumerator2(*args) -> "svn_boolean_t":
    """svn_config_invoke_enumerator2(svn_config_enumerator2_t _obj, char const * name, char const * value, void * baton, apr_pool_t pool) -> svn_boolean_t"""
    return _core.svn_config_invoke_enumerator2(*args)

def svn_config_invoke_auth_walk_func(*args) -> "svn_boolean_t *":
    """svn_config_invoke_auth_walk_func(svn_config_auth_walk_func_t _obj, void * walk_baton, char const * cred_kind, char const * realmstring, apr_hash_t hash, apr_pool_t scratch_pool) -> svn_error_t"""
    return _core.svn_config_invoke_auth_walk_func(*args)
class svn_config_section_enumerator_t(object):
    """Proxy of C svn_config_section_enumerator_t struct."""

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    def set_parent_pool(self, parent_pool=None):
      """Create a new proxy object for TYPE"""
      import libsvn.core, weakref
      self.__dict__["_parent_pool"] = \
        parent_pool or libsvn.core.application_pool;
      if self.__dict__["_parent_pool"]:
        self.__dict__["_is_valid"] = weakref.ref(
          self.__dict__["_parent_pool"]._is_valid)

    def assert_valid(self):
      """Assert that this object is using valid pool memory"""
      if "_is_valid" in self.__dict__:
        assert self.__dict__["_is_valid"](), "Variable has already been deleted"

    def _retrieve_swig_value(self, name, value):
    # If we got back a different object than we have cached, we need to copy
    # all our metadata into it, so that it looks identical to the one
    # originally set.
      members = self.__dict__.get('_members')
      if members is not None and name in members:
        _copy_metadata_deep(value, members[name])

    # Verify that the new object is good
      _assert_valid_deep(value)

      return value

    # Attribute access must be intercepted to ensure that objects coming from
    # read attribute access match those that are set with write attribute access.
    # Specifically the metadata, such as the associated apr_pool object, should
    # match the originally assigned object.
    #
    # For classic classes it is enough to use __getattr__ to intercept swig
    # derived attributes. However, with new style classes SWIG makes use of
    # descriptors which mean that __getattr__ is never called. Therefore,
    # __getattribute__ must be used for the interception.

    if _newclass:
      def __getattribute__(self, name):
        """Manage access to all attributes of this object."""

    # Start by mimicing __getattr__ behavior: immediately return __dict__ or
    # items directly present in __dict__
        mydict = object.__getattribute__(self, '__dict__')

        if name == "__dict__":
          return mydict

        if name in mydict:
          return mydict[name]

        object.__getattribute__(self, 'assert_valid')()

        value = _get_instance_attr(self, name)
        fn = object.__getattribute__(self, '_retrieve_swig_value')
        return fn(name, value)
    else:
      def __getattr__(self, name):
        """Get an attribute from this object"""
        self.assert_valid()

        value = _swig_getattr(self, self.__class__, name)

        return self._retrieve_swig_value(name, value)

    def __setattr__(self, name, value):
      """Set an attribute on this object"""
      self.assert_valid()

    # Save a copy of the object, so that the garbage
    # collector won't kill the object while it's in
    # SWIG-land
      self.__dict__.setdefault("_members",{})[name] = value

      return _set_instance_attr(self, name, value)


    def __call__(self, *args):
      return svn_config_invoke_section_enumerator(self, *args)

svn_config_section_enumerator_t_swigregister = _core.svn_config_section_enumerator_t_swigregister
svn_config_section_enumerator_t_swigregister(svn_config_section_enumerator_t)

class svn_config_section_enumerator2_t(object):
    """Proxy of C svn_config_section_enumerator2_t struct."""

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    def set_parent_pool(self, parent_pool=None):
      """Create a new proxy object for TYPE"""
      import libsvn.core, weakref
      self.__dict__["_parent_pool"] = \
        parent_pool or libsvn.core.application_pool;
      if self.__dict__["_parent_pool"]:
        self.__dict__["_is_valid"] = weakref.ref(
          self.__dict__["_parent_pool"]._is_valid)

    def assert_valid(self):
      """Assert that this object is using valid pool memory"""
      if "_is_valid" in self.__dict__:
        assert self.__dict__["_is_valid"](), "Variable has already been deleted"

    def _retrieve_swig_value(self, name, value):
    # If we got back a different object than we have cached, we need to copy
    # all our metadata into it, so that it looks identical to the one
    # originally set.
      members = self.__dict__.get('_members')
      if members is not None and name in members:
        _copy_metadata_deep(value, members[name])

    # Verify that the new object is good
      _assert_valid_deep(value)

      return value

    # Attribute access must be intercepted to ensure that objects coming from
    # read attribute access match those that are set with write attribute access.
    # Specifically the metadata, such as the associated apr_pool object, should
    # match the originally assigned object.
    #
    # For classic classes it is enough to use __getattr__ to intercept swig
    # derived attributes. However, with new style classes SWIG makes use of
    # descriptors which mean that __getattr__ is never called. Therefore,
    # __getattribute__ must be used for the interception.

    if _newclass:
      def __getattribute__(self, name):
        """Manage access to all attributes of this object."""

    # Start by mimicing __getattr__ behavior: immediately return __dict__ or
    # items directly present in __dict__
        mydict = object.__getattribute__(self, '__dict__')

        if name == "__dict__":
          return mydict

        if name in mydict:
          return mydict[name]

        object.__getattribute__(self, 'assert_valid')()

        value = _get_instance_attr(self, name)
        fn = object.__getattribute__(self, '_retrieve_swig_value')
        return fn(name, value)
    else:
      def __getattr__(self, name):
        """Get an attribute from this object"""
        self.assert_valid()

        value = _swig_getattr(self, self.__class__, name)

        return self._retrieve_swig_value(name, value)

    def __setattr__(self, name, value):
      """Set an attribute on this object"""
      self.assert_valid()

    # Save a copy of the object, so that the garbage
    # collector won't kill the object while it's in
    # SWIG-land
      self.__dict__.setdefault("_members",{})[name] = value

      return _set_instance_attr(self, name, value)


    def __call__(self, *args):
      return svn_config_invoke_section_enumerator2(self, *args)

svn_config_section_enumerator2_t_swigregister = _core.svn_config_section_enumerator2_t_swigregister
svn_config_section_enumerator2_t_swigregister(svn_config_section_enumerator2_t)

class svn_config_enumerator_t(object):
    """Proxy of C svn_config_enumerator_t struct."""

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    def set_parent_pool(self, parent_pool=None):
      """Create a new proxy object for TYPE"""
      import libsvn.core, weakref
      self.__dict__["_parent_pool"] = \
        parent_pool or libsvn.core.application_pool;
      if self.__dict__["_parent_pool"]:
        self.__dict__["_is_valid"] = weakref.ref(
          self.__dict__["_parent_pool"]._is_valid)

    def assert_valid(self):
      """Assert that this object is using valid pool memory"""
      if "_is_valid" in self.__dict__:
        assert self.__dict__["_is_valid"](), "Variable has already been deleted"

    def _retrieve_swig_value(self, name, value):
    # If we got back a different object than we have cached, we need to copy
    # all our metadata into it, so that it looks identical to the one
    # originally set.
      members = self.__dict__.get('_members')
      if members is not None and name in members:
        _copy_metadata_deep(value, members[name])

    # Verify that the new object is good
      _assert_valid_deep(value)

      return value

    # Attribute access must be intercepted to ensure that objects coming from
    # read attribute access match those that are set with write attribute access.
    # Specifically the metadata, such as the associated apr_pool object, should
    # match the originally assigned object.
    #
    # For classic classes it is enough to use __getattr__ to intercept swig
    # derived attributes. However, with new style classes SWIG makes use of
    # descriptors which mean that __getattr__ is never called. Therefore,
    # __getattribute__ must be used for the interception.

    if _newclass:
      def __getattribute__(self, name):
        """Manage access to all attributes of this object."""

    # Start by mimicing __getattr__ behavior: immediately return __dict__ or
    # items directly present in __dict__
        mydict = object.__getattribute__(self, '__dict__')

        if name == "__dict__":
          return mydict

        if name in mydict:
          return mydict[name]

        object.__getattribute__(self, 'assert_valid')()

        value = _get_instance_attr(self, name)
        fn = object.__getattribute__(self, '_retrieve_swig_value')
        return fn(name, value)
    else:
      def __getattr__(self, name):
        """Get an attribute from this object"""
        self.assert_valid()

        value = _swig_getattr(self, self.__class__, name)

        return self._retrieve_swig_value(name, value)

    def __setattr__(self, name, value):
      """Set an attribute on this object"""
      self.assert_valid()

    # Save a copy of the object, so that the garbage
    # collector won't kill the object while it's in
    # SWIG-land
      self.__dict__.setdefault("_members",{})[name] = value

      return _set_instance_attr(self, name, value)


    def __call__(self, *args):
      return svn_config_invoke_enumerator(self, *args)

svn_config_enumerator_t_swigregister = _core.svn_config_enumerator_t_swigregister
svn_config_enumerator_t_swigregister(svn_config_enumerator_t)

class svn_config_enumerator2_t(object):
    """Proxy of C svn_config_enumerator2_t struct."""

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    def set_parent_pool(self, parent_pool=None):
      """Create a new proxy object for TYPE"""
      import libsvn.core, weakref
      self.__dict__["_parent_pool"] = \
        parent_pool or libsvn.core.application_pool;
      if self.__dict__["_parent_pool"]:
        self.__dict__["_is_valid"] = weakref.ref(
          self.__dict__["_parent_pool"]._is_valid)

    def assert_valid(self):
      """Assert that this object is using valid pool memory"""
      if "_is_valid" in self.__dict__:
        assert self.__dict__["_is_valid"](), "Variable has already been deleted"

    def _retrieve_swig_value(self, name, value):
    # If we got back a different object than we have cached, we need to copy
    # all our metadata into it, so that it looks identical to the one
    # originally set.
      members = self.__dict__.get('_members')
      if members is not None and name in members:
        _copy_metadata_deep(value, members[name])

    # Verify that the new object is good
      _assert_valid_deep(value)

      return value

    # Attribute access must be intercepted to ensure that objects coming from
    # read attribute access match those that are set with write attribute access.
    # Specifically the metadata, such as the associated apr_pool object, should
    # match the originally assigned object.
    #
    # For classic classes it is enough to use __getattr__ to intercept swig
    # derived attributes. However, with new style classes SWIG makes use of
    # descriptors which mean that __getattr__ is never called. Therefore,
    # __getattribute__ must be used for the interception.

    if _newclass:
      def __getattribute__(self, name):
        """Manage access to all attributes of this object."""

    # Start by mimicing __getattr__ behavior: immediately return __dict__ or
    # items directly present in __dict__
        mydict = object.__getattribute__(self, '__dict__')

        if name == "__dict__":
          return mydict

        if name in mydict:
          return mydict[name]

        object.__getattribute__(self, 'assert_valid')()

        value = _get_instance_attr(self, name)
        fn = object.__getattribute__(self, '_retrieve_swig_value')
        return fn(name, value)
    else:
      def __getattr__(self, name):
        """Get an attribute from this object"""
        self.assert_valid()

        value = _swig_getattr(self, self.__class__, name)

        return self._retrieve_swig_value(name, value)

    def __setattr__(self, name, value):
      """Set an attribute on this object"""
      self.assert_valid()

    # Save a copy of the object, so that the garbage
    # collector won't kill the object while it's in
    # SWIG-land
      self.__dict__.setdefault("_members",{})[name] = value

      return _set_instance_attr(self, name, value)


    def __call__(self, *args):
      return svn_config_invoke_enumerator2(self, *args)

svn_config_enumerator2_t_swigregister = _core.svn_config_enumerator2_t_swigregister
svn_config_enumerator2_t_swigregister(svn_config_enumerator2_t)

class svn_config_auth_walk_func_t(object):
    """Proxy of C svn_config_auth_walk_func_t struct."""

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    def set_parent_pool(self, parent_pool=None):
      """Create a new proxy object for TYPE"""
      import libsvn.core, weakref
      self.__dict__["_parent_pool"] = \
        parent_pool or libsvn.core.application_pool;
      if self.__dict__["_parent_pool"]:
        self.__dict__["_is_valid"] = weakref.ref(
          self.__dict__["_parent_pool"]._is_valid)

    def assert_valid(self):
      """Assert that this object is using valid pool memory"""
      if "_is_valid" in self.__dict__:
        assert self.__dict__["_is_valid"](), "Variable has already been deleted"

    def _retrieve_swig_value(self, name, value):
    # If we got back a different object than we have cached, we need to copy
    # all our metadata into it, so that it looks identical to the one
    # originally set.
      members = self.__dict__.get('_members')
      if members is not None and name in members:
        _copy_metadata_deep(value, members[name])

    # Verify that the new object is good
      _assert_valid_deep(value)

      return value

    # Attribute access must be intercepted to ensure that objects coming from
    # read attribute access match those that are set with write attribute access.
    # Specifically the metadata, such as the associated apr_pool object, should
    # match the originally assigned object.
    #
    # For classic classes it is enough to use __getattr__ to intercept swig
    # derived attributes. However, with new style classes SWIG makes use of
    # descriptors which mean that __getattr__ is never called. Therefore,
    # __getattribute__ must be used for the interception.

    if _newclass:
      def __getattribute__(self, name):
        """Manage access to all attributes of this object."""

    # Start by mimicing __getattr__ behavior: immediately return __dict__ or
    # items directly present in __dict__
        mydict = object.__getattribute__(self, '__dict__')

        if name == "__dict__":
          return mydict

        if name in mydict:
          return mydict[name]

        object.__getattribute__(self, 'assert_valid')()

        value = _get_instance_attr(self, name)
        fn = object.__getattribute__(self, '_retrieve_swig_value')
        return fn(name, value)
    else:
      def __getattr__(self, name):
        """Get an attribute from this object"""
        self.assert_valid()

        value = _swig_getattr(self, self.__class__, name)

        return self._retrieve_swig_value(name, value)

    def __setattr__(self, name, value):
      """Set an attribute on this object"""
      self.assert_valid()

    # Save a copy of the object, so that the garbage
    # collector won't kill the object while it's in
    # SWIG-land
      self.__dict__.setdefault("_members",{})[name] = value

      return _set_instance_attr(self, name, value)


    def __call__(self, *args):
      return svn_config_invoke_auth_walk_func(self, *args)

svn_config_auth_walk_func_t_swigregister = _core.svn_config_auth_walk_func_t_swigregister
svn_config_auth_walk_func_t_swigregister(svn_config_auth_walk_func_t)


def svn_utf_initialize2(*args) -> "void":
    """svn_utf_initialize2(svn_boolean_t assume_native_utf8, apr_pool_t pool)"""
    return _core.svn_utf_initialize2(*args)

def svn_utf_initialize(*args) -> "void":
    """svn_utf_initialize(apr_pool_t pool)"""
    return _core.svn_utf_initialize(*args)

def svn_utf_stringbuf_to_utf8(*args) -> "svn_stringbuf_t **":
    """svn_utf_stringbuf_to_utf8(svn_stringbuf_t const * src, apr_pool_t pool) -> svn_error_t"""
    return _core.svn_utf_stringbuf_to_utf8(*args)

def svn_utf_string_to_utf8(*args) -> "svn_string_t **":
    """svn_utf_string_to_utf8(svn_string_t const * src, apr_pool_t pool) -> svn_error_t"""
    return _core.svn_utf_string_to_utf8(*args)

def svn_utf_cstring_to_utf8(*args) -> "char const **":
    """svn_utf_cstring_to_utf8(char const * src, apr_pool_t pool) -> svn_error_t"""
    return _core.svn_utf_cstring_to_utf8(*args)

def svn_utf_cstring_to_utf8_ex2(*args) -> "char const **":
    """svn_utf_cstring_to_utf8_ex2(char const * src, char const * frompage, apr_pool_t pool) -> svn_error_t"""
    return _core.svn_utf_cstring_to_utf8_ex2(*args)

def svn_utf_cstring_to_utf8_ex(*args) -> "char const **":
    """svn_utf_cstring_to_utf8_ex(char const * src, char const * frompage, char const * convset_key, apr_pool_t pool) -> svn_error_t"""
    return _core.svn_utf_cstring_to_utf8_ex(*args)

def svn_utf_stringbuf_from_utf8(*args) -> "svn_stringbuf_t **":
    """svn_utf_stringbuf_from_utf8(svn_stringbuf_t const * src, apr_pool_t pool) -> svn_error_t"""
    return _core.svn_utf_stringbuf_from_utf8(*args)

def svn_utf_string_from_utf8(*args) -> "svn_string_t **":
    """svn_utf_string_from_utf8(svn_string_t const * src, apr_pool_t pool) -> svn_error_t"""
    return _core.svn_utf_string_from_utf8(*args)

def svn_utf_cstring_from_utf8(*args) -> "char const **":
    """svn_utf_cstring_from_utf8(char const * src, apr_pool_t pool) -> svn_error_t"""
    return _core.svn_utf_cstring_from_utf8(*args)

def svn_utf_cstring_from_utf8_ex2(*args) -> "char const **":
    """svn_utf_cstring_from_utf8_ex2(char const * src, char const * topage, apr_pool_t pool) -> svn_error_t"""
    return _core.svn_utf_cstring_from_utf8_ex2(*args)

def svn_utf_cstring_from_utf8_ex(*args) -> "char const **":
    """svn_utf_cstring_from_utf8_ex(char const * src, char const * topage, char const * convset_key, apr_pool_t pool) -> svn_error_t"""
    return _core.svn_utf_cstring_from_utf8_ex(*args)

def svn_utf_cstring_from_utf8_fuzzy(*args) -> "char const *":
    """svn_utf_cstring_from_utf8_fuzzy(char const * src, apr_pool_t pool) -> char const *"""
    return _core.svn_utf_cstring_from_utf8_fuzzy(*args)

def svn_utf_cstring_from_utf8_stringbuf(*args) -> "char const **":
    """svn_utf_cstring_from_utf8_stringbuf(svn_stringbuf_t const * src, apr_pool_t pool) -> svn_error_t"""
    return _core.svn_utf_cstring_from_utf8_stringbuf(*args)

def svn_utf_cstring_from_utf8_string(*args) -> "char const **":
    """svn_utf_cstring_from_utf8_string(svn_string_t const * src, apr_pool_t pool) -> svn_error_t"""
    return _core.svn_utf_cstring_from_utf8_string(*args)

def svn_utf_cstring_utf8_width(cstr: 'char const *') -> "int":
    """svn_utf_cstring_utf8_width(char const * cstr) -> int"""
    return _core.svn_utf_cstring_utf8_width(cstr)

def svn_nls_init() -> "svn_error_t *":
    """svn_nls_init() -> svn_error_t"""
    return _core.svn_nls_init()

def svn_path_internal_style(*args) -> "char const *":
    """svn_path_internal_style(char const * path, apr_pool_t pool) -> char const *"""
    return _core.svn_path_internal_style(*args)

def svn_path_local_style(*args) -> "char const *":
    """svn_path_local_style(char const * path, apr_pool_t pool) -> char const *"""
    return _core.svn_path_local_style(*args)

def svn_path_splitext(*args) -> "char const **, char const **":
    """svn_path_splitext(char const * path, apr_pool_t pool)"""
    return _core.svn_path_splitext(*args)

def svn_path_is_empty(path: 'char const *') -> "int":
    """svn_path_is_empty(char const * path) -> int"""
    return _core.svn_path_is_empty(path)

def svn_dirent_is_root(dirent: 'char const *', len: 'apr_size_t') -> "svn_boolean_t":
    """svn_dirent_is_root(char const * dirent, apr_size_t len) -> svn_boolean_t"""
    return _core.svn_dirent_is_root(dirent, len)

def svn_path_canonicalize(*args) -> "char const *":
    """svn_path_canonicalize(char const * path, apr_pool_t pool) -> char const *"""
    return _core.svn_path_canonicalize(*args)

def svn_path_is_canonical(*args) -> "svn_boolean_t":
    """svn_path_is_canonical(char const * path, apr_pool_t pool) -> svn_boolean_t"""
    return _core.svn_path_is_canonical(*args)

def svn_path_compare_paths(path1: 'char const *', path2: 'char const *') -> "int":
    """svn_path_compare_paths(char const * path1, char const * path2) -> int"""
    return _core.svn_path_compare_paths(path1, path2)

def svn_path_get_longest_ancestor(*args) -> "char *":
    """svn_path_get_longest_ancestor(char const * path1, char const * path2, apr_pool_t pool) -> char *"""
    return _core.svn_path_get_longest_ancestor(*args)

def svn_path_is_dotpath_present(path: 'char const *') -> "svn_boolean_t":
    """svn_path_is_dotpath_present(char const * path) -> svn_boolean_t"""
    return _core.svn_path_is_dotpath_present(path)

def svn_path_is_url(path: 'char const *') -> "svn_boolean_t":
    """svn_path_is_url(char const * path) -> svn_boolean_t"""
    return _core.svn_path_is_url(path)

def svn_path_is_uri_safe(path: 'char const *') -> "svn_boolean_t":
    """svn_path_is_uri_safe(char const * path) -> svn_boolean_t"""
    return _core.svn_path_is_uri_safe(path)

def svn_path_url_add_component2(*args) -> "char const *":
    """svn_path_url_add_component2(char const * url, char const * component, apr_pool_t pool) -> char const *"""
    return _core.svn_path_url_add_component2(*args)

def svn_path_is_repos_relative_url(path: 'char const *') -> "svn_boolean_t":
    """svn_path_is_repos_relative_url(char const * path) -> svn_boolean_t"""
    return _core.svn_path_is_repos_relative_url(path)

def svn_path_resolve_repos_relative_url(*args) -> "char const **":
    """svn_path_resolve_repos_relative_url(char const * relative_url, char const * repos_root_url, apr_pool_t pool) -> svn_error_t"""
    return _core.svn_path_resolve_repos_relative_url(*args)

def svn_path_illegal_path_escape(*args) -> "char const *":
    """svn_path_illegal_path_escape(char const * path, apr_pool_t pool) -> char const *"""
    return _core.svn_path_illegal_path_escape(*args)

def svn_dirent_internal_style(*args) -> "char const *":
    """svn_dirent_internal_style(char const * dirent, apr_pool_t result_pool) -> char const *"""
    return _core.svn_dirent_internal_style(*args)

def svn_dirent_internal_style_safe(*args) -> "char const **, char const **":
    """svn_dirent_internal_style_safe(char const * dirent, apr_pool_t result_pool, apr_pool_t scratch_pool) -> svn_error_t"""
    return _core.svn_dirent_internal_style_safe(*args)

def svn_dirent_local_style(*args) -> "char const *":
    """svn_dirent_local_style(char const * dirent, apr_pool_t result_pool) -> char const *"""
    return _core.svn_dirent_local_style(*args)

def svn_dirent_join(*args) -> "char *":
    """svn_dirent_join(char const * base, char const * component, apr_pool_t result_pool) -> char *"""
    return _core.svn_dirent_join(*args)

def svn_relpath_join(*args) -> "char *":
    """svn_relpath_join(char const * base, char const * component, apr_pool_t result_pool) -> char *"""
    return _core.svn_relpath_join(*args)

def svn_dirent_basename(*args) -> "char const *":
    """svn_dirent_basename(char const * dirent, apr_pool_t result_pool) -> char const *"""
    return _core.svn_dirent_basename(*args)

def svn_dirent_dirname(*args) -> "char *":
    """svn_dirent_dirname(char const * dirent, apr_pool_t result_pool) -> char *"""
    return _core.svn_dirent_dirname(*args)

def svn_dirent_split(*args) -> "char const **, char const **":
    """svn_dirent_split(char const * dirent, apr_pool_t result_pool)"""
    return _core.svn_dirent_split(*args)

def svn_relpath_split(*args) -> "char const **, char const **":
    """svn_relpath_split(char const * relpath, apr_pool_t result_pool)"""
    return _core.svn_relpath_split(*args)

def svn_relpath_basename(*args) -> "char const *":
    """svn_relpath_basename(char const * relpath, apr_pool_t result_pool) -> char const *"""
    return _core.svn_relpath_basename(*args)

def svn_relpath_dirname(*args) -> "char *":
    """svn_relpath_dirname(char const * relpath, apr_pool_t result_pool) -> char *"""
    return _core.svn_relpath_dirname(*args)

def svn_relpath_prefix(*args) -> "char const *":
    """svn_relpath_prefix(char const * relpath, int max_components, apr_pool_t result_pool) -> char const *"""
    return _core.svn_relpath_prefix(*args)

def svn_uri_split(*args) -> "char const **, char const **":
    """svn_uri_split(char const * uri, apr_pool_t result_pool)"""
    return _core.svn_uri_split(*args)

def svn_uri_basename(*args) -> "char const *":
    """svn_uri_basename(char const * uri, apr_pool_t result_pool) -> char const *"""
    return _core.svn_uri_basename(*args)

def svn_uri_dirname(*args) -> "char *":
    """svn_uri_dirname(char const * uri, apr_pool_t result_pool) -> char *"""
    return _core.svn_uri_dirname(*args)

def svn_dirent_is_absolute(dirent: 'char const *') -> "svn_boolean_t":
    """svn_dirent_is_absolute(char const * dirent) -> svn_boolean_t"""
    return _core.svn_dirent_is_absolute(dirent)

def svn_uri_is_root(uri: 'char const *', len: 'apr_size_t') -> "svn_boolean_t":
    """svn_uri_is_root(char const * uri, apr_size_t len) -> svn_boolean_t"""
    return _core.svn_uri_is_root(uri, len)

def svn_dirent_canonicalize(*args) -> "char const *":
    """svn_dirent_canonicalize(char const * dirent, apr_pool_t result_pool) -> char const *"""
    return _core.svn_dirent_canonicalize(*args)

def svn_dirent_canonicalize_safe(*args) -> "char const **, char const **":
    """svn_dirent_canonicalize_safe(char const * dirent, apr_pool_t result_pool, apr_pool_t scratch_pool) -> svn_error_t"""
    return _core.svn_dirent_canonicalize_safe(*args)

def svn_relpath_canonicalize(*args) -> "char const *":
    """svn_relpath_canonicalize(char const * relpath, apr_pool_t result_pool) -> char const *"""
    return _core.svn_relpath_canonicalize(*args)

def svn_relpath_canonicalize_safe(*args) -> "char const **, char const **":
    """svn_relpath_canonicalize_safe(char const * relpath, apr_pool_t result_pool, apr_pool_t scratch_pool) -> svn_error_t"""
    return _core.svn_relpath_canonicalize_safe(*args)

def svn_uri_canonicalize(*args) -> "char const *":
    """svn_uri_canonicalize(char const * uri, apr_pool_t result_pool) -> char const *"""
    return _core.svn_uri_canonicalize(*args)

def svn_uri_canonicalize_safe(*args) -> "char const **, char const **":
    """svn_uri_canonicalize_safe(char const * uri, apr_pool_t result_pool, apr_pool_t scratch_pool) -> svn_error_t"""
    return _core.svn_uri_canonicalize_safe(*args)

def svn_dirent_is_canonical(*args) -> "svn_boolean_t":
    """svn_dirent_is_canonical(char const * dirent, apr_pool_t scratch_pool) -> svn_boolean_t"""
    return _core.svn_dirent_is_canonical(*args)

def svn_relpath_is_canonical(relpath: 'char const *') -> "svn_boolean_t":
    """svn_relpath_is_canonical(char const * relpath) -> svn_boolean_t"""
    return _core.svn_relpath_is_canonical(relpath)

def svn_uri_is_canonical(*args) -> "svn_boolean_t":
    """svn_uri_is_canonical(char const * uri, apr_pool_t scratch_pool) -> svn_boolean_t"""
    return _core.svn_uri_is_canonical(*args)

def svn_dirent_get_longest_ancestor(*args) -> "char *":
    """svn_dirent_get_longest_ancestor(char const * dirent1, char const * dirent2, apr_pool_t result_pool) -> char *"""
    return _core.svn_dirent_get_longest_ancestor(*args)

def svn_relpath_get_longest_ancestor(*args) -> "char *":
    """svn_relpath_get_longest_ancestor(char const * relpath1, char const * relpath2, apr_pool_t result_pool) -> char *"""
    return _core.svn_relpath_get_longest_ancestor(*args)

def svn_uri_get_longest_ancestor(*args) -> "char *":
    """svn_uri_get_longest_ancestor(char const * uri1, char const * uri2, apr_pool_t result_pool) -> char *"""
    return _core.svn_uri_get_longest_ancestor(*args)

def svn_dirent_get_absolute(*args) -> "char const **":
    """svn_dirent_get_absolute(char const * relative, apr_pool_t result_pool) -> svn_error_t"""
    return _core.svn_dirent_get_absolute(*args)

def svn_dirent_is_child(*args) -> "char const *":
    """svn_dirent_is_child(char const * parent_dirent, char const * child_dirent, apr_pool_t result_pool) -> char const *"""
    return _core.svn_dirent_is_child(*args)

def svn_dirent_is_ancestor(parent_dirent: 'char const *', child_dirent: 'char const *') -> "svn_boolean_t":
    """svn_dirent_is_ancestor(char const * parent_dirent, char const * child_dirent) -> svn_boolean_t"""
    return _core.svn_dirent_is_ancestor(parent_dirent, child_dirent)

def svn_uri__is_ancestor(parent_uri: 'char const *', child_uri: 'char const *') -> "svn_boolean_t":
    """svn_uri__is_ancestor(char const * parent_uri, char const * child_uri) -> svn_boolean_t"""
    return _core.svn_uri__is_ancestor(parent_uri, child_uri)

def svn_dirent_skip_ancestor(parent_dirent: 'char const *', child_dirent: 'char const *') -> "char const *":
    """svn_dirent_skip_ancestor(char const * parent_dirent, char const * child_dirent) -> char const *"""
    return _core.svn_dirent_skip_ancestor(parent_dirent, child_dirent)

def svn_relpath_skip_ancestor(parent_relpath: 'char const *', child_relpath: 'char const *') -> "char const *":
    """svn_relpath_skip_ancestor(char const * parent_relpath, char const * child_relpath) -> char const *"""
    return _core.svn_relpath_skip_ancestor(parent_relpath, child_relpath)

def svn_uri_skip_ancestor(*args) -> "char const *":
    """svn_uri_skip_ancestor(char const * parent_uri, char const * child_uri, apr_pool_t result_pool) -> char const *"""
    return _core.svn_uri_skip_ancestor(*args)

def svn_uri_get_dirent_from_file_url(*args) -> "char const **":
    """svn_uri_get_dirent_from_file_url(char const * url, apr_pool_t result_pool) -> svn_error_t"""
    return _core.svn_uri_get_dirent_from_file_url(*args)

def svn_uri_get_file_url_from_dirent(*args) -> "char const **":
    """svn_uri_get_file_url_from_dirent(char const * dirent, apr_pool_t result_pool) -> svn_error_t"""
    return _core.svn_uri_get_file_url_from_dirent(*args)
SVN_MERGEINFO_NONINHERITABLE_STR = _core.SVN_MERGEINFO_NONINHERITABLE_STR

def svn_mergeinfo_parse(*args) -> "apr_hash_t **":
    """svn_mergeinfo_parse(char const * input, apr_pool_t pool) -> svn_error_t"""
    return _core.svn_mergeinfo_parse(*args)

def svn_mergeinfo_diff2(*args) -> "apr_hash_t **, apr_hash_t **":
    """svn_mergeinfo_diff2(apr_hash_t mergefrom, apr_hash_t mergeto, svn_boolean_t consider_inheritance, apr_pool_t result_pool, apr_pool_t scratch_pool) -> svn_error_t"""
    return _core.svn_mergeinfo_diff2(*args)

def svn_mergeinfo_diff(*args) -> "apr_hash_t **, apr_hash_t **":
    """svn_mergeinfo_diff(apr_hash_t mergefrom, apr_hash_t mergeto, svn_boolean_t consider_inheritance, apr_pool_t pool) -> svn_error_t"""
    return _core.svn_mergeinfo_diff(*args)

def svn_mergeinfo_merge2(*args) -> "svn_error_t *":
    """svn_mergeinfo_merge2(apr_hash_t mergeinfo, apr_hash_t changes, apr_pool_t result_pool, apr_pool_t scratch_pool) -> svn_error_t"""
    return _core.svn_mergeinfo_merge2(*args)

def svn_mergeinfo_catalog_merge(*args) -> "svn_error_t *":
    """svn_mergeinfo_catalog_merge(apr_hash_t mergeinfo_catalog, apr_hash_t changes_catalog, apr_pool_t result_pool, apr_pool_t scratch_pool) -> svn_error_t"""
    return _core.svn_mergeinfo_catalog_merge(*args)

def svn_mergeinfo_remove(*args) -> "apr_hash_t **":
    """svn_mergeinfo_remove(apr_hash_t eraser, apr_hash_t whiteboard, apr_pool_t pool) -> svn_error_t"""
    return _core.svn_mergeinfo_remove(*args)

def svn_mergeinfo_remove2(*args) -> "apr_hash_t **":
    """svn_mergeinfo_remove2(apr_hash_t eraser, apr_hash_t whiteboard, svn_boolean_t consider_inheritance, apr_pool_t result_pool, apr_pool_t scratch_pool) -> svn_error_t"""
    return _core.svn_mergeinfo_remove2(*args)

def svn_rangelist_diff(*args) -> "svn_rangelist_t **, svn_rangelist_t **":
    """svn_rangelist_diff(apr_array_header_t arg3, apr_array_header_t to, svn_boolean_t consider_inheritance, apr_pool_t pool) -> svn_error_t"""
    return _core.svn_rangelist_diff(*args)

def svn_rangelist_merge2(*args) -> "svn_error_t *":
    """svn_rangelist_merge2(apr_array_header_t rangelist, apr_array_header_t changes, apr_pool_t result_pool, apr_pool_t scratch_pool) -> svn_error_t"""
    return _core.svn_rangelist_merge2(*args)

def svn_rangelist_remove(*args) -> "svn_rangelist_t **":
    """svn_rangelist_remove(apr_array_header_t eraser, apr_array_header_t whiteboard, svn_boolean_t consider_inheritance, apr_pool_t pool) -> svn_error_t"""
    return _core.svn_rangelist_remove(*args)

def svn_mergeinfo_intersect2(*args) -> "apr_hash_t **":
    """svn_mergeinfo_intersect2(apr_hash_t mergeinfo1, apr_hash_t mergeinfo2, svn_boolean_t consider_inheritance, apr_pool_t result_pool, apr_pool_t scratch_pool) -> svn_error_t"""
    return _core.svn_mergeinfo_intersect2(*args)

def svn_mergeinfo_intersect(*args) -> "apr_hash_t **":
    """svn_mergeinfo_intersect(apr_hash_t mergeinfo1, apr_hash_t mergeinfo2, apr_pool_t pool) -> svn_error_t"""
    return _core.svn_mergeinfo_intersect(*args)

def svn_rangelist_intersect(*args) -> "svn_rangelist_t **":
    """svn_rangelist_intersect(apr_array_header_t rangelist1, apr_array_header_t rangelist2, svn_boolean_t consider_inheritance, apr_pool_t pool) -> svn_error_t"""
    return _core.svn_rangelist_intersect(*args)

def svn_rangelist_to_string(*args) -> "svn_string_t **":
    """svn_rangelist_to_string(apr_array_header_t rangelist, apr_pool_t pool) -> svn_error_t"""
    return _core.svn_rangelist_to_string(*args)

def svn_rangelist_inheritable2(*args) -> "svn_rangelist_t **":
    """svn_rangelist_inheritable2(apr_array_header_t rangelist, svn_revnum_t start, svn_revnum_t end, svn_boolean_t inheritable, apr_pool_t result_pool, apr_pool_t scratch_pool) -> svn_error_t"""
    return _core.svn_rangelist_inheritable2(*args)

def svn_rangelist_inheritable(*args) -> "svn_rangelist_t **":
    """svn_rangelist_inheritable(apr_array_header_t rangelist, svn_revnum_t start, svn_revnum_t end, apr_pool_t pool) -> svn_error_t"""
    return _core.svn_rangelist_inheritable(*args)

def svn_mergeinfo_inheritable2(*args) -> "apr_hash_t **":
    """svn_mergeinfo_inheritable2(apr_hash_t mergeinfo, char const * path, svn_revnum_t start, svn_revnum_t end, svn_boolean_t inheritable, apr_pool_t result_pool, apr_pool_t scratch_pool) -> svn_error_t"""
    return _core.svn_mergeinfo_inheritable2(*args)

def svn_mergeinfo_inheritable(*args) -> "apr_hash_t **":
    """svn_mergeinfo_inheritable(apr_hash_t mergeinfo, char const * path, svn_revnum_t start, svn_revnum_t end, apr_pool_t pool) -> svn_error_t"""
    return _core.svn_mergeinfo_inheritable(*args)

def svn_mergeinfo_to_string(*args) -> "svn_string_t **":
    """svn_mergeinfo_to_string(apr_hash_t mergeinput, apr_pool_t pool) -> svn_error_t"""
    return _core.svn_mergeinfo_to_string(*args)

def svn_mergeinfo_catalog_dup(*args) -> "svn_mergeinfo_catalog_t":
    """svn_mergeinfo_catalog_dup(apr_hash_t mergeinfo_catalog, apr_pool_t pool) -> apr_hash_t"""
    return _core.svn_mergeinfo_catalog_dup(*args)

def svn_mergeinfo_dup(*args) -> "svn_mergeinfo_t":
    """svn_mergeinfo_dup(apr_hash_t mergeinfo, apr_pool_t pool) -> apr_hash_t"""
    return _core.svn_mergeinfo_dup(*args)

def svn_rangelist_dup(*args) -> "svn_rangelist_t *":
    """svn_rangelist_dup(apr_array_header_t rangelist, apr_pool_t pool) -> apr_array_header_t"""
    return _core.svn_rangelist_dup(*args)
svn_mergeinfo_explicit = _core.svn_mergeinfo_explicit
svn_mergeinfo_inherited = _core.svn_mergeinfo_inherited
svn_mergeinfo_nearest_ancestor = _core.svn_mergeinfo_nearest_ancestor

def svn_inheritance_to_word(inherit: 'svn_mergeinfo_inheritance_t') -> "char const *":
    """svn_inheritance_to_word(svn_mergeinfo_inheritance_t inherit) -> char const *"""
    return _core.svn_inheritance_to_word(inherit)

def svn_inheritance_from_word(word: 'char const *') -> "svn_mergeinfo_inheritance_t":
    """svn_inheritance_from_word(char const * word) -> svn_mergeinfo_inheritance_t"""
    return _core.svn_inheritance_from_word(word)
svn_io_file_del_none = _core.svn_io_file_del_none
svn_io_file_del_on_close = _core.svn_io_file_del_on_close
svn_io_file_del_on_pool_cleanup = _core.svn_io_file_del_on_pool_cleanup
class svn_io_dirent2_t(object):
    """Proxy of C svn_io_dirent2_t struct."""

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    kind = _swig_property(_core.svn_io_dirent2_t_kind_get, _core.svn_io_dirent2_t_kind_set)
    special = _swig_property(_core.svn_io_dirent2_t_special_get, _core.svn_io_dirent2_t_special_set)
    filesize = _swig_property(_core.svn_io_dirent2_t_filesize_get, _core.svn_io_dirent2_t_filesize_set)
    mtime = _swig_property(_core.svn_io_dirent2_t_mtime_get, _core.svn_io_dirent2_t_mtime_set)
    def set_parent_pool(self, parent_pool=None):
      """Create a new proxy object for TYPE"""
      import libsvn.core, weakref
      self.__dict__["_parent_pool"] = \
        parent_pool or libsvn.core.application_pool;
      if self.__dict__["_parent_pool"]:
        self.__dict__["_is_valid"] = weakref.ref(
          self.__dict__["_parent_pool"]._is_valid)

    def assert_valid(self):
      """Assert that this object is using valid pool memory"""
      if "_is_valid" in self.__dict__:
        assert self.__dict__["_is_valid"](), "Variable has already been deleted"

    def _retrieve_swig_value(self, name, value):
    # If we got back a different object than we have cached, we need to copy
    # all our metadata into it, so that it looks identical to the one
    # originally set.
      members = self.__dict__.get('_members')
      if members is not None and name in members:
        _copy_metadata_deep(value, members[name])

    # Verify that the new object is good
      _assert_valid_deep(value)

      return value

    # Attribute access must be intercepted to ensure that objects coming from
    # read attribute access match those that are set with write attribute access.
    # Specifically the metadata, such as the associated apr_pool object, should
    # match the originally assigned object.
    #
    # For classic classes it is enough to use __getattr__ to intercept swig
    # derived attributes. However, with new style classes SWIG makes use of
    # descriptors which mean that __getattr__ is never called. Therefore,
    # __getattribute__ must be used for the interception.

    if _newclass:
      def __getattribute__(self, name):
        """Manage access to all attributes of this object."""

    # Start by mimicing __getattr__ behavior: immediately return __dict__ or
    # items directly present in __dict__
        mydict = object.__getattribute__(self, '__dict__')

        if name == "__dict__":
          return mydict

        if name in mydict:
          return mydict[name]

        object.__getattribute__(self, 'assert_valid')()

        value = _get_instance_attr(self, name)
        fn = object.__getattribute__(self, '_retrieve_swig_value')
        return fn(name, value)
    else:
      def __getattr__(self, name):
        """Get an attribute from this object"""
        self.assert_valid()

        value = _swig_getattr(self, self.__class__, name)

        return self._retrieve_swig_value(name, value)

    def __setattr__(self, name, value):
      """Set an attribute on this object"""
      self.assert_valid()

    # Save a copy of the object, so that the garbage
    # collector won't kill the object while it's in
    # SWIG-land
      self.__dict__.setdefault("_members",{})[name] = value

      return _set_instance_attr(self, name, value)


    def __init__(self):
        """__init__(svn_io_dirent2_t self) -> svn_io_dirent2_t"""
        this = _core.new_svn_io_dirent2_t()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _core.delete_svn_io_dirent2_t
    __del__ = lambda self: None
svn_io_dirent2_t_swigregister = _core.svn_io_dirent2_t_swigregister
svn_io_dirent2_t_swigregister(svn_io_dirent2_t)


def svn_io_dirent2_create(*args) -> "svn_io_dirent2_t *":
    """svn_io_dirent2_create(apr_pool_t result_pool) -> svn_io_dirent2_t"""
    return _core.svn_io_dirent2_create(*args)

def svn_io_dirent2_dup(*args) -> "svn_io_dirent2_t *":
    """svn_io_dirent2_dup(svn_io_dirent2_t item, apr_pool_t result_pool) -> svn_io_dirent2_t"""
    return _core.svn_io_dirent2_dup(*args)
class svn_io_dirent_t(object):
    """Proxy of C svn_io_dirent_t struct."""

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    kind = _swig_property(_core.svn_io_dirent_t_kind_get, _core.svn_io_dirent_t_kind_set)
    special = _swig_property(_core.svn_io_dirent_t_special_get, _core.svn_io_dirent_t_special_set)
    def set_parent_pool(self, parent_pool=None):
      """Create a new proxy object for TYPE"""
      import libsvn.core, weakref
      self.__dict__["_parent_pool"] = \
        parent_pool or libsvn.core.application_pool;
      if self.__dict__["_parent_pool"]:
        self.__dict__["_is_valid"] = weakref.ref(
          self.__dict__["_parent_pool"]._is_valid)

    def assert_valid(self):
      """Assert that this object is using valid pool memory"""
      if "_is_valid" in self.__dict__:
        assert self.__dict__["_is_valid"](), "Variable has already been deleted"

    def _retrieve_swig_value(self, name, value):
    # If we got back a different object than we have cached, we need to copy
    # all our metadata into it, so that it looks identical to the one
    # originally set.
      members = self.__dict__.get('_members')
      if members is not None and name in members:
        _copy_metadata_deep(value, members[name])

    # Verify that the new object is good
      _assert_valid_deep(value)

      return value

    # Attribute access must be intercepted to ensure that objects coming from
    # read attribute access match those that are set with write attribute access.
    # Specifically the metadata, such as the associated apr_pool object, should
    # match the originally assigned object.
    #
    # For classic classes it is enough to use __getattr__ to intercept swig
    # derived attributes. However, with new style classes SWIG makes use of
    # descriptors which mean that __getattr__ is never called. Therefore,
    # __getattribute__ must be used for the interception.

    if _newclass:
      def __getattribute__(self, name):
        """Manage access to all attributes of this object."""

    # Start by mimicing __getattr__ behavior: immediately return __dict__ or
    # items directly present in __dict__
        mydict = object.__getattribute__(self, '__dict__')

        if name == "__dict__":
          return mydict

        if name in mydict:
          return mydict[name]

        object.__getattribute__(self, 'assert_valid')()

        value = _get_instance_attr(self, name)
        fn = object.__getattribute__(self, '_retrieve_swig_value')
        return fn(name, value)
    else:
      def __getattr__(self, name):
        """Get an attribute from this object"""
        self.assert_valid()

        value = _swig_getattr(self, self.__class__, name)

        return self._retrieve_swig_value(name, value)

    def __setattr__(self, name, value):
      """Set an attribute on this object"""
      self.assert_valid()

    # Save a copy of the object, so that the garbage
    # collector won't kill the object while it's in
    # SWIG-land
      self.__dict__.setdefault("_members",{})[name] = value

      return _set_instance_attr(self, name, value)


    def __init__(self):
        """__init__(svn_io_dirent_t self) -> svn_io_dirent_t"""
        this = _core.new_svn_io_dirent_t()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _core.delete_svn_io_dirent_t
    __del__ = lambda self: None
svn_io_dirent_t_swigregister = _core.svn_io_dirent_t_swigregister
svn_io_dirent_t_swigregister(svn_io_dirent_t)


def svn_io_open_uniquely_named(*args) -> "apr_file_t **, char const **":
    """svn_io_open_uniquely_named(char const * dirpath, char const * filename, char const * suffix, svn_io_file_del_t delete_when, apr_pool_t result_pool, apr_pool_t scratch_pool) -> svn_error_t"""
    return _core.svn_io_open_uniquely_named(*args)

def svn_io_open_unique_file3(*args) -> "apr_file_t **, char const **":
    """svn_io_open_unique_file3(char const * dirpath, svn_io_file_del_t delete_when, apr_pool_t result_pool, apr_pool_t scratch_pool) -> svn_error_t"""
    return _core.svn_io_open_unique_file3(*args)

def svn_io_open_unique_file2(*args) -> "apr_file_t **, char const **":
    """svn_io_open_unique_file2(char const * path, char const * suffix, svn_io_file_del_t delete_when, apr_pool_t pool) -> svn_error_t"""
    return _core.svn_io_open_unique_file2(*args)

def svn_io_open_unique_file(*args) -> "apr_file_t **, char const **":
    """svn_io_open_unique_file(char const * path, char const * suffix, svn_boolean_t delete_on_close, apr_pool_t pool) -> svn_error_t"""
    return _core.svn_io_open_unique_file(*args)

def svn_io_copy_perms(*args) -> "svn_error_t *":
    """svn_io_copy_perms(char const * src, char const * dst, apr_pool_t pool) -> svn_error_t"""
    return _core.svn_io_copy_perms(*args)

def svn_io_sleep_for_timestamps(*args) -> "void":
    """svn_io_sleep_for_timestamps(char const * path, apr_pool_t pool)"""
    return _core.svn_io_sleep_for_timestamps(*args)

def svn_io_filesizes_three_different_p(*args) -> "svn_boolean_t *, svn_boolean_t *, svn_boolean_t *":
    """svn_io_filesizes_three_different_p(char const * file1, char const * file2, char const * file3, apr_pool_t scratch_pool) -> svn_error_t"""
    return _core.svn_io_filesizes_three_different_p(*args)

def svn_io_file_checksum2(*args) -> "svn_checksum_t **":
    """svn_io_file_checksum2(char const * file, svn_checksum_kind_t kind, apr_pool_t pool) -> svn_error_t"""
    return _core.svn_io_file_checksum2(*args)

def svn_io_file_checksum(*args) -> "unsigned char [ANY]":
    """svn_io_file_checksum(char const * file, apr_pool_t pool) -> svn_error_t"""
    return _core.svn_io_file_checksum(*args)

def svn_io_files_contents_same_p(*args) -> "svn_boolean_t *":
    """svn_io_files_contents_same_p(char const * file1, char const * file2, apr_pool_t pool) -> svn_error_t"""
    return _core.svn_io_files_contents_same_p(*args)

def svn_io_files_contents_three_same_p(*args) -> "svn_boolean_t *, svn_boolean_t *, svn_boolean_t *":
    """svn_io_files_contents_three_same_p(char const * file1, char const * file2, char const * file3, apr_pool_t scratch_pool) -> svn_error_t"""
    return _core.svn_io_files_contents_three_same_p(*args)

def svn_io_file_create_bytes(*args) -> "svn_error_t *":
    """svn_io_file_create_bytes(char const * file, void const * contents, apr_size_t length, apr_pool_t scratch_pool) -> svn_error_t"""
    return _core.svn_io_file_create_bytes(*args)

def svn_io_file_create_empty(*args) -> "svn_error_t *":
    """svn_io_file_create_empty(char const * file, apr_pool_t scratch_pool) -> svn_error_t"""
    return _core.svn_io_file_create_empty(*args)

def svn_io_lock_open_file(*args) -> "svn_error_t *":
    """svn_io_lock_open_file(apr_file_t lockfile_handle, svn_boolean_t exclusive, svn_boolean_t nonblocking, apr_pool_t pool) -> svn_error_t"""
    return _core.svn_io_lock_open_file(*args)

def svn_io_unlock_open_file(*args) -> "svn_error_t *":
    """svn_io_unlock_open_file(apr_file_t lockfile_handle, apr_pool_t pool) -> svn_error_t"""
    return _core.svn_io_unlock_open_file(*args)

def svn_stream_set_read2(stream: 'svn_stream_t *', read_fn: 'svn_read_fn_t', read_full_fn: 'svn_read_fn_t') -> "void":
    """svn_stream_set_read2(svn_stream_t * stream, svn_read_fn_t read_fn, svn_read_fn_t read_full_fn)"""
    return _core.svn_stream_set_read2(stream, read_fn, read_full_fn)

def svn_stream_set_skip(stream: 'svn_stream_t *', skip_fn: 'svn_stream_skip_fn_t') -> "void":
    """svn_stream_set_skip(svn_stream_t * stream, svn_stream_skip_fn_t skip_fn)"""
    return _core.svn_stream_set_skip(stream, skip_fn)

def svn_stream_set_mark(stream: 'svn_stream_t *', mark_fn: 'svn_stream_mark_fn_t') -> "void":
    """svn_stream_set_mark(svn_stream_t * stream, svn_stream_mark_fn_t mark_fn)"""
    return _core.svn_stream_set_mark(stream, mark_fn)

def svn_stream_set_seek(stream: 'svn_stream_t *', seek_fn: 'svn_stream_seek_fn_t') -> "void":
    """svn_stream_set_seek(svn_stream_t * stream, svn_stream_seek_fn_t seek_fn)"""
    return _core.svn_stream_set_seek(stream, seek_fn)

def svn_stream_set_data_available(stream: 'svn_stream_t *', data_available: 'svn_stream_data_available_fn_t') -> "void":
    """svn_stream_set_data_available(svn_stream_t * stream, svn_stream_data_available_fn_t data_available)"""
    return _core.svn_stream_set_data_available(stream, data_available)

def svn_stream_set_readline(stream: 'svn_stream_t *', readline_fn: 'svn_stream_readline_fn_t') -> "void":
    """svn_stream_set_readline(svn_stream_t * stream, svn_stream_readline_fn_t readline_fn)"""
    return _core.svn_stream_set_readline(stream, readline_fn)

def svn_stream_empty(*args) -> "svn_stream_t *":
    """svn_stream_empty(apr_pool_t pool) -> svn_stream_t *"""
    return _core.svn_stream_empty(*args)

def svn_stream_disown(*args) -> "svn_stream_t *":
    """svn_stream_disown(svn_stream_t * stream, apr_pool_t pool) -> svn_stream_t *"""
    return _core.svn_stream_disown(*args)

def svn_stream_open_readonly(*args) -> "svn_stream_t **":
    """svn_stream_open_readonly(char const * path, apr_pool_t result_pool, apr_pool_t scratch_pool) -> svn_error_t"""
    return _core.svn_stream_open_readonly(*args)

def svn_stream_open_writable(*args) -> "svn_stream_t **":
    """svn_stream_open_writable(char const * path, apr_pool_t result_pool, apr_pool_t scratch_pool) -> svn_error_t"""
    return _core.svn_stream_open_writable(*args)

def svn_stream_open_unique(*args) -> "svn_stream_t **, char const **":
    """svn_stream_open_unique(char const * dirpath, svn_io_file_del_t delete_when, apr_pool_t result_pool, apr_pool_t scratch_pool) -> svn_error_t"""
    return _core.svn_stream_open_unique(*args)

def svn_stream_from_aprfile2(*args) -> "svn_stream_t *":
    """svn_stream_from_aprfile2(apr_file_t file, svn_boolean_t disown, apr_pool_t pool) -> svn_stream_t *"""
    return _core.svn_stream_from_aprfile2(*args)

def svn_stream_from_aprfile(*args) -> "svn_stream_t *":
    """svn_stream_from_aprfile(apr_file_t file, apr_pool_t pool) -> svn_stream_t *"""
    return _core.svn_stream_from_aprfile(*args)

def svn_stream_for_stdin2(*args) -> "svn_stream_t **":
    """svn_stream_for_stdin2(svn_boolean_t buffered, apr_pool_t pool) -> svn_error_t"""
    return _core.svn_stream_for_stdin2(*args)

def svn_stream_for_stdin(*args) -> "svn_stream_t **":
    """svn_stream_for_stdin(apr_pool_t pool) -> svn_error_t"""
    return _core.svn_stream_for_stdin(*args)

def svn_stream_for_stderr(*args) -> "svn_stream_t **":
    """svn_stream_for_stderr(apr_pool_t pool) -> svn_error_t"""
    return _core.svn_stream_for_stderr(*args)

def svn_stream_for_stdout(*args) -> "svn_stream_t **":
    """svn_stream_for_stdout(apr_pool_t pool) -> svn_error_t"""
    return _core.svn_stream_for_stdout(*args)

def svn_stringbuf_from_stream(*args) -> "svn_stringbuf_t **":
    """svn_stringbuf_from_stream(svn_stream_t * stream, apr_size_t len_hint, apr_pool_t result_pool) -> svn_error_t"""
    return _core.svn_stringbuf_from_stream(*args)

def svn_stream_from_stringbuf(*args) -> "svn_stream_t *":
    """svn_stream_from_stringbuf(svn_stringbuf_t * str, apr_pool_t pool) -> svn_stream_t *"""
    return _core.svn_stream_from_stringbuf(*args)

def svn_stream_from_string(*args) -> "svn_stream_t *":
    """svn_stream_from_string(svn_string_t const * str, apr_pool_t pool) -> svn_stream_t *"""
    return _core.svn_stream_from_string(*args)

def svn_stream_buffered(*args) -> "svn_stream_t *":
    """svn_stream_buffered(apr_pool_t result_pool) -> svn_stream_t *"""
    return _core.svn_stream_buffered(*args)

def svn_stream_compressed(*args) -> "svn_stream_t *":
    """svn_stream_compressed(svn_stream_t * stream, apr_pool_t pool) -> svn_stream_t *"""
    return _core.svn_stream_compressed(*args)

def svn_stream_checksummed2(*args) -> "svn_checksum_t **, svn_checksum_t **":
    """svn_stream_checksummed2(svn_stream_t * stream, svn_checksum_kind_t checksum_kind, svn_boolean_t read_all, apr_pool_t pool) -> svn_stream_t *"""
    return _core.svn_stream_checksummed2(*args)

def svn_stream_contents_checksum(*args) -> "svn_checksum_t **":
    """svn_stream_contents_checksum(svn_stream_t * stream, svn_checksum_kind_t kind, apr_pool_t result_pool, apr_pool_t scratch_pool) -> svn_error_t"""
    return _core.svn_stream_contents_checksum(*args)

def svn_stream_read_full(stream: 'svn_stream_t *', buffer: 'char *') -> "apr_size_t *":
    """svn_stream_read_full(svn_stream_t * stream, char * buffer) -> svn_error_t"""
    return _core.svn_stream_read_full(stream, buffer)

def svn_stream_supports_partial_read(stream: 'svn_stream_t *') -> "svn_boolean_t":
    """svn_stream_supports_partial_read(svn_stream_t * stream) -> svn_boolean_t"""
    return _core.svn_stream_supports_partial_read(stream)

def svn_stream_read2(stream: 'svn_stream_t *', buffer: 'char *') -> "apr_size_t *":
    """svn_stream_read2(svn_stream_t * stream, char * buffer) -> svn_error_t"""
    return _core.svn_stream_read2(stream, buffer)

def svn_stream_read(stream: 'svn_stream_t *', buffer: 'char *') -> "apr_size_t *":
    """svn_stream_read(svn_stream_t * stream, char * buffer) -> svn_error_t"""
    return _core.svn_stream_read(stream, buffer)

def svn_stream_skip(stream: 'svn_stream_t *', len: 'apr_size_t') -> "svn_error_t *":
    """svn_stream_skip(svn_stream_t * stream, apr_size_t len) -> svn_error_t"""
    return _core.svn_stream_skip(stream, len)

def svn_stream_write(stream: 'svn_stream_t *', data: 'char const *') -> "apr_size_t *":
    """svn_stream_write(svn_stream_t * stream, char const * data) -> svn_error_t"""
    return _core.svn_stream_write(stream, data)

def svn_stream_close(stream: 'svn_stream_t *') -> "svn_error_t *":
    """svn_stream_close(svn_stream_t * stream) -> svn_error_t"""
    return _core.svn_stream_close(stream)

def svn_stream_reset(stream: 'svn_stream_t *') -> "svn_error_t *":
    """svn_stream_reset(svn_stream_t * stream) -> svn_error_t"""
    return _core.svn_stream_reset(stream)

def svn_stream_supports_mark(stream: 'svn_stream_t *') -> "svn_boolean_t":
    """svn_stream_supports_mark(svn_stream_t * stream) -> svn_boolean_t"""
    return _core.svn_stream_supports_mark(stream)

def svn_stream_supports_reset(stream: 'svn_stream_t *') -> "svn_boolean_t":
    """svn_stream_supports_reset(svn_stream_t * stream) -> svn_boolean_t"""
    return _core.svn_stream_supports_reset(stream)

def svn_stream_mark(*args) -> "svn_stream_mark_t **":
    """svn_stream_mark(svn_stream_t * stream, apr_pool_t pool) -> svn_error_t"""
    return _core.svn_stream_mark(*args)

def svn_stream_seek(stream: 'svn_stream_t *', mark: 'svn_stream_mark_t const *') -> "svn_error_t *":
    """svn_stream_seek(svn_stream_t * stream, svn_stream_mark_t const * mark) -> svn_error_t"""
    return _core.svn_stream_seek(stream, mark)

def svn_stream_data_available(stream: 'svn_stream_t *') -> "svn_boolean_t *":
    """svn_stream_data_available(svn_stream_t * stream) -> svn_error_t"""
    return _core.svn_stream_data_available(stream)

def svn_stream_tee(*args) -> "svn_stream_t *":
    """svn_stream_tee(svn_stream_t * out1, svn_stream_t * out2, apr_pool_t pool) -> svn_stream_t *"""
    return _core.svn_stream_tee(*args)

def svn_stream_puts(stream: 'svn_stream_t *', str: 'char const *') -> "svn_error_t *":
    """svn_stream_puts(svn_stream_t * stream, char const * str) -> svn_error_t"""
    return _core.svn_stream_puts(stream, str)

def svn_stream_readline(*args) -> "svn_stringbuf_t **, svn_boolean_t *":
    """svn_stream_readline(svn_stream_t * stream, char const * eol, apr_pool_t pool) -> svn_error_t"""
    return _core.svn_stream_readline(*args)

def svn_stream_copy3(*args) -> "svn_error_t *":
    """svn_stream_copy3(svn_stream_t * arg1, svn_stream_t * to, svn_cancel_func_t cancel_func, apr_pool_t pool) -> svn_error_t"""
    return _core.svn_stream_copy3(*args)

def svn_stream_copy2(*args) -> "svn_error_t *":
    """svn_stream_copy2(svn_stream_t * arg1, svn_stream_t * to, svn_cancel_func_t cancel_func, apr_pool_t pool) -> svn_error_t"""
    return _core.svn_stream_copy2(*args)

def svn_stream_copy(*args) -> "svn_error_t *":
    """svn_stream_copy(svn_stream_t * arg1, svn_stream_t * to, apr_pool_t pool) -> svn_error_t"""
    return _core.svn_stream_copy(*args)

def svn_stream_contents_same2(*args) -> "svn_boolean_t *":
    """svn_stream_contents_same2(svn_stream_t * stream1, svn_stream_t * stream2, apr_pool_t pool) -> svn_error_t"""
    return _core.svn_stream_contents_same2(*args)

def svn_stream_contents_same(*args) -> "svn_boolean_t *":
    """svn_stream_contents_same(svn_stream_t * stream1, svn_stream_t * stream2, apr_pool_t pool) -> svn_error_t"""
    return _core.svn_stream_contents_same(*args)

def svn_string_from_stream2(*args) -> "svn_string_t **":
    """svn_string_from_stream2(svn_stream_t * stream, apr_size_t len_hint, apr_pool_t result_pool) -> svn_error_t"""
    return _core.svn_string_from_stream2(*args)

def svn_string_from_stream(*args) -> "svn_string_t **":
    """svn_string_from_stream(svn_stream_t * stream, apr_pool_t result_pool, apr_pool_t scratch_pool) -> svn_error_t"""
    return _core.svn_string_from_stream(*args)

def svn_stream_lazyopen_create(*args) -> "svn_stream_t *":
    """svn_stream_lazyopen_create(svn_stream_lazyopen_func_t open_func, void * open_baton, svn_boolean_t open_on_close, apr_pool_t result_pool) -> svn_stream_t *"""
    return _core.svn_stream_lazyopen_create(*args)

def svn_stringbuf_from_file2(*args) -> "svn_stringbuf_t **":
    """svn_stringbuf_from_file2(char const * filename, apr_pool_t pool) -> svn_error_t"""
    return _core.svn_stringbuf_from_file2(*args)

def svn_stringbuf_from_file(*args) -> "svn_stringbuf_t **":
    """svn_stringbuf_from_file(char const * filename, apr_pool_t pool) -> svn_error_t"""
    return _core.svn_stringbuf_from_file(*args)

def svn_stringbuf_from_aprfile(*args) -> "svn_stringbuf_t **":
    """svn_stringbuf_from_aprfile(apr_file_t file, apr_pool_t pool) -> svn_error_t"""
    return _core.svn_stringbuf_from_aprfile(*args)

def svn_io_remove_file2(*args) -> "svn_error_t *":
    """svn_io_remove_file2(char const * path, svn_boolean_t ignore_enoent, apr_pool_t scratch_pool) -> svn_error_t"""
    return _core.svn_io_remove_file2(*args)

def svn_io_remove_file(*args) -> "svn_error_t *":
    """svn_io_remove_file(char const * path, apr_pool_t pool) -> svn_error_t"""
    return _core.svn_io_remove_file(*args)

def svn_io_remove_dir2(*args) -> "svn_error_t *":
    """svn_io_remove_dir2(char const * path, svn_boolean_t ignore_enoent, svn_cancel_func_t cancel_func, apr_pool_t pool) -> svn_error_t"""
    return _core.svn_io_remove_dir2(*args)

def svn_io_remove_dir(*args) -> "svn_error_t *":
    """svn_io_remove_dir(char const * path, apr_pool_t pool) -> svn_error_t"""
    return _core.svn_io_remove_dir(*args)

def svn_io_get_dirents3(*args) -> "apr_hash_t **":
    """svn_io_get_dirents3(char const * path, svn_boolean_t only_check_type, apr_pool_t result_pool, apr_pool_t scratch_pool) -> svn_error_t"""
    return _core.svn_io_get_dirents3(*args)

def svn_io_stat_dirent2(*args) -> "svn_io_dirent2_t **":
    """svn_io_stat_dirent2(char const * path, svn_boolean_t verify_truename, svn_boolean_t ignore_enoent, apr_pool_t result_pool, apr_pool_t scratch_pool) -> svn_error_t"""
    return _core.svn_io_stat_dirent2(*args)

def svn_io_stat_dirent(*args) -> "svn_io_dirent2_t **":
    """svn_io_stat_dirent(char const * path, svn_boolean_t ignore_enoent, apr_pool_t result_pool, apr_pool_t scratch_pool) -> svn_error_t"""
    return _core.svn_io_stat_dirent(*args)

def svn_io_dir_walk2(*args) -> "svn_error_t *":
    """svn_io_dir_walk2(char const * dirname, apr_int32_t wanted, svn_io_walk_func_t walk_func, void * walk_baton, apr_pool_t pool) -> svn_error_t"""
    return _core.svn_io_dir_walk2(*args)

def svn_io_start_cmd3(*args) -> "svn_error_t *":
    """svn_io_start_cmd3(apr_proc_t * cmd_proc, char const * path, char const * cmd, char const *const * args, char const *const * env, svn_boolean_t inherit, svn_boolean_t infile_pipe, apr_file_t infile, svn_boolean_t outfile_pipe, apr_file_t outfile, svn_boolean_t errfile_pipe, apr_file_t errfile, apr_pool_t pool) -> svn_error_t"""
    return _core.svn_io_start_cmd3(*args)

def svn_io_start_cmd2(*args) -> "svn_error_t *":
    """svn_io_start_cmd2(apr_proc_t * cmd_proc, char const * path, char const * cmd, char const *const * args, svn_boolean_t inherit, svn_boolean_t infile_pipe, apr_file_t infile, svn_boolean_t outfile_pipe, apr_file_t outfile, svn_boolean_t errfile_pipe, apr_file_t errfile, apr_pool_t pool) -> svn_error_t"""
    return _core.svn_io_start_cmd2(*args)

def svn_io_run_diff2(*args) -> "int *":
    """svn_io_run_diff2(char const * dir, char const *const * user_args, int num_user_args, char const * label1, char const * label2, char const * arg6, char const * to, apr_file_t outfile, apr_file_t errfile, char const * diff_cmd, apr_pool_t pool) -> svn_error_t"""
    return _core.svn_io_run_diff2(*args)

def svn_io_run_diff3_3(*args) -> "int *":
    """svn_io_run_diff3_3(char const * dir, char const * mine, char const * older, char const * yours, char const * mine_label, char const * older_label, char const * yours_label, apr_file_t merged, char const * diff3_cmd, apr_array_header_t user_args, apr_pool_t pool) -> svn_error_t"""
    return _core.svn_io_run_diff3_3(*args)

def svn_io_parse_mimetypes_file(*args) -> "apr_hash_t **":
    """svn_io_parse_mimetypes_file(char const * mimetypes_file, apr_pool_t pool) -> svn_error_t"""
    return _core.svn_io_parse_mimetypes_file(*args)

def svn_io_detect_mimetype2(*args) -> "char const **":
    """svn_io_detect_mimetype2(char const * file, apr_hash_t mimetype_map, apr_pool_t pool) -> svn_error_t"""
    return _core.svn_io_detect_mimetype2(*args)

def svn_io_detect_mimetype(*args) -> "char const **":
    """svn_io_detect_mimetype(char const * file, apr_pool_t pool) -> svn_error_t"""
    return _core.svn_io_detect_mimetype(*args)

def svn_io_is_binary_data(buf: 'void const *', len: 'apr_size_t') -> "svn_boolean_t":
    """svn_io_is_binary_data(void const * buf, apr_size_t len) -> svn_boolean_t"""
    return _core.svn_io_is_binary_data(buf, len)

def svn_io_file_putc(*args) -> "svn_error_t *":
    """svn_io_file_putc(char ch, apr_file_t file, apr_pool_t pool) -> svn_error_t"""
    return _core.svn_io_file_putc(*args)

def svn_io_file_size_get(*args) -> "svn_filesize_t *":
    """svn_io_file_size_get(apr_file_t file, apr_pool_t pool) -> svn_error_t"""
    return _core.svn_io_file_size_get(*args)

def svn_io_file_get_offset(*args) -> "svn_error_t *":
    """svn_io_file_get_offset(apr_off_t * offset_p, apr_file_t file, apr_pool_t pool) -> svn_error_t"""
    return _core.svn_io_file_get_offset(*args)

def svn_io_file_read_full2(*args) -> "apr_size_t *, svn_boolean_t *":
    """svn_io_file_read_full2(apr_file_t file, void * buf, apr_size_t nbytes, apr_pool_t pool) -> svn_error_t"""
    return _core.svn_io_file_read_full2(*args)

def svn_io_file_aligned_seek(*args) -> "svn_error_t *":
    """svn_io_file_aligned_seek(apr_file_t file, apr_off_t block_size, apr_off_t * buffer_start, apr_off_t offset, apr_pool_t scratch_pool) -> svn_error_t"""
    return _core.svn_io_file_aligned_seek(*args)

def svn_io_file_flush(*args) -> "svn_error_t *":
    """svn_io_file_flush(apr_file_t file, apr_pool_t scratch_pool) -> svn_error_t"""
    return _core.svn_io_file_flush(*args)

def svn_io_write_atomic2(*args) -> "svn_error_t *":
    """svn_io_write_atomic2(char const * final_path, void const * buf, apr_size_t nbytes, char const * copy_perms_path, svn_boolean_t flush_to_disk, apr_pool_t scratch_pool) -> svn_error_t"""
    return _core.svn_io_write_atomic2(*args)

def svn_io_write_atomic(*args) -> "svn_error_t *":
    """svn_io_write_atomic(char const * final_path, void const * buf, apr_size_t nbytes, char const * copy_perms_path, apr_pool_t scratch_pool) -> svn_error_t"""
    return _core.svn_io_write_atomic(*args)

def svn_io_write_unique(*args) -> "char const **":
    """svn_io_write_unique(char const * dirpath, void const * buf, apr_size_t nbytes, svn_io_file_del_t delete_when, apr_pool_t pool) -> svn_error_t"""
    return _core.svn_io_write_unique(*args)

def svn_io_file_trunc(*args) -> "svn_error_t *":
    """svn_io_file_trunc(apr_file_t file, apr_off_t offset, apr_pool_t pool) -> svn_error_t"""
    return _core.svn_io_file_trunc(*args)

def svn_io_file_rename2(*args) -> "svn_error_t *":
    """svn_io_file_rename2(char const * from_path, char const * to_path, svn_boolean_t flush_to_disk, apr_pool_t pool) -> svn_error_t"""
    return _core.svn_io_file_rename2(*args)

def svn_io_dir_close(thedir: 'apr_dir_t *') -> "svn_error_t *":
    """svn_io_dir_close(apr_dir_t * thedir) -> svn_error_t"""
    return _core.svn_io_dir_close(thedir)

def svn_io_file_name_get(*args) -> "char const **":
    """svn_io_file_name_get(apr_file_t file, apr_pool_t pool) -> svn_error_t"""
    return _core.svn_io_file_name_get(*args)

def svn_io_file_readline(*args) -> "svn_stringbuf_t **, char const **, svn_boolean_t *":
    """svn_io_file_readline(apr_file_t file, apr_size_t max_len, apr_pool_t result_pool, apr_pool_t scratch_pool) -> svn_error_t"""
    return _core.svn_io_file_readline(*args)
class svn_stream_t(object):
    """Proxy of C svn_stream_t struct."""

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    def set_parent_pool(self, parent_pool=None):
      """Create a new proxy object for TYPE"""
      import libsvn.core, weakref
      self.__dict__["_parent_pool"] = \
        parent_pool or libsvn.core.application_pool;
      if self.__dict__["_parent_pool"]:
        self.__dict__["_is_valid"] = weakref.ref(
          self.__dict__["_parent_pool"]._is_valid)

    def assert_valid(self):
      """Assert that this object is using valid pool memory"""
      if "_is_valid" in self.__dict__:
        assert self.__dict__["_is_valid"](), "Variable has already been deleted"

    def _retrieve_swig_value(self, name, value):
    # If we got back a different object than we have cached, we need to copy
    # all our metadata into it, so that it looks identical to the one
    # originally set.
      members = self.__dict__.get('_members')
      if members is not None and name in members:
        _copy_metadata_deep(value, members[name])

    # Verify that the new object is good
      _assert_valid_deep(value)

      return value

    # Attribute access must be intercepted to ensure that objects coming from
    # read attribute access match those that are set with write attribute access.
    # Specifically the metadata, such as the associated apr_pool object, should
    # match the originally assigned object.
    #
    # For classic classes it is enough to use __getattr__ to intercept swig
    # derived attributes. However, with new style classes SWIG makes use of
    # descriptors which mean that __getattr__ is never called. Therefore,
    # __getattribute__ must be used for the interception.

    if _newclass:
      def __getattribute__(self, name):
        """Manage access to all attributes of this object."""

    # Start by mimicing __getattr__ behavior: immediately return __dict__ or
    # items directly present in __dict__
        mydict = object.__getattribute__(self, '__dict__')

        if name == "__dict__":
          return mydict

        if name in mydict:
          return mydict[name]

        object.__getattribute__(self, 'assert_valid')()

        value = _get_instance_attr(self, name)
        fn = object.__getattribute__(self, '_retrieve_swig_value')
        return fn(name, value)
    else:
      def __getattr__(self, name):
        """Get an attribute from this object"""
        self.assert_valid()

        value = _swig_getattr(self, self.__class__, name)

        return self._retrieve_swig_value(name, value)

    def __setattr__(self, name, value):
      """Set an attribute on this object"""
      self.assert_valid()

    # Save a copy of the object, so that the garbage
    # collector won't kill the object while it's in
    # SWIG-land
      self.__dict__.setdefault("_members",{})[name] = value

      return _set_instance_attr(self, name, value)

svn_stream_t_swigregister = _core.svn_stream_t_swigregister
svn_stream_t_swigregister(svn_stream_t)

class svn_stream_mark_t(object):
    """Proxy of C svn_stream_mark_t struct."""

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    def set_parent_pool(self, parent_pool=None):
      """Create a new proxy object for TYPE"""
      import libsvn.core, weakref
      self.__dict__["_parent_pool"] = \
        parent_pool or libsvn.core.application_pool;
      if self.__dict__["_parent_pool"]:
        self.__dict__["_is_valid"] = weakref.ref(
          self.__dict__["_parent_pool"]._is_valid)

    def assert_valid(self):
      """Assert that this object is using valid pool memory"""
      if "_is_valid" in self.__dict__:
        assert self.__dict__["_is_valid"](), "Variable has already been deleted"

    def _retrieve_swig_value(self, name, value):
    # If we got back a different object than we have cached, we need to copy
    # all our metadata into it, so that it looks identical to the one
    # originally set.
      members = self.__dict__.get('_members')
      if members is not None and name in members:
        _copy_metadata_deep(value, members[name])

    # Verify that the new object is good
      _assert_valid_deep(value)

      return value

    # Attribute access must be intercepted to ensure that objects coming from
    # read attribute access match those that are set with write attribute access.
    # Specifically the metadata, such as the associated apr_pool object, should
    # match the originally assigned object.
    #
    # For classic classes it is enough to use __getattr__ to intercept swig
    # derived attributes. However, with new style classes SWIG makes use of
    # descriptors which mean that __getattr__ is never called. Therefore,
    # __getattribute__ must be used for the interception.

    if _newclass:
      def __getattribute__(self, name):
        """Manage access to all attributes of this object."""

    # Start by mimicing __getattr__ behavior: immediately return __dict__ or
    # items directly present in __dict__
        mydict = object.__getattribute__(self, '__dict__')

        if name == "__dict__":
          return mydict

        if name in mydict:
          return mydict[name]

        object.__getattribute__(self, 'assert_valid')()

        value = _get_instance_attr(self, name)
        fn = object.__getattribute__(self, '_retrieve_swig_value')
        return fn(name, value)
    else:
      def __getattr__(self, name):
        """Get an attribute from this object"""
        self.assert_valid()

        value = _swig_getattr(self, self.__class__, name)

        return self._retrieve_swig_value(name, value)

    def __setattr__(self, name, value):
      """Set an attribute on this object"""
      self.assert_valid()

    # Save a copy of the object, so that the garbage
    # collector won't kill the object while it's in
    # SWIG-land
      self.__dict__.setdefault("_members",{})[name] = value

      return _set_instance_attr(self, name, value)

svn_stream_mark_t_swigregister = _core.svn_stream_mark_t_swigregister
svn_stream_mark_t_swigregister(svn_stream_mark_t)


def svn_read_invoke_fn(_obj: 'svn_read_fn_t', baton: 'void *', buffer: 'char *') -> "apr_size_t *":
    """svn_read_invoke_fn(svn_read_fn_t _obj, void * baton, char * buffer) -> svn_error_t"""
    return _core.svn_read_invoke_fn(_obj, baton, buffer)

def svn_stream_invoke_skip_fn(_obj: 'svn_stream_skip_fn_t', baton: 'void *', len: 'apr_size_t') -> "svn_error_t *":
    """svn_stream_invoke_skip_fn(svn_stream_skip_fn_t _obj, void * baton, apr_size_t len) -> svn_error_t"""
    return _core.svn_stream_invoke_skip_fn(_obj, baton, len)

def svn_write_invoke_fn(_obj: 'svn_write_fn_t', baton: 'void *', data: 'char const *') -> "apr_size_t *":
    """svn_write_invoke_fn(svn_write_fn_t _obj, void * baton, char const * data) -> svn_error_t"""
    return _core.svn_write_invoke_fn(_obj, baton, data)

def svn_close_invoke_fn(_obj: 'svn_close_fn_t', baton: 'void *') -> "svn_error_t *":
    """svn_close_invoke_fn(svn_close_fn_t _obj, void * baton) -> svn_error_t"""
    return _core.svn_close_invoke_fn(_obj, baton)

def svn_stream_invoke_mark_fn(*args) -> "svn_stream_mark_t **":
    """svn_stream_invoke_mark_fn(svn_stream_mark_fn_t _obj, void * baton, apr_pool_t pool) -> svn_error_t"""
    return _core.svn_stream_invoke_mark_fn(*args)

def svn_stream_invoke_seek_fn(_obj: 'svn_stream_seek_fn_t', baton: 'void *', mark: 'svn_stream_mark_t const *') -> "svn_error_t *":
    """svn_stream_invoke_seek_fn(svn_stream_seek_fn_t _obj, void * baton, svn_stream_mark_t const * mark) -> svn_error_t"""
    return _core.svn_stream_invoke_seek_fn(_obj, baton, mark)

def svn_stream_invoke_data_available_fn(_obj: 'svn_stream_data_available_fn_t', baton: 'void *') -> "svn_boolean_t *":
    """svn_stream_invoke_data_available_fn(svn_stream_data_available_fn_t _obj, void * baton) -> svn_error_t"""
    return _core.svn_stream_invoke_data_available_fn(_obj, baton)

def svn_stream_invoke_readline_fn(*args) -> "svn_stringbuf_t **, svn_boolean_t *":
    """svn_stream_invoke_readline_fn(svn_stream_readline_fn_t _obj, void * baton, char const * eol, apr_pool_t pool) -> svn_error_t"""
    return _core.svn_stream_invoke_readline_fn(*args)

def svn_stream_invoke_lazyopen_func(*args) -> "svn_stream_t **":
    """svn_stream_invoke_lazyopen_func(svn_stream_lazyopen_func_t _obj, void * baton, apr_pool_t result_pool, apr_pool_t scratch_pool) -> svn_error_t"""
    return _core.svn_stream_invoke_lazyopen_func(*args)

def svn_io_invoke_walk_func(*args) -> "svn_error_t *":
    """svn_io_invoke_walk_func(svn_io_walk_func_t _obj, void * baton, char const * path, apr_finfo_t const * finfo, apr_pool_t pool) -> svn_error_t"""
    return _core.svn_io_invoke_walk_func(*args)
class svn_read_fn_t(object):
    """Proxy of C svn_read_fn_t struct."""

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    def set_parent_pool(self, parent_pool=None):
      """Create a new proxy object for TYPE"""
      import libsvn.core, weakref
      self.__dict__["_parent_pool"] = \
        parent_pool or libsvn.core.application_pool;
      if self.__dict__["_parent_pool"]:
        self.__dict__["_is_valid"] = weakref.ref(
          self.__dict__["_parent_pool"]._is_valid)

    def assert_valid(self):
      """Assert that this object is using valid pool memory"""
      if "_is_valid" in self.__dict__:
        assert self.__dict__["_is_valid"](), "Variable has already been deleted"

    def _retrieve_swig_value(self, name, value):
    # If we got back a different object than we have cached, we need to copy
    # all our metadata into it, so that it looks identical to the one
    # originally set.
      members = self.__dict__.get('_members')
      if members is not None and name in members:
        _copy_metadata_deep(value, members[name])

    # Verify that the new object is good
      _assert_valid_deep(value)

      return value

    # Attribute access must be intercepted to ensure that objects coming from
    # read attribute access match those that are set with write attribute access.
    # Specifically the metadata, such as the associated apr_pool object, should
    # match the originally assigned object.
    #
    # For classic classes it is enough to use __getattr__ to intercept swig
    # derived attributes. However, with new style classes SWIG makes use of
    # descriptors which mean that __getattr__ is never called. Therefore,
    # __getattribute__ must be used for the interception.

    if _newclass:
      def __getattribute__(self, name):
        """Manage access to all attributes of this object."""

    # Start by mimicing __getattr__ behavior: immediately return __dict__ or
    # items directly present in __dict__
        mydict = object.__getattribute__(self, '__dict__')

        if name == "__dict__":
          return mydict

        if name in mydict:
          return mydict[name]

        object.__getattribute__(self, 'assert_valid')()

        value = _get_instance_attr(self, name)
        fn = object.__getattribute__(self, '_retrieve_swig_value')
        return fn(name, value)
    else:
      def __getattr__(self, name):
        """Get an attribute from this object"""
        self.assert_valid()

        value = _swig_getattr(self, self.__class__, name)

        return self._retrieve_swig_value(name, value)

    def __setattr__(self, name, value):
      """Set an attribute on this object"""
      self.assert_valid()

    # Save a copy of the object, so that the garbage
    # collector won't kill the object while it's in
    # SWIG-land
      self.__dict__.setdefault("_members",{})[name] = value

      return _set_instance_attr(self, name, value)


    def __call__(self, *args):
      return svn_read_invoke_fn(self, *args)

svn_read_fn_t_swigregister = _core.svn_read_fn_t_swigregister
svn_read_fn_t_swigregister(svn_read_fn_t)

class svn_stream_skip_fn_t(object):
    """Proxy of C svn_stream_skip_fn_t struct."""

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    def set_parent_pool(self, parent_pool=None):
      """Create a new proxy object for TYPE"""
      import libsvn.core, weakref
      self.__dict__["_parent_pool"] = \
        parent_pool or libsvn.core.application_pool;
      if self.__dict__["_parent_pool"]:
        self.__dict__["_is_valid"] = weakref.ref(
          self.__dict__["_parent_pool"]._is_valid)

    def assert_valid(self):
      """Assert that this object is using valid pool memory"""
      if "_is_valid" in self.__dict__:
        assert self.__dict__["_is_valid"](), "Variable has already been deleted"

    def _retrieve_swig_value(self, name, value):
    # If we got back a different object than we have cached, we need to copy
    # all our metadata into it, so that it looks identical to the one
    # originally set.
      members = self.__dict__.get('_members')
      if members is not None and name in members:
        _copy_metadata_deep(value, members[name])

    # Verify that the new object is good
      _assert_valid_deep(value)

      return value

    # Attribute access must be intercepted to ensure that objects coming from
    # read attribute access match those that are set with write attribute access.
    # Specifically the metadata, such as the associated apr_pool object, should
    # match the originally assigned object.
    #
    # For classic classes it is enough to use __getattr__ to intercept swig
    # derived attributes. However, with new style classes SWIG makes use of
    # descriptors which mean that __getattr__ is never called. Therefore,
    # __getattribute__ must be used for the interception.

    if _newclass:
      def __getattribute__(self, name):
        """Manage access to all attributes of this object."""

    # Start by mimicing __getattr__ behavior: immediately return __dict__ or
    # items directly present in __dict__
        mydict = object.__getattribute__(self, '__dict__')

        if name == "__dict__":
          return mydict

        if name in mydict:
          return mydict[name]

        object.__getattribute__(self, 'assert_valid')()

        value = _get_instance_attr(self, name)
        fn = object.__getattribute__(self, '_retrieve_swig_value')
        return fn(name, value)
    else:
      def __getattr__(self, name):
        """Get an attribute from this object"""
        self.assert_valid()

        value = _swig_getattr(self, self.__class__, name)

        return self._retrieve_swig_value(name, value)

    def __setattr__(self, name, value):
      """Set an attribute on this object"""
      self.assert_valid()

    # Save a copy of the object, so that the garbage
    # collector won't kill the object while it's in
    # SWIG-land
      self.__dict__.setdefault("_members",{})[name] = value

      return _set_instance_attr(self, name, value)


    def __call__(self, *args):
      return svn_stream_invoke_skip_fn(self, *args)

svn_stream_skip_fn_t_swigregister = _core.svn_stream_skip_fn_t_swigregister
svn_stream_skip_fn_t_swigregister(svn_stream_skip_fn_t)

class svn_write_fn_t(object):
    """Proxy of C svn_write_fn_t struct."""

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    def set_parent_pool(self, parent_pool=None):
      """Create a new proxy object for TYPE"""
      import libsvn.core, weakref
      self.__dict__["_parent_pool"] = \
        parent_pool or libsvn.core.application_pool;
      if self.__dict__["_parent_pool"]:
        self.__dict__["_is_valid"] = weakref.ref(
          self.__dict__["_parent_pool"]._is_valid)

    def assert_valid(self):
      """Assert that this object is using valid pool memory"""
      if "_is_valid" in self.__dict__:
        assert self.__dict__["_is_valid"](), "Variable has already been deleted"

    def _retrieve_swig_value(self, name, value):
    # If we got back a different object than we have cached, we need to copy
    # all our metadata into it, so that it looks identical to the one
    # originally set.
      members = self.__dict__.get('_members')
      if members is not None and name in members:
        _copy_metadata_deep(value, members[name])

    # Verify that the new object is good
      _assert_valid_deep(value)

      return value

    # Attribute access must be intercepted to ensure that objects coming from
    # read attribute access match those that are set with write attribute access.
    # Specifically the metadata, such as the associated apr_pool object, should
    # match the originally assigned object.
    #
    # For classic classes it is enough to use __getattr__ to intercept swig
    # derived attributes. However, with new style classes SWIG makes use of
    # descriptors which mean that __getattr__ is never called. Therefore,
    # __getattribute__ must be used for the interception.

    if _newclass:
      def __getattribute__(self, name):
        """Manage access to all attributes of this object."""

    # Start by mimicing __getattr__ behavior: immediately return __dict__ or
    # items directly present in __dict__
        mydict = object.__getattribute__(self, '__dict__')

        if name == "__dict__":
          return mydict

        if name in mydict:
          return mydict[name]

        object.__getattribute__(self, 'assert_valid')()

        value = _get_instance_attr(self, name)
        fn = object.__getattribute__(self, '_retrieve_swig_value')
        return fn(name, value)
    else:
      def __getattr__(self, name):
        """Get an attribute from this object"""
        self.assert_valid()

        value = _swig_getattr(self, self.__class__, name)

        return self._retrieve_swig_value(name, value)

    def __setattr__(self, name, value):
      """Set an attribute on this object"""
      self.assert_valid()

    # Save a copy of the object, so that the garbage
    # collector won't kill the object while it's in
    # SWIG-land
      self.__dict__.setdefault("_members",{})[name] = value

      return _set_instance_attr(self, name, value)


    def __call__(self, *args):
      return svn_write_invoke_fn(self, *args)

svn_write_fn_t_swigregister = _core.svn_write_fn_t_swigregister
svn_write_fn_t_swigregister(svn_write_fn_t)

class svn_close_fn_t(object):
    """Proxy of C svn_close_fn_t struct."""

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    def set_parent_pool(self, parent_pool=None):
      """Create a new proxy object for TYPE"""
      import libsvn.core, weakref
      self.__dict__["_parent_pool"] = \
        parent_pool or libsvn.core.application_pool;
      if self.__dict__["_parent_pool"]:
        self.__dict__["_is_valid"] = weakref.ref(
          self.__dict__["_parent_pool"]._is_valid)

    def assert_valid(self):
      """Assert that this object is using valid pool memory"""
      if "_is_valid" in self.__dict__:
        assert self.__dict__["_is_valid"](), "Variable has already been deleted"

    def _retrieve_swig_value(self, name, value):
    # If we got back a different object than we have cached, we need to copy
    # all our metadata into it, so that it looks identical to the one
    # originally set.
      members = self.__dict__.get('_members')
      if members is not None and name in members:
        _copy_metadata_deep(value, members[name])

    # Verify that the new object is good
      _assert_valid_deep(value)

      return value

    # Attribute access must be intercepted to ensure that objects coming from
    # read attribute access match those that are set with write attribute access.
    # Specifically the metadata, such as the associated apr_pool object, should
    # match the originally assigned object.
    #
    # For classic classes it is enough to use __getattr__ to intercept swig
    # derived attributes. However, with new style classes SWIG makes use of
    # descriptors which mean that __getattr__ is never called. Therefore,
    # __getattribute__ must be used for the interception.

    if _newclass:
      def __getattribute__(self, name):
        """Manage access to all attributes of this object."""

    # Start by mimicing __getattr__ behavior: immediately return __dict__ or
    # items directly present in __dict__
        mydict = object.__getattribute__(self, '__dict__')

        if name == "__dict__":
          return mydict

        if name in mydict:
          return mydict[name]

        object.__getattribute__(self, 'assert_valid')()

        value = _get_instance_attr(self, name)
        fn = object.__getattribute__(self, '_retrieve_swig_value')
        return fn(name, value)
    else:
      def __getattr__(self, name):
        """Get an attribute from this object"""
        self.assert_valid()

        value = _swig_getattr(self, self.__class__, name)

        return self._retrieve_swig_value(name, value)

    def __setattr__(self, name, value):
      """Set an attribute on this object"""
      self.assert_valid()

    # Save a copy of the object, so that the garbage
    # collector won't kill the object while it's in
    # SWIG-land
      self.__dict__.setdefault("_members",{})[name] = value

      return _set_instance_attr(self, name, value)


    def __call__(self, *args):
      return svn_close_invoke_fn(self, *args)

svn_close_fn_t_swigregister = _core.svn_close_fn_t_swigregister
svn_close_fn_t_swigregister(svn_close_fn_t)

class svn_stream_mark_fn_t(object):
    """Proxy of C svn_stream_mark_fn_t struct."""

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    def set_parent_pool(self, parent_pool=None):
      """Create a new proxy object for TYPE"""
      import libsvn.core, weakref
      self.__dict__["_parent_pool"] = \
        parent_pool or libsvn.core.application_pool;
      if self.__dict__["_parent_pool"]:
        self.__dict__["_is_valid"] = weakref.ref(
          self.__dict__["_parent_pool"]._is_valid)

    def assert_valid(self):
      """Assert that this object is using valid pool memory"""
      if "_is_valid" in self.__dict__:
        assert self.__dict__["_is_valid"](), "Variable has already been deleted"

    def _retrieve_swig_value(self, name, value):
    # If we got back a different object than we have cached, we need to copy
    # all our metadata into it, so that it looks identical to the one
    # originally set.
      members = self.__dict__.get('_members')
      if members is not None and name in members:
        _copy_metadata_deep(value, members[name])

    # Verify that the new object is good
      _assert_valid_deep(value)

      return value

    # Attribute access must be intercepted to ensure that objects coming from
    # read attribute access match those that are set with write attribute access.
    # Specifically the metadata, such as the associated apr_pool object, should
    # match the originally assigned object.
    #
    # For classic classes it is enough to use __getattr__ to intercept swig
    # derived attributes. However, with new style classes SWIG makes use of
    # descriptors which mean that __getattr__ is never called. Therefore,
    # __getattribute__ must be used for the interception.

    if _newclass:
      def __getattribute__(self, name):
        """Manage access to all attributes of this object."""

    # Start by mimicing __getattr__ behavior: immediately return __dict__ or
    # items directly present in __dict__
        mydict = object.__getattribute__(self, '__dict__')

        if name == "__dict__":
          return mydict

        if name in mydict:
          return mydict[name]

        object.__getattribute__(self, 'assert_valid')()

        value = _get_instance_attr(self, name)
        fn = object.__getattribute__(self, '_retrieve_swig_value')
        return fn(name, value)
    else:
      def __getattr__(self, name):
        """Get an attribute from this object"""
        self.assert_valid()

        value = _swig_getattr(self, self.__class__, name)

        return self._retrieve_swig_value(name, value)

    def __setattr__(self, name, value):
      """Set an attribute on this object"""
      self.assert_valid()

    # Save a copy of the object, so that the garbage
    # collector won't kill the object while it's in
    # SWIG-land
      self.__dict__.setdefault("_members",{})[name] = value

      return _set_instance_attr(self, name, value)


    def __call__(self, *args):
      return svn_stream_invoke_mark_fn(self, *args)

svn_stream_mark_fn_t_swigregister = _core.svn_stream_mark_fn_t_swigregister
svn_stream_mark_fn_t_swigregister(svn_stream_mark_fn_t)

class svn_stream_seek_fn_t(object):
    """Proxy of C svn_stream_seek_fn_t struct."""

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    def set_parent_pool(self, parent_pool=None):
      """Create a new proxy object for TYPE"""
      import libsvn.core, weakref
      self.__dict__["_parent_pool"] = \
        parent_pool or libsvn.core.application_pool;
      if self.__dict__["_parent_pool"]:
        self.__dict__["_is_valid"] = weakref.ref(
          self.__dict__["_parent_pool"]._is_valid)

    def assert_valid(self):
      """Assert that this object is using valid pool memory"""
      if "_is_valid" in self.__dict__:
        assert self.__dict__["_is_valid"](), "Variable has already been deleted"

    def _retrieve_swig_value(self, name, value):
    # If we got back a different object than we have cached, we need to copy
    # all our metadata into it, so that it looks identical to the one
    # originally set.
      members = self.__dict__.get('_members')
      if members is not None and name in members:
        _copy_metadata_deep(value, members[name])

    # Verify that the new object is good
      _assert_valid_deep(value)

      return value

    # Attribute access must be intercepted to ensure that objects coming from
    # read attribute access match those that are set with write attribute access.
    # Specifically the metadata, such as the associated apr_pool object, should
    # match the originally assigned object.
    #
    # For classic classes it is enough to use __getattr__ to intercept swig
    # derived attributes. However, with new style classes SWIG makes use of
    # descriptors which mean that __getattr__ is never called. Therefore,
    # __getattribute__ must be used for the interception.

    if _newclass:
      def __getattribute__(self, name):
        """Manage access to all attributes of this object."""

    # Start by mimicing __getattr__ behavior: immediately return __dict__ or
    # items directly present in __dict__
        mydict = object.__getattribute__(self, '__dict__')

        if name == "__dict__":
          return mydict

        if name in mydict:
          return mydict[name]

        object.__getattribute__(self, 'assert_valid')()

        value = _get_instance_attr(self, name)
        fn = object.__getattribute__(self, '_retrieve_swig_value')
        return fn(name, value)
    else:
      def __getattr__(self, name):
        """Get an attribute from this object"""
        self.assert_valid()

        value = _swig_getattr(self, self.__class__, name)

        return self._retrieve_swig_value(name, value)

    def __setattr__(self, name, value):
      """Set an attribute on this object"""
      self.assert_valid()

    # Save a copy of the object, so that the garbage
    # collector won't kill the object while it's in
    # SWIG-land
      self.__dict__.setdefault("_members",{})[name] = value

      return _set_instance_attr(self, name, value)


    def __call__(self, *args):
      return svn_stream_invoke_seek_fn(self, *args)

svn_stream_seek_fn_t_swigregister = _core.svn_stream_seek_fn_t_swigregister
svn_stream_seek_fn_t_swigregister(svn_stream_seek_fn_t)

class svn_stream_data_available_fn_t(object):
    """Proxy of C svn_stream_data_available_fn_t struct."""

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    def set_parent_pool(self, parent_pool=None):
      """Create a new proxy object for TYPE"""
      import libsvn.core, weakref
      self.__dict__["_parent_pool"] = \
        parent_pool or libsvn.core.application_pool;
      if self.__dict__["_parent_pool"]:
        self.__dict__["_is_valid"] = weakref.ref(
          self.__dict__["_parent_pool"]._is_valid)

    def assert_valid(self):
      """Assert that this object is using valid pool memory"""
      if "_is_valid" in self.__dict__:
        assert self.__dict__["_is_valid"](), "Variable has already been deleted"

    def _retrieve_swig_value(self, name, value):
    # If we got back a different object than we have cached, we need to copy
    # all our metadata into it, so that it looks identical to the one
    # originally set.
      members = self.__dict__.get('_members')
      if members is not None and name in members:
        _copy_metadata_deep(value, members[name])

    # Verify that the new object is good
      _assert_valid_deep(value)

      return value

    # Attribute access must be intercepted to ensure that objects coming from
    # read attribute access match those that are set with write attribute access.
    # Specifically the metadata, such as the associated apr_pool object, should
    # match the originally assigned object.
    #
    # For classic classes it is enough to use __getattr__ to intercept swig
    # derived attributes. However, with new style classes SWIG makes use of
    # descriptors which mean that __getattr__ is never called. Therefore,
    # __getattribute__ must be used for the interception.

    if _newclass:
      def __getattribute__(self, name):
        """Manage access to all attributes of this object."""

    # Start by mimicing __getattr__ behavior: immediately return __dict__ or
    # items directly present in __dict__
        mydict = object.__getattribute__(self, '__dict__')

        if name == "__dict__":
          return mydict

        if name in mydict:
          return mydict[name]

        object.__getattribute__(self, 'assert_valid')()

        value = _get_instance_attr(self, name)
        fn = object.__getattribute__(self, '_retrieve_swig_value')
        return fn(name, value)
    else:
      def __getattr__(self, name):
        """Get an attribute from this object"""
        self.assert_valid()

        value = _swig_getattr(self, self.__class__, name)

        return self._retrieve_swig_value(name, value)

    def __setattr__(self, name, value):
      """Set an attribute on this object"""
      self.assert_valid()

    # Save a copy of the object, so that the garbage
    # collector won't kill the object while it's in
    # SWIG-land
      self.__dict__.setdefault("_members",{})[name] = value

      return _set_instance_attr(self, name, value)


    def __call__(self, *args):
      return svn_stream_invoke_data_available_fn(self, *args)

svn_stream_data_available_fn_t_swigregister = _core.svn_stream_data_available_fn_t_swigregister
svn_stream_data_available_fn_t_swigregister(svn_stream_data_available_fn_t)

class svn_stream_readline_fn_t(object):
    """Proxy of C svn_stream_readline_fn_t struct."""

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    def set_parent_pool(self, parent_pool=None):
      """Create a new proxy object for TYPE"""
      import libsvn.core, weakref
      self.__dict__["_parent_pool"] = \
        parent_pool or libsvn.core.application_pool;
      if self.__dict__["_parent_pool"]:
        self.__dict__["_is_valid"] = weakref.ref(
          self.__dict__["_parent_pool"]._is_valid)

    def assert_valid(self):
      """Assert that this object is using valid pool memory"""
      if "_is_valid" in self.__dict__:
        assert self.__dict__["_is_valid"](), "Variable has already been deleted"

    def _retrieve_swig_value(self, name, value):
    # If we got back a different object than we have cached, we need to copy
    # all our metadata into it, so that it looks identical to the one
    # originally set.
      members = self.__dict__.get('_members')
      if members is not None and name in members:
        _copy_metadata_deep(value, members[name])

    # Verify that the new object is good
      _assert_valid_deep(value)

      return value

    # Attribute access must be intercepted to ensure that objects coming from
    # read attribute access match those that are set with write attribute access.
    # Specifically the metadata, such as the associated apr_pool object, should
    # match the originally assigned object.
    #
    # For classic classes it is enough to use __getattr__ to intercept swig
    # derived attributes. However, with new style classes SWIG makes use of
    # descriptors which mean that __getattr__ is never called. Therefore,
    # __getattribute__ must be used for the interception.

    if _newclass:
      def __getattribute__(self, name):
        """Manage access to all attributes of this object."""

    # Start by mimicing __getattr__ behavior: immediately return __dict__ or
    # items directly present in __dict__
        mydict = object.__getattribute__(self, '__dict__')

        if name == "__dict__":
          return mydict

        if name in mydict:
          return mydict[name]

        object.__getattribute__(self, 'assert_valid')()

        value = _get_instance_attr(self, name)
        fn = object.__getattribute__(self, '_retrieve_swig_value')
        return fn(name, value)
    else:
      def __getattr__(self, name):
        """Get an attribute from this object"""
        self.assert_valid()

        value = _swig_getattr(self, self.__class__, name)

        return self._retrieve_swig_value(name, value)

    def __setattr__(self, name, value):
      """Set an attribute on this object"""
      self.assert_valid()

    # Save a copy of the object, so that the garbage
    # collector won't kill the object while it's in
    # SWIG-land
      self.__dict__.setdefault("_members",{})[name] = value

      return _set_instance_attr(self, name, value)


    def __call__(self, *args):
      return svn_stream_invoke_readline_fn(self, *args)

svn_stream_readline_fn_t_swigregister = _core.svn_stream_readline_fn_t_swigregister
svn_stream_readline_fn_t_swigregister(svn_stream_readline_fn_t)

class svn_stream_lazyopen_func_t(object):
    """Proxy of C svn_stream_lazyopen_func_t struct."""

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    def set_parent_pool(self, parent_pool=None):
      """Create a new proxy object for TYPE"""
      import libsvn.core, weakref
      self.__dict__["_parent_pool"] = \
        parent_pool or libsvn.core.application_pool;
      if self.__dict__["_parent_pool"]:
        self.__dict__["_is_valid"] = weakref.ref(
          self.__dict__["_parent_pool"]._is_valid)

    def assert_valid(self):
      """Assert that this object is using valid pool memory"""
      if "_is_valid" in self.__dict__:
        assert self.__dict__["_is_valid"](), "Variable has already been deleted"

    def _retrieve_swig_value(self, name, value):
    # If we got back a different object than we have cached, we need to copy
    # all our metadata into it, so that it looks identical to the one
    # originally set.
      members = self.__dict__.get('_members')
      if members is not None and name in members:
        _copy_metadata_deep(value, members[name])

    # Verify that the new object is good
      _assert_valid_deep(value)

      return value

    # Attribute access must be intercepted to ensure that objects coming from
    # read attribute access match those that are set with write attribute access.
    # Specifically the metadata, such as the associated apr_pool object, should
    # match the originally assigned object.
    #
    # For classic classes it is enough to use __getattr__ to intercept swig
    # derived attributes. However, with new style classes SWIG makes use of
    # descriptors which mean that __getattr__ is never called. Therefore,
    # __getattribute__ must be used for the interception.

    if _newclass:
      def __getattribute__(self, name):
        """Manage access to all attributes of this object."""

    # Start by mimicing __getattr__ behavior: immediately return __dict__ or
    # items directly present in __dict__
        mydict = object.__getattribute__(self, '__dict__')

        if name == "__dict__":
          return mydict

        if name in mydict:
          return mydict[name]

        object.__getattribute__(self, 'assert_valid')()

        value = _get_instance_attr(self, name)
        fn = object.__getattribute__(self, '_retrieve_swig_value')
        return fn(name, value)
    else:
      def __getattr__(self, name):
        """Get an attribute from this object"""
        self.assert_valid()

        value = _swig_getattr(self, self.__class__, name)

        return self._retrieve_swig_value(name, value)

    def __setattr__(self, name, value):
      """Set an attribute on this object"""
      self.assert_valid()

    # Save a copy of the object, so that the garbage
    # collector won't kill the object while it's in
    # SWIG-land
      self.__dict__.setdefault("_members",{})[name] = value

      return _set_instance_attr(self, name, value)


    def __call__(self, *args):
      return svn_stream_invoke_lazyopen_func(self, *args)

svn_stream_lazyopen_func_t_swigregister = _core.svn_stream_lazyopen_func_t_swigregister
svn_stream_lazyopen_func_t_swigregister(svn_stream_lazyopen_func_t)

class svn_io_walk_func_t(object):
    """Proxy of C svn_io_walk_func_t struct."""

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    def set_parent_pool(self, parent_pool=None):
      """Create a new proxy object for TYPE"""
      import libsvn.core, weakref
      self.__dict__["_parent_pool"] = \
        parent_pool or libsvn.core.application_pool;
      if self.__dict__["_parent_pool"]:
        self.__dict__["_is_valid"] = weakref.ref(
          self.__dict__["_parent_pool"]._is_valid)

    def assert_valid(self):
      """Assert that this object is using valid pool memory"""
      if "_is_valid" in self.__dict__:
        assert self.__dict__["_is_valid"](), "Variable has already been deleted"

    def _retrieve_swig_value(self, name, value):
    # If we got back a different object than we have cached, we need to copy
    # all our metadata into it, so that it looks identical to the one
    # originally set.
      members = self.__dict__.get('_members')
      if members is not None and name in members:
        _copy_metadata_deep(value, members[name])

    # Verify that the new object is good
      _assert_valid_deep(value)

      return value

    # Attribute access must be intercepted to ensure that objects coming from
    # read attribute access match those that are set with write attribute access.
    # Specifically the metadata, such as the associated apr_pool object, should
    # match the originally assigned object.
    #
    # For classic classes it is enough to use __getattr__ to intercept swig
    # derived attributes. However, with new style classes SWIG makes use of
    # descriptors which mean that __getattr__ is never called. Therefore,
    # __getattribute__ must be used for the interception.

    if _newclass:
      def __getattribute__(self, name):
        """Manage access to all attributes of this object."""

    # Start by mimicing __getattr__ behavior: immediately return __dict__ or
    # items directly present in __dict__
        mydict = object.__getattribute__(self, '__dict__')

        if name == "__dict__":
          return mydict

        if name in mydict:
          return mydict[name]

        object.__getattribute__(self, 'assert_valid')()

        value = _get_instance_attr(self, name)
        fn = object.__getattribute__(self, '_retrieve_swig_value')
        return fn(name, value)
    else:
      def __getattr__(self, name):
        """Get an attribute from this object"""
        self.assert_valid()

        value = _swig_getattr(self, self.__class__, name)

        return self._retrieve_swig_value(name, value)

    def __setattr__(self, name, value):
      """Set an attribute on this object"""
      self.assert_valid()

    # Save a copy of the object, so that the garbage
    # collector won't kill the object while it's in
    # SWIG-land
      self.__dict__.setdefault("_members",{})[name] = value

      return _set_instance_attr(self, name, value)


    def __call__(self, *args):
      return svn_io_invoke_walk_func(self, *args)

svn_io_walk_func_t_swigregister = _core.svn_io_walk_func_t_swigregister
svn_io_walk_func_t_swigregister(svn_io_walk_func_t)

svn_checksum_md5 = _core.svn_checksum_md5
svn_checksum_sha1 = _core.svn_checksum_sha1
svn_checksum_fnv1a_32 = _core.svn_checksum_fnv1a_32
svn_checksum_fnv1a_32x4 = _core.svn_checksum_fnv1a_32x4
class svn_checksum_t(object):
    """Proxy of C svn_checksum_t struct."""

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    digest = _swig_property(_core.svn_checksum_t_digest_get, _core.svn_checksum_t_digest_set)
    kind = _swig_property(_core.svn_checksum_t_kind_get, _core.svn_checksum_t_kind_set)
    def set_parent_pool(self, parent_pool=None):
      """Create a new proxy object for TYPE"""
      import libsvn.core, weakref
      self.__dict__["_parent_pool"] = \
        parent_pool or libsvn.core.application_pool;
      if self.__dict__["_parent_pool"]:
        self.__dict__["_is_valid"] = weakref.ref(
          self.__dict__["_parent_pool"]._is_valid)

    def assert_valid(self):
      """Assert that this object is using valid pool memory"""
      if "_is_valid" in self.__dict__:
        assert self.__dict__["_is_valid"](), "Variable has already been deleted"

    def _retrieve_swig_value(self, name, value):
    # If we got back a different object than we have cached, we need to copy
    # all our metadata into it, so that it looks identical to the one
    # originally set.
      members = self.__dict__.get('_members')
      if members is not None and name in members:
        _copy_metadata_deep(value, members[name])

    # Verify that the new object is good
      _assert_valid_deep(value)

      return value

    # Attribute access must be intercepted to ensure that objects coming from
    # read attribute access match those that are set with write attribute access.
    # Specifically the metadata, such as the associated apr_pool object, should
    # match the originally assigned object.
    #
    # For classic classes it is enough to use __getattr__ to intercept swig
    # derived attributes. However, with new style classes SWIG makes use of
    # descriptors which mean that __getattr__ is never called. Therefore,
    # __getattribute__ must be used for the interception.

    if _newclass:
      def __getattribute__(self, name):
        """Manage access to all attributes of this object."""

    # Start by mimicing __getattr__ behavior: immediately return __dict__ or
    # items directly present in __dict__
        mydict = object.__getattribute__(self, '__dict__')

        if name == "__dict__":
          return mydict

        if name in mydict:
          return mydict[name]

        object.__getattribute__(self, 'assert_valid')()

        value = _get_instance_attr(self, name)
        fn = object.__getattribute__(self, '_retrieve_swig_value')
        return fn(name, value)
    else:
      def __getattr__(self, name):
        """Get an attribute from this object"""
        self.assert_valid()

        value = _swig_getattr(self, self.__class__, name)

        return self._retrieve_swig_value(name, value)

    def __setattr__(self, name, value):
      """Set an attribute on this object"""
      self.assert_valid()

    # Save a copy of the object, so that the garbage
    # collector won't kill the object while it's in
    # SWIG-land
      self.__dict__.setdefault("_members",{})[name] = value

      return _set_instance_attr(self, name, value)


    def __init__(self):
        """__init__(svn_checksum_t self) -> svn_checksum_t"""
        this = _core.new_svn_checksum_t()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _core.delete_svn_checksum_t
    __del__ = lambda self: None
svn_checksum_t_swigregister = _core.svn_checksum_t_swigregister
svn_checksum_t_swigregister(svn_checksum_t)


def svn_checksum_create(*args) -> "svn_checksum_t *":
    """svn_checksum_create(svn_checksum_kind_t kind, apr_pool_t pool) -> svn_checksum_t"""
    return _core.svn_checksum_create(*args)

def svn_checksum_clear(checksum: 'svn_checksum_t') -> "svn_error_t *":
    """svn_checksum_clear(svn_checksum_t checksum) -> svn_error_t"""
    return _core.svn_checksum_clear(checksum)

def svn_checksum_match(checksum1: 'svn_checksum_t', checksum2: 'svn_checksum_t') -> "svn_boolean_t":
    """svn_checksum_match(svn_checksum_t checksum1, svn_checksum_t checksum2) -> svn_boolean_t"""
    return _core.svn_checksum_match(checksum1, checksum2)

def svn_checksum_dup(*args) -> "svn_checksum_t *":
    """svn_checksum_dup(svn_checksum_t checksum, apr_pool_t pool) -> svn_checksum_t"""
    return _core.svn_checksum_dup(*args)

def svn_checksum_to_cstring_display(*args) -> "char const *":
    """svn_checksum_to_cstring_display(svn_checksum_t checksum, apr_pool_t pool) -> char const *"""
    return _core.svn_checksum_to_cstring_display(*args)

def svn_checksum_to_cstring(*args) -> "char const *":
    """svn_checksum_to_cstring(svn_checksum_t checksum, apr_pool_t pool) -> char const *"""
    return _core.svn_checksum_to_cstring(*args)

def svn_checksum_serialize(*args) -> "char const *":
    """svn_checksum_serialize(svn_checksum_t checksum, apr_pool_t result_pool, apr_pool_t scratch_pool) -> char const *"""
    return _core.svn_checksum_serialize(*args)

def svn_checksum_deserialize(*args) -> "svn_checksum_t **":
    """svn_checksum_deserialize(char const * data, apr_pool_t result_pool, apr_pool_t scratch_pool) -> svn_error_t"""
    return _core.svn_checksum_deserialize(*args)

def svn_checksum_parse_hex(*args) -> "svn_checksum_t **":
    """svn_checksum_parse_hex(svn_checksum_kind_t kind, char const * hex, apr_pool_t pool) -> svn_error_t"""
    return _core.svn_checksum_parse_hex(*args)

def svn_checksum(*args) -> "svn_checksum_t **":
    """svn_checksum(svn_checksum_kind_t kind, void const * data, apr_size_t len, apr_pool_t pool) -> svn_error_t"""
    return _core.svn_checksum(*args)

def svn_checksum_empty_checksum(*args) -> "svn_checksum_t *":
    """svn_checksum_empty_checksum(svn_checksum_kind_t kind, apr_pool_t pool) -> svn_checksum_t"""
    return _core.svn_checksum_empty_checksum(*args)

def svn_checksum_ctx_create(*args) -> "svn_checksum_ctx_t *":
    """svn_checksum_ctx_create(svn_checksum_kind_t kind, apr_pool_t pool) -> svn_checksum_ctx_t *"""
    return _core.svn_checksum_ctx_create(*args)

def svn_checksum_ctx_reset(ctx: 'svn_checksum_ctx_t *') -> "svn_error_t *":
    """svn_checksum_ctx_reset(svn_checksum_ctx_t * ctx) -> svn_error_t"""
    return _core.svn_checksum_ctx_reset(ctx)

def svn_checksum_update(ctx: 'svn_checksum_ctx_t *', data: 'void const *', len: 'apr_size_t') -> "svn_error_t *":
    """svn_checksum_update(svn_checksum_ctx_t * ctx, void const * data, apr_size_t len) -> svn_error_t"""
    return _core.svn_checksum_update(ctx, data, len)

def svn_checksum_final(*args) -> "svn_checksum_t **":
    """svn_checksum_final(svn_checksum_ctx_t const * ctx, apr_pool_t pool) -> svn_error_t"""
    return _core.svn_checksum_final(*args)

def svn_checksum_size(checksum: 'svn_checksum_t') -> "apr_size_t":
    """svn_checksum_size(svn_checksum_t checksum) -> apr_size_t"""
    return _core.svn_checksum_size(checksum)

def svn_checksum_is_empty_checksum(checksum: 'svn_checksum_t') -> "svn_boolean_t":
    """svn_checksum_is_empty_checksum(svn_checksum_t checksum) -> svn_boolean_t"""
    return _core.svn_checksum_is_empty_checksum(checksum)

def svn_checksum_mismatch_err(*args) -> "svn_error_t *":
    """svn_checksum_mismatch_err(svn_checksum_t expected, svn_checksum_t actual, apr_pool_t scratch_pool, char const * fmt) -> svn_error_t"""
    return _core.svn_checksum_mismatch_err(*args)
class svn_checksum_ctx_t(object):
    """Proxy of C svn_checksum_ctx_t struct."""

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    def set_parent_pool(self, parent_pool=None):
      """Create a new proxy object for TYPE"""
      import libsvn.core, weakref
      self.__dict__["_parent_pool"] = \
        parent_pool or libsvn.core.application_pool;
      if self.__dict__["_parent_pool"]:
        self.__dict__["_is_valid"] = weakref.ref(
          self.__dict__["_parent_pool"]._is_valid)

    def assert_valid(self):
      """Assert that this object is using valid pool memory"""
      if "_is_valid" in self.__dict__:
        assert self.__dict__["_is_valid"](), "Variable has already been deleted"

    def _retrieve_swig_value(self, name, value):
    # If we got back a different object than we have cached, we need to copy
    # all our metadata into it, so that it looks identical to the one
    # originally set.
      members = self.__dict__.get('_members')
      if members is not None and name in members:
        _copy_metadata_deep(value, members[name])

    # Verify that the new object is good
      _assert_valid_deep(value)

      return value

    # Attribute access must be intercepted to ensure that objects coming from
    # read attribute access match those that are set with write attribute access.
    # Specifically the metadata, such as the associated apr_pool object, should
    # match the originally assigned object.
    #
    # For classic classes it is enough to use __getattr__ to intercept swig
    # derived attributes. However, with new style classes SWIG makes use of
    # descriptors which mean that __getattr__ is never called. Therefore,
    # __getattribute__ must be used for the interception.

    if _newclass:
      def __getattribute__(self, name):
        """Manage access to all attributes of this object."""

    # Start by mimicing __getattr__ behavior: immediately return __dict__ or
    # items directly present in __dict__
        mydict = object.__getattribute__(self, '__dict__')

        if name == "__dict__":
          return mydict

        if name in mydict:
          return mydict[name]

        object.__getattribute__(self, 'assert_valid')()

        value = _get_instance_attr(self, name)
        fn = object.__getattribute__(self, '_retrieve_swig_value')
        return fn(name, value)
    else:
      def __getattr__(self, name):
        """Get an attribute from this object"""
        self.assert_valid()

        value = _swig_getattr(self, self.__class__, name)

        return self._retrieve_swig_value(name, value)

    def __setattr__(self, name, value):
      """Set an attribute on this object"""
      self.assert_valid()

    # Save a copy of the object, so that the garbage
    # collector won't kill the object while it's in
    # SWIG-land
      self.__dict__.setdefault("_members",{})[name] = value

      return _set_instance_attr(self, name, value)

svn_checksum_ctx_t_swigregister = _core.svn_checksum_ctx_t_swigregister
svn_checksum_ctx_t_swigregister(svn_checksum_ctx_t)

class svn_cache_config_t(object):
    """Proxy of C svn_cache_config_t struct."""

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    cache_size = _swig_property(_core.svn_cache_config_t_cache_size_get, _core.svn_cache_config_t_cache_size_set)
    file_handle_count = _swig_property(_core.svn_cache_config_t_file_handle_count_get, _core.svn_cache_config_t_file_handle_count_set)
    single_threaded = _swig_property(_core.svn_cache_config_t_single_threaded_get, _core.svn_cache_config_t_single_threaded_set)
    def set_parent_pool(self, parent_pool=None):
      """Create a new proxy object for TYPE"""
      import libsvn.core, weakref
      self.__dict__["_parent_pool"] = \
        parent_pool or libsvn.core.application_pool;
      if self.__dict__["_parent_pool"]:
        self.__dict__["_is_valid"] = weakref.ref(
          self.__dict__["_parent_pool"]._is_valid)

    def assert_valid(self):
      """Assert that this object is using valid pool memory"""
      if "_is_valid" in self.__dict__:
        assert self.__dict__["_is_valid"](), "Variable has already been deleted"

    def _retrieve_swig_value(self, name, value):
    # If we got back a different object than we have cached, we need to copy
    # all our metadata into it, so that it looks identical to the one
    # originally set.
      members = self.__dict__.get('_members')
      if members is not None and name in members:
        _copy_metadata_deep(value, members[name])

    # Verify that the new object is good
      _assert_valid_deep(value)

      return value

    # Attribute access must be intercepted to ensure that objects coming from
    # read attribute access match those that are set with write attribute access.
    # Specifically the metadata, such as the associated apr_pool object, should
    # match the originally assigned object.
    #
    # For classic classes it is enough to use __getattr__ to intercept swig
    # derived attributes. However, with new style classes SWIG makes use of
    # descriptors which mean that __getattr__ is never called. Therefore,
    # __getattribute__ must be used for the interception.

    if _newclass:
      def __getattribute__(self, name):
        """Manage access to all attributes of this object."""

    # Start by mimicing __getattr__ behavior: immediately return __dict__ or
    # items directly present in __dict__
        mydict = object.__getattribute__(self, '__dict__')

        if name == "__dict__":
          return mydict

        if name in mydict:
          return mydict[name]

        object.__getattribute__(self, 'assert_valid')()

        value = _get_instance_attr(self, name)
        fn = object.__getattribute__(self, '_retrieve_swig_value')
        return fn(name, value)
    else:
      def __getattr__(self, name):
        """Get an attribute from this object"""
        self.assert_valid()

        value = _swig_getattr(self, self.__class__, name)

        return self._retrieve_swig_value(name, value)

    def __setattr__(self, name, value):
      """Set an attribute on this object"""
      self.assert_valid()

    # Save a copy of the object, so that the garbage
    # collector won't kill the object while it's in
    # SWIG-land
      self.__dict__.setdefault("_members",{})[name] = value

      return _set_instance_attr(self, name, value)


    def __init__(self):
        """__init__(svn_cache_config_t self) -> svn_cache_config_t"""
        this = _core.new_svn_cache_config_t()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _core.delete_svn_cache_config_t
    __del__ = lambda self: None
svn_cache_config_t_swigregister = _core.svn_cache_config_t_swigregister
svn_cache_config_t_swigregister(svn_cache_config_t)


def svn_cache_config_get() -> "svn_cache_config_t const *":
    """svn_cache_config_get() -> svn_cache_config_t"""
    return _core.svn_cache_config_get()

def svn_cache_config_set(settings: 'svn_cache_config_t') -> "void":
    """svn_cache_config_set(svn_cache_config_t settings)"""
    return _core.svn_cache_config_set(settings)

def svn_auth_set_gnome_keyring_unlock_prompt_func(ab: 'svn_auth_baton_t *', prompt_func: 'svn_auth_gnome_keyring_unlock_prompt_func_t') -> "void":
    """svn_auth_set_gnome_keyring_unlock_prompt_func(svn_auth_baton_t * ab, svn_auth_gnome_keyring_unlock_prompt_func_t prompt_func)"""
    return _core.svn_auth_set_gnome_keyring_unlock_prompt_func(ab, prompt_func)

def svn_swig_py_set_application_pool(*args) -> "void":
    """svn_swig_py_set_application_pool(PyObject * py_pool, apr_pool_t pool)"""
    return _core.svn_swig_py_set_application_pool(*args)

def svn_swig_py_clear_application_pool() -> "void":
    """svn_swig_py_clear_application_pool()"""
    return _core.svn_swig_py_clear_application_pool()
class apr_array_header_t(object):
    """Proxy of C apr_array_header_t struct."""

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    def set_parent_pool(self, parent_pool=None):
      """Create a new proxy object for TYPE"""
      import libsvn.core, weakref
      self.__dict__["_parent_pool"] = \
        parent_pool or libsvn.core.application_pool;
      if self.__dict__["_parent_pool"]:
        self.__dict__["_is_valid"] = weakref.ref(
          self.__dict__["_parent_pool"]._is_valid)

    def assert_valid(self):
      """Assert that this object is using valid pool memory"""
      if "_is_valid" in self.__dict__:
        assert self.__dict__["_is_valid"](), "Variable has already been deleted"

    def _retrieve_swig_value(self, name, value):
    # If we got back a different object than we have cached, we need to copy
    # all our metadata into it, so that it looks identical to the one
    # originally set.
      members = self.__dict__.get('_members')
      if members is not None and name in members:
        _copy_metadata_deep(value, members[name])

    # Verify that the new object is good
      _assert_valid_deep(value)

      return value

    # Attribute access must be intercepted to ensure that objects coming from
    # read attribute access match those that are set with write attribute access.
    # Specifically the metadata, such as the associated apr_pool object, should
    # match the originally assigned object.
    #
    # For classic classes it is enough to use __getattr__ to intercept swig
    # derived attributes. However, with new style classes SWIG makes use of
    # descriptors which mean that __getattr__ is never called. Therefore,
    # __getattribute__ must be used for the interception.

    if _newclass:
      def __getattribute__(self, name):
        """Manage access to all attributes of this object."""

    # Start by mimicing __getattr__ behavior: immediately return __dict__ or
    # items directly present in __dict__
        mydict = object.__getattribute__(self, '__dict__')

        if name == "__dict__":
          return mydict

        if name in mydict:
          return mydict[name]

        object.__getattribute__(self, 'assert_valid')()

        value = _get_instance_attr(self, name)
        fn = object.__getattribute__(self, '_retrieve_swig_value')
        return fn(name, value)
    else:
      def __getattr__(self, name):
        """Get an attribute from this object"""
        self.assert_valid()

        value = _swig_getattr(self, self.__class__, name)

        return self._retrieve_swig_value(name, value)

    def __setattr__(self, name, value):
      """Set an attribute on this object"""
      self.assert_valid()

    # Save a copy of the object, so that the garbage
    # collector won't kill the object while it's in
    # SWIG-land
      self.__dict__.setdefault("_members",{})[name] = value

      return _set_instance_attr(self, name, value)

apr_array_header_t_swigregister = _core.apr_array_header_t_swigregister
apr_array_header_t_swigregister(apr_array_header_t)

class apr_file_t(object):
    """Proxy of C apr_file_t struct."""

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    def set_parent_pool(self, parent_pool=None):
      """Create a new proxy object for TYPE"""
      import libsvn.core, weakref
      self.__dict__["_parent_pool"] = \
        parent_pool or libsvn.core.application_pool;
      if self.__dict__["_parent_pool"]:
        self.__dict__["_is_valid"] = weakref.ref(
          self.__dict__["_parent_pool"]._is_valid)

    def assert_valid(self):
      """Assert that this object is using valid pool memory"""
      if "_is_valid" in self.__dict__:
        assert self.__dict__["_is_valid"](), "Variable has already been deleted"

    def _retrieve_swig_value(self, name, value):
    # If we got back a different object than we have cached, we need to copy
    # all our metadata into it, so that it looks identical to the one
    # originally set.
      members = self.__dict__.get('_members')
      if members is not None and name in members:
        _copy_metadata_deep(value, members[name])

    # Verify that the new object is good
      _assert_valid_deep(value)

      return value

    # Attribute access must be intercepted to ensure that objects coming from
    # read attribute access match those that are set with write attribute access.
    # Specifically the metadata, such as the associated apr_pool object, should
    # match the originally assigned object.
    #
    # For classic classes it is enough to use __getattr__ to intercept swig
    # derived attributes. However, with new style classes SWIG makes use of
    # descriptors which mean that __getattr__ is never called. Therefore,
    # __getattribute__ must be used for the interception.

    if _newclass:
      def __getattribute__(self, name):
        """Manage access to all attributes of this object."""

    # Start by mimicing __getattr__ behavior: immediately return __dict__ or
    # items directly present in __dict__
        mydict = object.__getattribute__(self, '__dict__')

        if name == "__dict__":
          return mydict

        if name in mydict:
          return mydict[name]

        object.__getattribute__(self, 'assert_valid')()

        value = _get_instance_attr(self, name)
        fn = object.__getattribute__(self, '_retrieve_swig_value')
        return fn(name, value)
    else:
      def __getattr__(self, name):
        """Get an attribute from this object"""
        self.assert_valid()

        value = _swig_getattr(self, self.__class__, name)

        return self._retrieve_swig_value(name, value)

    def __setattr__(self, name, value):
      """Set an attribute on this object"""
      self.assert_valid()

    # Save a copy of the object, so that the garbage
    # collector won't kill the object while it's in
    # SWIG-land
      self.__dict__.setdefault("_members",{})[name] = value

      return _set_instance_attr(self, name, value)

apr_file_t_swigregister = _core.apr_file_t_swigregister
apr_file_t_swigregister(apr_file_t)

class apr_hash_t(object):
    """Proxy of C apr_hash_t struct."""

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    def set_parent_pool(self, parent_pool=None):
      """Create a new proxy object for TYPE"""
      import libsvn.core, weakref
      self.__dict__["_parent_pool"] = \
        parent_pool or libsvn.core.application_pool;
      if self.__dict__["_parent_pool"]:
        self.__dict__["_is_valid"] = weakref.ref(
          self.__dict__["_parent_pool"]._is_valid)

    def assert_valid(self):
      """Assert that this object is using valid pool memory"""
      if "_is_valid" in self.__dict__:
        assert self.__dict__["_is_valid"](), "Variable has already been deleted"

    def _retrieve_swig_value(self, name, value):
    # If we got back a different object than we have cached, we need to copy
    # all our metadata into it, so that it looks identical to the one
    # originally set.
      members = self.__dict__.get('_members')
      if members is not None and name in members:
        _copy_metadata_deep(value, members[name])

    # Verify that the new object is good
      _assert_valid_deep(value)

      return value

    # Attribute access must be intercepted to ensure that objects coming from
    # read attribute access match those that are set with write attribute access.
    # Specifically the metadata, such as the associated apr_pool object, should
    # match the originally assigned object.
    #
    # For classic classes it is enough to use __getattr__ to intercept swig
    # derived attributes. However, with new style classes SWIG makes use of
    # descriptors which mean that __getattr__ is never called. Therefore,
    # __getattribute__ must be used for the interception.

    if _newclass:
      def __getattribute__(self, name):
        """Manage access to all attributes of this object."""

    # Start by mimicing __getattr__ behavior: immediately return __dict__ or
    # items directly present in __dict__
        mydict = object.__getattribute__(self, '__dict__')

        if name == "__dict__":
          return mydict

        if name in mydict:
          return mydict[name]

        object.__getattribute__(self, 'assert_valid')()

        value = _get_instance_attr(self, name)
        fn = object.__getattribute__(self, '_retrieve_swig_value')
        return fn(name, value)
    else:
      def __getattr__(self, name):
        """Get an attribute from this object"""
        self.assert_valid()

        value = _swig_getattr(self, self.__class__, name)

        return self._retrieve_swig_value(name, value)

    def __setattr__(self, name, value):
      """Set an attribute on this object"""
      self.assert_valid()

    # Save a copy of the object, so that the garbage
    # collector won't kill the object while it's in
    # SWIG-land
      self.__dict__.setdefault("_members",{})[name] = value

      return _set_instance_attr(self, name, value)

apr_hash_t_swigregister = _core.apr_hash_t_swigregister
apr_hash_t_swigregister(apr_hash_t)


import threading

application_pool = None
application_pool_lock = threading.Lock()
class GenericSWIGWrapper:
  def __init__(self, this, pool):
    """Create new Generic SWIG wrapper object"""
    import weakref
    self.this = this
    self._parent_pool = pool
    self._is_valid = weakref.ref(pool._is_valid)

  def set_parent_pool(self, pool):
    """Set the parent pool of this object"""
    self._parent_pool = pool
    self._is_valid = weakref.ref(pool._is_valid)

  def valid(self):
    """Is this object valid?"""
    return self._is_valid()

  def assert_valid(self):
    """Assert that this object is still valid"""
    assert self.valid(), "This object has already been destroyed"

  def _unwrap(self):
    """Return underlying SWIG object"""
    self.assert_valid()
    return self.this

def _mark_weakpool_invalid(weakpool):
  if weakpool:
    pool = weakpool()
    if pool:
      try:
        del pool._is_valid
      except AttributeError:
        pass



class apr_pool_t(object):
    """Proxy of C apr_pool_t struct."""

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def set_parent_pool(self, parent_pool=None):
      """Create a new memory pool"""
      global application_pool

      try:
        application_pool_lock.acquire()

        self._parent_pool = parent_pool or application_pool
        self._mark_valid()

    # Protect important functions from GC
        self._apr_pool_destroy = _core.apr_pool_destroy
        self._svn_swig_py_clear_application_pool = \
          _core.svn_swig_py_clear_application_pool

    # If we are an application-level pool,
    # then set this pool to be the application-level pool
        if not self._parent_pool:
          svn_swig_py_set_application_pool(self, self)
          application_pool = self
      finally:
        application_pool_lock.release()

    def valid(self):
      """Check whether this memory pool and its parents
      are still valid"""
      try:
        self._is_valid
      except AttributeError:
        return False
    # We must check whether the parent pool is valid even if
    # the pool is valid because weakref's callback is not
    # invoked when it is finalized by cyclic garbage collector
      if self._parent_pool:
        return self._parent_pool.valid()
      else:
        return True

    def assert_valid(self):
      """Assert that this memory_pool is still valid."""
      assert self.valid(), "This pool has already been destroyed"

    def clear(self):
      """Clear embedded memory pool. Invalidate all subpools."""
      pool = self._parent_pool
      apr_pool_clear(self)
      self.set_parent_pool(pool)

    def destroy(self):
      """Destroy embedded memory pool. If you do not destroy
      the memory pool manually, Python will destroy it
      automatically."""
      global application_pool

      self.assert_valid()

      is_application_pool = not self._parent_pool

    # Destroy pool
      self._apr_pool_destroy(self)

    # Clear application pool if necessary
      if is_application_pool:
        application_pool = None
        self._svn_swig_py_clear_application_pool()

    # Mark self as invalid
      try:
        del self._parent_pool
      except AttributeError:
        pass

      try:
        del self._is_valid
      except AttributeError:
        pass

    def __del__(self):
      """Automatically destroy memory pools, if necessary"""
      if self.valid():
        self.destroy()

    def _mark_valid(self):
      """Mark pool as valid"""

      self._weakparent = None

      if self._parent_pool:
        import weakref

    # Make sure that the parent object is valid
        self._parent_pool.assert_valid()

    # Refer to self using a weakreference so that we don't
    # create a reference cycle
        weakself = weakref.ref(self)

    # Set up callbacks to mark pool as invalid when parents
    # are destroyed
        self._weakparent = weakref.ref(self._parent_pool._is_valid,
          lambda x: _mark_weakpool_invalid(weakself))

    # Mark pool as valid
      self._is_valid = lambda: 1

    def _wrap(self, obj):
      """Mark a SWIG object as owned by this pool"""
      self.assert_valid()

      fn = getattr(obj, 'set_parent_pool', None)

      if fn is not None:
        fn(self)
        return obj
      elif obj is None:
        return None
      else:
        return GenericSWIGWrapper(obj, self)


apr_pool_t_swigregister = _core.apr_pool_t_swigregister
apr_pool_t_swigregister(apr_pool_t)


# Initialize a global pool
svn_pool_create()


def svn_swig_mergeinfo_merge(*args) -> "apr_hash_t **":
    """svn_swig_mergeinfo_merge(apr_hash_t ** mergeinfo_inout, apr_hash_t changes, apr_pool_t pool) -> svn_error_t"""
    return _core.svn_swig_mergeinfo_merge(*args)

def svn_swig_mergeinfo_sort(*args) -> "apr_hash_t **":
    """svn_swig_mergeinfo_sort(apr_hash_t ** mergeinfo_inout, apr_pool_t pool) -> svn_error_t"""
    return _core.svn_swig_mergeinfo_sort(*args)

def svn_swig_rangelist_merge(*args) -> "svn_rangelist_t **":
    """svn_swig_rangelist_merge(svn_rangelist_t ** rangelist_inout, apr_array_header_t changes, apr_pool_t pool) -> svn_error_t"""
    return _core.svn_swig_rangelist_merge(*args)

def svn_swig_rangelist_reverse(*args) -> "svn_rangelist_t **":
    """svn_swig_rangelist_reverse(svn_rangelist_t ** rangelist_inout, apr_pool_t pool) -> svn_error_t"""
    return _core.svn_swig_rangelist_reverse(*args)


