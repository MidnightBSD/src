# This file was automatically generated by SWIG (http://www.swig.org).
# Version 3.0.12
#
# Do not make changes to this file unless you know what you are doing--modify
# the SWIG interface file instead.


def _dll_paths():
    import os
    if hasattr(os, 'add_dll_directory'):  # Python 3.8+ on Windows
        cookies = []
        for path in os.environ.get('PATH', '').split(os.pathsep):
            if path and os.path.isabs(path):
                try:
                    cookie = os.add_dll_directory(path)
                except OSError:
                    continue
                else:
                    cookies.append(cookie)
        return cookies
    else:
        return ()

_dll_paths = _dll_paths()
try:
    from . import _client
finally:
    _dll_path = None
    for _dll_path in _dll_paths:
        _dll_path.close()
    del _dll_paths, _dll_path

try:
    _swig_property = property
except NameError:
    pass  # Python < 2.2 doesn't have 'property'.

try:
    import builtins as __builtin__
except ImportError:
    import __builtin__

def _swig_setattr_nondynamic(self, class_type, name, value, static=1):
    if (name == "thisown"):
        return self.this.own(value)
    if (name == "this"):
        if type(value).__name__ == 'SwigPyObject':
            self.__dict__[name] = value
            return
    method = class_type.__swig_setmethods__.get(name, None)
    if method:
        return method(self, value)
    if (not static):
        object.__setattr__(self, name, value)
    else:
        raise AttributeError("You cannot add attributes to %s" % self)


def _swig_setattr(self, class_type, name, value):
    return _swig_setattr_nondynamic(self, class_type, name, value, 0)


def _swig_getattr(self, class_type, name):
    if (name == "thisown"):
        return self.this.own()
    method = class_type.__swig_getmethods__.get(name, None)
    if method:
        return method(self)
    raise AttributeError("'%s' object has no attribute '%s'" % (class_type.__name__, name))


def _swig_repr(self):
    try:
        strthis = "proxy of " + self.this.__repr__()
    except __builtin__.Exception:
        strthis = ""
    return "<%s.%s; %s >" % (self.__class__.__module__, self.__class__.__name__, strthis,)


def _swig_setattr_nondynamic_method(set):
    def set_attr(self, name, value):
        if (name == "thisown"):
            return self.this.own(value)
        if hasattr(self, name) or (name == "this"):
            set(self, name, value)
        else:
            raise AttributeError("You cannot add attributes to %s" % self)
    return set_attr



def _copy_metadata_deep(value, old_value):
  """Copy all attributes of old_value into value, recursively traversing
  lists and dicts if needed."""
  if value is None or old_value is None or value is old_value: return

  if isinstance(value, dict):
    for k in value:
      _copy_metadata_deep(value[k], old_value[k])
  elif isinstance(value, list):
    for v, old_v in zip(value, old_value):
      _copy_metadata_deep(v, old_v)
  else:
    try:
      value.__dict__.update(old_value.__dict__)
    except AttributeError:
      pass

def _assert_valid_deep(value):
  """Assert value's validity, recursively traversing lists and dicts."""
  if isinstance(value, dict):
    for k in value:
      _assert_valid_deep(value[k])
  elif isinstance(value, list):
    for v in value:
      _assert_valid_deep(v)
# Ensure that the passed in value isn't a type, which could have an
# assert_valid attribute, but it can not be called without an instance.
  elif type(value) != type:
    try:
      fn = value.assert_valid
    except AttributeError:
      pass
    else:
      fn()



  # SWIG classes generated with -modern do not define this variable
try:
  _newclass
except NameError:
  _newclass = 1
else:
  raise RuntimeError("Require -modern option, but _newclass is defined")

_get_instance_attr = object.__getattribute__
_set_instance_attr = _swig_setattr_nondynamic_method(object.__setattr__)


import libsvn.core
import libsvn.delta
import libsvn.wc
import libsvn.ra

def svn_client_version() -> "svn_version_t const *":
    """svn_client_version() -> svn_version_t const *"""
    return _client.svn_client_version()

def svn_client_get_simple_prompt_provider(*args) -> "svn_auth_provider_object_t **":
    """svn_client_get_simple_prompt_provider(svn_auth_simple_prompt_func_t prompt_func, int retry_limit, apr_pool_t pool)"""
    return _client.svn_client_get_simple_prompt_provider(*args)

def svn_client_get_username_prompt_provider(*args) -> "svn_auth_provider_object_t **":
    """svn_client_get_username_prompt_provider(svn_auth_username_prompt_func_t prompt_func, int retry_limit, apr_pool_t pool)"""
    return _client.svn_client_get_username_prompt_provider(*args)

def svn_client_get_simple_provider(*args) -> "svn_auth_provider_object_t **":
    """svn_client_get_simple_provider(apr_pool_t pool)"""
    return _client.svn_client_get_simple_provider(*args)

def svn_client_get_username_provider(*args) -> "svn_auth_provider_object_t **":
    """svn_client_get_username_provider(apr_pool_t pool)"""
    return _client.svn_client_get_username_provider(*args)

def svn_client_get_ssl_server_trust_file_provider(*args) -> "svn_auth_provider_object_t **":
    """svn_client_get_ssl_server_trust_file_provider(apr_pool_t pool)"""
    return _client.svn_client_get_ssl_server_trust_file_provider(*args)

def svn_client_get_ssl_client_cert_file_provider(*args) -> "svn_auth_provider_object_t **":
    """svn_client_get_ssl_client_cert_file_provider(apr_pool_t pool)"""
    return _client.svn_client_get_ssl_client_cert_file_provider(*args)

def svn_client_get_ssl_client_cert_pw_file_provider(*args) -> "svn_auth_provider_object_t **":
    """svn_client_get_ssl_client_cert_pw_file_provider(apr_pool_t pool)"""
    return _client.svn_client_get_ssl_client_cert_pw_file_provider(*args)

def svn_client_get_ssl_server_trust_prompt_provider(*args) -> "svn_auth_provider_object_t **":
    """svn_client_get_ssl_server_trust_prompt_provider(svn_auth_ssl_server_trust_prompt_func_t prompt_func, apr_pool_t pool)"""
    return _client.svn_client_get_ssl_server_trust_prompt_provider(*args)

def svn_client_get_ssl_client_cert_prompt_provider(*args) -> "svn_auth_provider_object_t **":
    """svn_client_get_ssl_client_cert_prompt_provider(svn_auth_ssl_client_cert_prompt_func_t prompt_func, int retry_limit, apr_pool_t pool)"""
    return _client.svn_client_get_ssl_client_cert_prompt_provider(*args)

def svn_client_get_ssl_client_cert_pw_prompt_provider(*args) -> "svn_auth_provider_object_t **":
    """svn_client_get_ssl_client_cert_pw_prompt_provider(svn_auth_ssl_client_cert_pw_prompt_func_t prompt_func, int retry_limit, apr_pool_t pool)"""
    return _client.svn_client_get_ssl_client_cert_pw_prompt_provider(*args)

def svn_client_proplist_item_dup(*args) -> "svn_client_proplist_item_t *":
    """svn_client_proplist_item_dup(svn_client_proplist_item_t const * item, apr_pool_t pool) -> svn_client_proplist_item_t *"""
    return _client.svn_client_proplist_item_dup(*args)
class svn_client_commit_info_t(object):
    """Proxy of C svn_client_commit_info_t struct."""

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    revision = _swig_property(_client.svn_client_commit_info_t_revision_get, _client.svn_client_commit_info_t_revision_set)
    date = _swig_property(_client.svn_client_commit_info_t_date_get, _client.svn_client_commit_info_t_date_set)
    author = _swig_property(_client.svn_client_commit_info_t_author_get, _client.svn_client_commit_info_t_author_set)
    def set_parent_pool(self, parent_pool=None):
      """Create a new proxy object for TYPE"""
      import libsvn.core, weakref
      self.__dict__["_parent_pool"] = \
        parent_pool or libsvn.core.application_pool;
      if self.__dict__["_parent_pool"]:
        self.__dict__["_is_valid"] = weakref.ref(
          self.__dict__["_parent_pool"]._is_valid)

    def assert_valid(self):
      """Assert that this object is using valid pool memory"""
      if "_is_valid" in self.__dict__:
        assert self.__dict__["_is_valid"](), "Variable has already been deleted"

    def _retrieve_swig_value(self, name, value):
    # If we got back a different object than we have cached, we need to copy
    # all our metadata into it, so that it looks identical to the one
    # originally set.
      members = self.__dict__.get('_members')
      if members is not None and name in members:
        _copy_metadata_deep(value, members[name])

    # Verify that the new object is good
      _assert_valid_deep(value)

      return value

    # Attribute access must be intercepted to ensure that objects coming from
    # read attribute access match those that are set with write attribute access.
    # Specifically the metadata, such as the associated apr_pool object, should
    # match the originally assigned object.
    #
    # For classic classes it is enough to use __getattr__ to intercept swig
    # derived attributes. However, with new style classes SWIG makes use of
    # descriptors which mean that __getattr__ is never called. Therefore,
    # __getattribute__ must be used for the interception.

    if _newclass:
      def __getattribute__(self, name):
        """Manage access to all attributes of this object."""

    # Start by mimicing __getattr__ behavior: immediately return __dict__ or
    # items directly present in __dict__
        mydict = object.__getattribute__(self, '__dict__')

        if name == "__dict__":
          return mydict

        if name in mydict:
          return mydict[name]

        object.__getattribute__(self, 'assert_valid')()

        value = _get_instance_attr(self, name)
        fn = object.__getattribute__(self, '_retrieve_swig_value')
        return fn(name, value)
    else:
      def __getattr__(self, name):
        """Get an attribute from this object"""
        self.assert_valid()

        value = _swig_getattr(self, self.__class__, name)

        return self._retrieve_swig_value(name, value)

    def __setattr__(self, name, value):
      """Set an attribute on this object"""
      self.assert_valid()

    # Save a copy of the object, so that the garbage
    # collector won't kill the object while it's in
    # SWIG-land
      self.__dict__.setdefault("_members",{})[name] = value

      return _set_instance_attr(self, name, value)


    def __init__(self):
        """__init__(svn_client_commit_info_t self) -> svn_client_commit_info_t"""
        this = _client.new_svn_client_commit_info_t()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _client.delete_svn_client_commit_info_t
    __del__ = lambda self: None
svn_client_commit_info_t_swigregister = _client.svn_client_commit_info_t_swigregister
svn_client_commit_info_t_swigregister(svn_client_commit_info_t)

SVN_CLIENT_COMMIT_ITEM_ADD = _client.SVN_CLIENT_COMMIT_ITEM_ADD
SVN_CLIENT_COMMIT_ITEM_DELETE = _client.SVN_CLIENT_COMMIT_ITEM_DELETE
SVN_CLIENT_COMMIT_ITEM_TEXT_MODS = _client.SVN_CLIENT_COMMIT_ITEM_TEXT_MODS
SVN_CLIENT_COMMIT_ITEM_PROP_MODS = _client.SVN_CLIENT_COMMIT_ITEM_PROP_MODS
SVN_CLIENT_COMMIT_ITEM_IS_COPY = _client.SVN_CLIENT_COMMIT_ITEM_IS_COPY
SVN_CLIENT_COMMIT_ITEM_LOCK_TOKEN = _client.SVN_CLIENT_COMMIT_ITEM_LOCK_TOKEN
SVN_CLIENT_COMMIT_ITEM_MOVED_HERE = _client.SVN_CLIENT_COMMIT_ITEM_MOVED_HERE
class svn_client_commit_item3_t(object):
    """Proxy of C svn_client_commit_item3_t struct."""

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    path = _swig_property(_client.svn_client_commit_item3_t_path_get, _client.svn_client_commit_item3_t_path_set)
    kind = _swig_property(_client.svn_client_commit_item3_t_kind_get, _client.svn_client_commit_item3_t_kind_set)
    url = _swig_property(_client.svn_client_commit_item3_t_url_get, _client.svn_client_commit_item3_t_url_set)
    revision = _swig_property(_client.svn_client_commit_item3_t_revision_get, _client.svn_client_commit_item3_t_revision_set)
    copyfrom_url = _swig_property(_client.svn_client_commit_item3_t_copyfrom_url_get, _client.svn_client_commit_item3_t_copyfrom_url_set)
    copyfrom_rev = _swig_property(_client.svn_client_commit_item3_t_copyfrom_rev_get, _client.svn_client_commit_item3_t_copyfrom_rev_set)
    state_flags = _swig_property(_client.svn_client_commit_item3_t_state_flags_get, _client.svn_client_commit_item3_t_state_flags_set)
    incoming_prop_changes = _swig_property(_client.svn_client_commit_item3_t_incoming_prop_changes_get, _client.svn_client_commit_item3_t_incoming_prop_changes_set)
    outgoing_prop_changes = _swig_property(_client.svn_client_commit_item3_t_outgoing_prop_changes_get, _client.svn_client_commit_item3_t_outgoing_prop_changes_set)
    session_relpath = _swig_property(_client.svn_client_commit_item3_t_session_relpath_get, _client.svn_client_commit_item3_t_session_relpath_set)
    moved_from_abspath = _swig_property(_client.svn_client_commit_item3_t_moved_from_abspath_get, _client.svn_client_commit_item3_t_moved_from_abspath_set)
    def set_parent_pool(self, parent_pool=None):
      """Create a new proxy object for TYPE"""
      import libsvn.core, weakref
      self.__dict__["_parent_pool"] = \
        parent_pool or libsvn.core.application_pool;
      if self.__dict__["_parent_pool"]:
        self.__dict__["_is_valid"] = weakref.ref(
          self.__dict__["_parent_pool"]._is_valid)

    def assert_valid(self):
      """Assert that this object is using valid pool memory"""
      if "_is_valid" in self.__dict__:
        assert self.__dict__["_is_valid"](), "Variable has already been deleted"

    def _retrieve_swig_value(self, name, value):
    # If we got back a different object than we have cached, we need to copy
    # all our metadata into it, so that it looks identical to the one
    # originally set.
      members = self.__dict__.get('_members')
      if members is not None and name in members:
        _copy_metadata_deep(value, members[name])

    # Verify that the new object is good
      _assert_valid_deep(value)

      return value

    # Attribute access must be intercepted to ensure that objects coming from
    # read attribute access match those that are set with write attribute access.
    # Specifically the metadata, such as the associated apr_pool object, should
    # match the originally assigned object.
    #
    # For classic classes it is enough to use __getattr__ to intercept swig
    # derived attributes. However, with new style classes SWIG makes use of
    # descriptors which mean that __getattr__ is never called. Therefore,
    # __getattribute__ must be used for the interception.

    if _newclass:
      def __getattribute__(self, name):
        """Manage access to all attributes of this object."""

    # Start by mimicing __getattr__ behavior: immediately return __dict__ or
    # items directly present in __dict__
        mydict = object.__getattribute__(self, '__dict__')

        if name == "__dict__":
          return mydict

        if name in mydict:
          return mydict[name]

        object.__getattribute__(self, 'assert_valid')()

        value = _get_instance_attr(self, name)
        fn = object.__getattribute__(self, '_retrieve_swig_value')
        return fn(name, value)
    else:
      def __getattr__(self, name):
        """Get an attribute from this object"""
        self.assert_valid()

        value = _swig_getattr(self, self.__class__, name)

        return self._retrieve_swig_value(name, value)

    def __setattr__(self, name, value):
      """Set an attribute on this object"""
      self.assert_valid()

    # Save a copy of the object, so that the garbage
    # collector won't kill the object while it's in
    # SWIG-land
      self.__dict__.setdefault("_members",{})[name] = value

      return _set_instance_attr(self, name, value)


    def __init__(self):
        """__init__(svn_client_commit_item3_t self) -> svn_client_commit_item3_t"""
        this = _client.new_svn_client_commit_item3_t()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _client.delete_svn_client_commit_item3_t
    __del__ = lambda self: None
svn_client_commit_item3_t_swigregister = _client.svn_client_commit_item3_t_swigregister
svn_client_commit_item3_t_swigregister(svn_client_commit_item3_t)

class svn_client_commit_item2_t(object):
    """Proxy of C svn_client_commit_item2_t struct."""

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    path = _swig_property(_client.svn_client_commit_item2_t_path_get, _client.svn_client_commit_item2_t_path_set)
    kind = _swig_property(_client.svn_client_commit_item2_t_kind_get, _client.svn_client_commit_item2_t_kind_set)
    url = _swig_property(_client.svn_client_commit_item2_t_url_get, _client.svn_client_commit_item2_t_url_set)
    revision = _swig_property(_client.svn_client_commit_item2_t_revision_get, _client.svn_client_commit_item2_t_revision_set)
    copyfrom_url = _swig_property(_client.svn_client_commit_item2_t_copyfrom_url_get, _client.svn_client_commit_item2_t_copyfrom_url_set)
    copyfrom_rev = _swig_property(_client.svn_client_commit_item2_t_copyfrom_rev_get, _client.svn_client_commit_item2_t_copyfrom_rev_set)
    state_flags = _swig_property(_client.svn_client_commit_item2_t_state_flags_get, _client.svn_client_commit_item2_t_state_flags_set)
    wcprop_changes = _swig_property(_client.svn_client_commit_item2_t_wcprop_changes_get, _client.svn_client_commit_item2_t_wcprop_changes_set)
    def set_parent_pool(self, parent_pool=None):
      """Create a new proxy object for TYPE"""
      import libsvn.core, weakref
      self.__dict__["_parent_pool"] = \
        parent_pool or libsvn.core.application_pool;
      if self.__dict__["_parent_pool"]:
        self.__dict__["_is_valid"] = weakref.ref(
          self.__dict__["_parent_pool"]._is_valid)

    def assert_valid(self):
      """Assert that this object is using valid pool memory"""
      if "_is_valid" in self.__dict__:
        assert self.__dict__["_is_valid"](), "Variable has already been deleted"

    def _retrieve_swig_value(self, name, value):
    # If we got back a different object than we have cached, we need to copy
    # all our metadata into it, so that it looks identical to the one
    # originally set.
      members = self.__dict__.get('_members')
      if members is not None and name in members:
        _copy_metadata_deep(value, members[name])

    # Verify that the new object is good
      _assert_valid_deep(value)

      return value

    # Attribute access must be intercepted to ensure that objects coming from
    # read attribute access match those that are set with write attribute access.
    # Specifically the metadata, such as the associated apr_pool object, should
    # match the originally assigned object.
    #
    # For classic classes it is enough to use __getattr__ to intercept swig
    # derived attributes. However, with new style classes SWIG makes use of
    # descriptors which mean that __getattr__ is never called. Therefore,
    # __getattribute__ must be used for the interception.

    if _newclass:
      def __getattribute__(self, name):
        """Manage access to all attributes of this object."""

    # Start by mimicing __getattr__ behavior: immediately return __dict__ or
    # items directly present in __dict__
        mydict = object.__getattribute__(self, '__dict__')

        if name == "__dict__":
          return mydict

        if name in mydict:
          return mydict[name]

        object.__getattribute__(self, 'assert_valid')()

        value = _get_instance_attr(self, name)
        fn = object.__getattribute__(self, '_retrieve_swig_value')
        return fn(name, value)
    else:
      def __getattr__(self, name):
        """Get an attribute from this object"""
        self.assert_valid()

        value = _swig_getattr(self, self.__class__, name)

        return self._retrieve_swig_value(name, value)

    def __setattr__(self, name, value):
      """Set an attribute on this object"""
      self.assert_valid()

    # Save a copy of the object, so that the garbage
    # collector won't kill the object while it's in
    # SWIG-land
      self.__dict__.setdefault("_members",{})[name] = value

      return _set_instance_attr(self, name, value)


    def __init__(self):
        """__init__(svn_client_commit_item2_t self) -> svn_client_commit_item2_t"""
        this = _client.new_svn_client_commit_item2_t()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _client.delete_svn_client_commit_item2_t
    __del__ = lambda self: None
svn_client_commit_item2_t_swigregister = _client.svn_client_commit_item2_t_swigregister
svn_client_commit_item2_t_swigregister(svn_client_commit_item2_t)

class svn_client_commit_item_t(object):
    """Proxy of C svn_client_commit_item_t struct."""

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    path = _swig_property(_client.svn_client_commit_item_t_path_get, _client.svn_client_commit_item_t_path_set)
    kind = _swig_property(_client.svn_client_commit_item_t_kind_get, _client.svn_client_commit_item_t_kind_set)
    url = _swig_property(_client.svn_client_commit_item_t_url_get, _client.svn_client_commit_item_t_url_set)
    revision = _swig_property(_client.svn_client_commit_item_t_revision_get, _client.svn_client_commit_item_t_revision_set)
    copyfrom_url = _swig_property(_client.svn_client_commit_item_t_copyfrom_url_get, _client.svn_client_commit_item_t_copyfrom_url_set)
    state_flags = _swig_property(_client.svn_client_commit_item_t_state_flags_get, _client.svn_client_commit_item_t_state_flags_set)
    wcprop_changes = _swig_property(_client.svn_client_commit_item_t_wcprop_changes_get, _client.svn_client_commit_item_t_wcprop_changes_set)
    def set_parent_pool(self, parent_pool=None):
      """Create a new proxy object for TYPE"""
      import libsvn.core, weakref
      self.__dict__["_parent_pool"] = \
        parent_pool or libsvn.core.application_pool;
      if self.__dict__["_parent_pool"]:
        self.__dict__["_is_valid"] = weakref.ref(
          self.__dict__["_parent_pool"]._is_valid)

    def assert_valid(self):
      """Assert that this object is using valid pool memory"""
      if "_is_valid" in self.__dict__:
        assert self.__dict__["_is_valid"](), "Variable has already been deleted"

    def _retrieve_swig_value(self, name, value):
    # If we got back a different object than we have cached, we need to copy
    # all our metadata into it, so that it looks identical to the one
    # originally set.
      members = self.__dict__.get('_members')
      if members is not None and name in members:
        _copy_metadata_deep(value, members[name])

    # Verify that the new object is good
      _assert_valid_deep(value)

      return value

    # Attribute access must be intercepted to ensure that objects coming from
    # read attribute access match those that are set with write attribute access.
    # Specifically the metadata, such as the associated apr_pool object, should
    # match the originally assigned object.
    #
    # For classic classes it is enough to use __getattr__ to intercept swig
    # derived attributes. However, with new style classes SWIG makes use of
    # descriptors which mean that __getattr__ is never called. Therefore,
    # __getattribute__ must be used for the interception.

    if _newclass:
      def __getattribute__(self, name):
        """Manage access to all attributes of this object."""

    # Start by mimicing __getattr__ behavior: immediately return __dict__ or
    # items directly present in __dict__
        mydict = object.__getattribute__(self, '__dict__')

        if name == "__dict__":
          return mydict

        if name in mydict:
          return mydict[name]

        object.__getattribute__(self, 'assert_valid')()

        value = _get_instance_attr(self, name)
        fn = object.__getattribute__(self, '_retrieve_swig_value')
        return fn(name, value)
    else:
      def __getattr__(self, name):
        """Get an attribute from this object"""
        self.assert_valid()

        value = _swig_getattr(self, self.__class__, name)

        return self._retrieve_swig_value(name, value)

    def __setattr__(self, name, value):
      """Set an attribute on this object"""
      self.assert_valid()

    # Save a copy of the object, so that the garbage
    # collector won't kill the object while it's in
    # SWIG-land
      self.__dict__.setdefault("_members",{})[name] = value

      return _set_instance_attr(self, name, value)


    def __init__(self):
        """__init__(svn_client_commit_item_t self) -> svn_client_commit_item_t"""
        this = _client.new_svn_client_commit_item_t()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _client.delete_svn_client_commit_item_t
    __del__ = lambda self: None
svn_client_commit_item_t_swigregister = _client.svn_client_commit_item_t_swigregister
svn_client_commit_item_t_swigregister(svn_client_commit_item_t)


def svn_client_commit_item3_create(*args) -> "svn_client_commit_item3_t *":
    """svn_client_commit_item3_create(apr_pool_t pool) -> svn_client_commit_item3_t"""
    return _client.svn_client_commit_item3_create(*args)

def svn_client_commit_item_create(*args) -> "svn_client_commit_item3_t const **":
    """svn_client_commit_item_create(apr_pool_t pool) -> svn_error_t"""
    return _client.svn_client_commit_item_create(*args)

def svn_client_commit_item3_dup(*args) -> "svn_client_commit_item3_t *":
    """svn_client_commit_item3_dup(svn_client_commit_item3_t item, apr_pool_t pool) -> svn_client_commit_item3_t"""
    return _client.svn_client_commit_item3_dup(*args)

def svn_client_commit_item2_dup(*args) -> "svn_client_commit_item2_t *":
    """svn_client_commit_item2_dup(svn_client_commit_item2_t item, apr_pool_t pool) -> svn_client_commit_item2_t"""
    return _client.svn_client_commit_item2_dup(*args)
svn_client_diff_summarize_kind_normal = _client.svn_client_diff_summarize_kind_normal
svn_client_diff_summarize_kind_added = _client.svn_client_diff_summarize_kind_added
svn_client_diff_summarize_kind_modified = _client.svn_client_diff_summarize_kind_modified
svn_client_diff_summarize_kind_deleted = _client.svn_client_diff_summarize_kind_deleted
class svn_client_diff_summarize_t(object):
    """Proxy of C svn_client_diff_summarize_t struct."""

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    path = _swig_property(_client.svn_client_diff_summarize_t_path_get, _client.svn_client_diff_summarize_t_path_set)
    summarize_kind = _swig_property(_client.svn_client_diff_summarize_t_summarize_kind_get, _client.svn_client_diff_summarize_t_summarize_kind_set)
    prop_changed = _swig_property(_client.svn_client_diff_summarize_t_prop_changed_get, _client.svn_client_diff_summarize_t_prop_changed_set)
    node_kind = _swig_property(_client.svn_client_diff_summarize_t_node_kind_get, _client.svn_client_diff_summarize_t_node_kind_set)
    def set_parent_pool(self, parent_pool=None):
      """Create a new proxy object for TYPE"""
      import libsvn.core, weakref
      self.__dict__["_parent_pool"] = \
        parent_pool or libsvn.core.application_pool;
      if self.__dict__["_parent_pool"]:
        self.__dict__["_is_valid"] = weakref.ref(
          self.__dict__["_parent_pool"]._is_valid)

    def assert_valid(self):
      """Assert that this object is using valid pool memory"""
      if "_is_valid" in self.__dict__:
        assert self.__dict__["_is_valid"](), "Variable has already been deleted"

    def _retrieve_swig_value(self, name, value):
    # If we got back a different object than we have cached, we need to copy
    # all our metadata into it, so that it looks identical to the one
    # originally set.
      members = self.__dict__.get('_members')
      if members is not None and name in members:
        _copy_metadata_deep(value, members[name])

    # Verify that the new object is good
      _assert_valid_deep(value)

      return value

    # Attribute access must be intercepted to ensure that objects coming from
    # read attribute access match those that are set with write attribute access.
    # Specifically the metadata, such as the associated apr_pool object, should
    # match the originally assigned object.
    #
    # For classic classes it is enough to use __getattr__ to intercept swig
    # derived attributes. However, with new style classes SWIG makes use of
    # descriptors which mean that __getattr__ is never called. Therefore,
    # __getattribute__ must be used for the interception.

    if _newclass:
      def __getattribute__(self, name):
        """Manage access to all attributes of this object."""

    # Start by mimicing __getattr__ behavior: immediately return __dict__ or
    # items directly present in __dict__
        mydict = object.__getattribute__(self, '__dict__')

        if name == "__dict__":
          return mydict

        if name in mydict:
          return mydict[name]

        object.__getattribute__(self, 'assert_valid')()

        value = _get_instance_attr(self, name)
        fn = object.__getattribute__(self, '_retrieve_swig_value')
        return fn(name, value)
    else:
      def __getattr__(self, name):
        """Get an attribute from this object"""
        self.assert_valid()

        value = _swig_getattr(self, self.__class__, name)

        return self._retrieve_swig_value(name, value)

    def __setattr__(self, name, value):
      """Set an attribute on this object"""
      self.assert_valid()

    # Save a copy of the object, so that the garbage
    # collector won't kill the object while it's in
    # SWIG-land
      self.__dict__.setdefault("_members",{})[name] = value

      return _set_instance_attr(self, name, value)


    def __init__(self):
        """__init__(svn_client_diff_summarize_t self) -> svn_client_diff_summarize_t"""
        this = _client.new_svn_client_diff_summarize_t()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _client.delete_svn_client_diff_summarize_t
    __del__ = lambda self: None
svn_client_diff_summarize_t_swigregister = _client.svn_client_diff_summarize_t_swigregister
svn_client_diff_summarize_t_swigregister(svn_client_diff_summarize_t)


def svn_client_diff_summarize_dup(*args) -> "svn_client_diff_summarize_t *":
    """svn_client_diff_summarize_dup(svn_client_diff_summarize_t diff, apr_pool_t pool) -> svn_client_diff_summarize_t"""
    return _client.svn_client_diff_summarize_dup(*args)
class svn_client_ctx_t(object):
    """Proxy of C svn_client_ctx_t struct."""

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    auth_baton = _swig_property(_client.svn_client_ctx_t_auth_baton_get, _client.svn_client_ctx_t_auth_baton_set)
    notify_func = _swig_property(_client.svn_client_ctx_t_notify_func_get, _client.svn_client_ctx_t_notify_func_set)
    notify_baton = _swig_property(_client.svn_client_ctx_t_notify_baton_get, _client.svn_client_ctx_t_notify_baton_set)
    log_msg_func = _swig_property(_client.svn_client_ctx_t_log_msg_func_get, _client.svn_client_ctx_t_log_msg_func_set)
    log_msg_baton = _swig_property(_client.svn_client_ctx_t_log_msg_baton_get, _client.svn_client_ctx_t_log_msg_baton_set)
    config = _swig_property(_client.svn_client_ctx_t_config_get, _client.svn_client_ctx_t_config_set)
    cancel_func = _swig_property(_client.svn_client_ctx_t_cancel_func_get, _client.svn_client_ctx_t_cancel_func_set)
    cancel_baton = _swig_property(_client.svn_client_ctx_t_cancel_baton_get, _client.svn_client_ctx_t_cancel_baton_set)
    notify_func2 = _swig_property(_client.svn_client_ctx_t_notify_func2_get, _client.svn_client_ctx_t_notify_func2_set)
    notify_baton2 = _swig_property(_client.svn_client_ctx_t_notify_baton2_get, _client.svn_client_ctx_t_notify_baton2_set)
    log_msg_func2 = _swig_property(_client.svn_client_ctx_t_log_msg_func2_get, _client.svn_client_ctx_t_log_msg_func2_set)
    log_msg_baton2 = _swig_property(_client.svn_client_ctx_t_log_msg_baton2_get, _client.svn_client_ctx_t_log_msg_baton2_set)
    progress_func = _swig_property(_client.svn_client_ctx_t_progress_func_get, _client.svn_client_ctx_t_progress_func_set)
    progress_baton = _swig_property(_client.svn_client_ctx_t_progress_baton_get, _client.svn_client_ctx_t_progress_baton_set)
    log_msg_func3 = _swig_property(_client.svn_client_ctx_t_log_msg_func3_get, _client.svn_client_ctx_t_log_msg_func3_set)
    log_msg_baton3 = _swig_property(_client.svn_client_ctx_t_log_msg_baton3_get, _client.svn_client_ctx_t_log_msg_baton3_set)
    mimetypes_map = _swig_property(_client.svn_client_ctx_t_mimetypes_map_get, _client.svn_client_ctx_t_mimetypes_map_set)
    conflict_func = _swig_property(_client.svn_client_ctx_t_conflict_func_get, _client.svn_client_ctx_t_conflict_func_set)
    conflict_baton = _swig_property(_client.svn_client_ctx_t_conflict_baton_get, _client.svn_client_ctx_t_conflict_baton_set)
    client_name = _swig_property(_client.svn_client_ctx_t_client_name_get, _client.svn_client_ctx_t_client_name_set)
    conflict_func2 = _swig_property(_client.svn_client_ctx_t_conflict_func2_get, _client.svn_client_ctx_t_conflict_func2_set)
    conflict_baton2 = _swig_property(_client.svn_client_ctx_t_conflict_baton2_get, _client.svn_client_ctx_t_conflict_baton2_set)
    wc_ctx = _swig_property(_client.svn_client_ctx_t_wc_ctx_get, _client.svn_client_ctx_t_wc_ctx_set)
    check_tunnel_func = _swig_property(_client.svn_client_ctx_t_check_tunnel_func_get, _client.svn_client_ctx_t_check_tunnel_func_set)
    open_tunnel_func = _swig_property(_client.svn_client_ctx_t_open_tunnel_func_get, _client.svn_client_ctx_t_open_tunnel_func_set)
    tunnel_baton = _swig_property(_client.svn_client_ctx_t_tunnel_baton_get, _client.svn_client_ctx_t_tunnel_baton_set)
    def set_parent_pool(self, parent_pool=None):
      """Create a new proxy object for TYPE"""
      import libsvn.core, weakref
      self.__dict__["_parent_pool"] = \
        parent_pool or libsvn.core.application_pool;
      if self.__dict__["_parent_pool"]:
        self.__dict__["_is_valid"] = weakref.ref(
          self.__dict__["_parent_pool"]._is_valid)

    def assert_valid(self):
      """Assert that this object is using valid pool memory"""
      if "_is_valid" in self.__dict__:
        assert self.__dict__["_is_valid"](), "Variable has already been deleted"

    def _retrieve_swig_value(self, name, value):
    # If we got back a different object than we have cached, we need to copy
    # all our metadata into it, so that it looks identical to the one
    # originally set.
      members = self.__dict__.get('_members')
      if members is not None and name in members:
        _copy_metadata_deep(value, members[name])

    # Verify that the new object is good
      _assert_valid_deep(value)

      return value

    # Attribute access must be intercepted to ensure that objects coming from
    # read attribute access match those that are set with write attribute access.
    # Specifically the metadata, such as the associated apr_pool object, should
    # match the originally assigned object.
    #
    # For classic classes it is enough to use __getattr__ to intercept swig
    # derived attributes. However, with new style classes SWIG makes use of
    # descriptors which mean that __getattr__ is never called. Therefore,
    # __getattribute__ must be used for the interception.

    if _newclass:
      def __getattribute__(self, name):
        """Manage access to all attributes of this object."""

    # Start by mimicing __getattr__ behavior: immediately return __dict__ or
    # items directly present in __dict__
        mydict = object.__getattribute__(self, '__dict__')

        if name == "__dict__":
          return mydict

        if name in mydict:
          return mydict[name]

        object.__getattribute__(self, 'assert_valid')()

        value = _get_instance_attr(self, name)
        fn = object.__getattribute__(self, '_retrieve_swig_value')
        return fn(name, value)
    else:
      def __getattr__(self, name):
        """Get an attribute from this object"""
        self.assert_valid()

        value = _swig_getattr(self, self.__class__, name)

        return self._retrieve_swig_value(name, value)

    def __setattr__(self, name, value):
      """Set an attribute on this object"""
      self.assert_valid()

    # Save a copy of the object, so that the garbage
    # collector won't kill the object while it's in
    # SWIG-land
      self.__dict__.setdefault("_members",{})[name] = value

      return _set_instance_attr(self, name, value)


    def __init__(self):
        """__init__(svn_client_ctx_t self) -> svn_client_ctx_t"""
        this = _client.new_svn_client_ctx_t()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _client.delete_svn_client_ctx_t
    __del__ = lambda self: None
svn_client_ctx_t_swigregister = _client.svn_client_ctx_t_swigregister
svn_client_ctx_t_swigregister(svn_client_ctx_t)


def svn_client_create_context2(*args) -> "svn_client_ctx_t **":
    """svn_client_create_context2(apr_hash_t cfg_hash, apr_pool_t pool) -> svn_error_t"""
    return _client.svn_client_create_context2(*args)

def svn_client_create_context(*args) -> "svn_client_ctx_t **":
    """svn_client_create_context(apr_pool_t pool) -> svn_error_t"""
    return _client.svn_client_create_context(*args)
SVN_CLIENT_AUTH_USERNAME = _client.SVN_CLIENT_AUTH_USERNAME
SVN_CLIENT_AUTH_PASSWORD = _client.SVN_CLIENT_AUTH_PASSWORD

def svn_client_args_to_target_array2(*args) -> "apr_array_header_t **":
    """svn_client_args_to_target_array2(apr_getopt_t * os, apr_array_header_t known_targets, svn_client_ctx_t ctx, svn_boolean_t keep_last_origpath_on_truepath_collision, apr_pool_t pool) -> svn_error_t"""
    return _client.svn_client_args_to_target_array2(*args)

def svn_client_args_to_target_array(*args) -> "apr_array_header_t **":
    """svn_client_args_to_target_array(apr_getopt_t * os, apr_array_header_t known_targets, svn_client_ctx_t ctx, apr_pool_t pool) -> svn_error_t"""
    return _client.svn_client_args_to_target_array(*args)

def svn_client_checkout3(*args) -> "svn_revnum_t *":
    """svn_client_checkout3(char const * URL, char const * path, svn_opt_revision_t peg_revision, svn_opt_revision_t revision, svn_depth_t depth, svn_boolean_t ignore_externals, svn_boolean_t allow_unver_obstructions, svn_client_ctx_t ctx, apr_pool_t pool) -> svn_error_t"""
    return _client.svn_client_checkout3(*args)

def svn_client_checkout2(*args) -> "svn_revnum_t *":
    """svn_client_checkout2(char const * URL, char const * path, svn_opt_revision_t peg_revision, svn_opt_revision_t revision, svn_boolean_t recurse, svn_boolean_t ignore_externals, svn_client_ctx_t ctx, apr_pool_t pool) -> svn_error_t"""
    return _client.svn_client_checkout2(*args)

def svn_client_checkout(*args) -> "svn_revnum_t *":
    """svn_client_checkout(char const * URL, char const * path, svn_opt_revision_t revision, svn_boolean_t recurse, svn_client_ctx_t ctx, apr_pool_t pool) -> svn_error_t"""
    return _client.svn_client_checkout(*args)

def svn_client_update4(*args) -> "apr_array_header_t **":
    """svn_client_update4(apr_array_header_t paths, svn_opt_revision_t revision, svn_depth_t depth, svn_boolean_t depth_is_sticky, svn_boolean_t ignore_externals, svn_boolean_t allow_unver_obstructions, svn_boolean_t adds_as_modification, svn_boolean_t make_parents, svn_client_ctx_t ctx, apr_pool_t pool) -> svn_error_t"""
    return _client.svn_client_update4(*args)

def svn_client_update3(*args) -> "apr_array_header_t **":
    """svn_client_update3(apr_array_header_t paths, svn_opt_revision_t revision, svn_depth_t depth, svn_boolean_t depth_is_sticky, svn_boolean_t ignore_externals, svn_boolean_t allow_unver_obstructions, svn_client_ctx_t ctx, apr_pool_t pool) -> svn_error_t"""
    return _client.svn_client_update3(*args)

def svn_client_update2(*args) -> "apr_array_header_t **":
    """svn_client_update2(apr_array_header_t paths, svn_opt_revision_t revision, svn_boolean_t recurse, svn_boolean_t ignore_externals, svn_client_ctx_t ctx, apr_pool_t pool) -> svn_error_t"""
    return _client.svn_client_update2(*args)

def svn_client_update(*args) -> "svn_revnum_t *":
    """svn_client_update(char const * path, svn_opt_revision_t revision, svn_boolean_t recurse, svn_client_ctx_t ctx, apr_pool_t pool) -> svn_error_t"""
    return _client.svn_client_update(*args)

def svn_client_switch3(*args) -> "svn_revnum_t *":
    """svn_client_switch3(char const * path, char const * url, svn_opt_revision_t peg_revision, svn_opt_revision_t revision, svn_depth_t depth, svn_boolean_t depth_is_sticky, svn_boolean_t ignore_externals, svn_boolean_t allow_unver_obstructions, svn_boolean_t ignore_ancestry, svn_client_ctx_t ctx, apr_pool_t pool) -> svn_error_t"""
    return _client.svn_client_switch3(*args)

def svn_client_switch2(*args) -> "svn_revnum_t *":
    """svn_client_switch2(char const * path, char const * url, svn_opt_revision_t peg_revision, svn_opt_revision_t revision, svn_depth_t depth, svn_boolean_t depth_is_sticky, svn_boolean_t ignore_externals, svn_boolean_t allow_unver_obstructions, svn_client_ctx_t ctx, apr_pool_t pool) -> svn_error_t"""
    return _client.svn_client_switch2(*args)

def svn_client_switch(*args) -> "svn_revnum_t *":
    """svn_client_switch(char const * path, char const * url, svn_opt_revision_t revision, svn_boolean_t recurse, svn_client_ctx_t ctx, apr_pool_t pool) -> svn_error_t"""
    return _client.svn_client_switch(*args)

def svn_client__layout_list(*args) -> "svn_error_t *":
    """svn_client__layout_list(char const * local_abspath, svn_client__layout_func_t layout, void * layout_baton, svn_client_ctx_t ctx, apr_pool_t scratch_pool) -> svn_error_t"""
    return _client.svn_client__layout_list(*args)

def svn_client_add5(*args) -> "svn_error_t *":
    """svn_client_add5(char const * path, svn_depth_t depth, svn_boolean_t force, svn_boolean_t no_ignore, svn_boolean_t no_autoprops, svn_boolean_t add_parents, svn_client_ctx_t ctx, apr_pool_t scratch_pool) -> svn_error_t"""
    return _client.svn_client_add5(*args)

def svn_client_add4(*args) -> "svn_error_t *":
    """svn_client_add4(char const * path, svn_depth_t depth, svn_boolean_t force, svn_boolean_t no_ignore, svn_boolean_t add_parents, svn_client_ctx_t ctx, apr_pool_t pool) -> svn_error_t"""
    return _client.svn_client_add4(*args)

def svn_client_add3(*args) -> "svn_error_t *":
    """svn_client_add3(char const * path, svn_boolean_t recursive, svn_boolean_t force, svn_boolean_t no_ignore, svn_client_ctx_t ctx, apr_pool_t pool) -> svn_error_t"""
    return _client.svn_client_add3(*args)

def svn_client_add2(*args) -> "svn_error_t *":
    """svn_client_add2(char const * path, svn_boolean_t recursive, svn_boolean_t force, svn_client_ctx_t ctx, apr_pool_t pool) -> svn_error_t"""
    return _client.svn_client_add2(*args)

def svn_client_add(*args) -> "svn_error_t *":
    """svn_client_add(char const * path, svn_boolean_t recursive, svn_client_ctx_t ctx, apr_pool_t pool) -> svn_error_t"""
    return _client.svn_client_add(*args)

def svn_client_mkdir4(*args) -> "svn_error_t *":
    """svn_client_mkdir4(apr_array_header_t paths, svn_boolean_t make_parents, apr_hash_t revprop_table, svn_commit_callback2_t commit_callback, svn_client_ctx_t ctx, apr_pool_t pool) -> svn_error_t"""
    return _client.svn_client_mkdir4(*args)

def svn_client_mkdir3(*args) -> "svn_commit_info_t **":
    """svn_client_mkdir3(apr_array_header_t paths, svn_boolean_t make_parents, apr_hash_t revprop_table, svn_client_ctx_t ctx, apr_pool_t pool) -> svn_error_t"""
    return _client.svn_client_mkdir3(*args)

def svn_client_mkdir2(*args) -> "svn_commit_info_t **":
    """svn_client_mkdir2(apr_array_header_t paths, svn_client_ctx_t ctx, apr_pool_t pool) -> svn_error_t"""
    return _client.svn_client_mkdir2(*args)

def svn_client_mkdir(*args) -> "svn_client_commit_info_t **":
    """svn_client_mkdir(apr_array_header_t paths, svn_client_ctx_t ctx, apr_pool_t pool) -> svn_error_t"""
    return _client.svn_client_mkdir(*args)

def svn_client_delete4(*args) -> "svn_error_t *":
    """svn_client_delete4(apr_array_header_t paths, svn_boolean_t force, svn_boolean_t keep_local, apr_hash_t revprop_table, svn_commit_callback2_t commit_callback, svn_client_ctx_t ctx, apr_pool_t pool) -> svn_error_t"""
    return _client.svn_client_delete4(*args)

def svn_client_delete3(*args) -> "svn_commit_info_t **":
    """svn_client_delete3(apr_array_header_t paths, svn_boolean_t force, svn_boolean_t keep_local, apr_hash_t revprop_table, svn_client_ctx_t ctx, apr_pool_t pool) -> svn_error_t"""
    return _client.svn_client_delete3(*args)

def svn_client_delete2(*args) -> "svn_commit_info_t **":
    """svn_client_delete2(apr_array_header_t paths, svn_boolean_t force, svn_client_ctx_t ctx, apr_pool_t pool) -> svn_error_t"""
    return _client.svn_client_delete2(*args)

def svn_client_delete(*args) -> "svn_client_commit_info_t **":
    """svn_client_delete(apr_array_header_t paths, svn_boolean_t force, svn_client_ctx_t ctx, apr_pool_t pool) -> svn_error_t"""
    return _client.svn_client_delete(*args)

def svn_client_import5(*args) -> "svn_error_t *":
    """svn_client_import5(char const * path, char const * url, svn_depth_t depth, svn_boolean_t no_ignore, svn_boolean_t no_autoprops, svn_boolean_t ignore_unknown_node_types, apr_hash_t revprop_table, svn_client_import_filter_func_t filter_callback, void * filter_baton, svn_commit_callback2_t commit_callback, svn_client_ctx_t ctx, apr_pool_t scratch_pool) -> svn_error_t"""
    return _client.svn_client_import5(*args)

def svn_client_import4(*args) -> "svn_error_t *":
    """svn_client_import4(char const * path, char const * url, svn_depth_t depth, svn_boolean_t no_ignore, svn_boolean_t ignore_unknown_node_types, apr_hash_t revprop_table, svn_commit_callback2_t commit_callback, svn_client_ctx_t ctx, apr_pool_t pool) -> svn_error_t"""
    return _client.svn_client_import4(*args)

def svn_client_import3(*args) -> "svn_commit_info_t **":
    """svn_client_import3(char const * path, char const * url, svn_depth_t depth, svn_boolean_t no_ignore, svn_boolean_t ignore_unknown_node_types, apr_hash_t revprop_table, svn_client_ctx_t ctx, apr_pool_t pool) -> svn_error_t"""
    return _client.svn_client_import3(*args)

def svn_client_import2(*args) -> "svn_commit_info_t **":
    """svn_client_import2(char const * path, char const * url, svn_boolean_t nonrecursive, svn_boolean_t no_ignore, svn_client_ctx_t ctx, apr_pool_t pool) -> svn_error_t"""
    return _client.svn_client_import2(*args)

def svn_client_import(*args) -> "svn_client_commit_info_t **":
    """svn_client_import(char const * path, char const * url, svn_boolean_t nonrecursive, svn_client_ctx_t ctx, apr_pool_t pool) -> svn_error_t"""
    return _client.svn_client_import(*args)

def svn_client_commit6(*args) -> "svn_error_t *":
    """svn_client_commit6(apr_array_header_t targets, svn_depth_t depth, svn_boolean_t keep_locks, svn_boolean_t keep_changelists, svn_boolean_t commit_as_operations, svn_boolean_t include_file_externals, svn_boolean_t include_dir_externals, apr_array_header_t changelists, apr_hash_t revprop_table, svn_commit_callback2_t commit_callback, svn_client_ctx_t ctx, apr_pool_t pool) -> svn_error_t"""
    return _client.svn_client_commit6(*args)

def svn_client_commit5(*args) -> "svn_error_t *":
    """svn_client_commit5(apr_array_header_t targets, svn_depth_t depth, svn_boolean_t keep_locks, svn_boolean_t keep_changelists, svn_boolean_t commit_as_operations, apr_array_header_t changelists, apr_hash_t revprop_table, svn_commit_callback2_t commit_callback, svn_client_ctx_t ctx, apr_pool_t pool) -> svn_error_t"""
    return _client.svn_client_commit5(*args)

def svn_client_commit4(*args) -> "svn_commit_info_t **":
    """svn_client_commit4(apr_array_header_t targets, svn_depth_t depth, svn_boolean_t keep_locks, svn_boolean_t keep_changelists, apr_array_header_t changelists, apr_hash_t revprop_table, svn_client_ctx_t ctx, apr_pool_t pool) -> svn_error_t"""
    return _client.svn_client_commit4(*args)

def svn_client_commit3(*args) -> "svn_commit_info_t **":
    """svn_client_commit3(apr_array_header_t targets, svn_boolean_t recurse, svn_boolean_t keep_locks, svn_client_ctx_t ctx, apr_pool_t pool) -> svn_error_t"""
    return _client.svn_client_commit3(*args)

def svn_client_commit2(*args) -> "svn_client_commit_info_t **":
    """svn_client_commit2(apr_array_header_t targets, svn_boolean_t recurse, svn_boolean_t keep_locks, svn_client_ctx_t ctx, apr_pool_t pool) -> svn_error_t"""
    return _client.svn_client_commit2(*args)

def svn_client_commit(*args) -> "svn_client_commit_info_t **":
    """svn_client_commit(apr_array_header_t targets, svn_boolean_t nonrecursive, svn_client_ctx_t ctx, apr_pool_t pool) -> svn_error_t"""
    return _client.svn_client_commit(*args)
class svn_client_status_t(object):
    """Proxy of C svn_client_status_t struct."""

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    kind = _swig_property(_client.svn_client_status_t_kind_get, _client.svn_client_status_t_kind_set)
    local_abspath = _swig_property(_client.svn_client_status_t_local_abspath_get, _client.svn_client_status_t_local_abspath_set)
    filesize = _swig_property(_client.svn_client_status_t_filesize_get, _client.svn_client_status_t_filesize_set)
    versioned = _swig_property(_client.svn_client_status_t_versioned_get, _client.svn_client_status_t_versioned_set)
    conflicted = _swig_property(_client.svn_client_status_t_conflicted_get, _client.svn_client_status_t_conflicted_set)
    node_status = _swig_property(_client.svn_client_status_t_node_status_get, _client.svn_client_status_t_node_status_set)
    text_status = _swig_property(_client.svn_client_status_t_text_status_get, _client.svn_client_status_t_text_status_set)
    prop_status = _swig_property(_client.svn_client_status_t_prop_status_get, _client.svn_client_status_t_prop_status_set)
    wc_is_locked = _swig_property(_client.svn_client_status_t_wc_is_locked_get, _client.svn_client_status_t_wc_is_locked_set)
    copied = _swig_property(_client.svn_client_status_t_copied_get, _client.svn_client_status_t_copied_set)
    repos_root_url = _swig_property(_client.svn_client_status_t_repos_root_url_get, _client.svn_client_status_t_repos_root_url_set)
    repos_uuid = _swig_property(_client.svn_client_status_t_repos_uuid_get, _client.svn_client_status_t_repos_uuid_set)
    repos_relpath = _swig_property(_client.svn_client_status_t_repos_relpath_get, _client.svn_client_status_t_repos_relpath_set)
    revision = _swig_property(_client.svn_client_status_t_revision_get, _client.svn_client_status_t_revision_set)
    changed_rev = _swig_property(_client.svn_client_status_t_changed_rev_get, _client.svn_client_status_t_changed_rev_set)
    changed_date = _swig_property(_client.svn_client_status_t_changed_date_get, _client.svn_client_status_t_changed_date_set)
    changed_author = _swig_property(_client.svn_client_status_t_changed_author_get, _client.svn_client_status_t_changed_author_set)
    switched = _swig_property(_client.svn_client_status_t_switched_get, _client.svn_client_status_t_switched_set)
    file_external = _swig_property(_client.svn_client_status_t_file_external_get, _client.svn_client_status_t_file_external_set)
    lock = _swig_property(_client.svn_client_status_t_lock_get, _client.svn_client_status_t_lock_set)
    changelist = _swig_property(_client.svn_client_status_t_changelist_get, _client.svn_client_status_t_changelist_set)
    depth = _swig_property(_client.svn_client_status_t_depth_get, _client.svn_client_status_t_depth_set)
    ood_kind = _swig_property(_client.svn_client_status_t_ood_kind_get, _client.svn_client_status_t_ood_kind_set)
    repos_node_status = _swig_property(_client.svn_client_status_t_repos_node_status_get, _client.svn_client_status_t_repos_node_status_set)
    repos_text_status = _swig_property(_client.svn_client_status_t_repos_text_status_get, _client.svn_client_status_t_repos_text_status_set)
    repos_prop_status = _swig_property(_client.svn_client_status_t_repos_prop_status_get, _client.svn_client_status_t_repos_prop_status_set)
    repos_lock = _swig_property(_client.svn_client_status_t_repos_lock_get, _client.svn_client_status_t_repos_lock_set)
    ood_changed_rev = _swig_property(_client.svn_client_status_t_ood_changed_rev_get, _client.svn_client_status_t_ood_changed_rev_set)
    ood_changed_date = _swig_property(_client.svn_client_status_t_ood_changed_date_get, _client.svn_client_status_t_ood_changed_date_set)
    ood_changed_author = _swig_property(_client.svn_client_status_t_ood_changed_author_get, _client.svn_client_status_t_ood_changed_author_set)
    backwards_compatibility_baton = _swig_property(_client.svn_client_status_t_backwards_compatibility_baton_get, _client.svn_client_status_t_backwards_compatibility_baton_set)
    moved_from_abspath = _swig_property(_client.svn_client_status_t_moved_from_abspath_get, _client.svn_client_status_t_moved_from_abspath_set)
    moved_to_abspath = _swig_property(_client.svn_client_status_t_moved_to_abspath_get, _client.svn_client_status_t_moved_to_abspath_set)
    def set_parent_pool(self, parent_pool=None):
      """Create a new proxy object for TYPE"""
      import libsvn.core, weakref
      self.__dict__["_parent_pool"] = \
        parent_pool or libsvn.core.application_pool;
      if self.__dict__["_parent_pool"]:
        self.__dict__["_is_valid"] = weakref.ref(
          self.__dict__["_parent_pool"]._is_valid)

    def assert_valid(self):
      """Assert that this object is using valid pool memory"""
      if "_is_valid" in self.__dict__:
        assert self.__dict__["_is_valid"](), "Variable has already been deleted"

    def _retrieve_swig_value(self, name, value):
    # If we got back a different object than we have cached, we need to copy
    # all our metadata into it, so that it looks identical to the one
    # originally set.
      members = self.__dict__.get('_members')
      if members is not None and name in members:
        _copy_metadata_deep(value, members[name])

    # Verify that the new object is good
      _assert_valid_deep(value)

      return value

    # Attribute access must be intercepted to ensure that objects coming from
    # read attribute access match those that are set with write attribute access.
    # Specifically the metadata, such as the associated apr_pool object, should
    # match the originally assigned object.
    #
    # For classic classes it is enough to use __getattr__ to intercept swig
    # derived attributes. However, with new style classes SWIG makes use of
    # descriptors which mean that __getattr__ is never called. Therefore,
    # __getattribute__ must be used for the interception.

    if _newclass:
      def __getattribute__(self, name):
        """Manage access to all attributes of this object."""

    # Start by mimicing __getattr__ behavior: immediately return __dict__ or
    # items directly present in __dict__
        mydict = object.__getattribute__(self, '__dict__')

        if name == "__dict__":
          return mydict

        if name in mydict:
          return mydict[name]

        object.__getattribute__(self, 'assert_valid')()

        value = _get_instance_attr(self, name)
        fn = object.__getattribute__(self, '_retrieve_swig_value')
        return fn(name, value)
    else:
      def __getattr__(self, name):
        """Get an attribute from this object"""
        self.assert_valid()

        value = _swig_getattr(self, self.__class__, name)

        return self._retrieve_swig_value(name, value)

    def __setattr__(self, name, value):
      """Set an attribute on this object"""
      self.assert_valid()

    # Save a copy of the object, so that the garbage
    # collector won't kill the object while it's in
    # SWIG-land
      self.__dict__.setdefault("_members",{})[name] = value

      return _set_instance_attr(self, name, value)


    def __init__(self):
        """__init__(svn_client_status_t self) -> svn_client_status_t"""
        this = _client.new_svn_client_status_t()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _client.delete_svn_client_status_t
    __del__ = lambda self: None
svn_client_status_t_swigregister = _client.svn_client_status_t_swigregister
svn_client_status_t_swigregister(svn_client_status_t)


def svn_client_status_dup(*args) -> "svn_client_status_t *":
    """svn_client_status_dup(svn_client_status_t status, apr_pool_t result_pool) -> svn_client_status_t"""
    return _client.svn_client_status_dup(*args)

def svn_client_status6(*args) -> "svn_revnum_t *":
    """svn_client_status6(svn_client_ctx_t ctx, char const * path, svn_opt_revision_t revision, svn_depth_t depth, svn_boolean_t get_all, svn_boolean_t check_out_of_date, svn_boolean_t check_working_copy, svn_boolean_t no_ignore, svn_boolean_t ignore_externals, svn_boolean_t depth_as_sticky, apr_array_header_t changelists, svn_client_status_func_t status_func, apr_pool_t scratch_pool) -> svn_error_t"""
    return _client.svn_client_status6(*args)

def svn_client_status5(*args) -> "svn_revnum_t *":
    """svn_client_status5(svn_client_ctx_t ctx, char const * path, svn_opt_revision_t revision, svn_depth_t depth, svn_boolean_t get_all, svn_boolean_t update, svn_boolean_t no_ignore, svn_boolean_t ignore_externals, svn_boolean_t depth_as_sticky, apr_array_header_t changelists, svn_client_status_func_t status_func, apr_pool_t scratch_pool) -> svn_error_t"""
    return _client.svn_client_status5(*args)

def svn_client_status4(*args) -> "svn_revnum_t *":
    """svn_client_status4(char const * path, svn_opt_revision_t revision, svn_wc_status_func3_t status_func, void * status_baton, svn_depth_t depth, svn_boolean_t get_all, svn_boolean_t update, svn_boolean_t no_ignore, svn_boolean_t ignore_externals, apr_array_header_t changelists, svn_client_ctx_t ctx, apr_pool_t pool) -> svn_error_t"""
    return _client.svn_client_status4(*args)

def svn_client_status3(*args) -> "svn_revnum_t *":
    """svn_client_status3(char const * path, svn_opt_revision_t revision, svn_wc_status_func2_t status_func, svn_depth_t depth, svn_boolean_t get_all, svn_boolean_t update, svn_boolean_t no_ignore, svn_boolean_t ignore_externals, apr_array_header_t changelists, svn_client_ctx_t ctx, apr_pool_t pool) -> svn_error_t"""
    return _client.svn_client_status3(*args)

def svn_client_status2(*args) -> "svn_revnum_t *":
    """svn_client_status2(char const * path, svn_opt_revision_t revision, svn_wc_status_func2_t status_func, svn_boolean_t recurse, svn_boolean_t get_all, svn_boolean_t update, svn_boolean_t no_ignore, svn_boolean_t ignore_externals, svn_client_ctx_t ctx, apr_pool_t pool) -> svn_error_t"""
    return _client.svn_client_status2(*args)

def svn_client_status(*args) -> "svn_revnum_t *":
    """svn_client_status(char const * path, svn_opt_revision_t revision, svn_wc_status_func_t status_func, svn_boolean_t recurse, svn_boolean_t get_all, svn_boolean_t update, svn_boolean_t no_ignore, svn_client_ctx_t ctx, apr_pool_t pool) -> svn_error_t"""
    return _client.svn_client_status(*args)

def svn_client_log5(*args) -> "svn_error_t *":
    """svn_client_log5(apr_array_header_t targets, svn_opt_revision_t peg_revision, apr_array_header_t revision_ranges, int limit, svn_boolean_t discover_changed_paths, svn_boolean_t strict_node_history, svn_boolean_t include_merged_revisions, apr_array_header_t revprops, svn_log_entry_receiver_t receiver, svn_client_ctx_t ctx, apr_pool_t pool) -> svn_error_t"""
    return _client.svn_client_log5(*args)

def svn_client_log4(*args) -> "svn_error_t *":
    """svn_client_log4(apr_array_header_t targets, svn_opt_revision_t peg_revision, svn_opt_revision_t start, svn_opt_revision_t end, int limit, svn_boolean_t discover_changed_paths, svn_boolean_t strict_node_history, svn_boolean_t include_merged_revisions, apr_array_header_t revprops, svn_log_entry_receiver_t receiver, svn_client_ctx_t ctx, apr_pool_t pool) -> svn_error_t"""
    return _client.svn_client_log4(*args)

def svn_client_log3(*args) -> "svn_error_t *":
    """svn_client_log3(apr_array_header_t targets, svn_opt_revision_t peg_revision, svn_opt_revision_t start, svn_opt_revision_t end, int limit, svn_boolean_t discover_changed_paths, svn_boolean_t strict_node_history, svn_log_message_receiver_t receiver, svn_client_ctx_t ctx, apr_pool_t pool) -> svn_error_t"""
    return _client.svn_client_log3(*args)

def svn_client_log2(*args) -> "svn_error_t *":
    """svn_client_log2(apr_array_header_t targets, svn_opt_revision_t start, svn_opt_revision_t end, int limit, svn_boolean_t discover_changed_paths, svn_boolean_t strict_node_history, svn_log_message_receiver_t receiver, svn_client_ctx_t ctx, apr_pool_t pool) -> svn_error_t"""
    return _client.svn_client_log2(*args)

def svn_client_log(*args) -> "svn_error_t *":
    """svn_client_log(apr_array_header_t targets, svn_opt_revision_t start, svn_opt_revision_t end, svn_boolean_t discover_changed_paths, svn_boolean_t strict_node_history, svn_log_message_receiver_t receiver, svn_client_ctx_t ctx, apr_pool_t pool) -> svn_error_t"""
    return _client.svn_client_log(*args)

def svn_client_blame6(*args) -> "svn_revnum_t *, svn_revnum_t *":
    """svn_client_blame6(char const * path_or_url, svn_opt_revision_t peg_revision, svn_opt_revision_t start, svn_opt_revision_t end, svn_diff_file_options_t const * diff_options, svn_boolean_t ignore_mime_type, svn_boolean_t include_merged_revisions, svn_client_blame_receiver4_t receiver, void * receiver_baton, svn_client_ctx_t ctx, apr_pool_t pool) -> svn_error_t"""
    return _client.svn_client_blame6(*args)

def svn_client_blame5(*args) -> "svn_error_t *":
    """svn_client_blame5(char const * path_or_url, svn_opt_revision_t peg_revision, svn_opt_revision_t start, svn_opt_revision_t end, svn_diff_file_options_t const * diff_options, svn_boolean_t ignore_mime_type, svn_boolean_t include_merged_revisions, svn_client_blame_receiver3_t receiver, void * receiver_baton, svn_client_ctx_t ctx, apr_pool_t pool) -> svn_error_t"""
    return _client.svn_client_blame5(*args)

def svn_client_blame4(*args) -> "svn_error_t *":
    """svn_client_blame4(char const * path_or_url, svn_opt_revision_t peg_revision, svn_opt_revision_t start, svn_opt_revision_t end, svn_diff_file_options_t const * diff_options, svn_boolean_t ignore_mime_type, svn_boolean_t include_merged_revisions, svn_client_blame_receiver2_t receiver, void * receiver_baton, svn_client_ctx_t ctx, apr_pool_t pool) -> svn_error_t"""
    return _client.svn_client_blame4(*args)

def svn_client_blame3(*args) -> "svn_error_t *":
    """svn_client_blame3(char const * path_or_url, svn_opt_revision_t peg_revision, svn_opt_revision_t start, svn_opt_revision_t end, svn_diff_file_options_t const * diff_options, svn_boolean_t ignore_mime_type, svn_client_blame_receiver_t receiver, svn_client_ctx_t ctx, apr_pool_t pool) -> svn_error_t"""
    return _client.svn_client_blame3(*args)

def svn_client_blame2(*args) -> "svn_error_t *":
    """svn_client_blame2(char const * path_or_url, svn_opt_revision_t peg_revision, svn_opt_revision_t start, svn_opt_revision_t end, svn_client_blame_receiver_t receiver, svn_client_ctx_t ctx, apr_pool_t pool) -> svn_error_t"""
    return _client.svn_client_blame2(*args)

def svn_client_blame(*args) -> "svn_error_t *":
    """svn_client_blame(char const * path_or_url, svn_opt_revision_t start, svn_opt_revision_t end, svn_client_blame_receiver_t receiver, svn_client_ctx_t ctx, apr_pool_t pool) -> svn_error_t"""
    return _client.svn_client_blame(*args)

def svn_client_diff7(*args) -> "svn_error_t *":
    """svn_client_diff7(apr_array_header_t diff_options, char const * path_or_url1, svn_opt_revision_t revision1, char const * path_or_url2, svn_opt_revision_t revision2, char const * relative_to_dir, svn_depth_t depth, svn_boolean_t ignore_ancestry, svn_boolean_t no_diff_added, svn_boolean_t no_diff_deleted, svn_boolean_t show_copies_as_adds, svn_boolean_t ignore_content_type, svn_boolean_t ignore_properties, svn_boolean_t properties_only, svn_boolean_t use_git_diff_format, svn_boolean_t pretty_print_mergeinfo, char const * header_encoding, svn_stream_t * outstream, svn_stream_t * errstream, apr_array_header_t changelists, svn_client_ctx_t ctx, apr_pool_t pool) -> svn_error_t"""
    return _client.svn_client_diff7(*args)

def svn_client_diff6(*args) -> "svn_error_t *":
    """svn_client_diff6(apr_array_header_t diff_options, char const * path_or_url1, svn_opt_revision_t revision1, char const * path_or_url2, svn_opt_revision_t revision2, char const * relative_to_dir, svn_depth_t depth, svn_boolean_t ignore_ancestry, svn_boolean_t no_diff_added, svn_boolean_t no_diff_deleted, svn_boolean_t show_copies_as_adds, svn_boolean_t ignore_content_type, svn_boolean_t ignore_properties, svn_boolean_t properties_only, svn_boolean_t use_git_diff_format, char const * header_encoding, svn_stream_t * outstream, svn_stream_t * errstream, apr_array_header_t changelists, svn_client_ctx_t ctx, apr_pool_t pool) -> svn_error_t"""
    return _client.svn_client_diff6(*args)

def svn_client_diff5(*args) -> "svn_error_t *":
    """svn_client_diff5(apr_array_header_t diff_options, char const * path1, svn_opt_revision_t revision1, char const * path2, svn_opt_revision_t revision2, char const * relative_to_dir, svn_depth_t depth, svn_boolean_t ignore_ancestry, svn_boolean_t no_diff_deleted, svn_boolean_t show_copies_as_adds, svn_boolean_t ignore_content_type, svn_boolean_t use_git_diff_format, char const * header_encoding, apr_file_t outfile, apr_file_t errfile, apr_array_header_t changelists, svn_client_ctx_t ctx, apr_pool_t pool) -> svn_error_t"""
    return _client.svn_client_diff5(*args)

def svn_client_diff4(*args) -> "svn_error_t *":
    """svn_client_diff4(apr_array_header_t diff_options, char const * path1, svn_opt_revision_t revision1, char const * path2, svn_opt_revision_t revision2, char const * relative_to_dir, svn_depth_t depth, svn_boolean_t ignore_ancestry, svn_boolean_t no_diff_deleted, svn_boolean_t ignore_content_type, char const * header_encoding, apr_file_t outfile, apr_file_t errfile, apr_array_header_t changelists, svn_client_ctx_t ctx, apr_pool_t pool) -> svn_error_t"""
    return _client.svn_client_diff4(*args)

def svn_client_diff3(*args) -> "svn_error_t *":
    """svn_client_diff3(apr_array_header_t diff_options, char const * path1, svn_opt_revision_t revision1, char const * path2, svn_opt_revision_t revision2, svn_boolean_t recurse, svn_boolean_t ignore_ancestry, svn_boolean_t no_diff_deleted, svn_boolean_t ignore_content_type, char const * header_encoding, apr_file_t outfile, apr_file_t errfile, svn_client_ctx_t ctx, apr_pool_t pool) -> svn_error_t"""
    return _client.svn_client_diff3(*args)

def svn_client_diff2(*args) -> "svn_error_t *":
    """svn_client_diff2(apr_array_header_t diff_options, char const * path1, svn_opt_revision_t revision1, char const * path2, svn_opt_revision_t revision2, svn_boolean_t recurse, svn_boolean_t ignore_ancestry, svn_boolean_t no_diff_deleted, svn_boolean_t ignore_content_type, apr_file_t outfile, apr_file_t errfile, svn_client_ctx_t ctx, apr_pool_t pool) -> svn_error_t"""
    return _client.svn_client_diff2(*args)

def svn_client_diff(*args) -> "svn_error_t *":
    """svn_client_diff(apr_array_header_t diff_options, char const * path1, svn_opt_revision_t revision1, char const * path2, svn_opt_revision_t revision2, svn_boolean_t recurse, svn_boolean_t ignore_ancestry, svn_boolean_t no_diff_deleted, apr_file_t outfile, apr_file_t errfile, svn_client_ctx_t ctx, apr_pool_t pool) -> svn_error_t"""
    return _client.svn_client_diff(*args)

def svn_client_diff_peg7(*args) -> "svn_error_t *":
    """svn_client_diff_peg7(apr_array_header_t diff_options, char const * path_or_url, svn_opt_revision_t peg_revision, svn_opt_revision_t start_revision, svn_opt_revision_t end_revision, char const * relative_to_dir, svn_depth_t depth, svn_boolean_t ignore_ancestry, svn_boolean_t no_diff_added, svn_boolean_t no_diff_deleted, svn_boolean_t show_copies_as_adds, svn_boolean_t ignore_content_type, svn_boolean_t ignore_properties, svn_boolean_t properties_only, svn_boolean_t use_git_diff_format, svn_boolean_t pretty_print_mergeinfo, char const * header_encoding, svn_stream_t * outstream, svn_stream_t * errstream, apr_array_header_t changelists, svn_client_ctx_t ctx, apr_pool_t pool) -> svn_error_t"""
    return _client.svn_client_diff_peg7(*args)

def svn_client_diff_peg6(*args) -> "svn_error_t *":
    """svn_client_diff_peg6(apr_array_header_t diff_options, char const * path_or_url, svn_opt_revision_t peg_revision, svn_opt_revision_t start_revision, svn_opt_revision_t end_revision, char const * relative_to_dir, svn_depth_t depth, svn_boolean_t ignore_ancestry, svn_boolean_t no_diff_added, svn_boolean_t no_diff_deleted, svn_boolean_t show_copies_as_adds, svn_boolean_t ignore_content_type, svn_boolean_t ignore_properties, svn_boolean_t properties_only, svn_boolean_t use_git_diff_format, char const * header_encoding, svn_stream_t * outstream, svn_stream_t * errstream, apr_array_header_t changelists, svn_client_ctx_t ctx, apr_pool_t pool) -> svn_error_t"""
    return _client.svn_client_diff_peg6(*args)

def svn_client_diff_peg5(*args) -> "svn_error_t *":
    """svn_client_diff_peg5(apr_array_header_t diff_options, char const * path, svn_opt_revision_t peg_revision, svn_opt_revision_t start_revision, svn_opt_revision_t end_revision, char const * relative_to_dir, svn_depth_t depth, svn_boolean_t ignore_ancestry, svn_boolean_t no_diff_deleted, svn_boolean_t show_copies_as_adds, svn_boolean_t ignore_content_type, svn_boolean_t use_git_diff_format, char const * header_encoding, apr_file_t outfile, apr_file_t errfile, apr_array_header_t changelists, svn_client_ctx_t ctx, apr_pool_t pool) -> svn_error_t"""
    return _client.svn_client_diff_peg5(*args)

def svn_client_diff_peg4(*args) -> "svn_error_t *":
    """svn_client_diff_peg4(apr_array_header_t diff_options, char const * path, svn_opt_revision_t peg_revision, svn_opt_revision_t start_revision, svn_opt_revision_t end_revision, char const * relative_to_dir, svn_depth_t depth, svn_boolean_t ignore_ancestry, svn_boolean_t no_diff_deleted, svn_boolean_t ignore_content_type, char const * header_encoding, apr_file_t outfile, apr_file_t errfile, apr_array_header_t changelists, svn_client_ctx_t ctx, apr_pool_t pool) -> svn_error_t"""
    return _client.svn_client_diff_peg4(*args)

def svn_client_diff_peg3(*args) -> "svn_error_t *":
    """svn_client_diff_peg3(apr_array_header_t diff_options, char const * path, svn_opt_revision_t peg_revision, svn_opt_revision_t start_revision, svn_opt_revision_t end_revision, svn_boolean_t recurse, svn_boolean_t ignore_ancestry, svn_boolean_t no_diff_deleted, svn_boolean_t ignore_content_type, char const * header_encoding, apr_file_t outfile, apr_file_t errfile, svn_client_ctx_t ctx, apr_pool_t pool) -> svn_error_t"""
    return _client.svn_client_diff_peg3(*args)

def svn_client_diff_peg2(*args) -> "svn_error_t *":
    """svn_client_diff_peg2(apr_array_header_t diff_options, char const * path, svn_opt_revision_t peg_revision, svn_opt_revision_t start_revision, svn_opt_revision_t end_revision, svn_boolean_t recurse, svn_boolean_t ignore_ancestry, svn_boolean_t no_diff_deleted, svn_boolean_t ignore_content_type, apr_file_t outfile, apr_file_t errfile, svn_client_ctx_t ctx, apr_pool_t pool) -> svn_error_t"""
    return _client.svn_client_diff_peg2(*args)

def svn_client_diff_peg(*args) -> "svn_error_t *":
    """svn_client_diff_peg(apr_array_header_t diff_options, char const * path, svn_opt_revision_t peg_revision, svn_opt_revision_t start_revision, svn_opt_revision_t end_revision, svn_boolean_t recurse, svn_boolean_t ignore_ancestry, svn_boolean_t no_diff_deleted, apr_file_t outfile, apr_file_t errfile, svn_client_ctx_t ctx, apr_pool_t pool) -> svn_error_t"""
    return _client.svn_client_diff_peg(*args)

def svn_client_diff_summarize2(*args) -> "svn_error_t *":
    """svn_client_diff_summarize2(char const * path_or_url1, svn_opt_revision_t revision1, char const * path_or_url2, svn_opt_revision_t revision2, svn_depth_t depth, svn_boolean_t ignore_ancestry, apr_array_header_t changelists, svn_client_diff_summarize_func_t summarize_func, void * summarize_baton, svn_client_ctx_t ctx, apr_pool_t pool) -> svn_error_t"""
    return _client.svn_client_diff_summarize2(*args)

def svn_client_diff_summarize(*args) -> "svn_error_t *":
    """svn_client_diff_summarize(char const * path1, svn_opt_revision_t revision1, char const * path2, svn_opt_revision_t revision2, svn_boolean_t recurse, svn_boolean_t ignore_ancestry, svn_client_diff_summarize_func_t summarize_func, void * summarize_baton, svn_client_ctx_t ctx, apr_pool_t pool) -> svn_error_t"""
    return _client.svn_client_diff_summarize(*args)

def svn_client_diff_summarize_peg2(*args) -> "svn_error_t *":
    """svn_client_diff_summarize_peg2(char const * path_or_url, svn_opt_revision_t peg_revision, svn_opt_revision_t start_revision, svn_opt_revision_t end_revision, svn_depth_t depth, svn_boolean_t ignore_ancestry, apr_array_header_t changelists, svn_client_diff_summarize_func_t summarize_func, void * summarize_baton, svn_client_ctx_t ctx, apr_pool_t pool) -> svn_error_t"""
    return _client.svn_client_diff_summarize_peg2(*args)

def svn_client_diff_summarize_peg(*args) -> "svn_error_t *":
    """svn_client_diff_summarize_peg(char const * path, svn_opt_revision_t peg_revision, svn_opt_revision_t start_revision, svn_opt_revision_t end_revision, svn_boolean_t recurse, svn_boolean_t ignore_ancestry, svn_client_diff_summarize_func_t summarize_func, void * summarize_baton, svn_client_ctx_t ctx, apr_pool_t pool) -> svn_error_t"""
    return _client.svn_client_diff_summarize_peg(*args)

def svn_client_get_merging_summary(*args) -> "svn_boolean_t *, char const **, svn_revnum_t *, char const **, svn_revnum_t *, char const **, svn_revnum_t *, char const **, svn_revnum_t *, char const **":
    """svn_client_get_merging_summary(char const * source_path_or_url, svn_opt_revision_t source_revision, char const * target_path_or_url, svn_opt_revision_t target_revision, svn_client_ctx_t ctx, apr_pool_t result_pool, apr_pool_t scratch_pool) -> svn_error_t"""
    return _client.svn_client_get_merging_summary(*args)

def svn_client_merge5(*args) -> "svn_error_t *":
    """svn_client_merge5(char const * source1, svn_opt_revision_t revision1, char const * source2, svn_opt_revision_t revision2, char const * target_wcpath, svn_depth_t depth, svn_boolean_t ignore_mergeinfo, svn_boolean_t diff_ignore_ancestry, svn_boolean_t force_delete, svn_boolean_t record_only, svn_boolean_t dry_run, svn_boolean_t allow_mixed_rev, apr_array_header_t merge_options, svn_client_ctx_t ctx, apr_pool_t pool) -> svn_error_t"""
    return _client.svn_client_merge5(*args)

def svn_client_merge4(*args) -> "svn_error_t *":
    """svn_client_merge4(char const * source1, svn_opt_revision_t revision1, char const * source2, svn_opt_revision_t revision2, char const * target_wcpath, svn_depth_t depth, svn_boolean_t ignore_ancestry, svn_boolean_t force_delete, svn_boolean_t record_only, svn_boolean_t dry_run, svn_boolean_t allow_mixed_rev, apr_array_header_t merge_options, svn_client_ctx_t ctx, apr_pool_t pool) -> svn_error_t"""
    return _client.svn_client_merge4(*args)

def svn_client_merge3(*args) -> "svn_error_t *":
    """svn_client_merge3(char const * source1, svn_opt_revision_t revision1, char const * source2, svn_opt_revision_t revision2, char const * target_wcpath, svn_depth_t depth, svn_boolean_t ignore_ancestry, svn_boolean_t force, svn_boolean_t record_only, svn_boolean_t dry_run, apr_array_header_t merge_options, svn_client_ctx_t ctx, apr_pool_t pool) -> svn_error_t"""
    return _client.svn_client_merge3(*args)

def svn_client_merge2(*args) -> "svn_error_t *":
    """svn_client_merge2(char const * source1, svn_opt_revision_t revision1, char const * source2, svn_opt_revision_t revision2, char const * target_wcpath, svn_boolean_t recurse, svn_boolean_t ignore_ancestry, svn_boolean_t force, svn_boolean_t dry_run, apr_array_header_t merge_options, svn_client_ctx_t ctx, apr_pool_t pool) -> svn_error_t"""
    return _client.svn_client_merge2(*args)

def svn_client_merge(*args) -> "svn_error_t *":
    """svn_client_merge(char const * source1, svn_opt_revision_t revision1, char const * source2, svn_opt_revision_t revision2, char const * target_wcpath, svn_boolean_t recurse, svn_boolean_t ignore_ancestry, svn_boolean_t force, svn_boolean_t dry_run, svn_client_ctx_t ctx, apr_pool_t pool) -> svn_error_t"""
    return _client.svn_client_merge(*args)

def svn_client_merge_reintegrate(*args) -> "svn_error_t *":
    """svn_client_merge_reintegrate(char const * source_path_or_url, svn_opt_revision_t source_peg_revision, char const * target_wcpath, svn_boolean_t dry_run, apr_array_header_t merge_options, svn_client_ctx_t ctx, apr_pool_t pool) -> svn_error_t"""
    return _client.svn_client_merge_reintegrate(*args)

def svn_client_merge_peg5(*args) -> "svn_error_t *":
    """svn_client_merge_peg5(char const * source_path_or_url, apr_array_header_t ranges_to_merge, svn_opt_revision_t source_peg_revision, char const * target_wcpath, svn_depth_t depth, svn_boolean_t ignore_mergeinfo, svn_boolean_t diff_ignore_ancestry, svn_boolean_t force_delete, svn_boolean_t record_only, svn_boolean_t dry_run, svn_boolean_t allow_mixed_rev, apr_array_header_t merge_options, svn_client_ctx_t ctx, apr_pool_t pool) -> svn_error_t"""
    return _client.svn_client_merge_peg5(*args)

def svn_client_merge_peg4(*args) -> "svn_error_t *":
    """svn_client_merge_peg4(char const * source_path_or_url, apr_array_header_t ranges_to_merge, svn_opt_revision_t source_peg_revision, char const * target_wcpath, svn_depth_t depth, svn_boolean_t ignore_ancestry, svn_boolean_t force_delete, svn_boolean_t record_only, svn_boolean_t dry_run, svn_boolean_t allow_mixed_rev, apr_array_header_t merge_options, svn_client_ctx_t ctx, apr_pool_t pool) -> svn_error_t"""
    return _client.svn_client_merge_peg4(*args)

def svn_client_merge_peg3(*args) -> "svn_error_t *":
    """svn_client_merge_peg3(char const * source, apr_array_header_t ranges_to_merge, svn_opt_revision_t peg_revision, char const * target_wcpath, svn_depth_t depth, svn_boolean_t ignore_ancestry, svn_boolean_t force, svn_boolean_t record_only, svn_boolean_t dry_run, apr_array_header_t merge_options, svn_client_ctx_t ctx, apr_pool_t pool) -> svn_error_t"""
    return _client.svn_client_merge_peg3(*args)

def svn_client_merge_peg2(*args) -> "svn_error_t *":
    """svn_client_merge_peg2(char const * source, svn_opt_revision_t revision1, svn_opt_revision_t revision2, svn_opt_revision_t peg_revision, char const * target_wcpath, svn_boolean_t recurse, svn_boolean_t ignore_ancestry, svn_boolean_t force, svn_boolean_t dry_run, apr_array_header_t merge_options, svn_client_ctx_t ctx, apr_pool_t pool) -> svn_error_t"""
    return _client.svn_client_merge_peg2(*args)

def svn_client_merge_peg(*args) -> "svn_error_t *":
    """svn_client_merge_peg(char const * source, svn_opt_revision_t revision1, svn_opt_revision_t revision2, svn_opt_revision_t peg_revision, char const * target_wcpath, svn_boolean_t recurse, svn_boolean_t ignore_ancestry, svn_boolean_t force, svn_boolean_t dry_run, svn_client_ctx_t ctx, apr_pool_t pool) -> svn_error_t"""
    return _client.svn_client_merge_peg(*args)

def svn_client_suggest_merge_sources(*args) -> "apr_array_header_t **":
    """svn_client_suggest_merge_sources(char const * path_or_url, svn_opt_revision_t peg_revision, svn_client_ctx_t ctx, apr_pool_t pool) -> svn_error_t"""
    return _client.svn_client_suggest_merge_sources(*args)

def svn_client_mergeinfo_get_merged(*args) -> "apr_hash_t **":
    """svn_client_mergeinfo_get_merged(char const * path_or_url, svn_opt_revision_t peg_revision, svn_client_ctx_t ctx, apr_pool_t pool) -> svn_error_t"""
    return _client.svn_client_mergeinfo_get_merged(*args)

def svn_client_mergeinfo_log2(*args) -> "svn_error_t *":
    """svn_client_mergeinfo_log2(svn_boolean_t finding_merged, char const * target_path_or_url, svn_opt_revision_t target_peg_revision, char const * source_path_or_url, svn_opt_revision_t source_peg_revision, svn_opt_revision_t source_start_revision, svn_opt_revision_t source_end_revision, svn_log_entry_receiver_t receiver, svn_boolean_t discover_changed_paths, svn_depth_t depth, apr_array_header_t revprops, svn_client_ctx_t ctx, apr_pool_t scratch_pool) -> svn_error_t"""
    return _client.svn_client_mergeinfo_log2(*args)

def svn_client_mergeinfo_log(*args) -> "svn_error_t *":
    """svn_client_mergeinfo_log(svn_boolean_t finding_merged, char const * target_path_or_url, svn_opt_revision_t target_peg_revision, char const * source_path_or_url, svn_opt_revision_t source_peg_revision, svn_log_entry_receiver_t receiver, svn_boolean_t discover_changed_paths, svn_depth_t depth, apr_array_header_t revprops, svn_client_ctx_t ctx, apr_pool_t scratch_pool) -> svn_error_t"""
    return _client.svn_client_mergeinfo_log(*args)

def svn_client_mergeinfo_log_merged(*args) -> "svn_error_t *":
    """svn_client_mergeinfo_log_merged(char const * path_or_url, svn_opt_revision_t peg_revision, char const * merge_source_path_or_url, svn_opt_revision_t src_peg_revision, svn_log_entry_receiver_t receiver, svn_boolean_t discover_changed_paths, apr_array_header_t revprops, svn_client_ctx_t ctx, apr_pool_t pool) -> svn_error_t"""
    return _client.svn_client_mergeinfo_log_merged(*args)

def svn_client_mergeinfo_log_eligible(*args) -> "svn_error_t *":
    """svn_client_mergeinfo_log_eligible(char const * path_or_url, svn_opt_revision_t peg_revision, char const * merge_source_path_or_url, svn_opt_revision_t src_peg_revision, svn_log_entry_receiver_t receiver, svn_boolean_t discover_changed_paths, apr_array_header_t revprops, svn_client_ctx_t ctx, apr_pool_t pool) -> svn_error_t"""
    return _client.svn_client_mergeinfo_log_eligible(*args)

def svn_client_vacuum(*args) -> "svn_error_t *":
    """svn_client_vacuum(char const * dir_abspath, svn_boolean_t remove_unversioned_items, svn_boolean_t remove_ignored_items, svn_boolean_t fix_recorded_timestamps, svn_boolean_t vacuum_pristines, svn_boolean_t include_externals, svn_client_ctx_t ctx, apr_pool_t scratch_pool) -> svn_error_t"""
    return _client.svn_client_vacuum(*args)

def svn_client_cleanup2(*args) -> "svn_error_t *":
    """svn_client_cleanup2(char const * dir_abspath, svn_boolean_t break_locks, svn_boolean_t fix_recorded_timestamps, svn_boolean_t clear_dav_cache, svn_boolean_t vacuum_pristines, svn_boolean_t include_externals, svn_client_ctx_t ctx, apr_pool_t scratch_pool) -> svn_error_t"""
    return _client.svn_client_cleanup2(*args)

def svn_client_cleanup(*args) -> "svn_error_t *":
    """svn_client_cleanup(char const * dir, svn_client_ctx_t ctx, apr_pool_t scratch_pool) -> svn_error_t"""
    return _client.svn_client_cleanup(*args)

def svn_client_upgrade(*args) -> "svn_error_t *":
    """svn_client_upgrade(char const * wcroot_dir, svn_client_ctx_t ctx, apr_pool_t scratch_pool) -> svn_error_t"""
    return _client.svn_client_upgrade(*args)

def svn_client_relocate2(*args) -> "svn_error_t *":
    """svn_client_relocate2(char const * wcroot_dir, char const * from_prefix, char const * to_prefix, svn_boolean_t ignore_externals, svn_client_ctx_t ctx, apr_pool_t pool) -> svn_error_t"""
    return _client.svn_client_relocate2(*args)

def svn_client_relocate(*args) -> "svn_error_t *":
    """svn_client_relocate(char const * dir, char const * from_prefix, char const * to_prefix, svn_boolean_t recurse, svn_client_ctx_t ctx, apr_pool_t pool) -> svn_error_t"""
    return _client.svn_client_relocate(*args)

def svn_client_revert4(*args) -> "svn_error_t *":
    """svn_client_revert4(apr_array_header_t paths, svn_depth_t depth, apr_array_header_t changelists, svn_boolean_t clear_changelists, svn_boolean_t metadata_only, svn_boolean_t added_keep_local, svn_client_ctx_t ctx, apr_pool_t scratch_pool) -> svn_error_t"""
    return _client.svn_client_revert4(*args)

def svn_client_revert3(*args) -> "svn_error_t *":
    """svn_client_revert3(apr_array_header_t paths, svn_depth_t depth, apr_array_header_t changelists, svn_boolean_t clear_changelists, svn_boolean_t metadata_only, svn_client_ctx_t ctx, apr_pool_t pool) -> svn_error_t"""
    return _client.svn_client_revert3(*args)

def svn_client_revert2(*args) -> "svn_error_t *":
    """svn_client_revert2(apr_array_header_t paths, svn_depth_t depth, apr_array_header_t changelists, svn_client_ctx_t ctx, apr_pool_t pool) -> svn_error_t"""
    return _client.svn_client_revert2(*args)

def svn_client_revert(*args) -> "svn_error_t *":
    """svn_client_revert(apr_array_header_t paths, svn_boolean_t recursive, svn_client_ctx_t ctx, apr_pool_t pool) -> svn_error_t"""
    return _client.svn_client_revert(*args)
svn_client_conflict_option_undefined = _client.svn_client_conflict_option_undefined
svn_client_conflict_option_postpone = _client.svn_client_conflict_option_postpone
svn_client_conflict_option_base_text = _client.svn_client_conflict_option_base_text
svn_client_conflict_option_incoming_text = _client.svn_client_conflict_option_incoming_text
svn_client_conflict_option_working_text = _client.svn_client_conflict_option_working_text
svn_client_conflict_option_incoming_text_where_conflicted = _client.svn_client_conflict_option_incoming_text_where_conflicted
svn_client_conflict_option_working_text_where_conflicted = _client.svn_client_conflict_option_working_text_where_conflicted
svn_client_conflict_option_merged_text = _client.svn_client_conflict_option_merged_text
svn_client_conflict_option_unspecified = _client.svn_client_conflict_option_unspecified
svn_client_conflict_option_accept_current_wc_state = _client.svn_client_conflict_option_accept_current_wc_state
svn_client_conflict_option_update_move_destination = _client.svn_client_conflict_option_update_move_destination
svn_client_conflict_option_update_any_moved_away_children = _client.svn_client_conflict_option_update_any_moved_away_children
svn_client_conflict_option_incoming_add_ignore = _client.svn_client_conflict_option_incoming_add_ignore
svn_client_conflict_option_incoming_added_file_text_merge = _client.svn_client_conflict_option_incoming_added_file_text_merge
svn_client_conflict_option_incoming_added_file_replace_and_merge = _client.svn_client_conflict_option_incoming_added_file_replace_and_merge
svn_client_conflict_option_incoming_added_dir_merge = _client.svn_client_conflict_option_incoming_added_dir_merge
svn_client_conflict_option_incoming_added_dir_replace = _client.svn_client_conflict_option_incoming_added_dir_replace
svn_client_conflict_option_incoming_added_dir_replace_and_merge = _client.svn_client_conflict_option_incoming_added_dir_replace_and_merge
svn_client_conflict_option_incoming_delete_ignore = _client.svn_client_conflict_option_incoming_delete_ignore
svn_client_conflict_option_incoming_delete_accept = _client.svn_client_conflict_option_incoming_delete_accept
svn_client_conflict_option_incoming_move_file_text_merge = _client.svn_client_conflict_option_incoming_move_file_text_merge
svn_client_conflict_option_incoming_move_dir_merge = _client.svn_client_conflict_option_incoming_move_dir_merge
svn_client_conflict_option_local_move_file_text_merge = _client.svn_client_conflict_option_local_move_file_text_merge
svn_client_conflict_option_local_move_dir_merge = _client.svn_client_conflict_option_local_move_dir_merge
svn_client_conflict_option_sibling_move_file_text_merge = _client.svn_client_conflict_option_sibling_move_file_text_merge
svn_client_conflict_option_sibling_move_dir_merge = _client.svn_client_conflict_option_sibling_move_dir_merge
svn_client_conflict_option_both_moved_file_merge = _client.svn_client_conflict_option_both_moved_file_merge
svn_client_conflict_option_both_moved_file_move_merge = _client.svn_client_conflict_option_both_moved_file_move_merge
svn_client_conflict_option_both_moved_dir_merge = _client.svn_client_conflict_option_both_moved_dir_merge
svn_client_conflict_option_both_moved_dir_move_merge = _client.svn_client_conflict_option_both_moved_dir_move_merge

def svn_client_conflict_option_set_merged_propval(option: 'svn_client_conflict_option_t *', merged_propval: 'svn_string_t const *') -> "void":
    """svn_client_conflict_option_set_merged_propval(svn_client_conflict_option_t * option, svn_string_t const * merged_propval)"""
    return _client.svn_client_conflict_option_set_merged_propval(option, merged_propval)

def svn_client_conflict_option_get_moved_to_repos_relpath_candidates2(*args) -> "apr_array_header_t **":
    """svn_client_conflict_option_get_moved_to_repos_relpath_candidates2(svn_client_conflict_option_t * option, apr_pool_t result_pool, apr_pool_t scratch_pool) -> svn_error_t"""
    return _client.svn_client_conflict_option_get_moved_to_repos_relpath_candidates2(*args)

def svn_client_conflict_option_get_moved_to_repos_relpath_candidates(*args) -> "apr_array_header_t **":
    """svn_client_conflict_option_get_moved_to_repos_relpath_candidates(svn_client_conflict_option_t * option, apr_pool_t result_pool, apr_pool_t scratch_pool) -> svn_error_t"""
    return _client.svn_client_conflict_option_get_moved_to_repos_relpath_candidates(*args)

def svn_client_conflict_option_set_moved_to_repos_relpath2(*args) -> "svn_error_t *":
    """svn_client_conflict_option_set_moved_to_repos_relpath2(svn_client_conflict_option_t * option, int preferred_move_target_idx, svn_client_ctx_t ctx, apr_pool_t scratch_pool) -> svn_error_t"""
    return _client.svn_client_conflict_option_set_moved_to_repos_relpath2(*args)

def svn_client_conflict_option_set_moved_to_repos_relpath(*args) -> "svn_error_t *":
    """svn_client_conflict_option_set_moved_to_repos_relpath(svn_client_conflict_option_t * option, int preferred_move_target_idx, svn_client_ctx_t ctx, apr_pool_t scratch_pool) -> svn_error_t"""
    return _client.svn_client_conflict_option_set_moved_to_repos_relpath(*args)

def svn_client_conflict_option_get_moved_to_abspath_candidates2(*args) -> "apr_array_header_t **":
    """svn_client_conflict_option_get_moved_to_abspath_candidates2(svn_client_conflict_option_t * option, apr_pool_t result_pool, apr_pool_t scratch_pool) -> svn_error_t"""
    return _client.svn_client_conflict_option_get_moved_to_abspath_candidates2(*args)

def svn_client_conflict_option_get_moved_to_abspath_candidates(*args) -> "apr_array_header_t **":
    """svn_client_conflict_option_get_moved_to_abspath_candidates(svn_client_conflict_option_t * option, apr_pool_t result_pool, apr_pool_t scratch_pool) -> svn_error_t"""
    return _client.svn_client_conflict_option_get_moved_to_abspath_candidates(*args)

def svn_client_conflict_option_set_moved_to_abspath2(*args) -> "svn_error_t *":
    """svn_client_conflict_option_set_moved_to_abspath2(svn_client_conflict_option_t * option, int preferred_move_target_idx, svn_client_ctx_t ctx, apr_pool_t scratch_pool) -> svn_error_t"""
    return _client.svn_client_conflict_option_set_moved_to_abspath2(*args)

def svn_client_conflict_option_set_moved_to_abspath(*args) -> "svn_error_t *":
    """svn_client_conflict_option_set_moved_to_abspath(svn_client_conflict_option_t * option, int preferred_move_target_idx, svn_client_ctx_t ctx, apr_pool_t scratch_pool) -> svn_error_t"""
    return _client.svn_client_conflict_option_set_moved_to_abspath(*args)

def svn_client_conflict_option_find_by_id(options: 'apr_array_header_t', option_id: 'svn_client_conflict_option_id_t') -> "svn_client_conflict_option_t *":
    """svn_client_conflict_option_find_by_id(apr_array_header_t options, svn_client_conflict_option_id_t option_id) -> svn_client_conflict_option_t *"""
    return _client.svn_client_conflict_option_find_by_id(options, option_id)

def svn_client_conflict_get(*args) -> "svn_client_conflict_t **":
    """svn_client_conflict_get(char const * local_abspath, svn_client_ctx_t ctx, apr_pool_t result_pool, apr_pool_t scratch_pool) -> svn_error_t"""
    return _client.svn_client_conflict_get(*args)

def svn_client_conflict_walk(*args) -> "svn_error_t *":
    """svn_client_conflict_walk(char const * local_abspath, svn_depth_t depth, svn_client_conflict_walk_func_t conflict_walk_func, void * conflict_walk_func_baton, svn_client_ctx_t ctx, apr_pool_t scratch_pool) -> svn_error_t"""
    return _client.svn_client_conflict_walk(*args)

def svn_client_conflict_get_conflicted(*args) -> "svn_boolean_t *, apr_array_header_t **, svn_boolean_t *":
    """svn_client_conflict_get_conflicted(svn_client_conflict_t * conflict, apr_pool_t result_pool, apr_pool_t scratch_pool) -> svn_error_t"""
    return _client.svn_client_conflict_get_conflicted(*args)

def svn_client_conflict_prop_get_description(*args) -> "char const **":
    """svn_client_conflict_prop_get_description(svn_client_conflict_t * conflict, apr_pool_t result_pool, apr_pool_t scratch_pool) -> svn_error_t"""
    return _client.svn_client_conflict_prop_get_description(*args)

def svn_client_conflict_tree_get_description(*args) -> "char const **, char const **":
    """svn_client_conflict_tree_get_description(svn_client_conflict_t * conflict, svn_client_ctx_t ctx, apr_pool_t result_pool, apr_pool_t scratch_pool) -> svn_error_t"""
    return _client.svn_client_conflict_tree_get_description(*args)

def svn_client_conflict_text_get_resolution_options(*args) -> "apr_array_header_t **":
    """svn_client_conflict_text_get_resolution_options(svn_client_conflict_t * conflict, svn_client_ctx_t ctx, apr_pool_t result_pool, apr_pool_t scratch_pool) -> svn_error_t"""
    return _client.svn_client_conflict_text_get_resolution_options(*args)

def svn_client_conflict_prop_get_resolution_options(*args) -> "apr_array_header_t **":
    """svn_client_conflict_prop_get_resolution_options(svn_client_conflict_t * conflict, svn_client_ctx_t ctx, apr_pool_t result_pool, apr_pool_t scratch_pool) -> svn_error_t"""
    return _client.svn_client_conflict_prop_get_resolution_options(*args)

def svn_client_conflict_tree_get_resolution_options(*args) -> "apr_array_header_t **":
    """svn_client_conflict_tree_get_resolution_options(svn_client_conflict_t * conflict, svn_client_ctx_t ctx, apr_pool_t result_pool, apr_pool_t scratch_pool) -> svn_error_t"""
    return _client.svn_client_conflict_tree_get_resolution_options(*args)

def svn_client_conflict_tree_get_details(*args) -> "svn_error_t *":
    """svn_client_conflict_tree_get_details(svn_client_conflict_t * conflict, svn_client_ctx_t ctx, apr_pool_t scratch_pool) -> svn_error_t"""
    return _client.svn_client_conflict_tree_get_details(*args)

def svn_client_conflict_option_get_id(option: 'svn_client_conflict_option_t *') -> "svn_client_conflict_option_id_t":
    """svn_client_conflict_option_get_id(svn_client_conflict_option_t * option) -> svn_client_conflict_option_id_t"""
    return _client.svn_client_conflict_option_get_id(option)

def svn_client_conflict_option_get_label(*args) -> "char const *":
    """svn_client_conflict_option_get_label(svn_client_conflict_option_t * option, apr_pool_t result_pool) -> char const *"""
    return _client.svn_client_conflict_option_get_label(*args)

def svn_client_conflict_option_get_description(*args) -> "char const *":
    """svn_client_conflict_option_get_description(svn_client_conflict_option_t * option, apr_pool_t result_pool) -> char const *"""
    return _client.svn_client_conflict_option_get_description(*args)

def svn_client_conflict_get_recommended_option_id(conflict: 'svn_client_conflict_t *') -> "svn_client_conflict_option_id_t":
    """svn_client_conflict_get_recommended_option_id(svn_client_conflict_t * conflict) -> svn_client_conflict_option_id_t"""
    return _client.svn_client_conflict_get_recommended_option_id(conflict)

def svn_client_conflict_get_local_abspath(conflict: 'svn_client_conflict_t *') -> "char const *":
    """svn_client_conflict_get_local_abspath(svn_client_conflict_t * conflict) -> char const *"""
    return _client.svn_client_conflict_get_local_abspath(conflict)

def svn_client_conflict_get_operation(conflict: 'svn_client_conflict_t *') -> "svn_wc_operation_t":
    """svn_client_conflict_get_operation(svn_client_conflict_t * conflict) -> svn_wc_operation_t"""
    return _client.svn_client_conflict_get_operation(conflict)

def svn_client_conflict_get_incoming_change(conflict: 'svn_client_conflict_t *') -> "svn_wc_conflict_action_t":
    """svn_client_conflict_get_incoming_change(svn_client_conflict_t * conflict) -> svn_wc_conflict_action_t"""
    return _client.svn_client_conflict_get_incoming_change(conflict)

def svn_client_conflict_get_local_change(conflict: 'svn_client_conflict_t *') -> "svn_wc_conflict_reason_t":
    """svn_client_conflict_get_local_change(svn_client_conflict_t * conflict) -> svn_wc_conflict_reason_t"""
    return _client.svn_client_conflict_get_local_change(conflict)

def svn_client_conflict_get_repos_info(*args) -> "char const **, char const **":
    """svn_client_conflict_get_repos_info(svn_client_conflict_t * conflict, apr_pool_t result_pool, apr_pool_t scratch_pool) -> svn_error_t"""
    return _client.svn_client_conflict_get_repos_info(*args)

def svn_client_conflict_get_incoming_old_repos_location(*args) -> "char const **, svn_revnum_t *, svn_node_kind_t *":
    """svn_client_conflict_get_incoming_old_repos_location(svn_client_conflict_t * conflict, apr_pool_t result_pool, apr_pool_t scratch_pool) -> svn_error_t"""
    return _client.svn_client_conflict_get_incoming_old_repos_location(*args)

def svn_client_conflict_get_incoming_new_repos_location(*args) -> "char const **, svn_revnum_t *, svn_node_kind_t *":
    """svn_client_conflict_get_incoming_new_repos_location(svn_client_conflict_t * conflict, apr_pool_t result_pool, apr_pool_t scratch_pool) -> svn_error_t"""
    return _client.svn_client_conflict_get_incoming_new_repos_location(*args)

def svn_client_conflict_tree_get_victim_node_kind(conflict: 'svn_client_conflict_t *') -> "svn_node_kind_t":
    """svn_client_conflict_tree_get_victim_node_kind(svn_client_conflict_t * conflict) -> svn_node_kind_t"""
    return _client.svn_client_conflict_tree_get_victim_node_kind(conflict)

def svn_client_conflict_tree_resolve(*args) -> "svn_error_t *":
    """svn_client_conflict_tree_resolve(svn_client_conflict_t * conflict, svn_client_conflict_option_t * option, svn_client_ctx_t ctx, apr_pool_t scratch_pool) -> svn_error_t"""
    return _client.svn_client_conflict_tree_resolve(*args)

def svn_client_conflict_tree_resolve_by_id(*args) -> "svn_error_t *":
    """svn_client_conflict_tree_resolve_by_id(svn_client_conflict_t * conflict, svn_client_conflict_option_id_t option_id, svn_client_ctx_t ctx, apr_pool_t scratch_pool) -> svn_error_t"""
    return _client.svn_client_conflict_tree_resolve_by_id(*args)

def svn_client_conflict_tree_get_resolution(conflict: 'svn_client_conflict_t *') -> "svn_client_conflict_option_id_t":
    """svn_client_conflict_tree_get_resolution(svn_client_conflict_t * conflict) -> svn_client_conflict_option_id_t"""
    return _client.svn_client_conflict_tree_get_resolution(conflict)

def svn_client_conflict_prop_get_reject_abspath(conflict: 'svn_client_conflict_t *') -> "char const *":
    """svn_client_conflict_prop_get_reject_abspath(svn_client_conflict_t * conflict) -> char const *"""
    return _client.svn_client_conflict_prop_get_reject_abspath(conflict)

def svn_client_conflict_prop_get_propvals(*args) -> "svn_string_t **, svn_string_t **, svn_string_t **, svn_string_t **":
    """svn_client_conflict_prop_get_propvals(svn_client_conflict_t * conflict, char const * propname, apr_pool_t result_pool) -> svn_error_t"""
    return _client.svn_client_conflict_prop_get_propvals(*args)

def svn_client_conflict_prop_resolve(*args) -> "svn_error_t *":
    """svn_client_conflict_prop_resolve(svn_client_conflict_t * conflict, char const * propname, svn_client_conflict_option_t * option, svn_client_ctx_t ctx, apr_pool_t scratch_pool) -> svn_error_t"""
    return _client.svn_client_conflict_prop_resolve(*args)

def svn_client_conflict_prop_resolve_by_id(*args) -> "svn_error_t *":
    """svn_client_conflict_prop_resolve_by_id(svn_client_conflict_t * conflict, char const * propname, svn_client_conflict_option_id_t option_id, svn_client_ctx_t ctx, apr_pool_t scratch_pool) -> svn_error_t"""
    return _client.svn_client_conflict_prop_resolve_by_id(*args)

def svn_client_conflict_prop_get_resolution(conflict: 'svn_client_conflict_t *', propname: 'char const *') -> "svn_client_conflict_option_id_t":
    """svn_client_conflict_prop_get_resolution(svn_client_conflict_t * conflict, char const * propname) -> svn_client_conflict_option_id_t"""
    return _client.svn_client_conflict_prop_get_resolution(conflict, propname)

def svn_client_conflict_text_get_mime_type(conflict: 'svn_client_conflict_t *') -> "char const *":
    """svn_client_conflict_text_get_mime_type(svn_client_conflict_t * conflict) -> char const *"""
    return _client.svn_client_conflict_text_get_mime_type(conflict)

def svn_client_conflict_text_get_contents(*args) -> "char const **, char const **, char const **, char const **":
    """svn_client_conflict_text_get_contents(svn_client_conflict_t * conflict, apr_pool_t result_pool, apr_pool_t scratch_pool) -> svn_error_t"""
    return _client.svn_client_conflict_text_get_contents(*args)

def svn_client_conflict_text_resolve(*args) -> "svn_error_t *":
    """svn_client_conflict_text_resolve(svn_client_conflict_t * conflict, svn_client_conflict_option_t * option, svn_client_ctx_t ctx, apr_pool_t scratch_pool) -> svn_error_t"""
    return _client.svn_client_conflict_text_resolve(*args)

def svn_client_conflict_text_resolve_by_id(*args) -> "svn_error_t *":
    """svn_client_conflict_text_resolve_by_id(svn_client_conflict_t * conflict, svn_client_conflict_option_id_t option_id, svn_client_ctx_t ctx, apr_pool_t scratch_pool) -> svn_error_t"""
    return _client.svn_client_conflict_text_resolve_by_id(*args)

def svn_client_conflict_text_get_resolution(conflict: 'svn_client_conflict_t *') -> "svn_client_conflict_option_id_t":
    """svn_client_conflict_text_get_resolution(svn_client_conflict_t * conflict) -> svn_client_conflict_option_id_t"""
    return _client.svn_client_conflict_text_get_resolution(conflict)

def svn_client_resolved(*args) -> "svn_error_t *":
    """svn_client_resolved(char const * path, svn_boolean_t recursive, svn_client_ctx_t ctx, apr_pool_t pool) -> svn_error_t"""
    return _client.svn_client_resolved(*args)

def svn_client_resolve(*args) -> "svn_error_t *":
    """svn_client_resolve(char const * path, svn_depth_t depth, svn_wc_conflict_choice_t conflict_choice, svn_client_ctx_t ctx, apr_pool_t pool) -> svn_error_t"""
    return _client.svn_client_resolve(*args)
class svn_client_copy_source_t(object):
    """Proxy of C svn_client_copy_source_t struct."""

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    path = _swig_property(_client.svn_client_copy_source_t_path_get, _client.svn_client_copy_source_t_path_set)
    revision = _swig_property(_client.svn_client_copy_source_t_revision_get, _client.svn_client_copy_source_t_revision_set)
    peg_revision = _swig_property(_client.svn_client_copy_source_t_peg_revision_get, _client.svn_client_copy_source_t_peg_revision_set)
    def set_parent_pool(self, parent_pool=None):
      """Create a new proxy object for TYPE"""
      import libsvn.core, weakref
      self.__dict__["_parent_pool"] = \
        parent_pool or libsvn.core.application_pool;
      if self.__dict__["_parent_pool"]:
        self.__dict__["_is_valid"] = weakref.ref(
          self.__dict__["_parent_pool"]._is_valid)

    def assert_valid(self):
      """Assert that this object is using valid pool memory"""
      if "_is_valid" in self.__dict__:
        assert self.__dict__["_is_valid"](), "Variable has already been deleted"

    def _retrieve_swig_value(self, name, value):
    # If we got back a different object than we have cached, we need to copy
    # all our metadata into it, so that it looks identical to the one
    # originally set.
      members = self.__dict__.get('_members')
      if members is not None and name in members:
        _copy_metadata_deep(value, members[name])

    # Verify that the new object is good
      _assert_valid_deep(value)

      return value

    # Attribute access must be intercepted to ensure that objects coming from
    # read attribute access match those that are set with write attribute access.
    # Specifically the metadata, such as the associated apr_pool object, should
    # match the originally assigned object.
    #
    # For classic classes it is enough to use __getattr__ to intercept swig
    # derived attributes. However, with new style classes SWIG makes use of
    # descriptors which mean that __getattr__ is never called. Therefore,
    # __getattribute__ must be used for the interception.

    if _newclass:
      def __getattribute__(self, name):
        """Manage access to all attributes of this object."""

    # Start by mimicing __getattr__ behavior: immediately return __dict__ or
    # items directly present in __dict__
        mydict = object.__getattribute__(self, '__dict__')

        if name == "__dict__":
          return mydict

        if name in mydict:
          return mydict[name]

        object.__getattribute__(self, 'assert_valid')()

        value = _get_instance_attr(self, name)
        fn = object.__getattribute__(self, '_retrieve_swig_value')
        return fn(name, value)
    else:
      def __getattr__(self, name):
        """Get an attribute from this object"""
        self.assert_valid()

        value = _swig_getattr(self, self.__class__, name)

        return self._retrieve_swig_value(name, value)

    def __setattr__(self, name, value):
      """Set an attribute on this object"""
      self.assert_valid()

    # Save a copy of the object, so that the garbage
    # collector won't kill the object while it's in
    # SWIG-land
      self.__dict__.setdefault("_members",{})[name] = value

      return _set_instance_attr(self, name, value)


    def __init__(self):
        """__init__(svn_client_copy_source_t self) -> svn_client_copy_source_t"""
        this = _client.new_svn_client_copy_source_t()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _client.delete_svn_client_copy_source_t
    __del__ = lambda self: None
svn_client_copy_source_t_swigregister = _client.svn_client_copy_source_t_swigregister
svn_client_copy_source_t_swigregister(svn_client_copy_source_t)


def svn_client_copy7(*args) -> "svn_error_t *":
    """svn_client_copy7(apr_array_header_t sources, char const * dst_path, svn_boolean_t copy_as_child, svn_boolean_t make_parents, svn_boolean_t ignore_externals, svn_boolean_t metadata_only, svn_boolean_t pin_externals, apr_hash_t externals_to_pin, apr_hash_t revprop_table, svn_commit_callback2_t commit_callback, svn_client_ctx_t ctx, apr_pool_t pool) -> svn_error_t"""
    return _client.svn_client_copy7(*args)

def svn_client_copy6(*args) -> "svn_error_t *":
    """svn_client_copy6(apr_array_header_t sources, char const * dst_path, svn_boolean_t copy_as_child, svn_boolean_t make_parents, svn_boolean_t ignore_externals, apr_hash_t revprop_table, svn_commit_callback2_t commit_callback, svn_client_ctx_t ctx, apr_pool_t pool) -> svn_error_t"""
    return _client.svn_client_copy6(*args)

def svn_client_copy5(*args) -> "svn_commit_info_t **":
    """svn_client_copy5(apr_array_header_t sources, char const * dst_path, svn_boolean_t copy_as_child, svn_boolean_t make_parents, svn_boolean_t ignore_externals, apr_hash_t revprop_table, svn_client_ctx_t ctx, apr_pool_t pool) -> svn_error_t"""
    return _client.svn_client_copy5(*args)

def svn_client_copy4(*args) -> "svn_commit_info_t **":
    """svn_client_copy4(apr_array_header_t sources, char const * dst_path, svn_boolean_t copy_as_child, svn_boolean_t make_parents, apr_hash_t revprop_table, svn_client_ctx_t ctx, apr_pool_t pool) -> svn_error_t"""
    return _client.svn_client_copy4(*args)

def svn_client_copy3(*args) -> "svn_commit_info_t **":
    """svn_client_copy3(char const * src_path, svn_opt_revision_t src_revision, char const * dst_path, svn_client_ctx_t ctx, apr_pool_t pool) -> svn_error_t"""
    return _client.svn_client_copy3(*args)

def svn_client_copy2(*args) -> "svn_commit_info_t **":
    """svn_client_copy2(char const * src_path, svn_opt_revision_t src_revision, char const * dst_path, svn_client_ctx_t ctx, apr_pool_t pool) -> svn_error_t"""
    return _client.svn_client_copy2(*args)

def svn_client_copy(*args) -> "svn_client_commit_info_t **":
    """svn_client_copy(char const * src_path, svn_opt_revision_t src_revision, char const * dst_path, svn_client_ctx_t ctx, apr_pool_t pool) -> svn_error_t"""
    return _client.svn_client_copy(*args)

def svn_client_move7(*args) -> "svn_error_t *":
    """svn_client_move7(apr_array_header_t src_paths, char const * dst_path, svn_boolean_t move_as_child, svn_boolean_t make_parents, svn_boolean_t allow_mixed_revisions, svn_boolean_t metadata_only, apr_hash_t revprop_table, svn_commit_callback2_t commit_callback, svn_client_ctx_t ctx, apr_pool_t pool) -> svn_error_t"""
    return _client.svn_client_move7(*args)

def svn_client_move6(*args) -> "svn_error_t *":
    """svn_client_move6(apr_array_header_t src_paths, char const * dst_path, svn_boolean_t move_as_child, svn_boolean_t make_parents, apr_hash_t revprop_table, svn_commit_callback2_t commit_callback, svn_client_ctx_t ctx, apr_pool_t pool) -> svn_error_t"""
    return _client.svn_client_move6(*args)

def svn_client_move5(*args) -> "svn_commit_info_t **":
    """svn_client_move5(apr_array_header_t src_paths, char const * dst_path, svn_boolean_t force, svn_boolean_t move_as_child, svn_boolean_t make_parents, apr_hash_t revprop_table, svn_client_ctx_t ctx, apr_pool_t pool) -> svn_error_t"""
    return _client.svn_client_move5(*args)

def svn_client_move4(*args) -> "svn_commit_info_t **":
    """svn_client_move4(char const * src_path, char const * dst_path, svn_boolean_t force, svn_client_ctx_t ctx, apr_pool_t pool) -> svn_error_t"""
    return _client.svn_client_move4(*args)

def svn_client_move3(*args) -> "svn_commit_info_t **":
    """svn_client_move3(char const * src_path, char const * dst_path, svn_boolean_t force, svn_client_ctx_t ctx, apr_pool_t pool) -> svn_error_t"""
    return _client.svn_client_move3(*args)

def svn_client_move2(*args) -> "svn_client_commit_info_t **":
    """svn_client_move2(char const * src_path, char const * dst_path, svn_boolean_t force, svn_client_ctx_t ctx, apr_pool_t pool) -> svn_error_t"""
    return _client.svn_client_move2(*args)

def svn_client_move(*args) -> "svn_client_commit_info_t **":
    """svn_client_move(char const * src_path, svn_opt_revision_t src_revision, char const * dst_path, svn_boolean_t force, svn_client_ctx_t ctx, apr_pool_t pool) -> svn_error_t"""
    return _client.svn_client_move(*args)

def svn_client_propset_remote(*args) -> "svn_error_t *":
    """svn_client_propset_remote(char const * propname, svn_string_t const * propval, char const * url, svn_boolean_t skip_checks, svn_revnum_t base_revision_for_url, apr_hash_t revprop_table, svn_commit_callback2_t commit_callback, svn_client_ctx_t ctx, apr_pool_t scratch_pool) -> svn_error_t"""
    return _client.svn_client_propset_remote(*args)

def svn_client_propset_local(*args) -> "svn_error_t *":
    """svn_client_propset_local(char const * propname, svn_string_t const * propval, apr_array_header_t targets, svn_depth_t depth, svn_boolean_t skip_checks, apr_array_header_t changelists, svn_client_ctx_t ctx, apr_pool_t scratch_pool) -> svn_error_t"""
    return _client.svn_client_propset_local(*args)

def svn_client_propset3(*args) -> "svn_commit_info_t **":
    """svn_client_propset3(char const * propname, svn_string_t const * propval, char const * target, svn_depth_t depth, svn_boolean_t skip_checks, svn_revnum_t base_revision_for_url, apr_array_header_t changelists, apr_hash_t revprop_table, svn_client_ctx_t ctx, apr_pool_t pool) -> svn_error_t"""
    return _client.svn_client_propset3(*args)

def svn_client_propset2(*args) -> "svn_error_t *":
    """svn_client_propset2(char const * propname, svn_string_t const * propval, char const * target, svn_boolean_t recurse, svn_boolean_t skip_checks, svn_client_ctx_t ctx, apr_pool_t pool) -> svn_error_t"""
    return _client.svn_client_propset2(*args)

def svn_client_propset(*args) -> "svn_error_t *":
    """svn_client_propset(char const * propname, svn_string_t const * propval, char const * target, svn_boolean_t recurse, apr_pool_t pool) -> svn_error_t"""
    return _client.svn_client_propset(*args)

def svn_client_revprop_set2(*args) -> "svn_revnum_t *":
    """svn_client_revprop_set2(char const * propname, svn_string_t const * propval, svn_string_t const * original_propval, char const * URL, svn_opt_revision_t revision, svn_boolean_t force, svn_client_ctx_t ctx, apr_pool_t pool) -> svn_error_t"""
    return _client.svn_client_revprop_set2(*args)

def svn_client_revprop_set(*args) -> "svn_revnum_t *":
    """svn_client_revprop_set(char const * propname, svn_string_t const * propval, char const * URL, svn_opt_revision_t revision, svn_boolean_t force, svn_client_ctx_t ctx, apr_pool_t pool) -> svn_error_t"""
    return _client.svn_client_revprop_set(*args)

def svn_client_propget5(*args) -> "apr_hash_t **, apr_array_header_t **, svn_revnum_t *":
    """svn_client_propget5(char const * propname, char const * target, svn_opt_revision_t peg_revision, svn_opt_revision_t revision, svn_depth_t depth, apr_array_header_t changelists, svn_client_ctx_t ctx, apr_pool_t result_pool, apr_pool_t scratch_pool) -> svn_error_t"""
    return _client.svn_client_propget5(*args)

def svn_client_propget4(*args) -> "apr_hash_t **, svn_revnum_t *":
    """svn_client_propget4(char const * propname, char const * target, svn_opt_revision_t peg_revision, svn_opt_revision_t revision, svn_depth_t depth, apr_array_header_t changelists, svn_client_ctx_t ctx, apr_pool_t result_pool, apr_pool_t scratch_pool) -> svn_error_t"""
    return _client.svn_client_propget4(*args)

def svn_client_propget3(*args) -> "apr_hash_t **, svn_revnum_t *":
    """svn_client_propget3(char const * propname, char const * target, svn_opt_revision_t peg_revision, svn_opt_revision_t revision, svn_depth_t depth, apr_array_header_t changelists, svn_client_ctx_t ctx, apr_pool_t pool) -> svn_error_t"""
    return _client.svn_client_propget3(*args)

def svn_client_propget2(*args) -> "apr_hash_t **":
    """svn_client_propget2(char const * propname, char const * target, svn_opt_revision_t peg_revision, svn_opt_revision_t revision, svn_boolean_t recurse, svn_client_ctx_t ctx, apr_pool_t pool) -> svn_error_t"""
    return _client.svn_client_propget2(*args)

def svn_client_propget(*args) -> "apr_hash_t **":
    """svn_client_propget(char const * propname, char const * target, svn_opt_revision_t revision, svn_boolean_t recurse, svn_client_ctx_t ctx, apr_pool_t pool) -> svn_error_t"""
    return _client.svn_client_propget(*args)

def svn_client_revprop_get(*args) -> "svn_string_t **, svn_revnum_t *":
    """svn_client_revprop_get(char const * propname, char const * URL, svn_opt_revision_t revision, svn_client_ctx_t ctx, apr_pool_t pool) -> svn_error_t"""
    return _client.svn_client_revprop_get(*args)

def svn_client_proplist4(*args) -> "svn_error_t *":
    """svn_client_proplist4(char const * target, svn_opt_revision_t peg_revision, svn_opt_revision_t revision, svn_depth_t depth, apr_array_header_t changelists, svn_boolean_t get_target_inherited_props, svn_proplist_receiver2_t receiver, svn_client_ctx_t ctx, apr_pool_t scratch_pool) -> svn_error_t"""
    return _client.svn_client_proplist4(*args)

def svn_client_proplist3(*args) -> "svn_error_t *":
    """svn_client_proplist3(char const * target, svn_opt_revision_t peg_revision, svn_opt_revision_t revision, svn_depth_t depth, apr_array_header_t changelists, svn_proplist_receiver_t receiver, void * receiver_baton, svn_client_ctx_t ctx, apr_pool_t pool) -> svn_error_t"""
    return _client.svn_client_proplist3(*args)

def svn_client_proplist2(*args) -> "apr_array_header_t **":
    """svn_client_proplist2(char const * target, svn_opt_revision_t peg_revision, svn_opt_revision_t revision, svn_boolean_t recurse, svn_client_ctx_t ctx, apr_pool_t pool) -> svn_error_t"""
    return _client.svn_client_proplist2(*args)

def svn_client_proplist(*args) -> "apr_array_header_t **":
    """svn_client_proplist(char const * target, svn_opt_revision_t revision, svn_boolean_t recurse, svn_client_ctx_t ctx, apr_pool_t pool) -> svn_error_t"""
    return _client.svn_client_proplist(*args)

def svn_client_revprop_list(*args) -> "apr_hash_t **, svn_revnum_t *":
    """svn_client_revprop_list(char const * URL, svn_opt_revision_t revision, svn_client_ctx_t ctx, apr_pool_t pool) -> svn_error_t"""
    return _client.svn_client_revprop_list(*args)

def svn_client_export5(*args) -> "svn_revnum_t *":
    """svn_client_export5(char const * from_path_or_url, char const * to_path, svn_opt_revision_t peg_revision, svn_opt_revision_t revision, svn_boolean_t overwrite, svn_boolean_t ignore_externals, svn_boolean_t ignore_keywords, svn_depth_t depth, char const * native_eol, svn_client_ctx_t ctx, apr_pool_t pool) -> svn_error_t"""
    return _client.svn_client_export5(*args)

def svn_client_export4(*args) -> "svn_revnum_t *":
    """svn_client_export4(char const * from_path_or_url, char const * to_path, svn_opt_revision_t peg_revision, svn_opt_revision_t revision, svn_boolean_t overwrite, svn_boolean_t ignore_externals, svn_depth_t depth, char const * native_eol, svn_client_ctx_t ctx, apr_pool_t pool) -> svn_error_t"""
    return _client.svn_client_export4(*args)

def svn_client_export3(*args) -> "svn_revnum_t *":
    """svn_client_export3(char const * from_path_or_url, char const * to_path, svn_opt_revision_t peg_revision, svn_opt_revision_t revision, svn_boolean_t overwrite, svn_boolean_t ignore_externals, svn_boolean_t recurse, char const * native_eol, svn_client_ctx_t ctx, apr_pool_t pool) -> svn_error_t"""
    return _client.svn_client_export3(*args)

def svn_client_export2(*args) -> "svn_revnum_t *":
    """svn_client_export2(char const * from_path_or_url, char const * to_path, svn_opt_revision_t revision, svn_boolean_t force, char const * native_eol, svn_client_ctx_t ctx, apr_pool_t pool) -> svn_error_t"""
    return _client.svn_client_export2(*args)

def svn_client_export(*args) -> "svn_revnum_t *":
    """svn_client_export(char const * from_path_or_url, char const * to_path, svn_opt_revision_t revision, svn_boolean_t force, svn_client_ctx_t ctx, apr_pool_t pool) -> svn_error_t"""
    return _client.svn_client_export(*args)

def svn_client_list4(*args) -> "svn_error_t *":
    """svn_client_list4(char const * path_or_url, svn_opt_revision_t peg_revision, svn_opt_revision_t revision, apr_array_header_t patterns, svn_depth_t depth, apr_uint32_t dirent_fields, svn_boolean_t fetch_locks, svn_boolean_t include_externals, svn_client_list_func2_t list_func, void * baton, svn_client_ctx_t ctx, apr_pool_t scratch_pool) -> svn_error_t"""
    return _client.svn_client_list4(*args)

def svn_client_list3(*args) -> "svn_error_t *":
    """svn_client_list3(char const * path_or_url, svn_opt_revision_t peg_revision, svn_opt_revision_t revision, svn_depth_t depth, apr_uint32_t dirent_fields, svn_boolean_t fetch_locks, svn_boolean_t include_externals, svn_client_list_func2_t list_func, void * baton, svn_client_ctx_t ctx, apr_pool_t pool) -> svn_error_t"""
    return _client.svn_client_list3(*args)

def svn_client_list2(*args) -> "svn_error_t *":
    """svn_client_list2(char const * path_or_url, svn_opt_revision_t peg_revision, svn_opt_revision_t revision, svn_depth_t depth, apr_uint32_t dirent_fields, svn_boolean_t fetch_locks, svn_client_list_func_t list_func, void * baton, svn_client_ctx_t ctx, apr_pool_t pool) -> svn_error_t"""
    return _client.svn_client_list2(*args)

def svn_client_list(*args) -> "svn_error_t *":
    """svn_client_list(char const * path_or_url, svn_opt_revision_t peg_revision, svn_opt_revision_t revision, svn_boolean_t recurse, apr_uint32_t dirent_fields, svn_boolean_t fetch_locks, svn_client_list_func_t list_func, void * baton, svn_client_ctx_t ctx, apr_pool_t pool) -> svn_error_t"""
    return _client.svn_client_list(*args)

def svn_client_ls3(*args) -> "apr_hash_t **, apr_hash_t **":
    """svn_client_ls3(char const * path_or_url, svn_opt_revision_t peg_revision, svn_opt_revision_t revision, svn_boolean_t recurse, svn_client_ctx_t ctx, apr_pool_t pool) -> svn_error_t"""
    return _client.svn_client_ls3(*args)

def svn_client_ls2(*args) -> "apr_hash_t **":
    """svn_client_ls2(char const * path_or_url, svn_opt_revision_t peg_revision, svn_opt_revision_t revision, svn_boolean_t recurse, svn_client_ctx_t ctx, apr_pool_t pool) -> svn_error_t"""
    return _client.svn_client_ls2(*args)

def svn_client_ls(*args) -> "apr_hash_t **":
    """svn_client_ls(char const * path_or_url, svn_opt_revision_t revision, svn_boolean_t recurse, svn_client_ctx_t ctx, apr_pool_t pool) -> svn_error_t"""
    return _client.svn_client_ls(*args)

def svn_client_cat3(*args) -> "apr_hash_t **":
    """svn_client_cat3(svn_stream_t * out, char const * path_or_url, svn_opt_revision_t peg_revision, svn_opt_revision_t revision, svn_boolean_t expand_keywords, svn_client_ctx_t ctx, apr_pool_t result_pool, apr_pool_t scratch_pool) -> svn_error_t"""
    return _client.svn_client_cat3(*args)

def svn_client_cat2(*args) -> "svn_error_t *":
    """svn_client_cat2(svn_stream_t * out, char const * path_or_url, svn_opt_revision_t peg_revision, svn_opt_revision_t revision, svn_client_ctx_t ctx, apr_pool_t pool) -> svn_error_t"""
    return _client.svn_client_cat2(*args)

def svn_client_cat(*args) -> "svn_error_t *":
    """svn_client_cat(svn_stream_t * out, char const * path_or_url, svn_opt_revision_t revision, svn_client_ctx_t ctx, apr_pool_t pool) -> svn_error_t"""
    return _client.svn_client_cat(*args)

def svn_client_add_to_changelist(*args) -> "svn_error_t *":
    """svn_client_add_to_changelist(apr_array_header_t paths, char const * changelist, svn_depth_t depth, apr_array_header_t changelists, svn_client_ctx_t ctx, apr_pool_t pool) -> svn_error_t"""
    return _client.svn_client_add_to_changelist(*args)

def svn_client_remove_from_changelists(*args) -> "svn_error_t *":
    """svn_client_remove_from_changelists(apr_array_header_t paths, svn_depth_t depth, apr_array_header_t changelists, svn_client_ctx_t ctx, apr_pool_t pool) -> svn_error_t"""
    return _client.svn_client_remove_from_changelists(*args)

def svn_client_get_changelists(*args) -> "svn_error_t *":
    """svn_client_get_changelists(char const * path, apr_array_header_t changelists, svn_depth_t depth, svn_changelist_receiver_t callback_func, svn_client_ctx_t ctx, apr_pool_t pool) -> svn_error_t"""
    return _client.svn_client_get_changelists(*args)

def svn_client_lock(*args) -> "svn_error_t *":
    """svn_client_lock(apr_array_header_t targets, char const * comment, svn_boolean_t steal_lock, svn_client_ctx_t ctx, apr_pool_t pool) -> svn_error_t"""
    return _client.svn_client_lock(*args)

def svn_client_unlock(*args) -> "svn_error_t *":
    """svn_client_unlock(apr_array_header_t targets, svn_boolean_t break_lock, svn_client_ctx_t ctx, apr_pool_t pool) -> svn_error_t"""
    return _client.svn_client_unlock(*args)
class svn_info_t(object):
    """Proxy of C svn_info_t struct."""

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    URL = _swig_property(_client.svn_info_t_URL_get, _client.svn_info_t_URL_set)
    rev = _swig_property(_client.svn_info_t_rev_get, _client.svn_info_t_rev_set)
    kind = _swig_property(_client.svn_info_t_kind_get, _client.svn_info_t_kind_set)
    repos_root_URL = _swig_property(_client.svn_info_t_repos_root_URL_get, _client.svn_info_t_repos_root_URL_set)
    repos_UUID = _swig_property(_client.svn_info_t_repos_UUID_get, _client.svn_info_t_repos_UUID_set)
    last_changed_rev = _swig_property(_client.svn_info_t_last_changed_rev_get, _client.svn_info_t_last_changed_rev_set)
    last_changed_date = _swig_property(_client.svn_info_t_last_changed_date_get, _client.svn_info_t_last_changed_date_set)
    last_changed_author = _swig_property(_client.svn_info_t_last_changed_author_get, _client.svn_info_t_last_changed_author_set)
    lock = _swig_property(_client.svn_info_t_lock_get, _client.svn_info_t_lock_set)
    has_wc_info = _swig_property(_client.svn_info_t_has_wc_info_get, _client.svn_info_t_has_wc_info_set)
    schedule = _swig_property(_client.svn_info_t_schedule_get, _client.svn_info_t_schedule_set)
    copyfrom_url = _swig_property(_client.svn_info_t_copyfrom_url_get, _client.svn_info_t_copyfrom_url_set)
    copyfrom_rev = _swig_property(_client.svn_info_t_copyfrom_rev_get, _client.svn_info_t_copyfrom_rev_set)
    text_time = _swig_property(_client.svn_info_t_text_time_get, _client.svn_info_t_text_time_set)
    prop_time = _swig_property(_client.svn_info_t_prop_time_get, _client.svn_info_t_prop_time_set)
    checksum = _swig_property(_client.svn_info_t_checksum_get, _client.svn_info_t_checksum_set)
    conflict_old = _swig_property(_client.svn_info_t_conflict_old_get, _client.svn_info_t_conflict_old_set)
    conflict_new = _swig_property(_client.svn_info_t_conflict_new_get, _client.svn_info_t_conflict_new_set)
    conflict_wrk = _swig_property(_client.svn_info_t_conflict_wrk_get, _client.svn_info_t_conflict_wrk_set)
    prejfile = _swig_property(_client.svn_info_t_prejfile_get, _client.svn_info_t_prejfile_set)
    changelist = _swig_property(_client.svn_info_t_changelist_get, _client.svn_info_t_changelist_set)
    depth = _swig_property(_client.svn_info_t_depth_get, _client.svn_info_t_depth_set)
    working_size = _swig_property(_client.svn_info_t_working_size_get, _client.svn_info_t_working_size_set)
    size = _swig_property(_client.svn_info_t_size_get, _client.svn_info_t_size_set)
    size64 = _swig_property(_client.svn_info_t_size64_get, _client.svn_info_t_size64_set)
    working_size64 = _swig_property(_client.svn_info_t_working_size64_get, _client.svn_info_t_working_size64_set)
    tree_conflict = _swig_property(_client.svn_info_t_tree_conflict_get, _client.svn_info_t_tree_conflict_set)
    def set_parent_pool(self, parent_pool=None):
      """Create a new proxy object for TYPE"""
      import libsvn.core, weakref
      self.__dict__["_parent_pool"] = \
        parent_pool or libsvn.core.application_pool;
      if self.__dict__["_parent_pool"]:
        self.__dict__["_is_valid"] = weakref.ref(
          self.__dict__["_parent_pool"]._is_valid)

    def assert_valid(self):
      """Assert that this object is using valid pool memory"""
      if "_is_valid" in self.__dict__:
        assert self.__dict__["_is_valid"](), "Variable has already been deleted"

    def _retrieve_swig_value(self, name, value):
    # If we got back a different object than we have cached, we need to copy
    # all our metadata into it, so that it looks identical to the one
    # originally set.
      members = self.__dict__.get('_members')
      if members is not None and name in members:
        _copy_metadata_deep(value, members[name])

    # Verify that the new object is good
      _assert_valid_deep(value)

      return value

    # Attribute access must be intercepted to ensure that objects coming from
    # read attribute access match those that are set with write attribute access.
    # Specifically the metadata, such as the associated apr_pool object, should
    # match the originally assigned object.
    #
    # For classic classes it is enough to use __getattr__ to intercept swig
    # derived attributes. However, with new style classes SWIG makes use of
    # descriptors which mean that __getattr__ is never called. Therefore,
    # __getattribute__ must be used for the interception.

    if _newclass:
      def __getattribute__(self, name):
        """Manage access to all attributes of this object."""

    # Start by mimicing __getattr__ behavior: immediately return __dict__ or
    # items directly present in __dict__
        mydict = object.__getattribute__(self, '__dict__')

        if name == "__dict__":
          return mydict

        if name in mydict:
          return mydict[name]

        object.__getattribute__(self, 'assert_valid')()

        value = _get_instance_attr(self, name)
        fn = object.__getattribute__(self, '_retrieve_swig_value')
        return fn(name, value)
    else:
      def __getattr__(self, name):
        """Get an attribute from this object"""
        self.assert_valid()

        value = _swig_getattr(self, self.__class__, name)

        return self._retrieve_swig_value(name, value)

    def __setattr__(self, name, value):
      """Set an attribute on this object"""
      self.assert_valid()

    # Save a copy of the object, so that the garbage
    # collector won't kill the object while it's in
    # SWIG-land
      self.__dict__.setdefault("_members",{})[name] = value

      return _set_instance_attr(self, name, value)


    def __init__(self):
        """__init__(svn_info_t self) -> svn_info_t"""
        this = _client.new_svn_info_t()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _client.delete_svn_info_t
    __del__ = lambda self: None
svn_info_t_swigregister = _client.svn_info_t_swigregister
svn_info_t_swigregister(svn_info_t)


def svn_info_dup(*args) -> "svn_info_t *":
    """svn_info_dup(svn_info_t info, apr_pool_t pool) -> svn_info_t"""
    return _client.svn_info_dup(*args)
class svn_client_info2_t(object):
    """Proxy of C svn_client_info2_t struct."""

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    URL = _swig_property(_client.svn_client_info2_t_URL_get, _client.svn_client_info2_t_URL_set)
    rev = _swig_property(_client.svn_client_info2_t_rev_get, _client.svn_client_info2_t_rev_set)
    repos_root_URL = _swig_property(_client.svn_client_info2_t_repos_root_URL_get, _client.svn_client_info2_t_repos_root_URL_set)
    repos_UUID = _swig_property(_client.svn_client_info2_t_repos_UUID_get, _client.svn_client_info2_t_repos_UUID_set)
    kind = _swig_property(_client.svn_client_info2_t_kind_get, _client.svn_client_info2_t_kind_set)
    size = _swig_property(_client.svn_client_info2_t_size_get, _client.svn_client_info2_t_size_set)
    last_changed_rev = _swig_property(_client.svn_client_info2_t_last_changed_rev_get, _client.svn_client_info2_t_last_changed_rev_set)
    last_changed_date = _swig_property(_client.svn_client_info2_t_last_changed_date_get, _client.svn_client_info2_t_last_changed_date_set)
    last_changed_author = _swig_property(_client.svn_client_info2_t_last_changed_author_get, _client.svn_client_info2_t_last_changed_author_set)
    lock = _swig_property(_client.svn_client_info2_t_lock_get, _client.svn_client_info2_t_lock_set)
    wc_info = _swig_property(_client.svn_client_info2_t_wc_info_get, _client.svn_client_info2_t_wc_info_set)
    def set_parent_pool(self, parent_pool=None):
      """Create a new proxy object for TYPE"""
      import libsvn.core, weakref
      self.__dict__["_parent_pool"] = \
        parent_pool or libsvn.core.application_pool;
      if self.__dict__["_parent_pool"]:
        self.__dict__["_is_valid"] = weakref.ref(
          self.__dict__["_parent_pool"]._is_valid)

    def assert_valid(self):
      """Assert that this object is using valid pool memory"""
      if "_is_valid" in self.__dict__:
        assert self.__dict__["_is_valid"](), "Variable has already been deleted"

    def _retrieve_swig_value(self, name, value):
    # If we got back a different object than we have cached, we need to copy
    # all our metadata into it, so that it looks identical to the one
    # originally set.
      members = self.__dict__.get('_members')
      if members is not None and name in members:
        _copy_metadata_deep(value, members[name])

    # Verify that the new object is good
      _assert_valid_deep(value)

      return value

    # Attribute access must be intercepted to ensure that objects coming from
    # read attribute access match those that are set with write attribute access.
    # Specifically the metadata, such as the associated apr_pool object, should
    # match the originally assigned object.
    #
    # For classic classes it is enough to use __getattr__ to intercept swig
    # derived attributes. However, with new style classes SWIG makes use of
    # descriptors which mean that __getattr__ is never called. Therefore,
    # __getattribute__ must be used for the interception.

    if _newclass:
      def __getattribute__(self, name):
        """Manage access to all attributes of this object."""

    # Start by mimicing __getattr__ behavior: immediately return __dict__ or
    # items directly present in __dict__
        mydict = object.__getattribute__(self, '__dict__')

        if name == "__dict__":
          return mydict

        if name in mydict:
          return mydict[name]

        object.__getattribute__(self, 'assert_valid')()

        value = _get_instance_attr(self, name)
        fn = object.__getattribute__(self, '_retrieve_swig_value')
        return fn(name, value)
    else:
      def __getattr__(self, name):
        """Get an attribute from this object"""
        self.assert_valid()

        value = _swig_getattr(self, self.__class__, name)

        return self._retrieve_swig_value(name, value)

    def __setattr__(self, name, value):
      """Set an attribute on this object"""
      self.assert_valid()

    # Save a copy of the object, so that the garbage
    # collector won't kill the object while it's in
    # SWIG-land
      self.__dict__.setdefault("_members",{})[name] = value

      return _set_instance_attr(self, name, value)


    def __init__(self):
        """__init__(svn_client_info2_t self) -> svn_client_info2_t"""
        this = _client.new_svn_client_info2_t()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _client.delete_svn_client_info2_t
    __del__ = lambda self: None
svn_client_info2_t_swigregister = _client.svn_client_info2_t_swigregister
svn_client_info2_t_swigregister(svn_client_info2_t)


def svn_client_info2_dup(*args) -> "svn_client_info2_t *":
    """svn_client_info2_dup(svn_client_info2_t info, apr_pool_t pool) -> svn_client_info2_t"""
    return _client.svn_client_info2_dup(*args)

def svn_client_info4(*args) -> "svn_error_t *":
    """svn_client_info4(char const * abspath_or_url, svn_opt_revision_t peg_revision, svn_opt_revision_t revision, svn_depth_t depth, svn_boolean_t fetch_excluded, svn_boolean_t fetch_actual_only, svn_boolean_t include_externals, apr_array_header_t changelists, svn_client_info_receiver2_t receiver, void * receiver_baton, svn_client_ctx_t ctx, apr_pool_t scratch_pool) -> svn_error_t"""
    return _client.svn_client_info4(*args)

def svn_client_info3(*args) -> "svn_error_t *":
    """svn_client_info3(char const * abspath_or_url, svn_opt_revision_t peg_revision, svn_opt_revision_t revision, svn_depth_t depth, svn_boolean_t fetch_excluded, svn_boolean_t fetch_actual_only, apr_array_header_t changelists, svn_client_info_receiver2_t receiver, void * receiver_baton, svn_client_ctx_t ctx, apr_pool_t scratch_pool) -> svn_error_t"""
    return _client.svn_client_info3(*args)

def svn_client_info2(*args) -> "svn_error_t *":
    """svn_client_info2(char const * path_or_url, svn_opt_revision_t peg_revision, svn_opt_revision_t revision, svn_info_receiver_t receiver, svn_depth_t depth, apr_array_header_t changelists, svn_client_ctx_t ctx, apr_pool_t pool) -> svn_error_t"""
    return _client.svn_client_info2(*args)

def svn_client_info(*args) -> "svn_error_t *":
    """svn_client_info(char const * path_or_url, svn_opt_revision_t peg_revision, svn_opt_revision_t revision, svn_info_receiver_t receiver, svn_boolean_t recurse, svn_client_ctx_t ctx, apr_pool_t pool) -> svn_error_t"""
    return _client.svn_client_info(*args)

def svn_client_get_wc_root(*args) -> "char const **":
    """svn_client_get_wc_root(char const * local_abspath, svn_client_ctx_t ctx, apr_pool_t result_pool, apr_pool_t scratch_pool) -> svn_error_t"""
    return _client.svn_client_get_wc_root(*args)

def svn_client_min_max_revisions(*args) -> "svn_revnum_t *, svn_revnum_t *":
    """svn_client_min_max_revisions(char const * local_abspath, svn_boolean_t committed, svn_client_ctx_t ctx, apr_pool_t scratch_pool) -> svn_error_t"""
    return _client.svn_client_min_max_revisions(*args)

def svn_client_patch(*args) -> "svn_error_t *":
    """svn_client_patch(char const * patch_abspath, char const * wc_dir_abspath, svn_boolean_t dry_run, int strip_count, svn_boolean_t reverse, svn_boolean_t ignore_whitespace, svn_boolean_t remove_tempfiles, svn_client_patch_func_t patch_func, void * patch_baton, svn_client_ctx_t ctx, apr_pool_t scratch_pool) -> svn_error_t"""
    return _client.svn_client_patch(*args)

def svn_client_url_from_path2(*args) -> "char const **":
    """svn_client_url_from_path2(char const * path_or_url, svn_client_ctx_t ctx, apr_pool_t result_pool, apr_pool_t scratch_pool) -> svn_error_t"""
    return _client.svn_client_url_from_path2(*args)

def svn_client_url_from_path(*args) -> "char const **":
    """svn_client_url_from_path(char const * path_or_url, apr_pool_t pool) -> svn_error_t"""
    return _client.svn_client_url_from_path(*args)

def svn_client_get_repos_root(*args) -> "char const **, char const **":
    """svn_client_get_repos_root(char const * abspath_or_url, svn_client_ctx_t ctx, apr_pool_t result_pool, apr_pool_t scratch_pool) -> svn_error_t"""
    return _client.svn_client_get_repos_root(*args)

def svn_client_root_url_from_path(*args) -> "char const **":
    """svn_client_root_url_from_path(char const * path_or_url, svn_client_ctx_t ctx, apr_pool_t pool) -> svn_error_t"""
    return _client.svn_client_root_url_from_path(*args)

def svn_client_uuid_from_url(*args) -> "char const **":
    """svn_client_uuid_from_url(char const * url, svn_client_ctx_t ctx, apr_pool_t pool) -> svn_error_t"""
    return _client.svn_client_uuid_from_url(*args)

def svn_client_uuid_from_path2(*args) -> "char const **":
    """svn_client_uuid_from_path2(char const * local_abspath, svn_client_ctx_t ctx, apr_pool_t result_pool, apr_pool_t scratch_pool) -> svn_error_t"""
    return _client.svn_client_uuid_from_path2(*args)

def svn_client_uuid_from_path(*args) -> "char const **":
    """svn_client_uuid_from_path(char const * path, svn_wc_adm_access_t * adm_access, svn_client_ctx_t ctx, apr_pool_t pool) -> svn_error_t"""
    return _client.svn_client_uuid_from_path(*args)

def svn_client_open_ra_session2(*args) -> "svn_ra_session_t **":
    """svn_client_open_ra_session2(char const * url, char const * wri_abspath, svn_client_ctx_t ctx, apr_pool_t result_pool, apr_pool_t scratch_pool) -> svn_error_t"""
    return _client.svn_client_open_ra_session2(*args)

def svn_client_open_ra_session(*args) -> "svn_ra_session_t **":
    """svn_client_open_ra_session(char const * url, svn_client_ctx_t ctx, apr_pool_t pool) -> svn_error_t"""
    return _client.svn_client_open_ra_session(*args)
class svn_client_conflict_t(object):
    """Proxy of C svn_client_conflict_t struct."""

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    def set_parent_pool(self, parent_pool=None):
      """Create a new proxy object for TYPE"""
      import libsvn.core, weakref
      self.__dict__["_parent_pool"] = \
        parent_pool or libsvn.core.application_pool;
      if self.__dict__["_parent_pool"]:
        self.__dict__["_is_valid"] = weakref.ref(
          self.__dict__["_parent_pool"]._is_valid)

    def assert_valid(self):
      """Assert that this object is using valid pool memory"""
      if "_is_valid" in self.__dict__:
        assert self.__dict__["_is_valid"](), "Variable has already been deleted"

    def _retrieve_swig_value(self, name, value):
    # If we got back a different object than we have cached, we need to copy
    # all our metadata into it, so that it looks identical to the one
    # originally set.
      members = self.__dict__.get('_members')
      if members is not None and name in members:
        _copy_metadata_deep(value, members[name])

    # Verify that the new object is good
      _assert_valid_deep(value)

      return value

    # Attribute access must be intercepted to ensure that objects coming from
    # read attribute access match those that are set with write attribute access.
    # Specifically the metadata, such as the associated apr_pool object, should
    # match the originally assigned object.
    #
    # For classic classes it is enough to use __getattr__ to intercept swig
    # derived attributes. However, with new style classes SWIG makes use of
    # descriptors which mean that __getattr__ is never called. Therefore,
    # __getattribute__ must be used for the interception.

    if _newclass:
      def __getattribute__(self, name):
        """Manage access to all attributes of this object."""

    # Start by mimicing __getattr__ behavior: immediately return __dict__ or
    # items directly present in __dict__
        mydict = object.__getattribute__(self, '__dict__')

        if name == "__dict__":
          return mydict

        if name in mydict:
          return mydict[name]

        object.__getattribute__(self, 'assert_valid')()

        value = _get_instance_attr(self, name)
        fn = object.__getattribute__(self, '_retrieve_swig_value')
        return fn(name, value)
    else:
      def __getattr__(self, name):
        """Get an attribute from this object"""
        self.assert_valid()

        value = _swig_getattr(self, self.__class__, name)

        return self._retrieve_swig_value(name, value)

    def __setattr__(self, name, value):
      """Set an attribute on this object"""
      self.assert_valid()

    # Save a copy of the object, so that the garbage
    # collector won't kill the object while it's in
    # SWIG-land
      self.__dict__.setdefault("_members",{})[name] = value

      return _set_instance_attr(self, name, value)

svn_client_conflict_t_swigregister = _client.svn_client_conflict_t_swigregister
svn_client_conflict_t_swigregister(svn_client_conflict_t)

class svn_client_conflict_option_t(object):
    """Proxy of C svn_client_conflict_option_t struct."""

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    def set_parent_pool(self, parent_pool=None):
      """Create a new proxy object for TYPE"""
      import libsvn.core, weakref
      self.__dict__["_parent_pool"] = \
        parent_pool or libsvn.core.application_pool;
      if self.__dict__["_parent_pool"]:
        self.__dict__["_is_valid"] = weakref.ref(
          self.__dict__["_parent_pool"]._is_valid)

    def assert_valid(self):
      """Assert that this object is using valid pool memory"""
      if "_is_valid" in self.__dict__:
        assert self.__dict__["_is_valid"](), "Variable has already been deleted"

    def _retrieve_swig_value(self, name, value):
    # If we got back a different object than we have cached, we need to copy
    # all our metadata into it, so that it looks identical to the one
    # originally set.
      members = self.__dict__.get('_members')
      if members is not None and name in members:
        _copy_metadata_deep(value, members[name])

    # Verify that the new object is good
      _assert_valid_deep(value)

      return value

    # Attribute access must be intercepted to ensure that objects coming from
    # read attribute access match those that are set with write attribute access.
    # Specifically the metadata, such as the associated apr_pool object, should
    # match the originally assigned object.
    #
    # For classic classes it is enough to use __getattr__ to intercept swig
    # derived attributes. However, with new style classes SWIG makes use of
    # descriptors which mean that __getattr__ is never called. Therefore,
    # __getattribute__ must be used for the interception.

    if _newclass:
      def __getattribute__(self, name):
        """Manage access to all attributes of this object."""

    # Start by mimicing __getattr__ behavior: immediately return __dict__ or
    # items directly present in __dict__
        mydict = object.__getattribute__(self, '__dict__')

        if name == "__dict__":
          return mydict

        if name in mydict:
          return mydict[name]

        object.__getattribute__(self, 'assert_valid')()

        value = _get_instance_attr(self, name)
        fn = object.__getattribute__(self, '_retrieve_swig_value')
        return fn(name, value)
    else:
      def __getattr__(self, name):
        """Get an attribute from this object"""
        self.assert_valid()

        value = _swig_getattr(self, self.__class__, name)

        return self._retrieve_swig_value(name, value)

    def __setattr__(self, name, value):
      """Set an attribute on this object"""
      self.assert_valid()

    # Save a copy of the object, so that the garbage
    # collector won't kill the object while it's in
    # SWIG-land
      self.__dict__.setdefault("_members",{})[name] = value

      return _set_instance_attr(self, name, value)

svn_client_conflict_option_t_swigregister = _client.svn_client_conflict_option_t_swigregister
svn_client_conflict_option_t_swigregister(svn_client_conflict_option_t)


def svn_proplist_invoke_receiver2(*args) -> "svn_error_t *":
    """svn_proplist_invoke_receiver2(svn_proplist_receiver2_t _obj, void * baton, char const * path, apr_hash_t prop_hash, apr_array_header_t inherited_props, apr_pool_t scratch_pool) -> svn_error_t"""
    return _client.svn_proplist_invoke_receiver2(*args)

def svn_proplist_invoke_receiver(*args) -> "svn_error_t *":
    """svn_proplist_invoke_receiver(svn_proplist_receiver_t _obj, void * baton, char const * path, apr_hash_t prop_hash, apr_pool_t pool) -> svn_error_t"""
    return _client.svn_proplist_invoke_receiver(*args)

def svn_client_invoke_get_commit_log3(*args) -> "char const **, char const **":
    """svn_client_invoke_get_commit_log3(svn_client_get_commit_log3_t _obj, apr_array_header_t commit_items, void * baton, apr_pool_t pool) -> svn_error_t"""
    return _client.svn_client_invoke_get_commit_log3(*args)

def svn_client_invoke_get_commit_log2(*args) -> "char const **, char const **":
    """svn_client_invoke_get_commit_log2(svn_client_get_commit_log2_t _obj, apr_array_header_t commit_items, void * baton, apr_pool_t pool) -> svn_error_t"""
    return _client.svn_client_invoke_get_commit_log2(*args)

def svn_client_invoke_get_commit_log(*args) -> "char const **, char const **":
    """svn_client_invoke_get_commit_log(svn_client_get_commit_log_t _obj, apr_array_header_t commit_items, void * baton, apr_pool_t pool) -> svn_error_t"""
    return _client.svn_client_invoke_get_commit_log(*args)

def svn_client_invoke_blame_receiver4(*args) -> "svn_error_t *":
    """svn_client_invoke_blame_receiver4(svn_client_blame_receiver4_t _obj, void * baton, apr_int64_t line_no, svn_revnum_t revision, apr_hash_t rev_props, svn_revnum_t merged_revision, apr_hash_t merged_rev_props, char const * merged_path, svn_string_t const * line, svn_boolean_t local_change, apr_pool_t pool) -> svn_error_t"""
    return _client.svn_client_invoke_blame_receiver4(*args)

def svn_client_invoke_blame_receiver3(*args) -> "svn_error_t *":
    """svn_client_invoke_blame_receiver3(svn_client_blame_receiver3_t _obj, void * baton, svn_revnum_t start_revnum, svn_revnum_t end_revnum, apr_int64_t line_no, svn_revnum_t revision, apr_hash_t rev_props, svn_revnum_t merged_revision, apr_hash_t merged_rev_props, char const * merged_path, char const * line, svn_boolean_t local_change, apr_pool_t pool) -> svn_error_t"""
    return _client.svn_client_invoke_blame_receiver3(*args)

def svn_client_invoke_blame_receiver2(*args) -> "svn_error_t *":
    """svn_client_invoke_blame_receiver2(svn_client_blame_receiver2_t _obj, void * baton, apr_int64_t line_no, svn_revnum_t revision, char const * author, char const * date, svn_revnum_t merged_revision, char const * merged_author, char const * merged_date, char const * merged_path, char const * line, apr_pool_t pool) -> svn_error_t"""
    return _client.svn_client_invoke_blame_receiver2(*args)

def svn_client_invoke_blame_receiver(*args) -> "svn_error_t *":
    """svn_client_invoke_blame_receiver(svn_client_blame_receiver_t _obj, void * baton, apr_int64_t line_no, svn_revnum_t revision, char const * author, char const * date, char const * line, apr_pool_t pool) -> svn_error_t"""
    return _client.svn_client_invoke_blame_receiver(*args)

def svn_client_invoke_diff_summarize_func(*args) -> "svn_error_t *":
    """svn_client_invoke_diff_summarize_func(svn_client_diff_summarize_func_t _obj, svn_client_diff_summarize_t diff, void * baton, apr_pool_t pool) -> svn_error_t"""
    return _client.svn_client_invoke_diff_summarize_func(*args)

def svn_client_invoke__layout_func(*args) -> "svn_error_t *":
    """svn_client_invoke__layout_func(svn_client__layout_func_t _obj, void * layout_baton, char const * local_abspath, char const * repos_root_url, svn_boolean_t not_present, svn_boolean_t url_changed, char const * url, svn_boolean_t revision_changed, svn_revnum_t revision, svn_boolean_t depth_changed, svn_depth_t depth, apr_pool_t scratch_pool) -> svn_error_t"""
    return _client.svn_client_invoke__layout_func(*args)

def svn_client_invoke_import_filter_func(*args) -> "svn_boolean_t *":
    """svn_client_invoke_import_filter_func(svn_client_import_filter_func_t _obj, void * baton, char const * local_abspath, svn_io_dirent2_t dirent, apr_pool_t scratch_pool) -> svn_error_t"""
    return _client.svn_client_invoke_import_filter_func(*args)

def svn_client_invoke_status_func(*args) -> "svn_error_t *":
    """svn_client_invoke_status_func(svn_client_status_func_t _obj, void * baton, char const * path, svn_client_status_t status, apr_pool_t scratch_pool) -> svn_error_t"""
    return _client.svn_client_invoke_status_func(*args)

def svn_client_invoke_conflict_walk_func(*args) -> "svn_error_t *":
    """svn_client_invoke_conflict_walk_func(svn_client_conflict_walk_func_t _obj, void * baton, svn_client_conflict_t * conflict, apr_pool_t scratch_pool) -> svn_error_t"""
    return _client.svn_client_invoke_conflict_walk_func(*args)

def svn_client_invoke_list_func2(*args) -> "svn_error_t *":
    """svn_client_invoke_list_func2(svn_client_list_func2_t _obj, void * baton, char const * path, svn_dirent_t dirent, svn_lock_t lock, char const * abs_path, char const * external_parent_url, char const * external_target, apr_pool_t scratch_pool) -> svn_error_t"""
    return _client.svn_client_invoke_list_func2(*args)

def svn_client_invoke_list_func(*args) -> "svn_error_t *":
    """svn_client_invoke_list_func(svn_client_list_func_t _obj, void * baton, char const * path, svn_dirent_t dirent, svn_lock_t lock, char const * abs_path, apr_pool_t pool) -> svn_error_t"""
    return _client.svn_client_invoke_list_func(*args)

def svn_info_invoke_receiver(*args) -> "svn_error_t *":
    """svn_info_invoke_receiver(svn_info_receiver_t _obj, void * baton, char const * path, svn_info_t info, apr_pool_t pool) -> svn_error_t"""
    return _client.svn_info_invoke_receiver(*args)

def svn_client_invoke_info_receiver2(*args) -> "svn_error_t *":
    """svn_client_invoke_info_receiver2(svn_client_info_receiver2_t _obj, void * baton, char const * abspath_or_url, svn_client_info2_t info, apr_pool_t scratch_pool) -> svn_error_t"""
    return _client.svn_client_invoke_info_receiver2(*args)

def svn_client_invoke_patch_func(*args) -> "svn_boolean_t *":
    """svn_client_invoke_patch_func(svn_client_patch_func_t _obj, void * baton, char const * canon_path_from_patchfile, char const * patch_abspath, char const * reject_abspath, apr_pool_t scratch_pool) -> svn_error_t"""
    return _client.svn_client_invoke_patch_func(*args)
class svn_proplist_receiver2_t(object):
    """Proxy of C svn_proplist_receiver2_t struct."""

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    def set_parent_pool(self, parent_pool=None):
      """Create a new proxy object for TYPE"""
      import libsvn.core, weakref
      self.__dict__["_parent_pool"] = \
        parent_pool or libsvn.core.application_pool;
      if self.__dict__["_parent_pool"]:
        self.__dict__["_is_valid"] = weakref.ref(
          self.__dict__["_parent_pool"]._is_valid)

    def assert_valid(self):
      """Assert that this object is using valid pool memory"""
      if "_is_valid" in self.__dict__:
        assert self.__dict__["_is_valid"](), "Variable has already been deleted"

    def _retrieve_swig_value(self, name, value):
    # If we got back a different object than we have cached, we need to copy
    # all our metadata into it, so that it looks identical to the one
    # originally set.
      members = self.__dict__.get('_members')
      if members is not None and name in members:
        _copy_metadata_deep(value, members[name])

    # Verify that the new object is good
      _assert_valid_deep(value)

      return value

    # Attribute access must be intercepted to ensure that objects coming from
    # read attribute access match those that are set with write attribute access.
    # Specifically the metadata, such as the associated apr_pool object, should
    # match the originally assigned object.
    #
    # For classic classes it is enough to use __getattr__ to intercept swig
    # derived attributes. However, with new style classes SWIG makes use of
    # descriptors which mean that __getattr__ is never called. Therefore,
    # __getattribute__ must be used for the interception.

    if _newclass:
      def __getattribute__(self, name):
        """Manage access to all attributes of this object."""

    # Start by mimicing __getattr__ behavior: immediately return __dict__ or
    # items directly present in __dict__
        mydict = object.__getattribute__(self, '__dict__')

        if name == "__dict__":
          return mydict

        if name in mydict:
          return mydict[name]

        object.__getattribute__(self, 'assert_valid')()

        value = _get_instance_attr(self, name)
        fn = object.__getattribute__(self, '_retrieve_swig_value')
        return fn(name, value)
    else:
      def __getattr__(self, name):
        """Get an attribute from this object"""
        self.assert_valid()

        value = _swig_getattr(self, self.__class__, name)

        return self._retrieve_swig_value(name, value)

    def __setattr__(self, name, value):
      """Set an attribute on this object"""
      self.assert_valid()

    # Save a copy of the object, so that the garbage
    # collector won't kill the object while it's in
    # SWIG-land
      self.__dict__.setdefault("_members",{})[name] = value

      return _set_instance_attr(self, name, value)


    def __call__(self, *args):
      return svn_proplist_invoke_receiver2(self, *args)

svn_proplist_receiver2_t_swigregister = _client.svn_proplist_receiver2_t_swigregister
svn_proplist_receiver2_t_swigregister(svn_proplist_receiver2_t)

class svn_proplist_receiver_t(object):
    """Proxy of C svn_proplist_receiver_t struct."""

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    def set_parent_pool(self, parent_pool=None):
      """Create a new proxy object for TYPE"""
      import libsvn.core, weakref
      self.__dict__["_parent_pool"] = \
        parent_pool or libsvn.core.application_pool;
      if self.__dict__["_parent_pool"]:
        self.__dict__["_is_valid"] = weakref.ref(
          self.__dict__["_parent_pool"]._is_valid)

    def assert_valid(self):
      """Assert that this object is using valid pool memory"""
      if "_is_valid" in self.__dict__:
        assert self.__dict__["_is_valid"](), "Variable has already been deleted"

    def _retrieve_swig_value(self, name, value):
    # If we got back a different object than we have cached, we need to copy
    # all our metadata into it, so that it looks identical to the one
    # originally set.
      members = self.__dict__.get('_members')
      if members is not None and name in members:
        _copy_metadata_deep(value, members[name])

    # Verify that the new object is good
      _assert_valid_deep(value)

      return value

    # Attribute access must be intercepted to ensure that objects coming from
    # read attribute access match those that are set with write attribute access.
    # Specifically the metadata, such as the associated apr_pool object, should
    # match the originally assigned object.
    #
    # For classic classes it is enough to use __getattr__ to intercept swig
    # derived attributes. However, with new style classes SWIG makes use of
    # descriptors which mean that __getattr__ is never called. Therefore,
    # __getattribute__ must be used for the interception.

    if _newclass:
      def __getattribute__(self, name):
        """Manage access to all attributes of this object."""

    # Start by mimicing __getattr__ behavior: immediately return __dict__ or
    # items directly present in __dict__
        mydict = object.__getattribute__(self, '__dict__')

        if name == "__dict__":
          return mydict

        if name in mydict:
          return mydict[name]

        object.__getattribute__(self, 'assert_valid')()

        value = _get_instance_attr(self, name)
        fn = object.__getattribute__(self, '_retrieve_swig_value')
        return fn(name, value)
    else:
      def __getattr__(self, name):
        """Get an attribute from this object"""
        self.assert_valid()

        value = _swig_getattr(self, self.__class__, name)

        return self._retrieve_swig_value(name, value)

    def __setattr__(self, name, value):
      """Set an attribute on this object"""
      self.assert_valid()

    # Save a copy of the object, so that the garbage
    # collector won't kill the object while it's in
    # SWIG-land
      self.__dict__.setdefault("_members",{})[name] = value

      return _set_instance_attr(self, name, value)


    def __call__(self, *args):
      return svn_proplist_invoke_receiver(self, *args)

svn_proplist_receiver_t_swigregister = _client.svn_proplist_receiver_t_swigregister
svn_proplist_receiver_t_swigregister(svn_proplist_receiver_t)

class svn_client_get_commit_log3_t(object):
    """Proxy of C svn_client_get_commit_log3_t struct."""

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    def set_parent_pool(self, parent_pool=None):
      """Create a new proxy object for TYPE"""
      import libsvn.core, weakref
      self.__dict__["_parent_pool"] = \
        parent_pool or libsvn.core.application_pool;
      if self.__dict__["_parent_pool"]:
        self.__dict__["_is_valid"] = weakref.ref(
          self.__dict__["_parent_pool"]._is_valid)

    def assert_valid(self):
      """Assert that this object is using valid pool memory"""
      if "_is_valid" in self.__dict__:
        assert self.__dict__["_is_valid"](), "Variable has already been deleted"

    def _retrieve_swig_value(self, name, value):
    # If we got back a different object than we have cached, we need to copy
    # all our metadata into it, so that it looks identical to the one
    # originally set.
      members = self.__dict__.get('_members')
      if members is not None and name in members:
        _copy_metadata_deep(value, members[name])

    # Verify that the new object is good
      _assert_valid_deep(value)

      return value

    # Attribute access must be intercepted to ensure that objects coming from
    # read attribute access match those that are set with write attribute access.
    # Specifically the metadata, such as the associated apr_pool object, should
    # match the originally assigned object.
    #
    # For classic classes it is enough to use __getattr__ to intercept swig
    # derived attributes. However, with new style classes SWIG makes use of
    # descriptors which mean that __getattr__ is never called. Therefore,
    # __getattribute__ must be used for the interception.

    if _newclass:
      def __getattribute__(self, name):
        """Manage access to all attributes of this object."""

    # Start by mimicing __getattr__ behavior: immediately return __dict__ or
    # items directly present in __dict__
        mydict = object.__getattribute__(self, '__dict__')

        if name == "__dict__":
          return mydict

        if name in mydict:
          return mydict[name]

        object.__getattribute__(self, 'assert_valid')()

        value = _get_instance_attr(self, name)
        fn = object.__getattribute__(self, '_retrieve_swig_value')
        return fn(name, value)
    else:
      def __getattr__(self, name):
        """Get an attribute from this object"""
        self.assert_valid()

        value = _swig_getattr(self, self.__class__, name)

        return self._retrieve_swig_value(name, value)

    def __setattr__(self, name, value):
      """Set an attribute on this object"""
      self.assert_valid()

    # Save a copy of the object, so that the garbage
    # collector won't kill the object while it's in
    # SWIG-land
      self.__dict__.setdefault("_members",{})[name] = value

      return _set_instance_attr(self, name, value)


    def __call__(self, *args):
      return svn_client_invoke_get_commit_log3(self, *args)

svn_client_get_commit_log3_t_swigregister = _client.svn_client_get_commit_log3_t_swigregister
svn_client_get_commit_log3_t_swigregister(svn_client_get_commit_log3_t)

class svn_client_get_commit_log2_t(object):
    """Proxy of C svn_client_get_commit_log2_t struct."""

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    def set_parent_pool(self, parent_pool=None):
      """Create a new proxy object for TYPE"""
      import libsvn.core, weakref
      self.__dict__["_parent_pool"] = \
        parent_pool or libsvn.core.application_pool;
      if self.__dict__["_parent_pool"]:
        self.__dict__["_is_valid"] = weakref.ref(
          self.__dict__["_parent_pool"]._is_valid)

    def assert_valid(self):
      """Assert that this object is using valid pool memory"""
      if "_is_valid" in self.__dict__:
        assert self.__dict__["_is_valid"](), "Variable has already been deleted"

    def _retrieve_swig_value(self, name, value):
    # If we got back a different object than we have cached, we need to copy
    # all our metadata into it, so that it looks identical to the one
    # originally set.
      members = self.__dict__.get('_members')
      if members is not None and name in members:
        _copy_metadata_deep(value, members[name])

    # Verify that the new object is good
      _assert_valid_deep(value)

      return value

    # Attribute access must be intercepted to ensure that objects coming from
    # read attribute access match those that are set with write attribute access.
    # Specifically the metadata, such as the associated apr_pool object, should
    # match the originally assigned object.
    #
    # For classic classes it is enough to use __getattr__ to intercept swig
    # derived attributes. However, with new style classes SWIG makes use of
    # descriptors which mean that __getattr__ is never called. Therefore,
    # __getattribute__ must be used for the interception.

    if _newclass:
      def __getattribute__(self, name):
        """Manage access to all attributes of this object."""

    # Start by mimicing __getattr__ behavior: immediately return __dict__ or
    # items directly present in __dict__
        mydict = object.__getattribute__(self, '__dict__')

        if name == "__dict__":
          return mydict

        if name in mydict:
          return mydict[name]

        object.__getattribute__(self, 'assert_valid')()

        value = _get_instance_attr(self, name)
        fn = object.__getattribute__(self, '_retrieve_swig_value')
        return fn(name, value)
    else:
      def __getattr__(self, name):
        """Get an attribute from this object"""
        self.assert_valid()

        value = _swig_getattr(self, self.__class__, name)

        return self._retrieve_swig_value(name, value)

    def __setattr__(self, name, value):
      """Set an attribute on this object"""
      self.assert_valid()

    # Save a copy of the object, so that the garbage
    # collector won't kill the object while it's in
    # SWIG-land
      self.__dict__.setdefault("_members",{})[name] = value

      return _set_instance_attr(self, name, value)


    def __call__(self, *args):
      return svn_client_invoke_get_commit_log2(self, *args)

svn_client_get_commit_log2_t_swigregister = _client.svn_client_get_commit_log2_t_swigregister
svn_client_get_commit_log2_t_swigregister(svn_client_get_commit_log2_t)

class svn_client_get_commit_log_t(object):
    """Proxy of C svn_client_get_commit_log_t struct."""

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    def set_parent_pool(self, parent_pool=None):
      """Create a new proxy object for TYPE"""
      import libsvn.core, weakref
      self.__dict__["_parent_pool"] = \
        parent_pool or libsvn.core.application_pool;
      if self.__dict__["_parent_pool"]:
        self.__dict__["_is_valid"] = weakref.ref(
          self.__dict__["_parent_pool"]._is_valid)

    def assert_valid(self):
      """Assert that this object is using valid pool memory"""
      if "_is_valid" in self.__dict__:
        assert self.__dict__["_is_valid"](), "Variable has already been deleted"

    def _retrieve_swig_value(self, name, value):
    # If we got back a different object than we have cached, we need to copy
    # all our metadata into it, so that it looks identical to the one
    # originally set.
      members = self.__dict__.get('_members')
      if members is not None and name in members:
        _copy_metadata_deep(value, members[name])

    # Verify that the new object is good
      _assert_valid_deep(value)

      return value

    # Attribute access must be intercepted to ensure that objects coming from
    # read attribute access match those that are set with write attribute access.
    # Specifically the metadata, such as the associated apr_pool object, should
    # match the originally assigned object.
    #
    # For classic classes it is enough to use __getattr__ to intercept swig
    # derived attributes. However, with new style classes SWIG makes use of
    # descriptors which mean that __getattr__ is never called. Therefore,
    # __getattribute__ must be used for the interception.

    if _newclass:
      def __getattribute__(self, name):
        """Manage access to all attributes of this object."""

    # Start by mimicing __getattr__ behavior: immediately return __dict__ or
    # items directly present in __dict__
        mydict = object.__getattribute__(self, '__dict__')

        if name == "__dict__":
          return mydict

        if name in mydict:
          return mydict[name]

        object.__getattribute__(self, 'assert_valid')()

        value = _get_instance_attr(self, name)
        fn = object.__getattribute__(self, '_retrieve_swig_value')
        return fn(name, value)
    else:
      def __getattr__(self, name):
        """Get an attribute from this object"""
        self.assert_valid()

        value = _swig_getattr(self, self.__class__, name)

        return self._retrieve_swig_value(name, value)

    def __setattr__(self, name, value):
      """Set an attribute on this object"""
      self.assert_valid()

    # Save a copy of the object, so that the garbage
    # collector won't kill the object while it's in
    # SWIG-land
      self.__dict__.setdefault("_members",{})[name] = value

      return _set_instance_attr(self, name, value)


    def __call__(self, *args):
      return svn_client_invoke_get_commit_log(self, *args)

svn_client_get_commit_log_t_swigregister = _client.svn_client_get_commit_log_t_swigregister
svn_client_get_commit_log_t_swigregister(svn_client_get_commit_log_t)

class svn_client_blame_receiver4_t(object):
    """Proxy of C svn_client_blame_receiver4_t struct."""

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    def set_parent_pool(self, parent_pool=None):
      """Create a new proxy object for TYPE"""
      import libsvn.core, weakref
      self.__dict__["_parent_pool"] = \
        parent_pool or libsvn.core.application_pool;
      if self.__dict__["_parent_pool"]:
        self.__dict__["_is_valid"] = weakref.ref(
          self.__dict__["_parent_pool"]._is_valid)

    def assert_valid(self):
      """Assert that this object is using valid pool memory"""
      if "_is_valid" in self.__dict__:
        assert self.__dict__["_is_valid"](), "Variable has already been deleted"

    def _retrieve_swig_value(self, name, value):
    # If we got back a different object than we have cached, we need to copy
    # all our metadata into it, so that it looks identical to the one
    # originally set.
      members = self.__dict__.get('_members')
      if members is not None and name in members:
        _copy_metadata_deep(value, members[name])

    # Verify that the new object is good
      _assert_valid_deep(value)

      return value

    # Attribute access must be intercepted to ensure that objects coming from
    # read attribute access match those that are set with write attribute access.
    # Specifically the metadata, such as the associated apr_pool object, should
    # match the originally assigned object.
    #
    # For classic classes it is enough to use __getattr__ to intercept swig
    # derived attributes. However, with new style classes SWIG makes use of
    # descriptors which mean that __getattr__ is never called. Therefore,
    # __getattribute__ must be used for the interception.

    if _newclass:
      def __getattribute__(self, name):
        """Manage access to all attributes of this object."""

    # Start by mimicing __getattr__ behavior: immediately return __dict__ or
    # items directly present in __dict__
        mydict = object.__getattribute__(self, '__dict__')

        if name == "__dict__":
          return mydict

        if name in mydict:
          return mydict[name]

        object.__getattribute__(self, 'assert_valid')()

        value = _get_instance_attr(self, name)
        fn = object.__getattribute__(self, '_retrieve_swig_value')
        return fn(name, value)
    else:
      def __getattr__(self, name):
        """Get an attribute from this object"""
        self.assert_valid()

        value = _swig_getattr(self, self.__class__, name)

        return self._retrieve_swig_value(name, value)

    def __setattr__(self, name, value):
      """Set an attribute on this object"""
      self.assert_valid()

    # Save a copy of the object, so that the garbage
    # collector won't kill the object while it's in
    # SWIG-land
      self.__dict__.setdefault("_members",{})[name] = value

      return _set_instance_attr(self, name, value)


    def __call__(self, *args):
      return svn_client_invoke_blame_receiver4(self, *args)

svn_client_blame_receiver4_t_swigregister = _client.svn_client_blame_receiver4_t_swigregister
svn_client_blame_receiver4_t_swigregister(svn_client_blame_receiver4_t)

class svn_client_blame_receiver3_t(object):
    """Proxy of C svn_client_blame_receiver3_t struct."""

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    def set_parent_pool(self, parent_pool=None):
      """Create a new proxy object for TYPE"""
      import libsvn.core, weakref
      self.__dict__["_parent_pool"] = \
        parent_pool or libsvn.core.application_pool;
      if self.__dict__["_parent_pool"]:
        self.__dict__["_is_valid"] = weakref.ref(
          self.__dict__["_parent_pool"]._is_valid)

    def assert_valid(self):
      """Assert that this object is using valid pool memory"""
      if "_is_valid" in self.__dict__:
        assert self.__dict__["_is_valid"](), "Variable has already been deleted"

    def _retrieve_swig_value(self, name, value):
    # If we got back a different object than we have cached, we need to copy
    # all our metadata into it, so that it looks identical to the one
    # originally set.
      members = self.__dict__.get('_members')
      if members is not None and name in members:
        _copy_metadata_deep(value, members[name])

    # Verify that the new object is good
      _assert_valid_deep(value)

      return value

    # Attribute access must be intercepted to ensure that objects coming from
    # read attribute access match those that are set with write attribute access.
    # Specifically the metadata, such as the associated apr_pool object, should
    # match the originally assigned object.
    #
    # For classic classes it is enough to use __getattr__ to intercept swig
    # derived attributes. However, with new style classes SWIG makes use of
    # descriptors which mean that __getattr__ is never called. Therefore,
    # __getattribute__ must be used for the interception.

    if _newclass:
      def __getattribute__(self, name):
        """Manage access to all attributes of this object."""

    # Start by mimicing __getattr__ behavior: immediately return __dict__ or
    # items directly present in __dict__
        mydict = object.__getattribute__(self, '__dict__')

        if name == "__dict__":
          return mydict

        if name in mydict:
          return mydict[name]

        object.__getattribute__(self, 'assert_valid')()

        value = _get_instance_attr(self, name)
        fn = object.__getattribute__(self, '_retrieve_swig_value')
        return fn(name, value)
    else:
      def __getattr__(self, name):
        """Get an attribute from this object"""
        self.assert_valid()

        value = _swig_getattr(self, self.__class__, name)

        return self._retrieve_swig_value(name, value)

    def __setattr__(self, name, value):
      """Set an attribute on this object"""
      self.assert_valid()

    # Save a copy of the object, so that the garbage
    # collector won't kill the object while it's in
    # SWIG-land
      self.__dict__.setdefault("_members",{})[name] = value

      return _set_instance_attr(self, name, value)


    def __call__(self, *args):
      return svn_client_invoke_blame_receiver3(self, *args)

svn_client_blame_receiver3_t_swigregister = _client.svn_client_blame_receiver3_t_swigregister
svn_client_blame_receiver3_t_swigregister(svn_client_blame_receiver3_t)

class svn_client_blame_receiver2_t(object):
    """Proxy of C svn_client_blame_receiver2_t struct."""

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    def set_parent_pool(self, parent_pool=None):
      """Create a new proxy object for TYPE"""
      import libsvn.core, weakref
      self.__dict__["_parent_pool"] = \
        parent_pool or libsvn.core.application_pool;
      if self.__dict__["_parent_pool"]:
        self.__dict__["_is_valid"] = weakref.ref(
          self.__dict__["_parent_pool"]._is_valid)

    def assert_valid(self):
      """Assert that this object is using valid pool memory"""
      if "_is_valid" in self.__dict__:
        assert self.__dict__["_is_valid"](), "Variable has already been deleted"

    def _retrieve_swig_value(self, name, value):
    # If we got back a different object than we have cached, we need to copy
    # all our metadata into it, so that it looks identical to the one
    # originally set.
      members = self.__dict__.get('_members')
      if members is not None and name in members:
        _copy_metadata_deep(value, members[name])

    # Verify that the new object is good
      _assert_valid_deep(value)

      return value

    # Attribute access must be intercepted to ensure that objects coming from
    # read attribute access match those that are set with write attribute access.
    # Specifically the metadata, such as the associated apr_pool object, should
    # match the originally assigned object.
    #
    # For classic classes it is enough to use __getattr__ to intercept swig
    # derived attributes. However, with new style classes SWIG makes use of
    # descriptors which mean that __getattr__ is never called. Therefore,
    # __getattribute__ must be used for the interception.

    if _newclass:
      def __getattribute__(self, name):
        """Manage access to all attributes of this object."""

    # Start by mimicing __getattr__ behavior: immediately return __dict__ or
    # items directly present in __dict__
        mydict = object.__getattribute__(self, '__dict__')

        if name == "__dict__":
          return mydict

        if name in mydict:
          return mydict[name]

        object.__getattribute__(self, 'assert_valid')()

        value = _get_instance_attr(self, name)
        fn = object.__getattribute__(self, '_retrieve_swig_value')
        return fn(name, value)
    else:
      def __getattr__(self, name):
        """Get an attribute from this object"""
        self.assert_valid()

        value = _swig_getattr(self, self.__class__, name)

        return self._retrieve_swig_value(name, value)

    def __setattr__(self, name, value):
      """Set an attribute on this object"""
      self.assert_valid()

    # Save a copy of the object, so that the garbage
    # collector won't kill the object while it's in
    # SWIG-land
      self.__dict__.setdefault("_members",{})[name] = value

      return _set_instance_attr(self, name, value)


    def __call__(self, *args):
      return svn_client_invoke_blame_receiver2(self, *args)

svn_client_blame_receiver2_t_swigregister = _client.svn_client_blame_receiver2_t_swigregister
svn_client_blame_receiver2_t_swigregister(svn_client_blame_receiver2_t)

class svn_client_blame_receiver_t(object):
    """Proxy of C svn_client_blame_receiver_t struct."""

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    def set_parent_pool(self, parent_pool=None):
      """Create a new proxy object for TYPE"""
      import libsvn.core, weakref
      self.__dict__["_parent_pool"] = \
        parent_pool or libsvn.core.application_pool;
      if self.__dict__["_parent_pool"]:
        self.__dict__["_is_valid"] = weakref.ref(
          self.__dict__["_parent_pool"]._is_valid)

    def assert_valid(self):
      """Assert that this object is using valid pool memory"""
      if "_is_valid" in self.__dict__:
        assert self.__dict__["_is_valid"](), "Variable has already been deleted"

    def _retrieve_swig_value(self, name, value):
    # If we got back a different object than we have cached, we need to copy
    # all our metadata into it, so that it looks identical to the one
    # originally set.
      members = self.__dict__.get('_members')
      if members is not None and name in members:
        _copy_metadata_deep(value, members[name])

    # Verify that the new object is good
      _assert_valid_deep(value)

      return value

    # Attribute access must be intercepted to ensure that objects coming from
    # read attribute access match those that are set with write attribute access.
    # Specifically the metadata, such as the associated apr_pool object, should
    # match the originally assigned object.
    #
    # For classic classes it is enough to use __getattr__ to intercept swig
    # derived attributes. However, with new style classes SWIG makes use of
    # descriptors which mean that __getattr__ is never called. Therefore,
    # __getattribute__ must be used for the interception.

    if _newclass:
      def __getattribute__(self, name):
        """Manage access to all attributes of this object."""

    # Start by mimicing __getattr__ behavior: immediately return __dict__ or
    # items directly present in __dict__
        mydict = object.__getattribute__(self, '__dict__')

        if name == "__dict__":
          return mydict

        if name in mydict:
          return mydict[name]

        object.__getattribute__(self, 'assert_valid')()

        value = _get_instance_attr(self, name)
        fn = object.__getattribute__(self, '_retrieve_swig_value')
        return fn(name, value)
    else:
      def __getattr__(self, name):
        """Get an attribute from this object"""
        self.assert_valid()

        value = _swig_getattr(self, self.__class__, name)

        return self._retrieve_swig_value(name, value)

    def __setattr__(self, name, value):
      """Set an attribute on this object"""
      self.assert_valid()

    # Save a copy of the object, so that the garbage
    # collector won't kill the object while it's in
    # SWIG-land
      self.__dict__.setdefault("_members",{})[name] = value

      return _set_instance_attr(self, name, value)


    def __call__(self, *args):
      return svn_client_invoke_blame_receiver(self, *args)

svn_client_blame_receiver_t_swigregister = _client.svn_client_blame_receiver_t_swigregister
svn_client_blame_receiver_t_swigregister(svn_client_blame_receiver_t)

class svn_client_diff_summarize_func_t(object):
    """Proxy of C svn_client_diff_summarize_func_t struct."""

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    def set_parent_pool(self, parent_pool=None):
      """Create a new proxy object for TYPE"""
      import libsvn.core, weakref
      self.__dict__["_parent_pool"] = \
        parent_pool or libsvn.core.application_pool;
      if self.__dict__["_parent_pool"]:
        self.__dict__["_is_valid"] = weakref.ref(
          self.__dict__["_parent_pool"]._is_valid)

    def assert_valid(self):
      """Assert that this object is using valid pool memory"""
      if "_is_valid" in self.__dict__:
        assert self.__dict__["_is_valid"](), "Variable has already been deleted"

    def _retrieve_swig_value(self, name, value):
    # If we got back a different object than we have cached, we need to copy
    # all our metadata into it, so that it looks identical to the one
    # originally set.
      members = self.__dict__.get('_members')
      if members is not None and name in members:
        _copy_metadata_deep(value, members[name])

    # Verify that the new object is good
      _assert_valid_deep(value)

      return value

    # Attribute access must be intercepted to ensure that objects coming from
    # read attribute access match those that are set with write attribute access.
    # Specifically the metadata, such as the associated apr_pool object, should
    # match the originally assigned object.
    #
    # For classic classes it is enough to use __getattr__ to intercept swig
    # derived attributes. However, with new style classes SWIG makes use of
    # descriptors which mean that __getattr__ is never called. Therefore,
    # __getattribute__ must be used for the interception.

    if _newclass:
      def __getattribute__(self, name):
        """Manage access to all attributes of this object."""

    # Start by mimicing __getattr__ behavior: immediately return __dict__ or
    # items directly present in __dict__
        mydict = object.__getattribute__(self, '__dict__')

        if name == "__dict__":
          return mydict

        if name in mydict:
          return mydict[name]

        object.__getattribute__(self, 'assert_valid')()

        value = _get_instance_attr(self, name)
        fn = object.__getattribute__(self, '_retrieve_swig_value')
        return fn(name, value)
    else:
      def __getattr__(self, name):
        """Get an attribute from this object"""
        self.assert_valid()

        value = _swig_getattr(self, self.__class__, name)

        return self._retrieve_swig_value(name, value)

    def __setattr__(self, name, value):
      """Set an attribute on this object"""
      self.assert_valid()

    # Save a copy of the object, so that the garbage
    # collector won't kill the object while it's in
    # SWIG-land
      self.__dict__.setdefault("_members",{})[name] = value

      return _set_instance_attr(self, name, value)


    def __call__(self, *args):
      return svn_client_invoke_diff_summarize_func(self, *args)

svn_client_diff_summarize_func_t_swigregister = _client.svn_client_diff_summarize_func_t_swigregister
svn_client_diff_summarize_func_t_swigregister(svn_client_diff_summarize_func_t)

class svn_client__layout_func_t(object):
    """Proxy of C svn_client__layout_func_t struct."""

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    def set_parent_pool(self, parent_pool=None):
      """Create a new proxy object for TYPE"""
      import libsvn.core, weakref
      self.__dict__["_parent_pool"] = \
        parent_pool or libsvn.core.application_pool;
      if self.__dict__["_parent_pool"]:
        self.__dict__["_is_valid"] = weakref.ref(
          self.__dict__["_parent_pool"]._is_valid)

    def assert_valid(self):
      """Assert that this object is using valid pool memory"""
      if "_is_valid" in self.__dict__:
        assert self.__dict__["_is_valid"](), "Variable has already been deleted"

    def _retrieve_swig_value(self, name, value):
    # If we got back a different object than we have cached, we need to copy
    # all our metadata into it, so that it looks identical to the one
    # originally set.
      members = self.__dict__.get('_members')
      if members is not None and name in members:
        _copy_metadata_deep(value, members[name])

    # Verify that the new object is good
      _assert_valid_deep(value)

      return value

    # Attribute access must be intercepted to ensure that objects coming from
    # read attribute access match those that are set with write attribute access.
    # Specifically the metadata, such as the associated apr_pool object, should
    # match the originally assigned object.
    #
    # For classic classes it is enough to use __getattr__ to intercept swig
    # derived attributes. However, with new style classes SWIG makes use of
    # descriptors which mean that __getattr__ is never called. Therefore,
    # __getattribute__ must be used for the interception.

    if _newclass:
      def __getattribute__(self, name):
        """Manage access to all attributes of this object."""

    # Start by mimicing __getattr__ behavior: immediately return __dict__ or
    # items directly present in __dict__
        mydict = object.__getattribute__(self, '__dict__')

        if name == "__dict__":
          return mydict

        if name in mydict:
          return mydict[name]

        object.__getattribute__(self, 'assert_valid')()

        value = _get_instance_attr(self, name)
        fn = object.__getattribute__(self, '_retrieve_swig_value')
        return fn(name, value)
    else:
      def __getattr__(self, name):
        """Get an attribute from this object"""
        self.assert_valid()

        value = _swig_getattr(self, self.__class__, name)

        return self._retrieve_swig_value(name, value)

    def __setattr__(self, name, value):
      """Set an attribute on this object"""
      self.assert_valid()

    # Save a copy of the object, so that the garbage
    # collector won't kill the object while it's in
    # SWIG-land
      self.__dict__.setdefault("_members",{})[name] = value

      return _set_instance_attr(self, name, value)


    def __call__(self, *args):
      return svn_client_invoke__layout_func(self, *args)

svn_client__layout_func_t_swigregister = _client.svn_client__layout_func_t_swigregister
svn_client__layout_func_t_swigregister(svn_client__layout_func_t)

class svn_client_import_filter_func_t(object):
    """Proxy of C svn_client_import_filter_func_t struct."""

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    def set_parent_pool(self, parent_pool=None):
      """Create a new proxy object for TYPE"""
      import libsvn.core, weakref
      self.__dict__["_parent_pool"] = \
        parent_pool or libsvn.core.application_pool;
      if self.__dict__["_parent_pool"]:
        self.__dict__["_is_valid"] = weakref.ref(
          self.__dict__["_parent_pool"]._is_valid)

    def assert_valid(self):
      """Assert that this object is using valid pool memory"""
      if "_is_valid" in self.__dict__:
        assert self.__dict__["_is_valid"](), "Variable has already been deleted"

    def _retrieve_swig_value(self, name, value):
    # If we got back a different object than we have cached, we need to copy
    # all our metadata into it, so that it looks identical to the one
    # originally set.
      members = self.__dict__.get('_members')
      if members is not None and name in members:
        _copy_metadata_deep(value, members[name])

    # Verify that the new object is good
      _assert_valid_deep(value)

      return value

    # Attribute access must be intercepted to ensure that objects coming from
    # read attribute access match those that are set with write attribute access.
    # Specifically the metadata, such as the associated apr_pool object, should
    # match the originally assigned object.
    #
    # For classic classes it is enough to use __getattr__ to intercept swig
    # derived attributes. However, with new style classes SWIG makes use of
    # descriptors which mean that __getattr__ is never called. Therefore,
    # __getattribute__ must be used for the interception.

    if _newclass:
      def __getattribute__(self, name):
        """Manage access to all attributes of this object."""

    # Start by mimicing __getattr__ behavior: immediately return __dict__ or
    # items directly present in __dict__
        mydict = object.__getattribute__(self, '__dict__')

        if name == "__dict__":
          return mydict

        if name in mydict:
          return mydict[name]

        object.__getattribute__(self, 'assert_valid')()

        value = _get_instance_attr(self, name)
        fn = object.__getattribute__(self, '_retrieve_swig_value')
        return fn(name, value)
    else:
      def __getattr__(self, name):
        """Get an attribute from this object"""
        self.assert_valid()

        value = _swig_getattr(self, self.__class__, name)

        return self._retrieve_swig_value(name, value)

    def __setattr__(self, name, value):
      """Set an attribute on this object"""
      self.assert_valid()

    # Save a copy of the object, so that the garbage
    # collector won't kill the object while it's in
    # SWIG-land
      self.__dict__.setdefault("_members",{})[name] = value

      return _set_instance_attr(self, name, value)


    def __call__(self, *args):
      return svn_client_invoke_import_filter_func(self, *args)

svn_client_import_filter_func_t_swigregister = _client.svn_client_import_filter_func_t_swigregister
svn_client_import_filter_func_t_swigregister(svn_client_import_filter_func_t)

class svn_client_status_func_t(object):
    """Proxy of C svn_client_status_func_t struct."""

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    def set_parent_pool(self, parent_pool=None):
      """Create a new proxy object for TYPE"""
      import libsvn.core, weakref
      self.__dict__["_parent_pool"] = \
        parent_pool or libsvn.core.application_pool;
      if self.__dict__["_parent_pool"]:
        self.__dict__["_is_valid"] = weakref.ref(
          self.__dict__["_parent_pool"]._is_valid)

    def assert_valid(self):
      """Assert that this object is using valid pool memory"""
      if "_is_valid" in self.__dict__:
        assert self.__dict__["_is_valid"](), "Variable has already been deleted"

    def _retrieve_swig_value(self, name, value):
    # If we got back a different object than we have cached, we need to copy
    # all our metadata into it, so that it looks identical to the one
    # originally set.
      members = self.__dict__.get('_members')
      if members is not None and name in members:
        _copy_metadata_deep(value, members[name])

    # Verify that the new object is good
      _assert_valid_deep(value)

      return value

    # Attribute access must be intercepted to ensure that objects coming from
    # read attribute access match those that are set with write attribute access.
    # Specifically the metadata, such as the associated apr_pool object, should
    # match the originally assigned object.
    #
    # For classic classes it is enough to use __getattr__ to intercept swig
    # derived attributes. However, with new style classes SWIG makes use of
    # descriptors which mean that __getattr__ is never called. Therefore,
    # __getattribute__ must be used for the interception.

    if _newclass:
      def __getattribute__(self, name):
        """Manage access to all attributes of this object."""

    # Start by mimicing __getattr__ behavior: immediately return __dict__ or
    # items directly present in __dict__
        mydict = object.__getattribute__(self, '__dict__')

        if name == "__dict__":
          return mydict

        if name in mydict:
          return mydict[name]

        object.__getattribute__(self, 'assert_valid')()

        value = _get_instance_attr(self, name)
        fn = object.__getattribute__(self, '_retrieve_swig_value')
        return fn(name, value)
    else:
      def __getattr__(self, name):
        """Get an attribute from this object"""
        self.assert_valid()

        value = _swig_getattr(self, self.__class__, name)

        return self._retrieve_swig_value(name, value)

    def __setattr__(self, name, value):
      """Set an attribute on this object"""
      self.assert_valid()

    # Save a copy of the object, so that the garbage
    # collector won't kill the object while it's in
    # SWIG-land
      self.__dict__.setdefault("_members",{})[name] = value

      return _set_instance_attr(self, name, value)


    def __call__(self, *args):
      return svn_client_invoke_status_func(self, *args)

svn_client_status_func_t_swigregister = _client.svn_client_status_func_t_swigregister
svn_client_status_func_t_swigregister(svn_client_status_func_t)

class svn_client_conflict_walk_func_t(object):
    """Proxy of C svn_client_conflict_walk_func_t struct."""

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    def set_parent_pool(self, parent_pool=None):
      """Create a new proxy object for TYPE"""
      import libsvn.core, weakref
      self.__dict__["_parent_pool"] = \
        parent_pool or libsvn.core.application_pool;
      if self.__dict__["_parent_pool"]:
        self.__dict__["_is_valid"] = weakref.ref(
          self.__dict__["_parent_pool"]._is_valid)

    def assert_valid(self):
      """Assert that this object is using valid pool memory"""
      if "_is_valid" in self.__dict__:
        assert self.__dict__["_is_valid"](), "Variable has already been deleted"

    def _retrieve_swig_value(self, name, value):
    # If we got back a different object than we have cached, we need to copy
    # all our metadata into it, so that it looks identical to the one
    # originally set.
      members = self.__dict__.get('_members')
      if members is not None and name in members:
        _copy_metadata_deep(value, members[name])

    # Verify that the new object is good
      _assert_valid_deep(value)

      return value

    # Attribute access must be intercepted to ensure that objects coming from
    # read attribute access match those that are set with write attribute access.
    # Specifically the metadata, such as the associated apr_pool object, should
    # match the originally assigned object.
    #
    # For classic classes it is enough to use __getattr__ to intercept swig
    # derived attributes. However, with new style classes SWIG makes use of
    # descriptors which mean that __getattr__ is never called. Therefore,
    # __getattribute__ must be used for the interception.

    if _newclass:
      def __getattribute__(self, name):
        """Manage access to all attributes of this object."""

    # Start by mimicing __getattr__ behavior: immediately return __dict__ or
    # items directly present in __dict__
        mydict = object.__getattribute__(self, '__dict__')

        if name == "__dict__":
          return mydict

        if name in mydict:
          return mydict[name]

        object.__getattribute__(self, 'assert_valid')()

        value = _get_instance_attr(self, name)
        fn = object.__getattribute__(self, '_retrieve_swig_value')
        return fn(name, value)
    else:
      def __getattr__(self, name):
        """Get an attribute from this object"""
        self.assert_valid()

        value = _swig_getattr(self, self.__class__, name)

        return self._retrieve_swig_value(name, value)

    def __setattr__(self, name, value):
      """Set an attribute on this object"""
      self.assert_valid()

    # Save a copy of the object, so that the garbage
    # collector won't kill the object while it's in
    # SWIG-land
      self.__dict__.setdefault("_members",{})[name] = value

      return _set_instance_attr(self, name, value)


    def __call__(self, *args):
      return svn_client_invoke_conflict_walk_func(self, *args)

svn_client_conflict_walk_func_t_swigregister = _client.svn_client_conflict_walk_func_t_swigregister
svn_client_conflict_walk_func_t_swigregister(svn_client_conflict_walk_func_t)

class svn_client_list_func2_t(object):
    """Proxy of C svn_client_list_func2_t struct."""

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    def set_parent_pool(self, parent_pool=None):
      """Create a new proxy object for TYPE"""
      import libsvn.core, weakref
      self.__dict__["_parent_pool"] = \
        parent_pool or libsvn.core.application_pool;
      if self.__dict__["_parent_pool"]:
        self.__dict__["_is_valid"] = weakref.ref(
          self.__dict__["_parent_pool"]._is_valid)

    def assert_valid(self):
      """Assert that this object is using valid pool memory"""
      if "_is_valid" in self.__dict__:
        assert self.__dict__["_is_valid"](), "Variable has already been deleted"

    def _retrieve_swig_value(self, name, value):
    # If we got back a different object than we have cached, we need to copy
    # all our metadata into it, so that it looks identical to the one
    # originally set.
      members = self.__dict__.get('_members')
      if members is not None and name in members:
        _copy_metadata_deep(value, members[name])

    # Verify that the new object is good
      _assert_valid_deep(value)

      return value

    # Attribute access must be intercepted to ensure that objects coming from
    # read attribute access match those that are set with write attribute access.
    # Specifically the metadata, such as the associated apr_pool object, should
    # match the originally assigned object.
    #
    # For classic classes it is enough to use __getattr__ to intercept swig
    # derived attributes. However, with new style classes SWIG makes use of
    # descriptors which mean that __getattr__ is never called. Therefore,
    # __getattribute__ must be used for the interception.

    if _newclass:
      def __getattribute__(self, name):
        """Manage access to all attributes of this object."""

    # Start by mimicing __getattr__ behavior: immediately return __dict__ or
    # items directly present in __dict__
        mydict = object.__getattribute__(self, '__dict__')

        if name == "__dict__":
          return mydict

        if name in mydict:
          return mydict[name]

        object.__getattribute__(self, 'assert_valid')()

        value = _get_instance_attr(self, name)
        fn = object.__getattribute__(self, '_retrieve_swig_value')
        return fn(name, value)
    else:
      def __getattr__(self, name):
        """Get an attribute from this object"""
        self.assert_valid()

        value = _swig_getattr(self, self.__class__, name)

        return self._retrieve_swig_value(name, value)

    def __setattr__(self, name, value):
      """Set an attribute on this object"""
      self.assert_valid()

    # Save a copy of the object, so that the garbage
    # collector won't kill the object while it's in
    # SWIG-land
      self.__dict__.setdefault("_members",{})[name] = value

      return _set_instance_attr(self, name, value)


    def __call__(self, *args):
      return svn_client_invoke_list_func2(self, *args)

svn_client_list_func2_t_swigregister = _client.svn_client_list_func2_t_swigregister
svn_client_list_func2_t_swigregister(svn_client_list_func2_t)

class svn_client_list_func_t(object):
    """Proxy of C svn_client_list_func_t struct."""

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    def set_parent_pool(self, parent_pool=None):
      """Create a new proxy object for TYPE"""
      import libsvn.core, weakref
      self.__dict__["_parent_pool"] = \
        parent_pool or libsvn.core.application_pool;
      if self.__dict__["_parent_pool"]:
        self.__dict__["_is_valid"] = weakref.ref(
          self.__dict__["_parent_pool"]._is_valid)

    def assert_valid(self):
      """Assert that this object is using valid pool memory"""
      if "_is_valid" in self.__dict__:
        assert self.__dict__["_is_valid"](), "Variable has already been deleted"

    def _retrieve_swig_value(self, name, value):
    # If we got back a different object than we have cached, we need to copy
    # all our metadata into it, so that it looks identical to the one
    # originally set.
      members = self.__dict__.get('_members')
      if members is not None and name in members:
        _copy_metadata_deep(value, members[name])

    # Verify that the new object is good
      _assert_valid_deep(value)

      return value

    # Attribute access must be intercepted to ensure that objects coming from
    # read attribute access match those that are set with write attribute access.
    # Specifically the metadata, such as the associated apr_pool object, should
    # match the originally assigned object.
    #
    # For classic classes it is enough to use __getattr__ to intercept swig
    # derived attributes. However, with new style classes SWIG makes use of
    # descriptors which mean that __getattr__ is never called. Therefore,
    # __getattribute__ must be used for the interception.

    if _newclass:
      def __getattribute__(self, name):
        """Manage access to all attributes of this object."""

    # Start by mimicing __getattr__ behavior: immediately return __dict__ or
    # items directly present in __dict__
        mydict = object.__getattribute__(self, '__dict__')

        if name == "__dict__":
          return mydict

        if name in mydict:
          return mydict[name]

        object.__getattribute__(self, 'assert_valid')()

        value = _get_instance_attr(self, name)
        fn = object.__getattribute__(self, '_retrieve_swig_value')
        return fn(name, value)
    else:
      def __getattr__(self, name):
        """Get an attribute from this object"""
        self.assert_valid()

        value = _swig_getattr(self, self.__class__, name)

        return self._retrieve_swig_value(name, value)

    def __setattr__(self, name, value):
      """Set an attribute on this object"""
      self.assert_valid()

    # Save a copy of the object, so that the garbage
    # collector won't kill the object while it's in
    # SWIG-land
      self.__dict__.setdefault("_members",{})[name] = value

      return _set_instance_attr(self, name, value)


    def __call__(self, *args):
      return svn_client_invoke_list_func(self, *args)

svn_client_list_func_t_swigregister = _client.svn_client_list_func_t_swigregister
svn_client_list_func_t_swigregister(svn_client_list_func_t)

class svn_info_receiver_t(object):
    """Proxy of C svn_info_receiver_t struct."""

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    def set_parent_pool(self, parent_pool=None):
      """Create a new proxy object for TYPE"""
      import libsvn.core, weakref
      self.__dict__["_parent_pool"] = \
        parent_pool or libsvn.core.application_pool;
      if self.__dict__["_parent_pool"]:
        self.__dict__["_is_valid"] = weakref.ref(
          self.__dict__["_parent_pool"]._is_valid)

    def assert_valid(self):
      """Assert that this object is using valid pool memory"""
      if "_is_valid" in self.__dict__:
        assert self.__dict__["_is_valid"](), "Variable has already been deleted"

    def _retrieve_swig_value(self, name, value):
    # If we got back a different object than we have cached, we need to copy
    # all our metadata into it, so that it looks identical to the one
    # originally set.
      members = self.__dict__.get('_members')
      if members is not None and name in members:
        _copy_metadata_deep(value, members[name])

    # Verify that the new object is good
      _assert_valid_deep(value)

      return value

    # Attribute access must be intercepted to ensure that objects coming from
    # read attribute access match those that are set with write attribute access.
    # Specifically the metadata, such as the associated apr_pool object, should
    # match the originally assigned object.
    #
    # For classic classes it is enough to use __getattr__ to intercept swig
    # derived attributes. However, with new style classes SWIG makes use of
    # descriptors which mean that __getattr__ is never called. Therefore,
    # __getattribute__ must be used for the interception.

    if _newclass:
      def __getattribute__(self, name):
        """Manage access to all attributes of this object."""

    # Start by mimicing __getattr__ behavior: immediately return __dict__ or
    # items directly present in __dict__
        mydict = object.__getattribute__(self, '__dict__')

        if name == "__dict__":
          return mydict

        if name in mydict:
          return mydict[name]

        object.__getattribute__(self, 'assert_valid')()

        value = _get_instance_attr(self, name)
        fn = object.__getattribute__(self, '_retrieve_swig_value')
        return fn(name, value)
    else:
      def __getattr__(self, name):
        """Get an attribute from this object"""
        self.assert_valid()

        value = _swig_getattr(self, self.__class__, name)

        return self._retrieve_swig_value(name, value)

    def __setattr__(self, name, value):
      """Set an attribute on this object"""
      self.assert_valid()

    # Save a copy of the object, so that the garbage
    # collector won't kill the object while it's in
    # SWIG-land
      self.__dict__.setdefault("_members",{})[name] = value

      return _set_instance_attr(self, name, value)


    def __call__(self, *args):
      return svn_info_invoke_receiver(self, *args)

svn_info_receiver_t_swigregister = _client.svn_info_receiver_t_swigregister
svn_info_receiver_t_swigregister(svn_info_receiver_t)

class svn_client_info_receiver2_t(object):
    """Proxy of C svn_client_info_receiver2_t struct."""

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    def set_parent_pool(self, parent_pool=None):
      """Create a new proxy object for TYPE"""
      import libsvn.core, weakref
      self.__dict__["_parent_pool"] = \
        parent_pool or libsvn.core.application_pool;
      if self.__dict__["_parent_pool"]:
        self.__dict__["_is_valid"] = weakref.ref(
          self.__dict__["_parent_pool"]._is_valid)

    def assert_valid(self):
      """Assert that this object is using valid pool memory"""
      if "_is_valid" in self.__dict__:
        assert self.__dict__["_is_valid"](), "Variable has already been deleted"

    def _retrieve_swig_value(self, name, value):
    # If we got back a different object than we have cached, we need to copy
    # all our metadata into it, so that it looks identical to the one
    # originally set.
      members = self.__dict__.get('_members')
      if members is not None and name in members:
        _copy_metadata_deep(value, members[name])

    # Verify that the new object is good
      _assert_valid_deep(value)

      return value

    # Attribute access must be intercepted to ensure that objects coming from
    # read attribute access match those that are set with write attribute access.
    # Specifically the metadata, such as the associated apr_pool object, should
    # match the originally assigned object.
    #
    # For classic classes it is enough to use __getattr__ to intercept swig
    # derived attributes. However, with new style classes SWIG makes use of
    # descriptors which mean that __getattr__ is never called. Therefore,
    # __getattribute__ must be used for the interception.

    if _newclass:
      def __getattribute__(self, name):
        """Manage access to all attributes of this object."""

    # Start by mimicing __getattr__ behavior: immediately return __dict__ or
    # items directly present in __dict__
        mydict = object.__getattribute__(self, '__dict__')

        if name == "__dict__":
          return mydict

        if name in mydict:
          return mydict[name]

        object.__getattribute__(self, 'assert_valid')()

        value = _get_instance_attr(self, name)
        fn = object.__getattribute__(self, '_retrieve_swig_value')
        return fn(name, value)
    else:
      def __getattr__(self, name):
        """Get an attribute from this object"""
        self.assert_valid()

        value = _swig_getattr(self, self.__class__, name)

        return self._retrieve_swig_value(name, value)

    def __setattr__(self, name, value):
      """Set an attribute on this object"""
      self.assert_valid()

    # Save a copy of the object, so that the garbage
    # collector won't kill the object while it's in
    # SWIG-land
      self.__dict__.setdefault("_members",{})[name] = value

      return _set_instance_attr(self, name, value)


    def __call__(self, *args):
      return svn_client_invoke_info_receiver2(self, *args)

svn_client_info_receiver2_t_swigregister = _client.svn_client_info_receiver2_t_swigregister
svn_client_info_receiver2_t_swigregister(svn_client_info_receiver2_t)

class svn_client_patch_func_t(object):
    """Proxy of C svn_client_patch_func_t struct."""

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    def set_parent_pool(self, parent_pool=None):
      """Create a new proxy object for TYPE"""
      import libsvn.core, weakref
      self.__dict__["_parent_pool"] = \
        parent_pool or libsvn.core.application_pool;
      if self.__dict__["_parent_pool"]:
        self.__dict__["_is_valid"] = weakref.ref(
          self.__dict__["_parent_pool"]._is_valid)

    def assert_valid(self):
      """Assert that this object is using valid pool memory"""
      if "_is_valid" in self.__dict__:
        assert self.__dict__["_is_valid"](), "Variable has already been deleted"

    def _retrieve_swig_value(self, name, value):
    # If we got back a different object than we have cached, we need to copy
    # all our metadata into it, so that it looks identical to the one
    # originally set.
      members = self.__dict__.get('_members')
      if members is not None and name in members:
        _copy_metadata_deep(value, members[name])

    # Verify that the new object is good
      _assert_valid_deep(value)

      return value

    # Attribute access must be intercepted to ensure that objects coming from
    # read attribute access match those that are set with write attribute access.
    # Specifically the metadata, such as the associated apr_pool object, should
    # match the originally assigned object.
    #
    # For classic classes it is enough to use __getattr__ to intercept swig
    # derived attributes. However, with new style classes SWIG makes use of
    # descriptors which mean that __getattr__ is never called. Therefore,
    # __getattribute__ must be used for the interception.

    if _newclass:
      def __getattribute__(self, name):
        """Manage access to all attributes of this object."""

    # Start by mimicing __getattr__ behavior: immediately return __dict__ or
    # items directly present in __dict__
        mydict = object.__getattribute__(self, '__dict__')

        if name == "__dict__":
          return mydict

        if name in mydict:
          return mydict[name]

        object.__getattribute__(self, 'assert_valid')()

        value = _get_instance_attr(self, name)
        fn = object.__getattribute__(self, '_retrieve_swig_value')
        return fn(name, value)
    else:
      def __getattr__(self, name):
        """Get an attribute from this object"""
        self.assert_valid()

        value = _swig_getattr(self, self.__class__, name)

        return self._retrieve_swig_value(name, value)

    def __setattr__(self, name, value):
      """Set an attribute on this object"""
      self.assert_valid()

    # Save a copy of the object, so that the garbage
    # collector won't kill the object while it's in
    # SWIG-land
      self.__dict__.setdefault("_members",{})[name] = value

      return _set_instance_attr(self, name, value)


    def __call__(self, *args):
      return svn_client_invoke_patch_func(self, *args)

svn_client_patch_func_t_swigregister = _client.svn_client_patch_func_t_swigregister
svn_client_patch_func_t_swigregister(svn_client_patch_func_t)

SWIG_SVN_INFO_SIZE_UNKNOWN = _client.SWIG_SVN_INFO_SIZE_UNKNOWN
svn_swig_py_cancel_func = _client.svn_swig_py_cancel_func
svn_swig_py_get_commit_log_func = _client.svn_swig_py_get_commit_log_func
svn_swig_py_notify_func = _client.svn_swig_py_notify_func
svn_swig_py_notify_func2 = _client.svn_swig_py_notify_func2


