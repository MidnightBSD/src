# This file was automatically generated by SWIG (http://www.swig.org).
# Version 3.0.12
#
# Do not make changes to this file unless you know what you are doing--modify
# the SWIG interface file instead.


def _dll_paths():
    import os
    if hasattr(os, 'add_dll_directory'):  # Python 3.8+ on Windows
        cookies = []
        for path in os.environ.get('PATH', '').split(os.pathsep):
            if path and os.path.isabs(path):
                try:
                    cookie = os.add_dll_directory(path)
                except OSError:
                    continue
                else:
                    cookies.append(cookie)
        return cookies
    else:
        return ()

_dll_paths = _dll_paths()
try:
    from . import _diff
finally:
    _dll_path = None
    for _dll_path in _dll_paths:
        _dll_path.close()
    del _dll_paths, _dll_path

try:
    _swig_property = property
except NameError:
    pass  # Python < 2.2 doesn't have 'property'.

try:
    import builtins as __builtin__
except ImportError:
    import __builtin__

def _swig_setattr_nondynamic(self, class_type, name, value, static=1):
    if (name == "thisown"):
        return self.this.own(value)
    if (name == "this"):
        if type(value).__name__ == 'SwigPyObject':
            self.__dict__[name] = value
            return
    method = class_type.__swig_setmethods__.get(name, None)
    if method:
        return method(self, value)
    if (not static):
        object.__setattr__(self, name, value)
    else:
        raise AttributeError("You cannot add attributes to %s" % self)


def _swig_setattr(self, class_type, name, value):
    return _swig_setattr_nondynamic(self, class_type, name, value, 0)


def _swig_getattr(self, class_type, name):
    if (name == "thisown"):
        return self.this.own()
    method = class_type.__swig_getmethods__.get(name, None)
    if method:
        return method(self)
    raise AttributeError("'%s' object has no attribute '%s'" % (class_type.__name__, name))


def _swig_repr(self):
    try:
        strthis = "proxy of " + self.this.__repr__()
    except __builtin__.Exception:
        strthis = ""
    return "<%s.%s; %s >" % (self.__class__.__module__, self.__class__.__name__, strthis,)


def _swig_setattr_nondynamic_method(set):
    def set_attr(self, name, value):
        if (name == "thisown"):
            return self.this.own(value)
        if hasattr(self, name) or (name == "this"):
            set(self, name, value)
        else:
            raise AttributeError("You cannot add attributes to %s" % self)
    return set_attr



def _copy_metadata_deep(value, old_value):
  """Copy all attributes of old_value into value, recursively traversing
  lists and dicts if needed."""
  if value is None or old_value is None or value is old_value: return

  if isinstance(value, dict):
    for k in value:
      _copy_metadata_deep(value[k], old_value[k])
  elif isinstance(value, list):
    for v, old_v in zip(value, old_value):
      _copy_metadata_deep(v, old_v)
  else:
    try:
      value.__dict__.update(old_value.__dict__)
    except AttributeError:
      pass

def _assert_valid_deep(value):
  """Assert value's validity, recursively traversing lists and dicts."""
  if isinstance(value, dict):
    for k in value:
      _assert_valid_deep(value[k])
  elif isinstance(value, list):
    for v in value:
      _assert_valid_deep(v)
# Ensure that the passed in value isn't a type, which could have an
# assert_valid attribute, but it can not be called without an instance.
  elif type(value) != type:
    try:
      fn = value.assert_valid
    except AttributeError:
      pass
    else:
      fn()



  # SWIG classes generated with -modern do not define this variable
try:
  _newclass
except NameError:
  _newclass = 1
else:
  raise RuntimeError("Require -modern option, but _newclass is defined")

_get_instance_attr = object.__getattribute__
_set_instance_attr = _swig_setattr_nondynamic_method(object.__setattr__)


import libsvn.core

def svn_diff_version() -> "svn_version_t const *":
    """svn_diff_version() -> svn_version_t const *"""
    return _diff.svn_diff_version()
svn_diff_datasource_original = _diff.svn_diff_datasource_original
svn_diff_datasource_modified = _diff.svn_diff_datasource_modified
svn_diff_datasource_latest = _diff.svn_diff_datasource_latest
svn_diff_datasource_ancestor = _diff.svn_diff_datasource_ancestor
class svn_diff_fns2_t(object):
    """Proxy of C svn_diff_fns2_t struct."""

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    datasources_open = _swig_property(_diff.svn_diff_fns2_t_datasources_open_get, _diff.svn_diff_fns2_t_datasources_open_set)
    datasource_close = _swig_property(_diff.svn_diff_fns2_t_datasource_close_get, _diff.svn_diff_fns2_t_datasource_close_set)
    datasource_get_next_token = _swig_property(_diff.svn_diff_fns2_t_datasource_get_next_token_get, _diff.svn_diff_fns2_t_datasource_get_next_token_set)
    token_compare = _swig_property(_diff.svn_diff_fns2_t_token_compare_get, _diff.svn_diff_fns2_t_token_compare_set)
    token_discard = _swig_property(_diff.svn_diff_fns2_t_token_discard_get, _diff.svn_diff_fns2_t_token_discard_set)
    token_discard_all = _swig_property(_diff.svn_diff_fns2_t_token_discard_all_get, _diff.svn_diff_fns2_t_token_discard_all_set)
    def set_parent_pool(self, parent_pool=None):
      """Create a new proxy object for TYPE"""
      import libsvn.core, weakref
      self.__dict__["_parent_pool"] = \
        parent_pool or libsvn.core.application_pool;
      if self.__dict__["_parent_pool"]:
        self.__dict__["_is_valid"] = weakref.ref(
          self.__dict__["_parent_pool"]._is_valid)

    def assert_valid(self):
      """Assert that this object is using valid pool memory"""
      if "_is_valid" in self.__dict__:
        assert self.__dict__["_is_valid"](), "Variable has already been deleted"

    def _retrieve_swig_value(self, name, value):
    # If we got back a different object than we have cached, we need to copy
    # all our metadata into it, so that it looks identical to the one
    # originally set.
      members = self.__dict__.get('_members')
      if members is not None and name in members:
        _copy_metadata_deep(value, members[name])

    # Verify that the new object is good
      _assert_valid_deep(value)

      return value

    # Attribute access must be intercepted to ensure that objects coming from
    # read attribute access match those that are set with write attribute access.
    # Specifically the metadata, such as the associated apr_pool object, should
    # match the originally assigned object.
    #
    # For classic classes it is enough to use __getattr__ to intercept swig
    # derived attributes. However, with new style classes SWIG makes use of
    # descriptors which mean that __getattr__ is never called. Therefore,
    # __getattribute__ must be used for the interception.

    if _newclass:
      def __getattribute__(self, name):
        """Manage access to all attributes of this object."""

    # Start by mimicing __getattr__ behavior: immediately return __dict__ or
    # items directly present in __dict__
        mydict = object.__getattribute__(self, '__dict__')

        if name == "__dict__":
          return mydict

        if name in mydict:
          return mydict[name]

        object.__getattribute__(self, 'assert_valid')()

        value = _get_instance_attr(self, name)
        fn = object.__getattribute__(self, '_retrieve_swig_value')
        return fn(name, value)
    else:
      def __getattr__(self, name):
        """Get an attribute from this object"""
        self.assert_valid()

        value = _swig_getattr(self, self.__class__, name)

        return self._retrieve_swig_value(name, value)

    def __setattr__(self, name, value):
      """Set an attribute on this object"""
      self.assert_valid()

    # Save a copy of the object, so that the garbage
    # collector won't kill the object while it's in
    # SWIG-land
      self.__dict__.setdefault("_members",{})[name] = value

      return _set_instance_attr(self, name, value)


    def datasources_open(self, *args):
      return svn_diff_fns2_invoke_datasources_open(self, *args)


    def datasource_close(self, *args):
      return svn_diff_fns2_invoke_datasource_close(self, *args)


    def datasource_get_next_token(self, *args):
      return svn_diff_fns2_invoke_datasource_get_next_token(self, *args)


    def token_compare(self, *args):
      return svn_diff_fns2_invoke_token_compare(self, *args)


    def token_discard(self, *args):
      return svn_diff_fns2_invoke_token_discard(self, *args)


    def token_discard_all(self, *args):
      return svn_diff_fns2_invoke_token_discard_all(self, *args)


    def __init__(self):
        """__init__(svn_diff_fns2_t self) -> svn_diff_fns2_t"""
        this = _diff.new_svn_diff_fns2_t()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _diff.delete_svn_diff_fns2_t
    __del__ = lambda self: None
svn_diff_fns2_t_swigregister = _diff.svn_diff_fns2_t_swigregister
svn_diff_fns2_t_swigregister(svn_diff_fns2_t)

class svn_diff_fns_t(object):
    """Proxy of C svn_diff_fns_t struct."""

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    datasource_open = _swig_property(_diff.svn_diff_fns_t_datasource_open_get, _diff.svn_diff_fns_t_datasource_open_set)
    datasource_close = _swig_property(_diff.svn_diff_fns_t_datasource_close_get, _diff.svn_diff_fns_t_datasource_close_set)
    datasource_get_next_token = _swig_property(_diff.svn_diff_fns_t_datasource_get_next_token_get, _diff.svn_diff_fns_t_datasource_get_next_token_set)
    token_compare = _swig_property(_diff.svn_diff_fns_t_token_compare_get, _diff.svn_diff_fns_t_token_compare_set)
    token_discard = _swig_property(_diff.svn_diff_fns_t_token_discard_get, _diff.svn_diff_fns_t_token_discard_set)
    token_discard_all = _swig_property(_diff.svn_diff_fns_t_token_discard_all_get, _diff.svn_diff_fns_t_token_discard_all_set)
    def set_parent_pool(self, parent_pool=None):
      """Create a new proxy object for TYPE"""
      import libsvn.core, weakref
      self.__dict__["_parent_pool"] = \
        parent_pool or libsvn.core.application_pool;
      if self.__dict__["_parent_pool"]:
        self.__dict__["_is_valid"] = weakref.ref(
          self.__dict__["_parent_pool"]._is_valid)

    def assert_valid(self):
      """Assert that this object is using valid pool memory"""
      if "_is_valid" in self.__dict__:
        assert self.__dict__["_is_valid"](), "Variable has already been deleted"

    def _retrieve_swig_value(self, name, value):
    # If we got back a different object than we have cached, we need to copy
    # all our metadata into it, so that it looks identical to the one
    # originally set.
      members = self.__dict__.get('_members')
      if members is not None and name in members:
        _copy_metadata_deep(value, members[name])

    # Verify that the new object is good
      _assert_valid_deep(value)

      return value

    # Attribute access must be intercepted to ensure that objects coming from
    # read attribute access match those that are set with write attribute access.
    # Specifically the metadata, such as the associated apr_pool object, should
    # match the originally assigned object.
    #
    # For classic classes it is enough to use __getattr__ to intercept swig
    # derived attributes. However, with new style classes SWIG makes use of
    # descriptors which mean that __getattr__ is never called. Therefore,
    # __getattribute__ must be used for the interception.

    if _newclass:
      def __getattribute__(self, name):
        """Manage access to all attributes of this object."""

    # Start by mimicing __getattr__ behavior: immediately return __dict__ or
    # items directly present in __dict__
        mydict = object.__getattribute__(self, '__dict__')

        if name == "__dict__":
          return mydict

        if name in mydict:
          return mydict[name]

        object.__getattribute__(self, 'assert_valid')()

        value = _get_instance_attr(self, name)
        fn = object.__getattribute__(self, '_retrieve_swig_value')
        return fn(name, value)
    else:
      def __getattr__(self, name):
        """Get an attribute from this object"""
        self.assert_valid()

        value = _swig_getattr(self, self.__class__, name)

        return self._retrieve_swig_value(name, value)

    def __setattr__(self, name, value):
      """Set an attribute on this object"""
      self.assert_valid()

    # Save a copy of the object, so that the garbage
    # collector won't kill the object while it's in
    # SWIG-land
      self.__dict__.setdefault("_members",{})[name] = value

      return _set_instance_attr(self, name, value)


    def datasource_open(self, *args):
      return svn_diff_fns_invoke_datasource_open(self, *args)


    def datasource_close(self, *args):
      return svn_diff_fns_invoke_datasource_close(self, *args)


    def datasource_get_next_token(self, *args):
      return svn_diff_fns_invoke_datasource_get_next_token(self, *args)


    def token_compare(self, *args):
      return svn_diff_fns_invoke_token_compare(self, *args)


    def token_discard(self, *args):
      return svn_diff_fns_invoke_token_discard(self, *args)


    def token_discard_all(self, *args):
      return svn_diff_fns_invoke_token_discard_all(self, *args)


    def __init__(self):
        """__init__(svn_diff_fns_t self) -> svn_diff_fns_t"""
        this = _diff.new_svn_diff_fns_t()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _diff.delete_svn_diff_fns_t
    __del__ = lambda self: None
svn_diff_fns_t_swigregister = _diff.svn_diff_fns_t_swigregister
svn_diff_fns_t_swigregister(svn_diff_fns_t)


def svn_diff_diff_2(*args) -> "svn_diff_t **":
    """svn_diff_diff_2(void * diff_baton, svn_diff_fns2_t diff_fns, apr_pool_t pool) -> svn_error_t"""
    return _diff.svn_diff_diff_2(*args)

def svn_diff_diff(*args) -> "svn_diff_t **":
    """svn_diff_diff(void * diff_baton, svn_diff_fns_t diff_fns, apr_pool_t pool) -> svn_error_t"""
    return _diff.svn_diff_diff(*args)

def svn_diff_diff3_2(*args) -> "svn_diff_t **":
    """svn_diff_diff3_2(void * diff_baton, svn_diff_fns2_t diff_fns, apr_pool_t pool) -> svn_error_t"""
    return _diff.svn_diff_diff3_2(*args)

def svn_diff_diff3(*args) -> "svn_diff_t **":
    """svn_diff_diff3(void * diff_baton, svn_diff_fns_t diff_fns, apr_pool_t pool) -> svn_error_t"""
    return _diff.svn_diff_diff3(*args)

def svn_diff_diff4_2(*args) -> "svn_diff_t **":
    """svn_diff_diff4_2(void * diff_baton, svn_diff_fns2_t diff_fns, apr_pool_t pool) -> svn_error_t"""
    return _diff.svn_diff_diff4_2(*args)

def svn_diff_diff4(*args) -> "svn_diff_t **":
    """svn_diff_diff4(void * diff_baton, svn_diff_fns_t diff_fns, apr_pool_t pool) -> svn_error_t"""
    return _diff.svn_diff_diff4(*args)

def svn_diff_contains_conflicts(diff: 'svn_diff_t *') -> "svn_boolean_t":
    """svn_diff_contains_conflicts(svn_diff_t * diff) -> svn_boolean_t"""
    return _diff.svn_diff_contains_conflicts(diff)

def svn_diff_contains_diffs(diff: 'svn_diff_t *') -> "svn_boolean_t":
    """svn_diff_contains_diffs(svn_diff_t * diff) -> svn_boolean_t"""
    return _diff.svn_diff_contains_diffs(diff)
class svn_diff_output_fns_t(object):
    """Proxy of C svn_diff_output_fns_t struct."""

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    output_common = _swig_property(_diff.svn_diff_output_fns_t_output_common_get, _diff.svn_diff_output_fns_t_output_common_set)
    output_diff_modified = _swig_property(_diff.svn_diff_output_fns_t_output_diff_modified_get, _diff.svn_diff_output_fns_t_output_diff_modified_set)
    output_diff_latest = _swig_property(_diff.svn_diff_output_fns_t_output_diff_latest_get, _diff.svn_diff_output_fns_t_output_diff_latest_set)
    output_diff_common = _swig_property(_diff.svn_diff_output_fns_t_output_diff_common_get, _diff.svn_diff_output_fns_t_output_diff_common_set)
    output_conflict = _swig_property(_diff.svn_diff_output_fns_t_output_conflict_get, _diff.svn_diff_output_fns_t_output_conflict_set)
    def set_parent_pool(self, parent_pool=None):
      """Create a new proxy object for TYPE"""
      import libsvn.core, weakref
      self.__dict__["_parent_pool"] = \
        parent_pool or libsvn.core.application_pool;
      if self.__dict__["_parent_pool"]:
        self.__dict__["_is_valid"] = weakref.ref(
          self.__dict__["_parent_pool"]._is_valid)

    def assert_valid(self):
      """Assert that this object is using valid pool memory"""
      if "_is_valid" in self.__dict__:
        assert self.__dict__["_is_valid"](), "Variable has already been deleted"

    def _retrieve_swig_value(self, name, value):
    # If we got back a different object than we have cached, we need to copy
    # all our metadata into it, so that it looks identical to the one
    # originally set.
      members = self.__dict__.get('_members')
      if members is not None and name in members:
        _copy_metadata_deep(value, members[name])

    # Verify that the new object is good
      _assert_valid_deep(value)

      return value

    # Attribute access must be intercepted to ensure that objects coming from
    # read attribute access match those that are set with write attribute access.
    # Specifically the metadata, such as the associated apr_pool object, should
    # match the originally assigned object.
    #
    # For classic classes it is enough to use __getattr__ to intercept swig
    # derived attributes. However, with new style classes SWIG makes use of
    # descriptors which mean that __getattr__ is never called. Therefore,
    # __getattribute__ must be used for the interception.

    if _newclass:
      def __getattribute__(self, name):
        """Manage access to all attributes of this object."""

    # Start by mimicing __getattr__ behavior: immediately return __dict__ or
    # items directly present in __dict__
        mydict = object.__getattribute__(self, '__dict__')

        if name == "__dict__":
          return mydict

        if name in mydict:
          return mydict[name]

        object.__getattribute__(self, 'assert_valid')()

        value = _get_instance_attr(self, name)
        fn = object.__getattribute__(self, '_retrieve_swig_value')
        return fn(name, value)
    else:
      def __getattr__(self, name):
        """Get an attribute from this object"""
        self.assert_valid()

        value = _swig_getattr(self, self.__class__, name)

        return self._retrieve_swig_value(name, value)

    def __setattr__(self, name, value):
      """Set an attribute on this object"""
      self.assert_valid()

    # Save a copy of the object, so that the garbage
    # collector won't kill the object while it's in
    # SWIG-land
      self.__dict__.setdefault("_members",{})[name] = value

      return _set_instance_attr(self, name, value)


    def output_common(self, *args):
      return svn_diff_output_fns_invoke_output_common(self, *args)


    def output_diff_modified(self, *args):
      return svn_diff_output_fns_invoke_output_diff_modified(self, *args)


    def output_diff_latest(self, *args):
      return svn_diff_output_fns_invoke_output_diff_latest(self, *args)


    def output_diff_common(self, *args):
      return svn_diff_output_fns_invoke_output_diff_common(self, *args)


    def output_conflict(self, *args):
      return svn_diff_output_fns_invoke_output_conflict(self, *args)


    def __init__(self):
        """__init__(svn_diff_output_fns_t self) -> svn_diff_output_fns_t"""
        this = _diff.new_svn_diff_output_fns_t()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _diff.delete_svn_diff_output_fns_t
    __del__ = lambda self: None
svn_diff_output_fns_t_swigregister = _diff.svn_diff_output_fns_t_swigregister
svn_diff_output_fns_t_swigregister(svn_diff_output_fns_t)

svn_diff_conflict_display_modified_latest = _diff.svn_diff_conflict_display_modified_latest
svn_diff_conflict_display_resolved_modified_latest = _diff.svn_diff_conflict_display_resolved_modified_latest
svn_diff_conflict_display_modified_original_latest = _diff.svn_diff_conflict_display_modified_original_latest
svn_diff_conflict_display_modified = _diff.svn_diff_conflict_display_modified
svn_diff_conflict_display_latest = _diff.svn_diff_conflict_display_latest
svn_diff_conflict_display_only_conflicts = _diff.svn_diff_conflict_display_only_conflicts

def svn_diff_output2(diff: 'svn_diff_t *', output_baton: 'void *', output_fns: 'svn_diff_output_fns_t', cancel_func: 'svn_cancel_func_t') -> "svn_error_t *":
    """svn_diff_output2(svn_diff_t * diff, void * output_baton, svn_diff_output_fns_t output_fns, svn_cancel_func_t cancel_func) -> svn_error_t"""
    return _diff.svn_diff_output2(diff, output_baton, output_fns, cancel_func)

def svn_diff_output(diff: 'svn_diff_t *', output_baton: 'void *', output_fns: 'svn_diff_output_fns_t') -> "svn_error_t *":
    """svn_diff_output(svn_diff_t * diff, void * output_baton, svn_diff_output_fns_t output_fns) -> svn_error_t"""
    return _diff.svn_diff_output(diff, output_baton, output_fns)
svn_diff_file_ignore_space_none = _diff.svn_diff_file_ignore_space_none
svn_diff_file_ignore_space_change = _diff.svn_diff_file_ignore_space_change
svn_diff_file_ignore_space_all = _diff.svn_diff_file_ignore_space_all
class svn_diff_file_options_t(object):
    """Proxy of C svn_diff_file_options_t struct."""

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    ignore_space = _swig_property(_diff.svn_diff_file_options_t_ignore_space_get, _diff.svn_diff_file_options_t_ignore_space_set)
    ignore_eol_style = _swig_property(_diff.svn_diff_file_options_t_ignore_eol_style_get, _diff.svn_diff_file_options_t_ignore_eol_style_set)
    show_c_function = _swig_property(_diff.svn_diff_file_options_t_show_c_function_get, _diff.svn_diff_file_options_t_show_c_function_set)
    context_size = _swig_property(_diff.svn_diff_file_options_t_context_size_get, _diff.svn_diff_file_options_t_context_size_set)
    def set_parent_pool(self, parent_pool=None):
      """Create a new proxy object for TYPE"""
      import libsvn.core, weakref
      self.__dict__["_parent_pool"] = \
        parent_pool or libsvn.core.application_pool;
      if self.__dict__["_parent_pool"]:
        self.__dict__["_is_valid"] = weakref.ref(
          self.__dict__["_parent_pool"]._is_valid)

    def assert_valid(self):
      """Assert that this object is using valid pool memory"""
      if "_is_valid" in self.__dict__:
        assert self.__dict__["_is_valid"](), "Variable has already been deleted"

    def _retrieve_swig_value(self, name, value):
    # If we got back a different object than we have cached, we need to copy
    # all our metadata into it, so that it looks identical to the one
    # originally set.
      members = self.__dict__.get('_members')
      if members is not None and name in members:
        _copy_metadata_deep(value, members[name])

    # Verify that the new object is good
      _assert_valid_deep(value)

      return value

    # Attribute access must be intercepted to ensure that objects coming from
    # read attribute access match those that are set with write attribute access.
    # Specifically the metadata, such as the associated apr_pool object, should
    # match the originally assigned object.
    #
    # For classic classes it is enough to use __getattr__ to intercept swig
    # derived attributes. However, with new style classes SWIG makes use of
    # descriptors which mean that __getattr__ is never called. Therefore,
    # __getattribute__ must be used for the interception.

    if _newclass:
      def __getattribute__(self, name):
        """Manage access to all attributes of this object."""

    # Start by mimicing __getattr__ behavior: immediately return __dict__ or
    # items directly present in __dict__
        mydict = object.__getattribute__(self, '__dict__')

        if name == "__dict__":
          return mydict

        if name in mydict:
          return mydict[name]

        object.__getattribute__(self, 'assert_valid')()

        value = _get_instance_attr(self, name)
        fn = object.__getattribute__(self, '_retrieve_swig_value')
        return fn(name, value)
    else:
      def __getattr__(self, name):
        """Get an attribute from this object"""
        self.assert_valid()

        value = _swig_getattr(self, self.__class__, name)

        return self._retrieve_swig_value(name, value)

    def __setattr__(self, name, value):
      """Set an attribute on this object"""
      self.assert_valid()

    # Save a copy of the object, so that the garbage
    # collector won't kill the object while it's in
    # SWIG-land
      self.__dict__.setdefault("_members",{})[name] = value

      return _set_instance_attr(self, name, value)


    def __init__(self):
        """__init__(svn_diff_file_options_t self) -> svn_diff_file_options_t"""
        this = _diff.new_svn_diff_file_options_t()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _diff.delete_svn_diff_file_options_t
    __del__ = lambda self: None
svn_diff_file_options_t_swigregister = _diff.svn_diff_file_options_t_swigregister
svn_diff_file_options_t_swigregister(svn_diff_file_options_t)


def svn_diff_file_options_create(*args) -> "svn_diff_file_options_t *":
    """svn_diff_file_options_create(apr_pool_t pool) -> svn_diff_file_options_t"""
    return _diff.svn_diff_file_options_create(*args)

def svn_diff_file_options_parse(*args) -> "svn_error_t *":
    """svn_diff_file_options_parse(svn_diff_file_options_t options, apr_array_header_t args, apr_pool_t pool) -> svn_error_t"""
    return _diff.svn_diff_file_options_parse(*args)

def svn_diff_file_diff_2(*args) -> "svn_diff_t **":
    """svn_diff_file_diff_2(char const * original, char const * modified, svn_diff_file_options_t options, apr_pool_t pool) -> svn_error_t"""
    return _diff.svn_diff_file_diff_2(*args)

def svn_diff_file_diff(*args) -> "svn_diff_t **":
    """svn_diff_file_diff(char const * original, char const * modified, apr_pool_t pool) -> svn_error_t"""
    return _diff.svn_diff_file_diff(*args)

def svn_diff_file_diff3_2(*args) -> "svn_diff_t **":
    """svn_diff_file_diff3_2(char const * original, char const * modified, char const * latest, svn_diff_file_options_t options, apr_pool_t pool) -> svn_error_t"""
    return _diff.svn_diff_file_diff3_2(*args)

def svn_diff_file_diff3(*args) -> "svn_diff_t **":
    """svn_diff_file_diff3(char const * original, char const * modified, char const * latest, apr_pool_t pool) -> svn_error_t"""
    return _diff.svn_diff_file_diff3(*args)

def svn_diff_file_diff4_2(*args) -> "svn_diff_t **":
    """svn_diff_file_diff4_2(char const * original, char const * modified, char const * latest, char const * ancestor, svn_diff_file_options_t options, apr_pool_t pool) -> svn_error_t"""
    return _diff.svn_diff_file_diff4_2(*args)

def svn_diff_file_diff4(*args) -> "svn_diff_t **":
    """svn_diff_file_diff4(char const * original, char const * modified, char const * latest, char const * ancestor, apr_pool_t pool) -> svn_error_t"""
    return _diff.svn_diff_file_diff4(*args)

def svn_diff_file_output_unified4(*args) -> "svn_error_t *":
    """svn_diff_file_output_unified4(svn_stream_t * output_stream, svn_diff_t * diff, char const * original_path, char const * modified_path, char const * original_header, char const * modified_header, char const * header_encoding, char const * relative_to_dir, svn_boolean_t show_c_function, int context_size, svn_cancel_func_t cancel_func, apr_pool_t scratch_pool) -> svn_error_t"""
    return _diff.svn_diff_file_output_unified4(*args)

def svn_diff_file_output_unified3(*args) -> "svn_error_t *":
    """svn_diff_file_output_unified3(svn_stream_t * output_stream, svn_diff_t * diff, char const * original_path, char const * modified_path, char const * original_header, char const * modified_header, char const * header_encoding, char const * relative_to_dir, svn_boolean_t show_c_function, apr_pool_t pool) -> svn_error_t"""
    return _diff.svn_diff_file_output_unified3(*args)

def svn_diff_file_output_unified2(*args) -> "svn_error_t *":
    """svn_diff_file_output_unified2(svn_stream_t * output_stream, svn_diff_t * diff, char const * original_path, char const * modified_path, char const * original_header, char const * modified_header, char const * header_encoding, apr_pool_t pool) -> svn_error_t"""
    return _diff.svn_diff_file_output_unified2(*args)

def svn_diff_file_output_unified(*args) -> "svn_error_t *":
    """svn_diff_file_output_unified(svn_stream_t * output_stream, svn_diff_t * diff, char const * original_path, char const * modified_path, char const * original_header, char const * modified_header, apr_pool_t pool) -> svn_error_t"""
    return _diff.svn_diff_file_output_unified(*args)

def svn_diff_file_output_merge3(*args) -> "svn_error_t *":
    """svn_diff_file_output_merge3(svn_stream_t * output_stream, svn_diff_t * diff, char const * original_path, char const * modified_path, char const * latest_path, char const * conflict_original, char const * conflict_modified, char const * conflict_latest, char const * conflict_separator, svn_diff_conflict_display_style_t conflict_style, svn_cancel_func_t cancel_func, apr_pool_t scratch_pool) -> svn_error_t"""
    return _diff.svn_diff_file_output_merge3(*args)

def svn_diff_file_output_merge2(*args) -> "svn_error_t *":
    """svn_diff_file_output_merge2(svn_stream_t * output_stream, svn_diff_t * diff, char const * original_path, char const * modified_path, char const * latest_path, char const * conflict_original, char const * conflict_modified, char const * conflict_latest, char const * conflict_separator, svn_diff_conflict_display_style_t conflict_style, apr_pool_t pool) -> svn_error_t"""
    return _diff.svn_diff_file_output_merge2(*args)

def svn_diff_file_output_merge(*args) -> "svn_error_t *":
    """svn_diff_file_output_merge(svn_stream_t * output_stream, svn_diff_t * diff, char const * original_path, char const * modified_path, char const * latest_path, char const * conflict_original, char const * conflict_modified, char const * conflict_latest, char const * conflict_separator, svn_boolean_t display_original_in_conflict, svn_boolean_t display_resolved_conflicts, apr_pool_t pool) -> svn_error_t"""
    return _diff.svn_diff_file_output_merge(*args)

def svn_diff_output_binary(*args) -> "svn_error_t *":
    """svn_diff_output_binary(svn_stream_t * output_stream, svn_stream_t * original, svn_stream_t * latest, svn_cancel_func_t cancel_func, apr_pool_t scratch_pool) -> svn_error_t"""
    return _diff.svn_diff_output_binary(*args)

def svn_diff_mem_string_diff(*args) -> "svn_diff_t **":
    """svn_diff_mem_string_diff(svn_string_t const * original, svn_string_t const * modified, svn_diff_file_options_t options, apr_pool_t pool) -> svn_error_t"""
    return _diff.svn_diff_mem_string_diff(*args)

def svn_diff_mem_string_diff3(*args) -> "svn_diff_t **":
    """svn_diff_mem_string_diff3(svn_string_t const * original, svn_string_t const * modified, svn_string_t const * latest, svn_diff_file_options_t options, apr_pool_t pool) -> svn_error_t"""
    return _diff.svn_diff_mem_string_diff3(*args)

def svn_diff_mem_string_diff4(*args) -> "svn_diff_t **":
    """svn_diff_mem_string_diff4(svn_string_t const * original, svn_string_t const * modified, svn_string_t const * latest, svn_string_t const * ancestor, svn_diff_file_options_t options, apr_pool_t pool) -> svn_error_t"""
    return _diff.svn_diff_mem_string_diff4(*args)

def svn_diff_mem_string_output_unified3(*args) -> "svn_error_t *":
    """svn_diff_mem_string_output_unified3(svn_stream_t * output_stream, svn_diff_t * diff, svn_boolean_t with_diff_header, char const * hunk_delimiter, char const * original_header, char const * modified_header, char const * header_encoding, svn_string_t const * original, svn_string_t const * modified, int context_size, svn_cancel_func_t cancel_func, apr_pool_t scratch_pool) -> svn_error_t"""
    return _diff.svn_diff_mem_string_output_unified3(*args)

def svn_diff_mem_string_output_unified2(*args) -> "svn_error_t *":
    """svn_diff_mem_string_output_unified2(svn_stream_t * output_stream, svn_diff_t * diff, svn_boolean_t with_diff_header, char const * hunk_delimiter, char const * original_header, char const * modified_header, char const * header_encoding, svn_string_t const * original, svn_string_t const * modified, apr_pool_t pool) -> svn_error_t"""
    return _diff.svn_diff_mem_string_output_unified2(*args)

def svn_diff_mem_string_output_unified(*args) -> "svn_error_t *":
    """svn_diff_mem_string_output_unified(svn_stream_t * output_stream, svn_diff_t * diff, char const * original_header, char const * modified_header, char const * header_encoding, svn_string_t const * original, svn_string_t const * modified, apr_pool_t pool) -> svn_error_t"""
    return _diff.svn_diff_mem_string_output_unified(*args)

def svn_diff_mem_string_output_merge3(*args) -> "svn_error_t *":
    """svn_diff_mem_string_output_merge3(svn_stream_t * output_stream, svn_diff_t * diff, svn_string_t const * original, svn_string_t const * modified, svn_string_t const * latest, char const * conflict_original, char const * conflict_modified, char const * conflict_latest, char const * conflict_separator, svn_diff_conflict_display_style_t style, svn_cancel_func_t cancel_func, apr_pool_t scratch_pool) -> svn_error_t"""
    return _diff.svn_diff_mem_string_output_merge3(*args)

def svn_diff_mem_string_output_merge2(*args) -> "svn_error_t *":
    """svn_diff_mem_string_output_merge2(svn_stream_t * output_stream, svn_diff_t * diff, svn_string_t const * original, svn_string_t const * modified, svn_string_t const * latest, char const * conflict_original, char const * conflict_modified, char const * conflict_latest, char const * conflict_separator, svn_diff_conflict_display_style_t style, apr_pool_t pool) -> svn_error_t"""
    return _diff.svn_diff_mem_string_output_merge2(*args)

def svn_diff_mem_string_output_merge(*args) -> "svn_error_t *":
    """svn_diff_mem_string_output_merge(svn_stream_t * output_stream, svn_diff_t * diff, svn_string_t const * original, svn_string_t const * modified, svn_string_t const * latest, char const * conflict_original, char const * conflict_modified, char const * conflict_latest, char const * conflict_separator, svn_boolean_t display_original_in_conflict, svn_boolean_t display_resolved_conflicts, apr_pool_t pool) -> svn_error_t"""
    return _diff.svn_diff_mem_string_output_merge(*args)
svn_diff_op_unchanged = _diff.svn_diff_op_unchanged
svn_diff_op_added = _diff.svn_diff_op_added
svn_diff_op_deleted = _diff.svn_diff_op_deleted
svn_diff_op_copied = _diff.svn_diff_op_copied
svn_diff_op_moved = _diff.svn_diff_op_moved
svn_diff_op_modified = _diff.svn_diff_op_modified

def svn_diff_hunk_readline_diff_text(*args) -> "svn_stringbuf_t **, char const **, svn_boolean_t *":
    """svn_diff_hunk_readline_diff_text(svn_diff_hunk_t * hunk, apr_pool_t result_pool, apr_pool_t scratch_pool) -> svn_error_t"""
    return _diff.svn_diff_hunk_readline_diff_text(*args)

def svn_diff_hunk_readline_original_text(*args) -> "svn_stringbuf_t **, char const **, svn_boolean_t *":
    """svn_diff_hunk_readline_original_text(svn_diff_hunk_t * hunk, apr_pool_t result_pool, apr_pool_t scratch_pool) -> svn_error_t"""
    return _diff.svn_diff_hunk_readline_original_text(*args)

def svn_diff_hunk_readline_modified_text(*args) -> "svn_stringbuf_t **, char const **, svn_boolean_t *":
    """svn_diff_hunk_readline_modified_text(svn_diff_hunk_t * hunk, apr_pool_t result_pool, apr_pool_t scratch_pool) -> svn_error_t"""
    return _diff.svn_diff_hunk_readline_modified_text(*args)

def svn_diff_hunk_reset_diff_text(hunk: 'svn_diff_hunk_t *') -> "void":
    """svn_diff_hunk_reset_diff_text(svn_diff_hunk_t * hunk)"""
    return _diff.svn_diff_hunk_reset_diff_text(hunk)

def svn_diff_hunk_reset_original_text(hunk: 'svn_diff_hunk_t *') -> "void":
    """svn_diff_hunk_reset_original_text(svn_diff_hunk_t * hunk)"""
    return _diff.svn_diff_hunk_reset_original_text(hunk)

def svn_diff_hunk_reset_modified_text(hunk: 'svn_diff_hunk_t *') -> "void":
    """svn_diff_hunk_reset_modified_text(svn_diff_hunk_t * hunk)"""
    return _diff.svn_diff_hunk_reset_modified_text(hunk)

def svn_diff_hunk_get_original_start(hunk: 'svn_diff_hunk_t const *') -> "svn_linenum_t":
    """svn_diff_hunk_get_original_start(svn_diff_hunk_t const * hunk) -> svn_linenum_t"""
    return _diff.svn_diff_hunk_get_original_start(hunk)

def svn_diff_hunk_get_original_length(hunk: 'svn_diff_hunk_t const *') -> "svn_linenum_t":
    """svn_diff_hunk_get_original_length(svn_diff_hunk_t const * hunk) -> svn_linenum_t"""
    return _diff.svn_diff_hunk_get_original_length(hunk)

def svn_diff_hunk_get_modified_start(hunk: 'svn_diff_hunk_t const *') -> "svn_linenum_t":
    """svn_diff_hunk_get_modified_start(svn_diff_hunk_t const * hunk) -> svn_linenum_t"""
    return _diff.svn_diff_hunk_get_modified_start(hunk)

def svn_diff_hunk_get_modified_length(hunk: 'svn_diff_hunk_t const *') -> "svn_linenum_t":
    """svn_diff_hunk_get_modified_length(svn_diff_hunk_t const * hunk) -> svn_linenum_t"""
    return _diff.svn_diff_hunk_get_modified_length(hunk)

def svn_diff_hunk_get_leading_context(hunk: 'svn_diff_hunk_t const *') -> "svn_linenum_t":
    """svn_diff_hunk_get_leading_context(svn_diff_hunk_t const * hunk) -> svn_linenum_t"""
    return _diff.svn_diff_hunk_get_leading_context(hunk)

def svn_diff_hunk_get_trailing_context(hunk: 'svn_diff_hunk_t const *') -> "svn_linenum_t":
    """svn_diff_hunk_get_trailing_context(svn_diff_hunk_t const * hunk) -> svn_linenum_t"""
    return _diff.svn_diff_hunk_get_trailing_context(hunk)
class svn_prop_patch_t(object):
    """Proxy of C svn_prop_patch_t struct."""

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    name = _swig_property(_diff.svn_prop_patch_t_name_get, _diff.svn_prop_patch_t_name_set)
    operation = _swig_property(_diff.svn_prop_patch_t_operation_get, _diff.svn_prop_patch_t_operation_set)
    hunks = _swig_property(_diff.svn_prop_patch_t_hunks_get, _diff.svn_prop_patch_t_hunks_set)
    def set_parent_pool(self, parent_pool=None):
      """Create a new proxy object for TYPE"""
      import libsvn.core, weakref
      self.__dict__["_parent_pool"] = \
        parent_pool or libsvn.core.application_pool;
      if self.__dict__["_parent_pool"]:
        self.__dict__["_is_valid"] = weakref.ref(
          self.__dict__["_parent_pool"]._is_valid)

    def assert_valid(self):
      """Assert that this object is using valid pool memory"""
      if "_is_valid" in self.__dict__:
        assert self.__dict__["_is_valid"](), "Variable has already been deleted"

    def _retrieve_swig_value(self, name, value):
    # If we got back a different object than we have cached, we need to copy
    # all our metadata into it, so that it looks identical to the one
    # originally set.
      members = self.__dict__.get('_members')
      if members is not None and name in members:
        _copy_metadata_deep(value, members[name])

    # Verify that the new object is good
      _assert_valid_deep(value)

      return value

    # Attribute access must be intercepted to ensure that objects coming from
    # read attribute access match those that are set with write attribute access.
    # Specifically the metadata, such as the associated apr_pool object, should
    # match the originally assigned object.
    #
    # For classic classes it is enough to use __getattr__ to intercept swig
    # derived attributes. However, with new style classes SWIG makes use of
    # descriptors which mean that __getattr__ is never called. Therefore,
    # __getattribute__ must be used for the interception.

    if _newclass:
      def __getattribute__(self, name):
        """Manage access to all attributes of this object."""

    # Start by mimicing __getattr__ behavior: immediately return __dict__ or
    # items directly present in __dict__
        mydict = object.__getattribute__(self, '__dict__')

        if name == "__dict__":
          return mydict

        if name in mydict:
          return mydict[name]

        object.__getattribute__(self, 'assert_valid')()

        value = _get_instance_attr(self, name)
        fn = object.__getattribute__(self, '_retrieve_swig_value')
        return fn(name, value)
    else:
      def __getattr__(self, name):
        """Get an attribute from this object"""
        self.assert_valid()

        value = _swig_getattr(self, self.__class__, name)

        return self._retrieve_swig_value(name, value)

    def __setattr__(self, name, value):
      """Set an attribute on this object"""
      self.assert_valid()

    # Save a copy of the object, so that the garbage
    # collector won't kill the object while it's in
    # SWIG-land
      self.__dict__.setdefault("_members",{})[name] = value

      return _set_instance_attr(self, name, value)


    def __init__(self):
        """__init__(svn_prop_patch_t self) -> svn_prop_patch_t"""
        this = _diff.new_svn_prop_patch_t()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _diff.delete_svn_prop_patch_t
    __del__ = lambda self: None
svn_prop_patch_t_swigregister = _diff.svn_prop_patch_t_swigregister
svn_prop_patch_t_swigregister(svn_prop_patch_t)


def svn_diff_get_binary_diff_original_stream(*args) -> "svn_stream_t *":
    """svn_diff_get_binary_diff_original_stream(svn_diff_binary_patch_t const * bpatch, apr_pool_t result_pool) -> svn_stream_t *"""
    return _diff.svn_diff_get_binary_diff_original_stream(*args)

def svn_diff_get_binary_diff_result_stream(*args) -> "svn_stream_t *":
    """svn_diff_get_binary_diff_result_stream(svn_diff_binary_patch_t const * bpatch, apr_pool_t result_pool) -> svn_stream_t *"""
    return _diff.svn_diff_get_binary_diff_result_stream(*args)
class svn_patch_t(object):
    """Proxy of C svn_patch_t struct."""

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    old_filename = _swig_property(_diff.svn_patch_t_old_filename_get, _diff.svn_patch_t_old_filename_set)
    new_filename = _swig_property(_diff.svn_patch_t_new_filename_get, _diff.svn_patch_t_new_filename_set)
    hunks = _swig_property(_diff.svn_patch_t_hunks_get, _diff.svn_patch_t_hunks_set)
    prop_patches = _swig_property(_diff.svn_patch_t_prop_patches_get, _diff.svn_patch_t_prop_patches_set)
    operation = _swig_property(_diff.svn_patch_t_operation_get, _diff.svn_patch_t_operation_set)
    reverse = _swig_property(_diff.svn_patch_t_reverse_get, _diff.svn_patch_t_reverse_set)
    mergeinfo = _swig_property(_diff.svn_patch_t_mergeinfo_get, _diff.svn_patch_t_mergeinfo_set)
    reverse_mergeinfo = _swig_property(_diff.svn_patch_t_reverse_mergeinfo_get, _diff.svn_patch_t_reverse_mergeinfo_set)
    binary_patch = _swig_property(_diff.svn_patch_t_binary_patch_get, _diff.svn_patch_t_binary_patch_set)
    old_executable_bit = _swig_property(_diff.svn_patch_t_old_executable_bit_get, _diff.svn_patch_t_old_executable_bit_set)
    new_executable_bit = _swig_property(_diff.svn_patch_t_new_executable_bit_get, _diff.svn_patch_t_new_executable_bit_set)
    old_symlink_bit = _swig_property(_diff.svn_patch_t_old_symlink_bit_get, _diff.svn_patch_t_old_symlink_bit_set)
    new_symlink_bit = _swig_property(_diff.svn_patch_t_new_symlink_bit_get, _diff.svn_patch_t_new_symlink_bit_set)
    def set_parent_pool(self, parent_pool=None):
      """Create a new proxy object for TYPE"""
      import libsvn.core, weakref
      self.__dict__["_parent_pool"] = \
        parent_pool or libsvn.core.application_pool;
      if self.__dict__["_parent_pool"]:
        self.__dict__["_is_valid"] = weakref.ref(
          self.__dict__["_parent_pool"]._is_valid)

    def assert_valid(self):
      """Assert that this object is using valid pool memory"""
      if "_is_valid" in self.__dict__:
        assert self.__dict__["_is_valid"](), "Variable has already been deleted"

    def _retrieve_swig_value(self, name, value):
    # If we got back a different object than we have cached, we need to copy
    # all our metadata into it, so that it looks identical to the one
    # originally set.
      members = self.__dict__.get('_members')
      if members is not None and name in members:
        _copy_metadata_deep(value, members[name])

    # Verify that the new object is good
      _assert_valid_deep(value)

      return value

    # Attribute access must be intercepted to ensure that objects coming from
    # read attribute access match those that are set with write attribute access.
    # Specifically the metadata, such as the associated apr_pool object, should
    # match the originally assigned object.
    #
    # For classic classes it is enough to use __getattr__ to intercept swig
    # derived attributes. However, with new style classes SWIG makes use of
    # descriptors which mean that __getattr__ is never called. Therefore,
    # __getattribute__ must be used for the interception.

    if _newclass:
      def __getattribute__(self, name):
        """Manage access to all attributes of this object."""

    # Start by mimicing __getattr__ behavior: immediately return __dict__ or
    # items directly present in __dict__
        mydict = object.__getattribute__(self, '__dict__')

        if name == "__dict__":
          return mydict

        if name in mydict:
          return mydict[name]

        object.__getattribute__(self, 'assert_valid')()

        value = _get_instance_attr(self, name)
        fn = object.__getattribute__(self, '_retrieve_swig_value')
        return fn(name, value)
    else:
      def __getattr__(self, name):
        """Get an attribute from this object"""
        self.assert_valid()

        value = _swig_getattr(self, self.__class__, name)

        return self._retrieve_swig_value(name, value)

    def __setattr__(self, name, value):
      """Set an attribute on this object"""
      self.assert_valid()

    # Save a copy of the object, so that the garbage
    # collector won't kill the object while it's in
    # SWIG-land
      self.__dict__.setdefault("_members",{})[name] = value

      return _set_instance_attr(self, name, value)


    def __init__(self):
        """__init__(svn_patch_t self) -> svn_patch_t"""
        this = _diff.new_svn_patch_t()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _diff.delete_svn_patch_t
    __del__ = lambda self: None
svn_patch_t_swigregister = _diff.svn_patch_t_swigregister
svn_patch_t_swigregister(svn_patch_t)


def svn_diff_open_patch_file(*args) -> "svn_patch_file_t **":
    """svn_diff_open_patch_file(char const * local_abspath, apr_pool_t result_pool) -> svn_error_t"""
    return _diff.svn_diff_open_patch_file(*args)

def svn_diff_parse_next_patch(*args) -> "svn_patch_t **":
    """svn_diff_parse_next_patch(svn_patch_file_t * patch_file, svn_boolean_t reverse, svn_boolean_t ignore_whitespace, apr_pool_t result_pool, apr_pool_t scratch_pool) -> svn_error_t"""
    return _diff.svn_diff_parse_next_patch(*args)

def svn_diff_close_patch_file(*args) -> "svn_error_t *":
    """svn_diff_close_patch_file(svn_patch_file_t * patch_file, apr_pool_t scratch_pool) -> svn_error_t"""
    return _diff.svn_diff_close_patch_file(*args)
class svn_diff_t(object):
    """Proxy of C svn_diff_t struct."""

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    def set_parent_pool(self, parent_pool=None):
      """Create a new proxy object for TYPE"""
      import libsvn.core, weakref
      self.__dict__["_parent_pool"] = \
        parent_pool or libsvn.core.application_pool;
      if self.__dict__["_parent_pool"]:
        self.__dict__["_is_valid"] = weakref.ref(
          self.__dict__["_parent_pool"]._is_valid)

    def assert_valid(self):
      """Assert that this object is using valid pool memory"""
      if "_is_valid" in self.__dict__:
        assert self.__dict__["_is_valid"](), "Variable has already been deleted"

    def _retrieve_swig_value(self, name, value):
    # If we got back a different object than we have cached, we need to copy
    # all our metadata into it, so that it looks identical to the one
    # originally set.
      members = self.__dict__.get('_members')
      if members is not None and name in members:
        _copy_metadata_deep(value, members[name])

    # Verify that the new object is good
      _assert_valid_deep(value)

      return value

    # Attribute access must be intercepted to ensure that objects coming from
    # read attribute access match those that are set with write attribute access.
    # Specifically the metadata, such as the associated apr_pool object, should
    # match the originally assigned object.
    #
    # For classic classes it is enough to use __getattr__ to intercept swig
    # derived attributes. However, with new style classes SWIG makes use of
    # descriptors which mean that __getattr__ is never called. Therefore,
    # __getattribute__ must be used for the interception.

    if _newclass:
      def __getattribute__(self, name):
        """Manage access to all attributes of this object."""

    # Start by mimicing __getattr__ behavior: immediately return __dict__ or
    # items directly present in __dict__
        mydict = object.__getattribute__(self, '__dict__')

        if name == "__dict__":
          return mydict

        if name in mydict:
          return mydict[name]

        object.__getattribute__(self, 'assert_valid')()

        value = _get_instance_attr(self, name)
        fn = object.__getattribute__(self, '_retrieve_swig_value')
        return fn(name, value)
    else:
      def __getattr__(self, name):
        """Get an attribute from this object"""
        self.assert_valid()

        value = _swig_getattr(self, self.__class__, name)

        return self._retrieve_swig_value(name, value)

    def __setattr__(self, name, value):
      """Set an attribute on this object"""
      self.assert_valid()

    # Save a copy of the object, so that the garbage
    # collector won't kill the object while it's in
    # SWIG-land
      self.__dict__.setdefault("_members",{})[name] = value

      return _set_instance_attr(self, name, value)

svn_diff_t_swigregister = _diff.svn_diff_t_swigregister
svn_diff_t_swigregister(svn_diff_t)

class svn_diff_hunk_t(object):
    """Proxy of C svn_diff_hunk_t struct."""

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    def set_parent_pool(self, parent_pool=None):
      """Create a new proxy object for TYPE"""
      import libsvn.core, weakref
      self.__dict__["_parent_pool"] = \
        parent_pool or libsvn.core.application_pool;
      if self.__dict__["_parent_pool"]:
        self.__dict__["_is_valid"] = weakref.ref(
          self.__dict__["_parent_pool"]._is_valid)

    def assert_valid(self):
      """Assert that this object is using valid pool memory"""
      if "_is_valid" in self.__dict__:
        assert self.__dict__["_is_valid"](), "Variable has already been deleted"

    def _retrieve_swig_value(self, name, value):
    # If we got back a different object than we have cached, we need to copy
    # all our metadata into it, so that it looks identical to the one
    # originally set.
      members = self.__dict__.get('_members')
      if members is not None and name in members:
        _copy_metadata_deep(value, members[name])

    # Verify that the new object is good
      _assert_valid_deep(value)

      return value

    # Attribute access must be intercepted to ensure that objects coming from
    # read attribute access match those that are set with write attribute access.
    # Specifically the metadata, such as the associated apr_pool object, should
    # match the originally assigned object.
    #
    # For classic classes it is enough to use __getattr__ to intercept swig
    # derived attributes. However, with new style classes SWIG makes use of
    # descriptors which mean that __getattr__ is never called. Therefore,
    # __getattribute__ must be used for the interception.

    if _newclass:
      def __getattribute__(self, name):
        """Manage access to all attributes of this object."""

    # Start by mimicing __getattr__ behavior: immediately return __dict__ or
    # items directly present in __dict__
        mydict = object.__getattribute__(self, '__dict__')

        if name == "__dict__":
          return mydict

        if name in mydict:
          return mydict[name]

        object.__getattribute__(self, 'assert_valid')()

        value = _get_instance_attr(self, name)
        fn = object.__getattribute__(self, '_retrieve_swig_value')
        return fn(name, value)
    else:
      def __getattr__(self, name):
        """Get an attribute from this object"""
        self.assert_valid()

        value = _swig_getattr(self, self.__class__, name)

        return self._retrieve_swig_value(name, value)

    def __setattr__(self, name, value):
      """Set an attribute on this object"""
      self.assert_valid()

    # Save a copy of the object, so that the garbage
    # collector won't kill the object while it's in
    # SWIG-land
      self.__dict__.setdefault("_members",{})[name] = value

      return _set_instance_attr(self, name, value)

svn_diff_hunk_t_swigregister = _diff.svn_diff_hunk_t_swigregister
svn_diff_hunk_t_swigregister(svn_diff_hunk_t)

class svn_diff_binary_patch_t(object):
    """Proxy of C svn_diff_binary_patch_t struct."""

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    def set_parent_pool(self, parent_pool=None):
      """Create a new proxy object for TYPE"""
      import libsvn.core, weakref
      self.__dict__["_parent_pool"] = \
        parent_pool or libsvn.core.application_pool;
      if self.__dict__["_parent_pool"]:
        self.__dict__["_is_valid"] = weakref.ref(
          self.__dict__["_parent_pool"]._is_valid)

    def assert_valid(self):
      """Assert that this object is using valid pool memory"""
      if "_is_valid" in self.__dict__:
        assert self.__dict__["_is_valid"](), "Variable has already been deleted"

    def _retrieve_swig_value(self, name, value):
    # If we got back a different object than we have cached, we need to copy
    # all our metadata into it, so that it looks identical to the one
    # originally set.
      members = self.__dict__.get('_members')
      if members is not None and name in members:
        _copy_metadata_deep(value, members[name])

    # Verify that the new object is good
      _assert_valid_deep(value)

      return value

    # Attribute access must be intercepted to ensure that objects coming from
    # read attribute access match those that are set with write attribute access.
    # Specifically the metadata, such as the associated apr_pool object, should
    # match the originally assigned object.
    #
    # For classic classes it is enough to use __getattr__ to intercept swig
    # derived attributes. However, with new style classes SWIG makes use of
    # descriptors which mean that __getattr__ is never called. Therefore,
    # __getattribute__ must be used for the interception.

    if _newclass:
      def __getattribute__(self, name):
        """Manage access to all attributes of this object."""

    # Start by mimicing __getattr__ behavior: immediately return __dict__ or
    # items directly present in __dict__
        mydict = object.__getattribute__(self, '__dict__')

        if name == "__dict__":
          return mydict

        if name in mydict:
          return mydict[name]

        object.__getattribute__(self, 'assert_valid')()

        value = _get_instance_attr(self, name)
        fn = object.__getattribute__(self, '_retrieve_swig_value')
        return fn(name, value)
    else:
      def __getattr__(self, name):
        """Get an attribute from this object"""
        self.assert_valid()

        value = _swig_getattr(self, self.__class__, name)

        return self._retrieve_swig_value(name, value)

    def __setattr__(self, name, value):
      """Set an attribute on this object"""
      self.assert_valid()

    # Save a copy of the object, so that the garbage
    # collector won't kill the object while it's in
    # SWIG-land
      self.__dict__.setdefault("_members",{})[name] = value

      return _set_instance_attr(self, name, value)

svn_diff_binary_patch_t_swigregister = _diff.svn_diff_binary_patch_t_swigregister
svn_diff_binary_patch_t_swigregister(svn_diff_binary_patch_t)

class svn_patch_file_t(object):
    """Proxy of C svn_patch_file_t struct."""

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    def set_parent_pool(self, parent_pool=None):
      """Create a new proxy object for TYPE"""
      import libsvn.core, weakref
      self.__dict__["_parent_pool"] = \
        parent_pool or libsvn.core.application_pool;
      if self.__dict__["_parent_pool"]:
        self.__dict__["_is_valid"] = weakref.ref(
          self.__dict__["_parent_pool"]._is_valid)

    def assert_valid(self):
      """Assert that this object is using valid pool memory"""
      if "_is_valid" in self.__dict__:
        assert self.__dict__["_is_valid"](), "Variable has already been deleted"

    def _retrieve_swig_value(self, name, value):
    # If we got back a different object than we have cached, we need to copy
    # all our metadata into it, so that it looks identical to the one
    # originally set.
      members = self.__dict__.get('_members')
      if members is not None and name in members:
        _copy_metadata_deep(value, members[name])

    # Verify that the new object is good
      _assert_valid_deep(value)

      return value

    # Attribute access must be intercepted to ensure that objects coming from
    # read attribute access match those that are set with write attribute access.
    # Specifically the metadata, such as the associated apr_pool object, should
    # match the originally assigned object.
    #
    # For classic classes it is enough to use __getattr__ to intercept swig
    # derived attributes. However, with new style classes SWIG makes use of
    # descriptors which mean that __getattr__ is never called. Therefore,
    # __getattribute__ must be used for the interception.

    if _newclass:
      def __getattribute__(self, name):
        """Manage access to all attributes of this object."""

    # Start by mimicing __getattr__ behavior: immediately return __dict__ or
    # items directly present in __dict__
        mydict = object.__getattribute__(self, '__dict__')

        if name == "__dict__":
          return mydict

        if name in mydict:
          return mydict[name]

        object.__getattribute__(self, 'assert_valid')()

        value = _get_instance_attr(self, name)
        fn = object.__getattribute__(self, '_retrieve_swig_value')
        return fn(name, value)
    else:
      def __getattr__(self, name):
        """Get an attribute from this object"""
        self.assert_valid()

        value = _swig_getattr(self, self.__class__, name)

        return self._retrieve_swig_value(name, value)

    def __setattr__(self, name, value):
      """Set an attribute on this object"""
      self.assert_valid()

    # Save a copy of the object, so that the garbage
    # collector won't kill the object while it's in
    # SWIG-land
      self.__dict__.setdefault("_members",{})[name] = value

      return _set_instance_attr(self, name, value)

svn_patch_file_t_swigregister = _diff.svn_patch_file_t_swigregister
svn_patch_file_t_swigregister(svn_patch_file_t)


def svn_diff_fns2_invoke_datasources_open(_obj: 'svn_diff_fns2_t', diff_baton: 'void *', prefix_lines: 'apr_off_t *', suffix_lines: 'apr_off_t *', datasources: 'svn_diff_datasource_e const *', datasources_len: 'apr_size_t') -> "svn_error_t *":
    """svn_diff_fns2_invoke_datasources_open(svn_diff_fns2_t _obj, void * diff_baton, apr_off_t * prefix_lines, apr_off_t * suffix_lines, svn_diff_datasource_e const * datasources, apr_size_t datasources_len) -> svn_error_t"""
    return _diff.svn_diff_fns2_invoke_datasources_open(_obj, diff_baton, prefix_lines, suffix_lines, datasources, datasources_len)

def svn_diff_fns2_invoke_datasource_close(_obj: 'svn_diff_fns2_t', diff_baton: 'void *', datasource: 'svn_diff_datasource_e') -> "svn_error_t *":
    """svn_diff_fns2_invoke_datasource_close(svn_diff_fns2_t _obj, void * diff_baton, svn_diff_datasource_e datasource) -> svn_error_t"""
    return _diff.svn_diff_fns2_invoke_datasource_close(_obj, diff_baton, datasource)

def svn_diff_fns2_invoke_datasource_get_next_token(_obj: 'svn_diff_fns2_t', diff_baton: 'void *', datasource: 'svn_diff_datasource_e') -> "apr_uint32_t *, void **":
    """svn_diff_fns2_invoke_datasource_get_next_token(svn_diff_fns2_t _obj, void * diff_baton, svn_diff_datasource_e datasource) -> svn_error_t"""
    return _diff.svn_diff_fns2_invoke_datasource_get_next_token(_obj, diff_baton, datasource)

def svn_diff_fns2_invoke_token_compare(_obj: 'svn_diff_fns2_t', diff_baton: 'void *', ltoken: 'void *', rtoken: 'void *') -> "int *":
    """svn_diff_fns2_invoke_token_compare(svn_diff_fns2_t _obj, void * diff_baton, void * ltoken, void * rtoken) -> svn_error_t"""
    return _diff.svn_diff_fns2_invoke_token_compare(_obj, diff_baton, ltoken, rtoken)

def svn_diff_fns2_invoke_token_discard(_obj: 'svn_diff_fns2_t', diff_baton: 'void *', token: 'void *') -> "void":
    """svn_diff_fns2_invoke_token_discard(svn_diff_fns2_t _obj, void * diff_baton, void * token)"""
    return _diff.svn_diff_fns2_invoke_token_discard(_obj, diff_baton, token)

def svn_diff_fns2_invoke_token_discard_all(_obj: 'svn_diff_fns2_t', diff_baton: 'void *') -> "void":
    """svn_diff_fns2_invoke_token_discard_all(svn_diff_fns2_t _obj, void * diff_baton)"""
    return _diff.svn_diff_fns2_invoke_token_discard_all(_obj, diff_baton)

def svn_diff_fns_invoke_datasource_open(_obj: 'svn_diff_fns_t', diff_baton: 'void *', datasource: 'svn_diff_datasource_e') -> "svn_error_t *":
    """svn_diff_fns_invoke_datasource_open(svn_diff_fns_t _obj, void * diff_baton, svn_diff_datasource_e datasource) -> svn_error_t"""
    return _diff.svn_diff_fns_invoke_datasource_open(_obj, diff_baton, datasource)

def svn_diff_fns_invoke_datasource_close(_obj: 'svn_diff_fns_t', diff_baton: 'void *', datasource: 'svn_diff_datasource_e') -> "svn_error_t *":
    """svn_diff_fns_invoke_datasource_close(svn_diff_fns_t _obj, void * diff_baton, svn_diff_datasource_e datasource) -> svn_error_t"""
    return _diff.svn_diff_fns_invoke_datasource_close(_obj, diff_baton, datasource)

def svn_diff_fns_invoke_datasource_get_next_token(_obj: 'svn_diff_fns_t', diff_baton: 'void *', datasource: 'svn_diff_datasource_e') -> "apr_uint32_t *, void **":
    """svn_diff_fns_invoke_datasource_get_next_token(svn_diff_fns_t _obj, void * diff_baton, svn_diff_datasource_e datasource) -> svn_error_t"""
    return _diff.svn_diff_fns_invoke_datasource_get_next_token(_obj, diff_baton, datasource)

def svn_diff_fns_invoke_token_compare(_obj: 'svn_diff_fns_t', diff_baton: 'void *', ltoken: 'void *', rtoken: 'void *') -> "int *":
    """svn_diff_fns_invoke_token_compare(svn_diff_fns_t _obj, void * diff_baton, void * ltoken, void * rtoken) -> svn_error_t"""
    return _diff.svn_diff_fns_invoke_token_compare(_obj, diff_baton, ltoken, rtoken)

def svn_diff_fns_invoke_token_discard(_obj: 'svn_diff_fns_t', diff_baton: 'void *', token: 'void *') -> "void":
    """svn_diff_fns_invoke_token_discard(svn_diff_fns_t _obj, void * diff_baton, void * token)"""
    return _diff.svn_diff_fns_invoke_token_discard(_obj, diff_baton, token)

def svn_diff_fns_invoke_token_discard_all(_obj: 'svn_diff_fns_t', diff_baton: 'void *') -> "void":
    """svn_diff_fns_invoke_token_discard_all(svn_diff_fns_t _obj, void * diff_baton)"""
    return _diff.svn_diff_fns_invoke_token_discard_all(_obj, diff_baton)

def svn_diff_output_fns_invoke_output_common(_obj: 'svn_diff_output_fns_t', output_baton: 'void *', original_start: 'apr_off_t', original_length: 'apr_off_t', modified_start: 'apr_off_t', modified_length: 'apr_off_t', latest_start: 'apr_off_t', latest_length: 'apr_off_t') -> "svn_error_t *":
    """svn_diff_output_fns_invoke_output_common(svn_diff_output_fns_t _obj, void * output_baton, apr_off_t original_start, apr_off_t original_length, apr_off_t modified_start, apr_off_t modified_length, apr_off_t latest_start, apr_off_t latest_length) -> svn_error_t"""
    return _diff.svn_diff_output_fns_invoke_output_common(_obj, output_baton, original_start, original_length, modified_start, modified_length, latest_start, latest_length)

def svn_diff_output_fns_invoke_output_diff_modified(_obj: 'svn_diff_output_fns_t', output_baton: 'void *', original_start: 'apr_off_t', original_length: 'apr_off_t', modified_start: 'apr_off_t', modified_length: 'apr_off_t', latest_start: 'apr_off_t', latest_length: 'apr_off_t') -> "svn_error_t *":
    """svn_diff_output_fns_invoke_output_diff_modified(svn_diff_output_fns_t _obj, void * output_baton, apr_off_t original_start, apr_off_t original_length, apr_off_t modified_start, apr_off_t modified_length, apr_off_t latest_start, apr_off_t latest_length) -> svn_error_t"""
    return _diff.svn_diff_output_fns_invoke_output_diff_modified(_obj, output_baton, original_start, original_length, modified_start, modified_length, latest_start, latest_length)

def svn_diff_output_fns_invoke_output_diff_latest(_obj: 'svn_diff_output_fns_t', output_baton: 'void *', original_start: 'apr_off_t', original_length: 'apr_off_t', modified_start: 'apr_off_t', modified_length: 'apr_off_t', latest_start: 'apr_off_t', latest_length: 'apr_off_t') -> "svn_error_t *":
    """svn_diff_output_fns_invoke_output_diff_latest(svn_diff_output_fns_t _obj, void * output_baton, apr_off_t original_start, apr_off_t original_length, apr_off_t modified_start, apr_off_t modified_length, apr_off_t latest_start, apr_off_t latest_length) -> svn_error_t"""
    return _diff.svn_diff_output_fns_invoke_output_diff_latest(_obj, output_baton, original_start, original_length, modified_start, modified_length, latest_start, latest_length)

def svn_diff_output_fns_invoke_output_diff_common(_obj: 'svn_diff_output_fns_t', output_baton: 'void *', original_start: 'apr_off_t', original_length: 'apr_off_t', modified_start: 'apr_off_t', modified_length: 'apr_off_t', latest_start: 'apr_off_t', latest_length: 'apr_off_t') -> "svn_error_t *":
    """svn_diff_output_fns_invoke_output_diff_common(svn_diff_output_fns_t _obj, void * output_baton, apr_off_t original_start, apr_off_t original_length, apr_off_t modified_start, apr_off_t modified_length, apr_off_t latest_start, apr_off_t latest_length) -> svn_error_t"""
    return _diff.svn_diff_output_fns_invoke_output_diff_common(_obj, output_baton, original_start, original_length, modified_start, modified_length, latest_start, latest_length)

def svn_diff_output_fns_invoke_output_conflict(_obj: 'svn_diff_output_fns_t', output_baton: 'void *', original_start: 'apr_off_t', original_length: 'apr_off_t', modified_start: 'apr_off_t', modified_length: 'apr_off_t', latest_start: 'apr_off_t', latest_length: 'apr_off_t', resolved_diff: 'svn_diff_t *') -> "svn_error_t *":
    """svn_diff_output_fns_invoke_output_conflict(svn_diff_output_fns_t _obj, void * output_baton, apr_off_t original_start, apr_off_t original_length, apr_off_t modified_start, apr_off_t modified_length, apr_off_t latest_start, apr_off_t latest_length, svn_diff_t * resolved_diff) -> svn_error_t"""
    return _diff.svn_diff_output_fns_invoke_output_conflict(_obj, output_baton, original_start, original_length, modified_start, modified_length, latest_start, latest_length, resolved_diff)


