# This file was automatically generated by SWIG (http://www.swig.org).
# Version 3.0.12
#
# Do not make changes to this file unless you know what you are doing--modify
# the SWIG interface file instead.


def _dll_paths():
    import os
    if hasattr(os, 'add_dll_directory'):  # Python 3.8+ on Windows
        cookies = []
        for path in os.environ.get('PATH', '').split(os.pathsep):
            if path and os.path.isabs(path):
                try:
                    cookie = os.add_dll_directory(path)
                except OSError:
                    continue
                else:
                    cookies.append(cookie)
        return cookies
    else:
        return ()

_dll_paths = _dll_paths()
try:
    from . import _repos
finally:
    _dll_path = None
    for _dll_path in _dll_paths:
        _dll_path.close()
    del _dll_paths, _dll_path

try:
    _swig_property = property
except NameError:
    pass  # Python < 2.2 doesn't have 'property'.

try:
    import builtins as __builtin__
except ImportError:
    import __builtin__

def _swig_setattr_nondynamic(self, class_type, name, value, static=1):
    if (name == "thisown"):
        return self.this.own(value)
    if (name == "this"):
        if type(value).__name__ == 'SwigPyObject':
            self.__dict__[name] = value
            return
    method = class_type.__swig_setmethods__.get(name, None)
    if method:
        return method(self, value)
    if (not static):
        object.__setattr__(self, name, value)
    else:
        raise AttributeError("You cannot add attributes to %s" % self)


def _swig_setattr(self, class_type, name, value):
    return _swig_setattr_nondynamic(self, class_type, name, value, 0)


def _swig_getattr(self, class_type, name):
    if (name == "thisown"):
        return self.this.own()
    method = class_type.__swig_getmethods__.get(name, None)
    if method:
        return method(self)
    raise AttributeError("'%s' object has no attribute '%s'" % (class_type.__name__, name))


def _swig_repr(self):
    try:
        strthis = "proxy of " + self.this.__repr__()
    except __builtin__.Exception:
        strthis = ""
    return "<%s.%s; %s >" % (self.__class__.__module__, self.__class__.__name__, strthis,)


def _swig_setattr_nondynamic_method(set):
    def set_attr(self, name, value):
        if (name == "thisown"):
            return self.this.own(value)
        if hasattr(self, name) or (name == "this"):
            set(self, name, value)
        else:
            raise AttributeError("You cannot add attributes to %s" % self)
    return set_attr



def _copy_metadata_deep(value, old_value):
  """Copy all attributes of old_value into value, recursively traversing
  lists and dicts if needed."""
  if value is None or old_value is None or value is old_value: return

  if isinstance(value, dict):
    for k in value:
      _copy_metadata_deep(value[k], old_value[k])
  elif isinstance(value, list):
    for v, old_v in zip(value, old_value):
      _copy_metadata_deep(v, old_v)
  else:
    try:
      value.__dict__.update(old_value.__dict__)
    except AttributeError:
      pass

def _assert_valid_deep(value):
  """Assert value's validity, recursively traversing lists and dicts."""
  if isinstance(value, dict):
    for k in value:
      _assert_valid_deep(value[k])
  elif isinstance(value, list):
    for v in value:
      _assert_valid_deep(v)
# Ensure that the passed in value isn't a type, which could have an
# assert_valid attribute, but it can not be called without an instance.
  elif type(value) != type:
    try:
      fn = value.assert_valid
    except AttributeError:
      pass
    else:
      fn()



  # SWIG classes generated with -modern do not define this variable
try:
  _newclass
except NameError:
  _newclass = 1
else:
  raise RuntimeError("Require -modern option, but _newclass is defined")

_get_instance_attr = object.__getattribute__
_set_instance_attr = _swig_setattr_nondynamic_method(object.__setattr__)


import libsvn.core
import libsvn.delta
import libsvn.fs

def svn_swig_py_make_parse_fns3(*args) -> "svn_repos_parse_fns3_t const **, void **":
    """svn_swig_py_make_parse_fns3(PyObject * py_parse_fns3, apr_pool_t pool)"""
    return _repos.svn_swig_py_make_parse_fns3(*args)

def svn_repos_version() -> "svn_version_t const *":
    """svn_repos_version() -> svn_version_t const *"""
    return _repos.svn_repos_version()
svn_node_action_change = _repos.svn_node_action_change
svn_node_action_add = _repos.svn_node_action_add
svn_node_action_delete = _repos.svn_node_action_delete
svn_node_action_replace = _repos.svn_node_action_replace
svn_authz_none = _repos.svn_authz_none
svn_authz_read = _repos.svn_authz_read
svn_authz_write = _repos.svn_authz_write
svn_authz_recursive = _repos.svn_authz_recursive
svn_repos_notify_warning = _repos.svn_repos_notify_warning
svn_repos_notify_dump_rev_end = _repos.svn_repos_notify_dump_rev_end
svn_repos_notify_verify_rev_end = _repos.svn_repos_notify_verify_rev_end
svn_repos_notify_dump_end = _repos.svn_repos_notify_dump_end
svn_repos_notify_verify_end = _repos.svn_repos_notify_verify_end
svn_repos_notify_pack_shard_start = _repos.svn_repos_notify_pack_shard_start
svn_repos_notify_pack_shard_end = _repos.svn_repos_notify_pack_shard_end
svn_repos_notify_pack_shard_start_revprop = _repos.svn_repos_notify_pack_shard_start_revprop
svn_repos_notify_pack_shard_end_revprop = _repos.svn_repos_notify_pack_shard_end_revprop
svn_repos_notify_load_txn_start = _repos.svn_repos_notify_load_txn_start
svn_repos_notify_load_txn_committed = _repos.svn_repos_notify_load_txn_committed
svn_repos_notify_load_node_start = _repos.svn_repos_notify_load_node_start
svn_repos_notify_load_node_done = _repos.svn_repos_notify_load_node_done
svn_repos_notify_load_copied_node = _repos.svn_repos_notify_load_copied_node
svn_repos_notify_load_normalized_mergeinfo = _repos.svn_repos_notify_load_normalized_mergeinfo
svn_repos_notify_mutex_acquired = _repos.svn_repos_notify_mutex_acquired
svn_repos_notify_recover_start = _repos.svn_repos_notify_recover_start
svn_repos_notify_upgrade_start = _repos.svn_repos_notify_upgrade_start
svn_repos_notify_load_skipped_rev = _repos.svn_repos_notify_load_skipped_rev
svn_repos_notify_verify_rev_structure = _repos.svn_repos_notify_verify_rev_structure
svn_repos_notify_pack_revprops = _repos.svn_repos_notify_pack_revprops
svn_repos_notify_cleanup_revprops = _repos.svn_repos_notify_cleanup_revprops
svn_repos_notify_format_bumped = _repos.svn_repos_notify_format_bumped
svn_repos_notify_hotcopy_rev_range = _repos.svn_repos_notify_hotcopy_rev_range
svn_repos_notify_pack_noop = _repos.svn_repos_notify_pack_noop
svn_repos_notify_load_revprop_set = _repos.svn_repos_notify_load_revprop_set
svn_repos_notify_warning_found_old_reference = _repos.svn_repos_notify_warning_found_old_reference
svn_repos_notify_warning_found_old_mergeinfo = _repos.svn_repos_notify_warning_found_old_mergeinfo
svn_repos_notify_warning_invalid_fspath = _repos.svn_repos_notify_warning_invalid_fspath
svn_repos_notify_warning_name_collision = _repos.svn_repos_notify_warning_name_collision
svn_repos_notify_warning_mergeinfo_collision = _repos.svn_repos_notify_warning_mergeinfo_collision
svn_repos_notify_warning_invalid_mergeinfo = _repos.svn_repos_notify_warning_invalid_mergeinfo
class svn_repos_notify_t(object):
    """Proxy of C svn_repos_notify_t struct."""

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    action = _swig_property(_repos.svn_repos_notify_t_action_get, _repos.svn_repos_notify_t_action_set)
    revision = _swig_property(_repos.svn_repos_notify_t_revision_get, _repos.svn_repos_notify_t_revision_set)
    warning_str = _swig_property(_repos.svn_repos_notify_t_warning_str_get, _repos.svn_repos_notify_t_warning_str_set)
    warning = _swig_property(_repos.svn_repos_notify_t_warning_get, _repos.svn_repos_notify_t_warning_set)
    shard = _swig_property(_repos.svn_repos_notify_t_shard_get, _repos.svn_repos_notify_t_shard_set)
    new_revision = _swig_property(_repos.svn_repos_notify_t_new_revision_get, _repos.svn_repos_notify_t_new_revision_set)
    old_revision = _swig_property(_repos.svn_repos_notify_t_old_revision_get, _repos.svn_repos_notify_t_old_revision_set)
    node_action = _swig_property(_repos.svn_repos_notify_t_node_action_get, _repos.svn_repos_notify_t_node_action_set)
    path = _swig_property(_repos.svn_repos_notify_t_path_get, _repos.svn_repos_notify_t_path_set)
    start_revision = _swig_property(_repos.svn_repos_notify_t_start_revision_get, _repos.svn_repos_notify_t_start_revision_set)
    end_revision = _swig_property(_repos.svn_repos_notify_t_end_revision_get, _repos.svn_repos_notify_t_end_revision_set)
    def set_parent_pool(self, parent_pool=None):
      """Create a new proxy object for TYPE"""
      import libsvn.core, weakref
      self.__dict__["_parent_pool"] = \
        parent_pool or libsvn.core.application_pool;
      if self.__dict__["_parent_pool"]:
        self.__dict__["_is_valid"] = weakref.ref(
          self.__dict__["_parent_pool"]._is_valid)

    def assert_valid(self):
      """Assert that this object is using valid pool memory"""
      if "_is_valid" in self.__dict__:
        assert self.__dict__["_is_valid"](), "Variable has already been deleted"

    def _retrieve_swig_value(self, name, value):
    # If we got back a different object than we have cached, we need to copy
    # all our metadata into it, so that it looks identical to the one
    # originally set.
      members = self.__dict__.get('_members')
      if members is not None and name in members:
        _copy_metadata_deep(value, members[name])

    # Verify that the new object is good
      _assert_valid_deep(value)

      return value

    # Attribute access must be intercepted to ensure that objects coming from
    # read attribute access match those that are set with write attribute access.
    # Specifically the metadata, such as the associated apr_pool object, should
    # match the originally assigned object.
    #
    # For classic classes it is enough to use __getattr__ to intercept swig
    # derived attributes. However, with new style classes SWIG makes use of
    # descriptors which mean that __getattr__ is never called. Therefore,
    # __getattribute__ must be used for the interception.

    if _newclass:
      def __getattribute__(self, name):
        """Manage access to all attributes of this object."""

    # Start by mimicing __getattr__ behavior: immediately return __dict__ or
    # items directly present in __dict__
        mydict = object.__getattribute__(self, '__dict__')

        if name == "__dict__":
          return mydict

        if name in mydict:
          return mydict[name]

        object.__getattribute__(self, 'assert_valid')()

        value = _get_instance_attr(self, name)
        fn = object.__getattribute__(self, '_retrieve_swig_value')
        return fn(name, value)
    else:
      def __getattr__(self, name):
        """Get an attribute from this object"""
        self.assert_valid()

        value = _swig_getattr(self, self.__class__, name)

        return self._retrieve_swig_value(name, value)

    def __setattr__(self, name, value):
      """Set an attribute on this object"""
      self.assert_valid()

    # Save a copy of the object, so that the garbage
    # collector won't kill the object while it's in
    # SWIG-land
      self.__dict__.setdefault("_members",{})[name] = value

      return _set_instance_attr(self, name, value)

svn_repos_notify_t_swigregister = _repos.svn_repos_notify_t_swigregister
svn_repos_notify_t_swigregister(svn_repos_notify_t)


def svn_repos_notify_create(*args) -> "svn_repos_notify_t *":
    """svn_repos_notify_create(svn_repos_notify_action_t action, apr_pool_t result_pool) -> svn_repos_notify_t"""
    return _repos.svn_repos_notify_create(*args)

def svn_repos_find_root_path(*args) -> "char const *":
    """svn_repos_find_root_path(char const * path, apr_pool_t pool) -> char const *"""
    return _repos.svn_repos_find_root_path(*args)

def svn_repos_open3(*args) -> "svn_repos_t **":
    """svn_repos_open3(char const * path, apr_hash_t fs_config, apr_pool_t result_pool, apr_pool_t scratch_pool) -> svn_error_t"""
    return _repos.svn_repos_open3(*args)

def svn_repos_open2(*args) -> "svn_repos_t **":
    """svn_repos_open2(char const * path, apr_hash_t fs_config, apr_pool_t pool) -> svn_error_t"""
    return _repos.svn_repos_open2(*args)

def svn_repos_open(*args) -> "svn_repos_t **":
    """svn_repos_open(char const * path, apr_pool_t pool) -> svn_error_t"""
    return _repos.svn_repos_open(*args)

def svn_repos_create(*args) -> "svn_repos_t **":
    """svn_repos_create(char const * path, char const * unused_1, char const * unused_2, apr_hash_t config, apr_hash_t fs_config, apr_pool_t pool) -> svn_error_t"""
    return _repos.svn_repos_create(*args)

def svn_repos_upgrade2(*args) -> "svn_error_t *":
    """svn_repos_upgrade2(char const * path, svn_boolean_t nonblocking, svn_repos_notify_func_t notify_func, void * notify_baton, apr_pool_t pool) -> svn_error_t"""
    return _repos.svn_repos_upgrade2(*args)

def svn_repos_upgrade(*args) -> "svn_error_t *":
    """svn_repos_upgrade(char const * path, svn_boolean_t nonblocking, svn_error_t *(*)(void *) start_callback, void * start_callback_baton, apr_pool_t pool) -> svn_error_t"""
    return _repos.svn_repos_upgrade(*args)

def svn_repos_delete(*args) -> "svn_error_t *":
    """svn_repos_delete(char const * path, apr_pool_t pool) -> svn_error_t"""
    return _repos.svn_repos_delete(*args)

def svn_repos_has_capability(*args) -> "svn_boolean_t *":
    """svn_repos_has_capability(svn_repos_t * repos, char const * capability, apr_pool_t pool) -> svn_error_t"""
    return _repos.svn_repos_has_capability(*args)

def svn_repos_capabilities(*args) -> "apr_hash_t **":
    """svn_repos_capabilities(svn_repos_t * repos, apr_pool_t result_pool, apr_pool_t scratch_pool) -> svn_error_t"""
    return _repos.svn_repos_capabilities(*args)
SVN_REPOS_CAPABILITY_MERGEINFO = _repos.SVN_REPOS_CAPABILITY_MERGEINFO

def svn_repos_remember_client_capabilities(repos: 'svn_repos_t *', capabilities: 'apr_array_header_t') -> "svn_error_t *":
    """svn_repos_remember_client_capabilities(svn_repos_t * repos, apr_array_header_t capabilities) -> svn_error_t"""
    return _repos.svn_repos_remember_client_capabilities(repos, capabilities)

def svn_repos_fs(repos: 'svn_repos_t *') -> "svn_fs_t *":
    """svn_repos_fs(svn_repos_t * repos) -> svn_fs_t *"""
    return _repos.svn_repos_fs(repos)

def svn_repos_fs_type(*args) -> "char const *":
    """svn_repos_fs_type(svn_repos_t * repos, apr_pool_t result_pool) -> char const *"""
    return _repos.svn_repos_fs_type(*args)

def svn_repos_hotcopy3(*args) -> "svn_error_t *":
    """svn_repos_hotcopy3(char const * src_path, char const * dst_path, svn_boolean_t clean_logs, svn_boolean_t incremental, svn_repos_notify_func_t notify_func, void * notify_baton, svn_cancel_func_t cancel_func, apr_pool_t scratch_pool) -> svn_error_t"""
    return _repos.svn_repos_hotcopy3(*args)

def svn_repos_hotcopy2(*args) -> "svn_error_t *":
    """svn_repos_hotcopy2(char const * src_path, char const * dst_path, svn_boolean_t clean_logs, svn_boolean_t incremental, svn_cancel_func_t cancel_func, apr_pool_t pool) -> svn_error_t"""
    return _repos.svn_repos_hotcopy2(*args)

def svn_repos_hotcopy(*args) -> "svn_error_t *":
    """svn_repos_hotcopy(char const * src_path, char const * dst_path, svn_boolean_t clean_logs, apr_pool_t pool) -> svn_error_t"""
    return _repos.svn_repos_hotcopy(*args)

def svn_repos_fs_pack2(*args) -> "svn_error_t *":
    """svn_repos_fs_pack2(svn_repos_t * repos, svn_repos_notify_func_t notify_func, void * notify_baton, svn_cancel_func_t cancel_func, apr_pool_t pool) -> svn_error_t"""
    return _repos.svn_repos_fs_pack2(*args)

def svn_repos_fs_pack(*args) -> "svn_error_t *":
    """svn_repos_fs_pack(svn_repos_t * repos, svn_fs_pack_notify_t notify_func, void * notify_baton, svn_cancel_func_t cancel_func, apr_pool_t pool) -> svn_error_t"""
    return _repos.svn_repos_fs_pack(*args)

def svn_repos_recover4(*args) -> "svn_error_t *":
    """svn_repos_recover4(char const * path, svn_boolean_t nonblocking, svn_repos_notify_func_t notify_func, void * notify_baton, svn_cancel_func_t cancel_func, apr_pool_t pool) -> svn_error_t"""
    return _repos.svn_repos_recover4(*args)

def svn_repos_recover3(*args) -> "svn_error_t *":
    """svn_repos_recover3(char const * path, svn_boolean_t nonblocking, svn_error_t *(*)(void *) start_callback, void * start_callback_baton, svn_cancel_func_t cancel_func, apr_pool_t pool) -> svn_error_t"""
    return _repos.svn_repos_recover3(*args)

def svn_repos_recover2(*args) -> "svn_error_t *":
    """svn_repos_recover2(char const * path, svn_boolean_t nonblocking, svn_error_t *(*)(void *) start_callback, void * start_callback_baton, apr_pool_t pool) -> svn_error_t"""
    return _repos.svn_repos_recover2(*args)

def svn_repos_recover(*args) -> "svn_error_t *":
    """svn_repos_recover(char const * path, apr_pool_t pool) -> svn_error_t"""
    return _repos.svn_repos_recover(*args)

def svn_repos_freeze(*args) -> "svn_error_t *":
    """svn_repos_freeze(apr_array_header_t paths, svn_repos_freeze_func_t freeze_func, apr_pool_t pool) -> svn_error_t"""
    return _repos.svn_repos_freeze(*args)

def svn_repos_db_logfiles(*args) -> "apr_array_header_t **":
    """svn_repos_db_logfiles(char const * path, svn_boolean_t only_unused, apr_pool_t pool) -> svn_error_t"""
    return _repos.svn_repos_db_logfiles(*args)

def svn_repos_path(*args) -> "char const *":
    """svn_repos_path(svn_repos_t * repos, apr_pool_t pool) -> char const *"""
    return _repos.svn_repos_path(*args)

def svn_repos_db_env(*args) -> "char const *":
    """svn_repos_db_env(svn_repos_t * repos, apr_pool_t pool) -> char const *"""
    return _repos.svn_repos_db_env(*args)

def svn_repos_conf_dir(*args) -> "char const *":
    """svn_repos_conf_dir(svn_repos_t * repos, apr_pool_t pool) -> char const *"""
    return _repos.svn_repos_conf_dir(*args)

def svn_repos_svnserve_conf(*args) -> "char const *":
    """svn_repos_svnserve_conf(svn_repos_t * repos, apr_pool_t pool) -> char const *"""
    return _repos.svn_repos_svnserve_conf(*args)

def svn_repos_lock_dir(*args) -> "char const *":
    """svn_repos_lock_dir(svn_repos_t * repos, apr_pool_t pool) -> char const *"""
    return _repos.svn_repos_lock_dir(*args)

def svn_repos_db_lockfile(*args) -> "char const *":
    """svn_repos_db_lockfile(svn_repos_t * repos, apr_pool_t pool) -> char const *"""
    return _repos.svn_repos_db_lockfile(*args)

def svn_repos_db_logs_lockfile(*args) -> "char const *":
    """svn_repos_db_logs_lockfile(svn_repos_t * repos, apr_pool_t pool) -> char const *"""
    return _repos.svn_repos_db_logs_lockfile(*args)

def svn_repos_hook_dir(*args) -> "char const *":
    """svn_repos_hook_dir(svn_repos_t * repos, apr_pool_t pool) -> char const *"""
    return _repos.svn_repos_hook_dir(*args)

def svn_repos_start_commit_hook(*args) -> "char const *":
    """svn_repos_start_commit_hook(svn_repos_t * repos, apr_pool_t pool) -> char const *"""
    return _repos.svn_repos_start_commit_hook(*args)

def svn_repos_pre_commit_hook(*args) -> "char const *":
    """svn_repos_pre_commit_hook(svn_repos_t * repos, apr_pool_t pool) -> char const *"""
    return _repos.svn_repos_pre_commit_hook(*args)

def svn_repos_post_commit_hook(*args) -> "char const *":
    """svn_repos_post_commit_hook(svn_repos_t * repos, apr_pool_t pool) -> char const *"""
    return _repos.svn_repos_post_commit_hook(*args)

def svn_repos_pre_revprop_change_hook(*args) -> "char const *":
    """svn_repos_pre_revprop_change_hook(svn_repos_t * repos, apr_pool_t pool) -> char const *"""
    return _repos.svn_repos_pre_revprop_change_hook(*args)

def svn_repos_post_revprop_change_hook(*args) -> "char const *":
    """svn_repos_post_revprop_change_hook(svn_repos_t * repos, apr_pool_t pool) -> char const *"""
    return _repos.svn_repos_post_revprop_change_hook(*args)

def svn_repos_pre_lock_hook(*args) -> "char const *":
    """svn_repos_pre_lock_hook(svn_repos_t * repos, apr_pool_t pool) -> char const *"""
    return _repos.svn_repos_pre_lock_hook(*args)

def svn_repos_post_lock_hook(*args) -> "char const *":
    """svn_repos_post_lock_hook(svn_repos_t * repos, apr_pool_t pool) -> char const *"""
    return _repos.svn_repos_post_lock_hook(*args)

def svn_repos_pre_unlock_hook(*args) -> "char const *":
    """svn_repos_pre_unlock_hook(svn_repos_t * repos, apr_pool_t pool) -> char const *"""
    return _repos.svn_repos_pre_unlock_hook(*args)

def svn_repos_post_unlock_hook(*args) -> "char const *":
    """svn_repos_post_unlock_hook(svn_repos_t * repos, apr_pool_t pool) -> char const *"""
    return _repos.svn_repos_post_unlock_hook(*args)

def svn_repos_hooks_setenv(*args) -> "svn_error_t *":
    """svn_repos_hooks_setenv(svn_repos_t * repos, char const * hooks_env_path, apr_pool_t scratch_pool) -> svn_error_t"""
    return _repos.svn_repos_hooks_setenv(*args)

def svn_repos_begin_report3(*args) -> "void **":
    """svn_repos_begin_report3(svn_revnum_t revnum, svn_repos_t * repos, char const * fs_base, char const * target, char const * tgt_path, svn_boolean_t text_deltas, svn_depth_t depth, svn_boolean_t ignore_ancestry, svn_boolean_t send_copyfrom_args, svn_delta_editor_t editor, void * edit_baton, svn_repos_authz_func_t authz_read_func, apr_size_t zero_copy_limit, apr_pool_t pool) -> svn_error_t"""
    return _repos.svn_repos_begin_report3(*args)

def svn_repos_begin_report2(*args) -> "void **":
    """svn_repos_begin_report2(svn_revnum_t revnum, svn_repos_t * repos, char const * fs_base, char const * target, char const * tgt_path, svn_boolean_t text_deltas, svn_depth_t depth, svn_boolean_t ignore_ancestry, svn_boolean_t send_copyfrom_args, svn_delta_editor_t editor, void * edit_baton, svn_repos_authz_func_t authz_read_func, apr_pool_t pool) -> svn_error_t"""
    return _repos.svn_repos_begin_report2(*args)

def svn_repos_begin_report(*args) -> "void **":
    """svn_repos_begin_report(svn_revnum_t revnum, char const * username, svn_repos_t * repos, char const * fs_base, char const * target, char const * tgt_path, svn_boolean_t text_deltas, svn_boolean_t recurse, svn_boolean_t ignore_ancestry, svn_delta_editor_t editor, void * edit_baton, svn_repos_authz_func_t authz_read_func, apr_pool_t pool) -> svn_error_t"""
    return _repos.svn_repos_begin_report(*args)

def svn_repos_set_path3(*args) -> "svn_error_t *":
    """svn_repos_set_path3(void * report_baton, char const * path, svn_revnum_t revision, svn_depth_t depth, svn_boolean_t start_empty, char const * lock_token, apr_pool_t pool) -> svn_error_t"""
    return _repos.svn_repos_set_path3(*args)

def svn_repos_set_path2(*args) -> "svn_error_t *":
    """svn_repos_set_path2(void * report_baton, char const * path, svn_revnum_t revision, svn_boolean_t start_empty, char const * lock_token, apr_pool_t pool) -> svn_error_t"""
    return _repos.svn_repos_set_path2(*args)

def svn_repos_set_path(*args) -> "svn_error_t *":
    """svn_repos_set_path(void * report_baton, char const * path, svn_revnum_t revision, svn_boolean_t start_empty, apr_pool_t pool) -> svn_error_t"""
    return _repos.svn_repos_set_path(*args)

def svn_repos_link_path3(*args) -> "svn_error_t *":
    """svn_repos_link_path3(void * report_baton, char const * path, char const * link_path, svn_revnum_t revision, svn_depth_t depth, svn_boolean_t start_empty, char const * lock_token, apr_pool_t pool) -> svn_error_t"""
    return _repos.svn_repos_link_path3(*args)

def svn_repos_link_path2(*args) -> "svn_error_t *":
    """svn_repos_link_path2(void * report_baton, char const * path, char const * link_path, svn_revnum_t revision, svn_boolean_t start_empty, char const * lock_token, apr_pool_t pool) -> svn_error_t"""
    return _repos.svn_repos_link_path2(*args)

def svn_repos_link_path(*args) -> "svn_error_t *":
    """svn_repos_link_path(void * report_baton, char const * path, char const * link_path, svn_revnum_t revision, svn_boolean_t start_empty, apr_pool_t pool) -> svn_error_t"""
    return _repos.svn_repos_link_path(*args)

def svn_repos_delete_path(*args) -> "svn_error_t *":
    """svn_repos_delete_path(void * report_baton, char const * path, apr_pool_t pool) -> svn_error_t"""
    return _repos.svn_repos_delete_path(*args)

def svn_repos_finish_report(*args) -> "svn_error_t *":
    """svn_repos_finish_report(void * report_baton, apr_pool_t pool) -> svn_error_t"""
    return _repos.svn_repos_finish_report(*args)

def svn_repos_abort_report(*args) -> "svn_error_t *":
    """svn_repos_abort_report(void * report_baton, apr_pool_t pool) -> svn_error_t"""
    return _repos.svn_repos_abort_report(*args)

def svn_repos_dir_delta2(*args) -> "svn_error_t *":
    """svn_repos_dir_delta2(svn_fs_root_t * src_root, char const * src_parent_dir, char const * src_entry, svn_fs_root_t * tgt_root, char const * tgt_path, svn_delta_editor_t editor, void * edit_baton, svn_repos_authz_func_t authz_read_func, svn_boolean_t text_deltas, svn_depth_t depth, svn_boolean_t entry_props, svn_boolean_t ignore_ancestry, apr_pool_t pool) -> svn_error_t"""
    return _repos.svn_repos_dir_delta2(*args)

def svn_repos_dir_delta(*args) -> "svn_error_t *":
    """svn_repos_dir_delta(svn_fs_root_t * src_root, char const * src_parent_dir, char const * src_entry, svn_fs_root_t * tgt_root, char const * tgt_path, svn_delta_editor_t editor, void * edit_baton, svn_repos_authz_func_t authz_read_func, svn_boolean_t text_deltas, svn_boolean_t recurse, svn_boolean_t entry_props, svn_boolean_t ignore_ancestry, apr_pool_t pool) -> svn_error_t"""
    return _repos.svn_repos_dir_delta(*args)

def svn_repos_replay2(*args) -> "svn_error_t *":
    """svn_repos_replay2(svn_fs_root_t * root, char const * base_dir, svn_revnum_t low_water_mark, svn_boolean_t send_deltas, svn_delta_editor_t editor, void * edit_baton, svn_repos_authz_func_t authz_read_func, apr_pool_t pool) -> svn_error_t"""
    return _repos.svn_repos_replay2(*args)

def svn_repos_replay(*args) -> "svn_error_t *":
    """svn_repos_replay(svn_fs_root_t * root, svn_delta_editor_t editor, void * edit_baton, apr_pool_t pool) -> svn_error_t"""
    return _repos.svn_repos_replay(*args)

def svn_repos_get_commit_editor5(*args) -> "svn_delta_editor_t const **, void **":
    """svn_repos_get_commit_editor5(svn_repos_t * repos, svn_fs_txn_t * txn, char const * repos_url_decoded, char const * base_path, apr_hash_t revprop_table, svn_commit_callback2_t commit_callback, svn_repos_authz_callback_t authz_callback, void * authz_baton, apr_pool_t pool) -> svn_error_t"""
    return _repos.svn_repos_get_commit_editor5(*args)

def svn_repos_get_commit_editor4(*args) -> "svn_delta_editor_t const **, void **":
    """svn_repos_get_commit_editor4(svn_repos_t * repos, svn_fs_txn_t * txn, char const * repos_url, char const * base_path, char const * user, char const * log_msg, svn_commit_callback2_t commit_callback, svn_repos_authz_callback_t authz_callback, void * authz_baton, apr_pool_t pool) -> svn_error_t"""
    return _repos.svn_repos_get_commit_editor4(*args)

def svn_repos_get_commit_editor3(*args) -> "svn_delta_editor_t const **, void **":
    """svn_repos_get_commit_editor3(svn_repos_t * repos, svn_fs_txn_t * txn, char const * repos_url, char const * base_path, char const * user, char const * log_msg, svn_commit_callback_t callback, svn_repos_authz_callback_t authz_callback, void * authz_baton, apr_pool_t pool) -> svn_error_t"""
    return _repos.svn_repos_get_commit_editor3(*args)

def svn_repos_get_commit_editor2(*args) -> "svn_delta_editor_t const **, void **":
    """svn_repos_get_commit_editor2(svn_repos_t * repos, svn_fs_txn_t * txn, char const * repos_url, char const * base_path, char const * user, char const * log_msg, svn_commit_callback_t callback, apr_pool_t pool) -> svn_error_t"""
    return _repos.svn_repos_get_commit_editor2(*args)

def svn_repos_get_commit_editor(*args) -> "svn_delta_editor_t const **, void **":
    """svn_repos_get_commit_editor(svn_repos_t * repos, char const * repos_url, char const * base_path, char const * user, char const * log_msg, svn_commit_callback_t callback, apr_pool_t pool) -> svn_error_t"""
    return _repos.svn_repos_get_commit_editor(*args)

def svn_repos_dated_revision(*args) -> "svn_revnum_t *":
    """svn_repos_dated_revision(svn_repos_t * repos, apr_time_t tm, apr_pool_t pool) -> svn_error_t"""
    return _repos.svn_repos_dated_revision(*args)

def svn_repos_get_committed_info(*args) -> "svn_revnum_t *, char const **, char const **":
    """svn_repos_get_committed_info(svn_fs_root_t * root, char const * path, apr_pool_t pool) -> svn_error_t"""
    return _repos.svn_repos_get_committed_info(*args)

def svn_repos_stat(*args) -> "svn_dirent_t **":
    """svn_repos_stat(svn_fs_root_t * root, char const * path, apr_pool_t pool) -> svn_error_t"""
    return _repos.svn_repos_stat(*args)

def svn_repos_list(*args) -> "svn_error_t *":
    """svn_repos_list(svn_fs_root_t * root, char const * path, apr_array_header_t patterns, svn_depth_t depth, svn_boolean_t path_info_only, svn_repos_authz_func_t authz_read_func, svn_repos_dirent_receiver_t receiver, void * receiver_baton, svn_cancel_func_t cancel_func, apr_pool_t scratch_pool) -> svn_error_t"""
    return _repos.svn_repos_list(*args)

def svn_repos_deleted_rev(*args) -> "svn_revnum_t *":
    """svn_repos_deleted_rev(svn_fs_t * fs, char const * path, svn_revnum_t start, svn_revnum_t end, apr_pool_t pool) -> svn_error_t"""
    return _repos.svn_repos_deleted_rev(*args)

def svn_repos_history2(*args) -> "svn_error_t *":
    """svn_repos_history2(svn_fs_t * fs, char const * path, svn_repos_history_func_t history_func, svn_repos_authz_func_t authz_read_func, svn_revnum_t start, svn_revnum_t end, svn_boolean_t cross_copies, apr_pool_t pool) -> svn_error_t"""
    return _repos.svn_repos_history2(*args)

def svn_repos_history(*args) -> "svn_error_t *":
    """svn_repos_history(svn_fs_t * fs, char const * path, svn_repos_history_func_t history_func, svn_revnum_t start, svn_revnum_t end, svn_boolean_t cross_copies, apr_pool_t pool) -> svn_error_t"""
    return _repos.svn_repos_history(*args)

def svn_repos_trace_node_locations(*args) -> "apr_hash_t **":
    """svn_repos_trace_node_locations(svn_fs_t * fs, char const * fs_path, svn_revnum_t peg_revision, apr_array_header_t location_revisions, svn_repos_authz_func_t authz_read_func, apr_pool_t pool) -> svn_error_t"""
    return _repos.svn_repos_trace_node_locations(*args)

def svn_repos_node_location_segments(*args) -> "svn_error_t *":
    """svn_repos_node_location_segments(svn_repos_t * repos, char const * path, svn_revnum_t peg_revision, svn_revnum_t start_rev, svn_revnum_t end_rev, svn_location_segment_receiver_t receiver, svn_repos_authz_func_t authz_read_func, apr_pool_t pool) -> svn_error_t"""
    return _repos.svn_repos_node_location_segments(*args)

def svn_repos_path_change_create(*args) -> "svn_repos_path_change_t *":
    """svn_repos_path_change_create(apr_pool_t result_pool) -> svn_fs_path_change3_t"""
    return _repos.svn_repos_path_change_create(*args)

def svn_repos_path_change_dup(*args) -> "svn_repos_path_change_t *":
    """svn_repos_path_change_dup(svn_fs_path_change3_t change, apr_pool_t result_pool) -> svn_fs_path_change3_t"""
    return _repos.svn_repos_path_change_dup(*args)
class svn_repos_log_entry_t(object):
    """Proxy of C svn_repos_log_entry_t struct."""

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    revision = _swig_property(_repos.svn_repos_log_entry_t_revision_get, _repos.svn_repos_log_entry_t_revision_set)
    revprops = _swig_property(_repos.svn_repos_log_entry_t_revprops_get, _repos.svn_repos_log_entry_t_revprops_set)
    has_children = _swig_property(_repos.svn_repos_log_entry_t_has_children_get, _repos.svn_repos_log_entry_t_has_children_set)
    non_inheritable = _swig_property(_repos.svn_repos_log_entry_t_non_inheritable_get, _repos.svn_repos_log_entry_t_non_inheritable_set)
    subtractive_merge = _swig_property(_repos.svn_repos_log_entry_t_subtractive_merge_get, _repos.svn_repos_log_entry_t_subtractive_merge_set)
    def set_parent_pool(self, parent_pool=None):
      """Create a new proxy object for TYPE"""
      import libsvn.core, weakref
      self.__dict__["_parent_pool"] = \
        parent_pool or libsvn.core.application_pool;
      if self.__dict__["_parent_pool"]:
        self.__dict__["_is_valid"] = weakref.ref(
          self.__dict__["_parent_pool"]._is_valid)

    def assert_valid(self):
      """Assert that this object is using valid pool memory"""
      if "_is_valid" in self.__dict__:
        assert self.__dict__["_is_valid"](), "Variable has already been deleted"

    def _retrieve_swig_value(self, name, value):
    # If we got back a different object than we have cached, we need to copy
    # all our metadata into it, so that it looks identical to the one
    # originally set.
      members = self.__dict__.get('_members')
      if members is not None and name in members:
        _copy_metadata_deep(value, members[name])

    # Verify that the new object is good
      _assert_valid_deep(value)

      return value

    # Attribute access must be intercepted to ensure that objects coming from
    # read attribute access match those that are set with write attribute access.
    # Specifically the metadata, such as the associated apr_pool object, should
    # match the originally assigned object.
    #
    # For classic classes it is enough to use __getattr__ to intercept swig
    # derived attributes. However, with new style classes SWIG makes use of
    # descriptors which mean that __getattr__ is never called. Therefore,
    # __getattribute__ must be used for the interception.

    if _newclass:
      def __getattribute__(self, name):
        """Manage access to all attributes of this object."""

    # Start by mimicing __getattr__ behavior: immediately return __dict__ or
    # items directly present in __dict__
        mydict = object.__getattribute__(self, '__dict__')

        if name == "__dict__":
          return mydict

        if name in mydict:
          return mydict[name]

        object.__getattribute__(self, 'assert_valid')()

        value = _get_instance_attr(self, name)
        fn = object.__getattribute__(self, '_retrieve_swig_value')
        return fn(name, value)
    else:
      def __getattr__(self, name):
        """Get an attribute from this object"""
        self.assert_valid()

        value = _swig_getattr(self, self.__class__, name)

        return self._retrieve_swig_value(name, value)

    def __setattr__(self, name, value):
      """Set an attribute on this object"""
      self.assert_valid()

    # Save a copy of the object, so that the garbage
    # collector won't kill the object while it's in
    # SWIG-land
      self.__dict__.setdefault("_members",{})[name] = value

      return _set_instance_attr(self, name, value)

svn_repos_log_entry_t_swigregister = _repos.svn_repos_log_entry_t_swigregister
svn_repos_log_entry_t_swigregister(svn_repos_log_entry_t)


def svn_repos_log_entry_create(*args) -> "svn_repos_log_entry_t *":
    """svn_repos_log_entry_create(apr_pool_t result_pool) -> svn_repos_log_entry_t"""
    return _repos.svn_repos_log_entry_create(*args)

def svn_repos_log_entry_dup(*args) -> "svn_repos_log_entry_t *":
    """svn_repos_log_entry_dup(svn_repos_log_entry_t log_entry, apr_pool_t result_pool) -> svn_repos_log_entry_t"""
    return _repos.svn_repos_log_entry_dup(*args)

def svn_repos_get_logs5(*args) -> "svn_error_t *":
    """svn_repos_get_logs5(svn_repos_t * repos, apr_array_header_t paths, svn_revnum_t start, svn_revnum_t end, int limit, svn_boolean_t strict_node_history, svn_boolean_t include_merged_revisions, apr_array_header_t revprops, svn_repos_authz_func_t authz_read_func, svn_repos_path_change_receiver_t path_change_receiver, void * path_change_receiver_baton, svn_repos_log_entry_receiver_t revision_receiver, void * revision_receiver_baton, apr_pool_t scratch_pool) -> svn_error_t"""
    return _repos.svn_repos_get_logs5(*args)

def svn_repos_get_logs4(*args) -> "svn_error_t *":
    """svn_repos_get_logs4(svn_repos_t * repos, apr_array_header_t paths, svn_revnum_t start, svn_revnum_t end, int limit, svn_boolean_t discover_changed_paths, svn_boolean_t strict_node_history, svn_boolean_t include_merged_revisions, apr_array_header_t revprops, svn_repos_authz_func_t authz_read_func, svn_log_entry_receiver_t receiver, apr_pool_t pool) -> svn_error_t"""
    return _repos.svn_repos_get_logs4(*args)

def svn_repos_get_logs3(*args) -> "svn_error_t *":
    """svn_repos_get_logs3(svn_repos_t * repos, apr_array_header_t paths, svn_revnum_t start, svn_revnum_t end, int limit, svn_boolean_t discover_changed_paths, svn_boolean_t strict_node_history, svn_repos_authz_func_t authz_read_func, svn_log_message_receiver_t receiver, apr_pool_t pool) -> svn_error_t"""
    return _repos.svn_repos_get_logs3(*args)

def svn_repos_get_logs2(*args) -> "svn_error_t *":
    """svn_repos_get_logs2(svn_repos_t * repos, apr_array_header_t paths, svn_revnum_t start, svn_revnum_t end, svn_boolean_t discover_changed_paths, svn_boolean_t strict_node_history, svn_repos_authz_func_t authz_read_func, svn_log_message_receiver_t receiver, apr_pool_t pool) -> svn_error_t"""
    return _repos.svn_repos_get_logs2(*args)

def svn_repos_get_logs(*args) -> "svn_error_t *":
    """svn_repos_get_logs(svn_repos_t * repos, apr_array_header_t paths, svn_revnum_t start, svn_revnum_t end, svn_boolean_t discover_changed_paths, svn_boolean_t strict_node_history, svn_log_message_receiver_t receiver, apr_pool_t pool) -> svn_error_t"""
    return _repos.svn_repos_get_logs(*args)

def svn_repos_fs_get_mergeinfo2(*args) -> "svn_error_t *":
    """svn_repos_fs_get_mergeinfo2(svn_repos_t * repos, apr_array_header_t paths, svn_revnum_t revision, svn_mergeinfo_inheritance_t inherit, svn_boolean_t include_descendants, svn_repos_authz_func_t authz_read_func, svn_repos_mergeinfo_receiver_t receiver, void * receiver_baton, apr_pool_t scratch_pool) -> svn_error_t"""
    return _repos.svn_repos_fs_get_mergeinfo2(*args)

def svn_repos_fs_get_mergeinfo(*args) -> "apr_hash_t **":
    """svn_repos_fs_get_mergeinfo(svn_repos_t * repos, apr_array_header_t paths, svn_revnum_t revision, svn_mergeinfo_inheritance_t inherit, svn_boolean_t include_descendants, svn_repos_authz_func_t authz_read_func, apr_pool_t pool) -> svn_error_t"""
    return _repos.svn_repos_fs_get_mergeinfo(*args)

def svn_repos_get_file_revs2(*args) -> "svn_error_t *":
    """svn_repos_get_file_revs2(svn_repos_t * repos, char const * path, svn_revnum_t start, svn_revnum_t end, svn_boolean_t include_merged_revisions, svn_repos_authz_func_t authz_read_func, svn_file_rev_handler_t handler, void * handler_baton, apr_pool_t pool) -> svn_error_t"""
    return _repos.svn_repos_get_file_revs2(*args)

def svn_repos_get_file_revs(*args) -> "svn_error_t *":
    """svn_repos_get_file_revs(svn_repos_t * repos, char const * path, svn_revnum_t start, svn_revnum_t end, svn_repos_authz_func_t authz_read_func, svn_repos_file_rev_handler_t handler, void * handler_baton, apr_pool_t pool) -> svn_error_t"""
    return _repos.svn_repos_get_file_revs(*args)

def svn_repos_fs_commit_txn(*args) -> "char const **, svn_revnum_t *":
    """svn_repos_fs_commit_txn(svn_repos_t * repos, svn_fs_txn_t * txn, apr_pool_t pool) -> svn_error_t"""
    return _repos.svn_repos_fs_commit_txn(*args)

def svn_repos_fs_begin_txn_for_commit2(*args) -> "svn_fs_txn_t **":
    """svn_repos_fs_begin_txn_for_commit2(svn_repos_t * repos, svn_revnum_t rev, apr_hash_t revprop_table, apr_pool_t pool) -> svn_error_t"""
    return _repos.svn_repos_fs_begin_txn_for_commit2(*args)

def svn_repos_fs_begin_txn_for_commit(*args) -> "svn_fs_txn_t **":
    """svn_repos_fs_begin_txn_for_commit(svn_repos_t * repos, svn_revnum_t rev, char const * author, char const * log_msg, apr_pool_t pool) -> svn_error_t"""
    return _repos.svn_repos_fs_begin_txn_for_commit(*args)

def svn_repos_fs_begin_txn_for_update(*args) -> "svn_fs_txn_t **":
    """svn_repos_fs_begin_txn_for_update(svn_repos_t * repos, svn_revnum_t rev, char const * author, apr_pool_t pool) -> svn_error_t"""
    return _repos.svn_repos_fs_begin_txn_for_update(*args)

def svn_repos_fs_lock_many(*args) -> "svn_error_t *":
    """svn_repos_fs_lock_many(svn_repos_t * repos, apr_hash_t lock_targets, char const * comment, svn_boolean_t is_dav_comment, apr_time_t expiration_date, svn_boolean_t steal_lock, svn_fs_lock_callback_t lock_callback, apr_pool_t result_pool, apr_pool_t scratch_pool) -> svn_error_t"""
    return _repos.svn_repos_fs_lock_many(*args)

def svn_repos_fs_lock(*args) -> "svn_lock_t **":
    """svn_repos_fs_lock(svn_repos_t * repos, char const * path, char const * token, char const * comment, svn_boolean_t is_dav_comment, apr_time_t expiration_date, svn_revnum_t current_rev, svn_boolean_t steal_lock, apr_pool_t pool) -> svn_error_t"""
    return _repos.svn_repos_fs_lock(*args)

def svn_repos_fs_unlock_many(*args) -> "svn_error_t *":
    """svn_repos_fs_unlock_many(svn_repos_t * repos, apr_hash_t unlock_targets, svn_boolean_t break_lock, svn_fs_lock_callback_t lock_callback, apr_pool_t result_pool, apr_pool_t scratch_pool) -> svn_error_t"""
    return _repos.svn_repos_fs_unlock_many(*args)

def svn_repos_fs_unlock(*args) -> "svn_error_t *":
    """svn_repos_fs_unlock(svn_repos_t * repos, char const * path, char const * token, svn_boolean_t break_lock, apr_pool_t pool) -> svn_error_t"""
    return _repos.svn_repos_fs_unlock(*args)

def svn_repos_fs_get_locks2(*args) -> "apr_hash_t **":
    """svn_repos_fs_get_locks2(svn_repos_t * repos, char const * path, svn_depth_t depth, svn_repos_authz_func_t authz_read_func, apr_pool_t pool) -> svn_error_t"""
    return _repos.svn_repos_fs_get_locks2(*args)

def svn_repos_fs_get_locks(*args) -> "apr_hash_t **":
    """svn_repos_fs_get_locks(svn_repos_t * repos, char const * path, svn_repos_authz_func_t authz_read_func, apr_pool_t pool) -> svn_error_t"""
    return _repos.svn_repos_fs_get_locks(*args)

def svn_repos_fs_change_rev_prop4(*args) -> "svn_string_t **":
    """svn_repos_fs_change_rev_prop4(svn_repos_t * repos, svn_revnum_t rev, char const * author, char const * name, svn_string_t const *const * old_value_p, svn_string_t const * new_value, svn_boolean_t use_pre_revprop_change_hook, svn_boolean_t use_post_revprop_change_hook, svn_repos_authz_func_t authz_read_func, apr_pool_t pool) -> svn_error_t"""
    return _repos.svn_repos_fs_change_rev_prop4(*args)

def svn_repos_fs_change_rev_prop3(*args) -> "svn_error_t *":
    """svn_repos_fs_change_rev_prop3(svn_repos_t * repos, svn_revnum_t rev, char const * author, char const * name, svn_string_t const * new_value, svn_boolean_t use_pre_revprop_change_hook, svn_boolean_t use_post_revprop_change_hook, svn_repos_authz_func_t authz_read_func, apr_pool_t pool) -> svn_error_t"""
    return _repos.svn_repos_fs_change_rev_prop3(*args)

def svn_repos_fs_change_rev_prop2(*args) -> "svn_error_t *":
    """svn_repos_fs_change_rev_prop2(svn_repos_t * repos, svn_revnum_t rev, char const * author, char const * name, svn_string_t const * new_value, svn_repos_authz_func_t authz_read_func, apr_pool_t pool) -> svn_error_t"""
    return _repos.svn_repos_fs_change_rev_prop2(*args)

def svn_repos_fs_change_rev_prop(*args) -> "svn_error_t *":
    """svn_repos_fs_change_rev_prop(svn_repos_t * repos, svn_revnum_t rev, char const * author, char const * name, svn_string_t const * new_value, apr_pool_t pool) -> svn_error_t"""
    return _repos.svn_repos_fs_change_rev_prop(*args)

def svn_repos_fs_revision_prop(*args) -> "svn_string_t **":
    """svn_repos_fs_revision_prop(svn_repos_t * repos, svn_revnum_t rev, char const * propname, svn_repos_authz_func_t authz_read_func, apr_pool_t pool) -> svn_error_t"""
    return _repos.svn_repos_fs_revision_prop(*args)

def svn_repos_fs_revision_proplist(*args) -> "apr_hash_t **":
    """svn_repos_fs_revision_proplist(svn_repos_t * repos, svn_revnum_t rev, svn_repos_authz_func_t authz_read_func, apr_pool_t pool) -> svn_error_t"""
    return _repos.svn_repos_fs_revision_proplist(*args)

def svn_repos_fs_change_node_prop(*args) -> "svn_error_t *":
    """svn_repos_fs_change_node_prop(svn_fs_root_t * root, char const * path, char const * name, svn_string_t const * value, apr_pool_t pool) -> svn_error_t"""
    return _repos.svn_repos_fs_change_node_prop(*args)

def svn_repos_fs_get_inherited_props(*args) -> "apr_array_header_t **":
    """svn_repos_fs_get_inherited_props(svn_fs_root_t * root, char const * path, char const * propname, svn_repos_authz_func_t authz_read_func, apr_pool_t result_pool, apr_pool_t scratch_pool) -> svn_error_t"""
    return _repos.svn_repos_fs_get_inherited_props(*args)

def svn_repos_fs_change_txn_prop(*args) -> "svn_error_t *":
    """svn_repos_fs_change_txn_prop(svn_fs_txn_t * txn, char const * name, svn_string_t const * value, apr_pool_t pool) -> svn_error_t"""
    return _repos.svn_repos_fs_change_txn_prop(*args)

def svn_repos_fs_change_txn_props(*args) -> "svn_error_t *":
    """svn_repos_fs_change_txn_props(svn_fs_txn_t * txn, apr_array_header_t props, apr_pool_t pool) -> svn_error_t"""
    return _repos.svn_repos_fs_change_txn_props(*args)
class svn_repos_node_t(object):
    """Proxy of C svn_repos_node_t struct."""

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    kind = _swig_property(_repos.svn_repos_node_t_kind_get, _repos.svn_repos_node_t_kind_set)
    action = _swig_property(_repos.svn_repos_node_t_action_get, _repos.svn_repos_node_t_action_set)
    text_mod = _swig_property(_repos.svn_repos_node_t_text_mod_get, _repos.svn_repos_node_t_text_mod_set)
    prop_mod = _swig_property(_repos.svn_repos_node_t_prop_mod_get, _repos.svn_repos_node_t_prop_mod_set)
    name = _swig_property(_repos.svn_repos_node_t_name_get, _repos.svn_repos_node_t_name_set)
    copyfrom_rev = _swig_property(_repos.svn_repos_node_t_copyfrom_rev_get, _repos.svn_repos_node_t_copyfrom_rev_set)
    copyfrom_path = _swig_property(_repos.svn_repos_node_t_copyfrom_path_get, _repos.svn_repos_node_t_copyfrom_path_set)
    sibling = _swig_property(_repos.svn_repos_node_t_sibling_get, _repos.svn_repos_node_t_sibling_set)
    child = _swig_property(_repos.svn_repos_node_t_child_get, _repos.svn_repos_node_t_child_set)
    parent = _swig_property(_repos.svn_repos_node_t_parent_get, _repos.svn_repos_node_t_parent_set)
    def set_parent_pool(self, parent_pool=None):
      """Create a new proxy object for TYPE"""
      import libsvn.core, weakref
      self.__dict__["_parent_pool"] = \
        parent_pool or libsvn.core.application_pool;
      if self.__dict__["_parent_pool"]:
        self.__dict__["_is_valid"] = weakref.ref(
          self.__dict__["_parent_pool"]._is_valid)

    def assert_valid(self):
      """Assert that this object is using valid pool memory"""
      if "_is_valid" in self.__dict__:
        assert self.__dict__["_is_valid"](), "Variable has already been deleted"

    def _retrieve_swig_value(self, name, value):
    # If we got back a different object than we have cached, we need to copy
    # all our metadata into it, so that it looks identical to the one
    # originally set.
      members = self.__dict__.get('_members')
      if members is not None and name in members:
        _copy_metadata_deep(value, members[name])

    # Verify that the new object is good
      _assert_valid_deep(value)

      return value

    # Attribute access must be intercepted to ensure that objects coming from
    # read attribute access match those that are set with write attribute access.
    # Specifically the metadata, such as the associated apr_pool object, should
    # match the originally assigned object.
    #
    # For classic classes it is enough to use __getattr__ to intercept swig
    # derived attributes. However, with new style classes SWIG makes use of
    # descriptors which mean that __getattr__ is never called. Therefore,
    # __getattribute__ must be used for the interception.

    if _newclass:
      def __getattribute__(self, name):
        """Manage access to all attributes of this object."""

    # Start by mimicing __getattr__ behavior: immediately return __dict__ or
    # items directly present in __dict__
        mydict = object.__getattribute__(self, '__dict__')

        if name == "__dict__":
          return mydict

        if name in mydict:
          return mydict[name]

        object.__getattribute__(self, 'assert_valid')()

        value = _get_instance_attr(self, name)
        fn = object.__getattribute__(self, '_retrieve_swig_value')
        return fn(name, value)
    else:
      def __getattr__(self, name):
        """Get an attribute from this object"""
        self.assert_valid()

        value = _swig_getattr(self, self.__class__, name)

        return self._retrieve_swig_value(name, value)

    def __setattr__(self, name, value):
      """Set an attribute on this object"""
      self.assert_valid()

    # Save a copy of the object, so that the garbage
    # collector won't kill the object while it's in
    # SWIG-land
      self.__dict__.setdefault("_members",{})[name] = value

      return _set_instance_attr(self, name, value)

svn_repos_node_t_swigregister = _repos.svn_repos_node_t_swigregister
svn_repos_node_t_swigregister(svn_repos_node_t)


def svn_repos_node_editor(*args) -> "svn_delta_editor_t const **, void **":
    """svn_repos_node_editor(svn_repos_t * repos, svn_fs_root_t * base_root, svn_fs_root_t * root, apr_pool_t node_pool, apr_pool_t pool) -> svn_error_t"""
    return _repos.svn_repos_node_editor(*args)

def svn_repos_node_from_baton(edit_baton: 'void *') -> "svn_repos_node_t *":
    """svn_repos_node_from_baton(void * edit_baton) -> svn_repos_node_t"""
    return _repos.svn_repos_node_from_baton(edit_baton)

def svn_repos_info_format(*args) -> "int *, SWIGTYPE **":
    """svn_repos_info_format(svn_repos_t * repos, apr_pool_t result_pool, apr_pool_t scratch_pool) -> svn_error_t"""
    return _repos.svn_repos_info_format(*args)
SVN_REPOS_DUMPFILE_MAGIC_HEADER = _repos.SVN_REPOS_DUMPFILE_MAGIC_HEADER
SVN_REPOS_DUMPFILE_FORMAT_VERSION = _repos.SVN_REPOS_DUMPFILE_FORMAT_VERSION
SVN_REPOS_DUMPFILE_FORMAT_VERSION_DELTAS = _repos.SVN_REPOS_DUMPFILE_FORMAT_VERSION_DELTAS
SVN_REPOS_DUMPFILE_UUID = _repos.SVN_REPOS_DUMPFILE_UUID
SVN_REPOS_DUMPFILE_CONTENT_LENGTH = _repos.SVN_REPOS_DUMPFILE_CONTENT_LENGTH
SVN_REPOS_DUMPFILE_REVISION_NUMBER = _repos.SVN_REPOS_DUMPFILE_REVISION_NUMBER
SVN_REPOS_DUMPFILE_NODE_PATH = _repos.SVN_REPOS_DUMPFILE_NODE_PATH
SVN_REPOS_DUMPFILE_NODE_KIND = _repos.SVN_REPOS_DUMPFILE_NODE_KIND
SVN_REPOS_DUMPFILE_NODE_ACTION = _repos.SVN_REPOS_DUMPFILE_NODE_ACTION
SVN_REPOS_DUMPFILE_NODE_COPYFROM_PATH = _repos.SVN_REPOS_DUMPFILE_NODE_COPYFROM_PATH
SVN_REPOS_DUMPFILE_NODE_COPYFROM_REV = _repos.SVN_REPOS_DUMPFILE_NODE_COPYFROM_REV
SVN_REPOS_DUMPFILE_TEXT_COPY_SOURCE_MD5 = _repos.SVN_REPOS_DUMPFILE_TEXT_COPY_SOURCE_MD5
SVN_REPOS_DUMPFILE_TEXT_COPY_SOURCE_SHA1 = _repos.SVN_REPOS_DUMPFILE_TEXT_COPY_SOURCE_SHA1
SVN_REPOS_DUMPFILE_TEXT_COPY_SOURCE_CHECKSUM = _repos.SVN_REPOS_DUMPFILE_TEXT_COPY_SOURCE_CHECKSUM
SVN_REPOS_DUMPFILE_TEXT_CONTENT_MD5 = _repos.SVN_REPOS_DUMPFILE_TEXT_CONTENT_MD5
SVN_REPOS_DUMPFILE_TEXT_CONTENT_SHA1 = _repos.SVN_REPOS_DUMPFILE_TEXT_CONTENT_SHA1
SVN_REPOS_DUMPFILE_TEXT_CONTENT_CHECKSUM = _repos.SVN_REPOS_DUMPFILE_TEXT_CONTENT_CHECKSUM
SVN_REPOS_DUMPFILE_PROP_CONTENT_LENGTH = _repos.SVN_REPOS_DUMPFILE_PROP_CONTENT_LENGTH
SVN_REPOS_DUMPFILE_TEXT_CONTENT_LENGTH = _repos.SVN_REPOS_DUMPFILE_TEXT_CONTENT_LENGTH
SVN_REPOS_DUMPFILE_PROP_DELTA = _repos.SVN_REPOS_DUMPFILE_PROP_DELTA
SVN_REPOS_DUMPFILE_TEXT_DELTA = _repos.SVN_REPOS_DUMPFILE_TEXT_DELTA
SVN_REPOS_DUMPFILE_TEXT_DELTA_BASE_MD5 = _repos.SVN_REPOS_DUMPFILE_TEXT_DELTA_BASE_MD5
SVN_REPOS_DUMPFILE_TEXT_DELTA_BASE_SHA1 = _repos.SVN_REPOS_DUMPFILE_TEXT_DELTA_BASE_SHA1
SVN_REPOS_DUMPFILE_TEXT_DELTA_BASE_CHECKSUM = _repos.SVN_REPOS_DUMPFILE_TEXT_DELTA_BASE_CHECKSUM
svn_repos_load_uuid_default = _repos.svn_repos_load_uuid_default
svn_repos_load_uuid_ignore = _repos.svn_repos_load_uuid_ignore
svn_repos_load_uuid_force = _repos.svn_repos_load_uuid_force

def svn_repos_verify_fs3(*args) -> "svn_error_t *":
    """svn_repos_verify_fs3(svn_repos_t * repos, svn_revnum_t start_rev, svn_revnum_t end_rev, svn_boolean_t check_normalization, svn_boolean_t metadata_only, svn_repos_notify_func_t notify_func, void * notify_baton, svn_repos_verify_callback_t verify_callback, void * verify_baton, svn_cancel_func_t cancel, void * cancel_baton, apr_pool_t scratch_pool) -> svn_error_t"""
    return _repos.svn_repos_verify_fs3(*args)

def svn_repos_verify_fs2(*args) -> "svn_error_t *":
    """svn_repos_verify_fs2(svn_repos_t * repos, svn_revnum_t start_rev, svn_revnum_t end_rev, svn_repos_notify_func_t notify_func, void * notify_baton, svn_cancel_func_t cancel, void * cancel_baton, apr_pool_t scratch_pool) -> svn_error_t"""
    return _repos.svn_repos_verify_fs2(*args)

def svn_repos_verify_fs(*args) -> "svn_error_t *":
    """svn_repos_verify_fs(svn_repos_t * repos, svn_stream_t * feedback_stream, svn_revnum_t start_rev, svn_revnum_t end_rev, svn_cancel_func_t cancel_func, apr_pool_t pool) -> svn_error_t"""
    return _repos.svn_repos_verify_fs(*args)

def svn_repos_dump_fs4(*args) -> "svn_error_t *":
    """svn_repos_dump_fs4(svn_repos_t * repos, svn_stream_t * stream, svn_revnum_t start_rev, svn_revnum_t end_rev, svn_boolean_t incremental, svn_boolean_t use_deltas, svn_boolean_t include_revprops, svn_boolean_t include_changes, svn_repos_notify_func_t notify_func, void * notify_baton, svn_repos_dump_filter_func_t filter_func, void * filter_baton, svn_cancel_func_t cancel_func, apr_pool_t pool) -> svn_error_t"""
    return _repos.svn_repos_dump_fs4(*args)

def svn_repos_dump_fs3(*args) -> "svn_error_t *":
    """svn_repos_dump_fs3(svn_repos_t * repos, svn_stream_t * dumpstream, svn_revnum_t start_rev, svn_revnum_t end_rev, svn_boolean_t incremental, svn_boolean_t use_deltas, svn_repos_notify_func_t notify_func, void * notify_baton, svn_cancel_func_t cancel_func, apr_pool_t scratch_pool) -> svn_error_t"""
    return _repos.svn_repos_dump_fs3(*args)

def svn_repos_dump_fs2(*args) -> "svn_error_t *":
    """svn_repos_dump_fs2(svn_repos_t * repos, svn_stream_t * dumpstream, svn_stream_t * feedback_stream, svn_revnum_t start_rev, svn_revnum_t end_rev, svn_boolean_t incremental, svn_boolean_t use_deltas, svn_cancel_func_t cancel_func, apr_pool_t pool) -> svn_error_t"""
    return _repos.svn_repos_dump_fs2(*args)

def svn_repos_dump_fs(*args) -> "svn_error_t *":
    """svn_repos_dump_fs(svn_repos_t * repos, svn_stream_t * dumpstream, svn_stream_t * feedback_stream, svn_revnum_t start_rev, svn_revnum_t end_rev, svn_boolean_t incremental, svn_cancel_func_t cancel_func, apr_pool_t pool) -> svn_error_t"""
    return _repos.svn_repos_dump_fs(*args)

def svn_repos_load_fs6(*args) -> "svn_error_t *":
    """svn_repos_load_fs6(svn_repos_t * repos, svn_stream_t * dumpstream, svn_revnum_t start_rev, svn_revnum_t end_rev, enum svn_repos_load_uuid uuid_action, char const * parent_dir, svn_boolean_t use_pre_commit_hook, svn_boolean_t use_post_commit_hook, svn_boolean_t validate_props, svn_boolean_t ignore_dates, svn_boolean_t normalize_props, svn_repos_notify_func_t notify_func, void * notify_baton, svn_cancel_func_t cancel_func, apr_pool_t pool) -> svn_error_t"""
    return _repos.svn_repos_load_fs6(*args)

def svn_repos_load_fs5(*args) -> "svn_error_t *":
    """svn_repos_load_fs5(svn_repos_t * repos, svn_stream_t * dumpstream, svn_revnum_t start_rev, svn_revnum_t end_rev, enum svn_repos_load_uuid uuid_action, char const * parent_dir, svn_boolean_t use_pre_commit_hook, svn_boolean_t use_post_commit_hook, svn_boolean_t validate_props, svn_boolean_t ignore_dates, svn_repos_notify_func_t notify_func, void * notify_baton, svn_cancel_func_t cancel_func, apr_pool_t pool) -> svn_error_t"""
    return _repos.svn_repos_load_fs5(*args)

def svn_repos_load_fs4(*args) -> "svn_error_t *":
    """svn_repos_load_fs4(svn_repos_t * repos, svn_stream_t * dumpstream, svn_revnum_t start_rev, svn_revnum_t end_rev, enum svn_repos_load_uuid uuid_action, char const * parent_dir, svn_boolean_t use_pre_commit_hook, svn_boolean_t use_post_commit_hook, svn_boolean_t validate_props, svn_repos_notify_func_t notify_func, void * notify_baton, svn_cancel_func_t cancel_func, apr_pool_t pool) -> svn_error_t"""
    return _repos.svn_repos_load_fs4(*args)

def svn_repos_load_fs3(*args) -> "svn_error_t *":
    """svn_repos_load_fs3(svn_repos_t * repos, svn_stream_t * dumpstream, enum svn_repos_load_uuid uuid_action, char const * parent_dir, svn_boolean_t use_pre_commit_hook, svn_boolean_t use_post_commit_hook, svn_boolean_t validate_props, svn_repos_notify_func_t notify_func, void * notify_baton, svn_cancel_func_t cancel_func, apr_pool_t pool) -> svn_error_t"""
    return _repos.svn_repos_load_fs3(*args)

def svn_repos_load_fs2(*args) -> "svn_error_t *":
    """svn_repos_load_fs2(svn_repos_t * repos, svn_stream_t * dumpstream, svn_stream_t * feedback_stream, enum svn_repos_load_uuid uuid_action, char const * parent_dir, svn_boolean_t use_pre_commit_hook, svn_boolean_t use_post_commit_hook, svn_cancel_func_t cancel_func, apr_pool_t pool) -> svn_error_t"""
    return _repos.svn_repos_load_fs2(*args)

def svn_repos_load_fs(*args) -> "svn_error_t *":
    """svn_repos_load_fs(svn_repos_t * repos, svn_stream_t * dumpstream, svn_stream_t * feedback_stream, enum svn_repos_load_uuid uuid_action, char const * parent_dir, svn_cancel_func_t cancel_func, apr_pool_t pool) -> svn_error_t"""
    return _repos.svn_repos_load_fs(*args)

def svn_repos_load_fs_revprops(*args) -> "svn_error_t *":
    """svn_repos_load_fs_revprops(svn_repos_t * repos, svn_stream_t * dumpstream, svn_revnum_t start_rev, svn_revnum_t end_rev, svn_boolean_t validate_props, svn_boolean_t ignore_dates, svn_boolean_t normalize_props, svn_repos_notify_func_t notify_func, void * notify_baton, svn_cancel_func_t cancel_func, apr_pool_t scratch_pool) -> svn_error_t"""
    return _repos.svn_repos_load_fs_revprops(*args)
class svn_repos_parse_fns3_t(object):
    """Proxy of C svn_repos_parse_fns3_t struct."""

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    magic_header_record = _swig_property(_repos.svn_repos_parse_fns3_t_magic_header_record_get, _repos.svn_repos_parse_fns3_t_magic_header_record_set)
    uuid_record = _swig_property(_repos.svn_repos_parse_fns3_t_uuid_record_get, _repos.svn_repos_parse_fns3_t_uuid_record_set)
    new_revision_record = _swig_property(_repos.svn_repos_parse_fns3_t_new_revision_record_get, _repos.svn_repos_parse_fns3_t_new_revision_record_set)
    new_node_record = _swig_property(_repos.svn_repos_parse_fns3_t_new_node_record_get, _repos.svn_repos_parse_fns3_t_new_node_record_set)
    set_revision_property = _swig_property(_repos.svn_repos_parse_fns3_t_set_revision_property_get, _repos.svn_repos_parse_fns3_t_set_revision_property_set)
    set_node_property = _swig_property(_repos.svn_repos_parse_fns3_t_set_node_property_get, _repos.svn_repos_parse_fns3_t_set_node_property_set)
    delete_node_property = _swig_property(_repos.svn_repos_parse_fns3_t_delete_node_property_get, _repos.svn_repos_parse_fns3_t_delete_node_property_set)
    remove_node_props = _swig_property(_repos.svn_repos_parse_fns3_t_remove_node_props_get, _repos.svn_repos_parse_fns3_t_remove_node_props_set)
    set_fulltext = _swig_property(_repos.svn_repos_parse_fns3_t_set_fulltext_get, _repos.svn_repos_parse_fns3_t_set_fulltext_set)
    apply_textdelta = _swig_property(_repos.svn_repos_parse_fns3_t_apply_textdelta_get, _repos.svn_repos_parse_fns3_t_apply_textdelta_set)
    close_node = _swig_property(_repos.svn_repos_parse_fns3_t_close_node_get, _repos.svn_repos_parse_fns3_t_close_node_set)
    close_revision = _swig_property(_repos.svn_repos_parse_fns3_t_close_revision_get, _repos.svn_repos_parse_fns3_t_close_revision_set)
    def set_parent_pool(self, parent_pool=None):
      """Create a new proxy object for TYPE"""
      import libsvn.core, weakref
      self.__dict__["_parent_pool"] = \
        parent_pool or libsvn.core.application_pool;
      if self.__dict__["_parent_pool"]:
        self.__dict__["_is_valid"] = weakref.ref(
          self.__dict__["_parent_pool"]._is_valid)

    def assert_valid(self):
      """Assert that this object is using valid pool memory"""
      if "_is_valid" in self.__dict__:
        assert self.__dict__["_is_valid"](), "Variable has already been deleted"

    def _retrieve_swig_value(self, name, value):
    # If we got back a different object than we have cached, we need to copy
    # all our metadata into it, so that it looks identical to the one
    # originally set.
      members = self.__dict__.get('_members')
      if members is not None and name in members:
        _copy_metadata_deep(value, members[name])

    # Verify that the new object is good
      _assert_valid_deep(value)

      return value

    # Attribute access must be intercepted to ensure that objects coming from
    # read attribute access match those that are set with write attribute access.
    # Specifically the metadata, such as the associated apr_pool object, should
    # match the originally assigned object.
    #
    # For classic classes it is enough to use __getattr__ to intercept swig
    # derived attributes. However, with new style classes SWIG makes use of
    # descriptors which mean that __getattr__ is never called. Therefore,
    # __getattribute__ must be used for the interception.

    if _newclass:
      def __getattribute__(self, name):
        """Manage access to all attributes of this object."""

    # Start by mimicing __getattr__ behavior: immediately return __dict__ or
    # items directly present in __dict__
        mydict = object.__getattribute__(self, '__dict__')

        if name == "__dict__":
          return mydict

        if name in mydict:
          return mydict[name]

        object.__getattribute__(self, 'assert_valid')()

        value = _get_instance_attr(self, name)
        fn = object.__getattribute__(self, '_retrieve_swig_value')
        return fn(name, value)
    else:
      def __getattr__(self, name):
        """Get an attribute from this object"""
        self.assert_valid()

        value = _swig_getattr(self, self.__class__, name)

        return self._retrieve_swig_value(name, value)

    def __setattr__(self, name, value):
      """Set an attribute on this object"""
      self.assert_valid()

    # Save a copy of the object, so that the garbage
    # collector won't kill the object while it's in
    # SWIG-land
      self.__dict__.setdefault("_members",{})[name] = value

      return _set_instance_attr(self, name, value)


    def magic_header_record(self, *args):
      return svn_repos_parse_fns3_invoke_magic_header_record(self, *args)


    def uuid_record(self, *args):
      return svn_repos_parse_fns3_invoke_uuid_record(self, *args)


    def new_revision_record(self, *args):
      return svn_repos_parse_fns3_invoke_new_revision_record(self, *args)


    def new_node_record(self, *args):
      return svn_repos_parse_fns3_invoke_new_node_record(self, *args)


    def set_revision_property(self, *args):
      return svn_repos_parse_fns3_invoke_set_revision_property(self, *args)


    def set_node_property(self, *args):
      return svn_repos_parse_fns3_invoke_set_node_property(self, *args)


    def delete_node_property(self, *args):
      return svn_repos_parse_fns3_invoke_delete_node_property(self, *args)


    def remove_node_props(self, *args):
      return svn_repos_parse_fns3_invoke_remove_node_props(self, *args)


    def set_fulltext(self, *args):
      return svn_repos_parse_fns3_invoke_set_fulltext(self, *args)


    def apply_textdelta(self, *args):
      return svn_repos_parse_fns3_invoke_apply_textdelta(self, *args)


    def close_node(self, *args):
      return svn_repos_parse_fns3_invoke_close_node(self, *args)


    def close_revision(self, *args):
      return svn_repos_parse_fns3_invoke_close_revision(self, *args)

svn_repos_parse_fns3_t_swigregister = _repos.svn_repos_parse_fns3_t_swigregister
svn_repos_parse_fns3_t_swigregister(svn_repos_parse_fns3_t)


def svn_repos_parse_dumpstream3(*args) -> "svn_error_t *":
    """svn_repos_parse_dumpstream3(svn_stream_t * stream, svn_repos_parse_fns3_t parse_fns, void * parse_baton, svn_boolean_t deltas_are_text, svn_cancel_func_t cancel_func, apr_pool_t pool) -> svn_error_t"""
    return _repos.svn_repos_parse_dumpstream3(*args)

def svn_repos_get_fs_build_parser6(*args) -> "svn_repos_parse_fns3_t const **, void **":
    """svn_repos_get_fs_build_parser6(svn_repos_t * repos, svn_revnum_t start_rev, svn_revnum_t end_rev, svn_boolean_t use_history, svn_boolean_t validate_props, enum svn_repos_load_uuid uuid_action, char const * parent_dir, svn_boolean_t use_pre_commit_hook, svn_boolean_t use_post_commit_hook, svn_boolean_t ignore_dates, svn_boolean_t normalize_props, svn_repos_notify_func_t notify_func, void * notify_baton, apr_pool_t pool) -> svn_error_t"""
    return _repos.svn_repos_get_fs_build_parser6(*args)

def svn_repos_get_fs_build_parser5(*args) -> "svn_repos_parse_fns3_t const **, void **":
    """svn_repos_get_fs_build_parser5(svn_repos_t * repos, svn_revnum_t start_rev, svn_revnum_t end_rev, svn_boolean_t use_history, svn_boolean_t validate_props, enum svn_repos_load_uuid uuid_action, char const * parent_dir, svn_boolean_t use_pre_commit_hook, svn_boolean_t use_post_commit_hook, svn_boolean_t ignore_dates, svn_repos_notify_func_t notify_func, void * notify_baton, apr_pool_t pool) -> svn_error_t"""
    return _repos.svn_repos_get_fs_build_parser5(*args)

def svn_repos_get_fs_build_parser4(*args) -> "svn_repos_parse_fns3_t const **, void **":
    """svn_repos_get_fs_build_parser4(svn_repos_t * repos, svn_revnum_t start_rev, svn_revnum_t end_rev, svn_boolean_t use_history, svn_boolean_t validate_props, enum svn_repos_load_uuid uuid_action, char const * parent_dir, svn_repos_notify_func_t notify_func, void * notify_baton, apr_pool_t pool) -> svn_error_t"""
    return _repos.svn_repos_get_fs_build_parser4(*args)
class svn_repos_parse_fns2_t(object):
    """Proxy of C svn_repos_parse_fns2_t struct."""

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    new_revision_record = _swig_property(_repos.svn_repos_parse_fns2_t_new_revision_record_get, _repos.svn_repos_parse_fns2_t_new_revision_record_set)
    uuid_record = _swig_property(_repos.svn_repos_parse_fns2_t_uuid_record_get, _repos.svn_repos_parse_fns2_t_uuid_record_set)
    new_node_record = _swig_property(_repos.svn_repos_parse_fns2_t_new_node_record_get, _repos.svn_repos_parse_fns2_t_new_node_record_set)
    set_revision_property = _swig_property(_repos.svn_repos_parse_fns2_t_set_revision_property_get, _repos.svn_repos_parse_fns2_t_set_revision_property_set)
    set_node_property = _swig_property(_repos.svn_repos_parse_fns2_t_set_node_property_get, _repos.svn_repos_parse_fns2_t_set_node_property_set)
    delete_node_property = _swig_property(_repos.svn_repos_parse_fns2_t_delete_node_property_get, _repos.svn_repos_parse_fns2_t_delete_node_property_set)
    remove_node_props = _swig_property(_repos.svn_repos_parse_fns2_t_remove_node_props_get, _repos.svn_repos_parse_fns2_t_remove_node_props_set)
    set_fulltext = _swig_property(_repos.svn_repos_parse_fns2_t_set_fulltext_get, _repos.svn_repos_parse_fns2_t_set_fulltext_set)
    apply_textdelta = _swig_property(_repos.svn_repos_parse_fns2_t_apply_textdelta_get, _repos.svn_repos_parse_fns2_t_apply_textdelta_set)
    close_node = _swig_property(_repos.svn_repos_parse_fns2_t_close_node_get, _repos.svn_repos_parse_fns2_t_close_node_set)
    close_revision = _swig_property(_repos.svn_repos_parse_fns2_t_close_revision_get, _repos.svn_repos_parse_fns2_t_close_revision_set)
    def set_parent_pool(self, parent_pool=None):
      """Create a new proxy object for TYPE"""
      import libsvn.core, weakref
      self.__dict__["_parent_pool"] = \
        parent_pool or libsvn.core.application_pool;
      if self.__dict__["_parent_pool"]:
        self.__dict__["_is_valid"] = weakref.ref(
          self.__dict__["_parent_pool"]._is_valid)

    def assert_valid(self):
      """Assert that this object is using valid pool memory"""
      if "_is_valid" in self.__dict__:
        assert self.__dict__["_is_valid"](), "Variable has already been deleted"

    def _retrieve_swig_value(self, name, value):
    # If we got back a different object than we have cached, we need to copy
    # all our metadata into it, so that it looks identical to the one
    # originally set.
      members = self.__dict__.get('_members')
      if members is not None and name in members:
        _copy_metadata_deep(value, members[name])

    # Verify that the new object is good
      _assert_valid_deep(value)

      return value

    # Attribute access must be intercepted to ensure that objects coming from
    # read attribute access match those that are set with write attribute access.
    # Specifically the metadata, such as the associated apr_pool object, should
    # match the originally assigned object.
    #
    # For classic classes it is enough to use __getattr__ to intercept swig
    # derived attributes. However, with new style classes SWIG makes use of
    # descriptors which mean that __getattr__ is never called. Therefore,
    # __getattribute__ must be used for the interception.

    if _newclass:
      def __getattribute__(self, name):
        """Manage access to all attributes of this object."""

    # Start by mimicing __getattr__ behavior: immediately return __dict__ or
    # items directly present in __dict__
        mydict = object.__getattribute__(self, '__dict__')

        if name == "__dict__":
          return mydict

        if name in mydict:
          return mydict[name]

        object.__getattribute__(self, 'assert_valid')()

        value = _get_instance_attr(self, name)
        fn = object.__getattribute__(self, '_retrieve_swig_value')
        return fn(name, value)
    else:
      def __getattr__(self, name):
        """Get an attribute from this object"""
        self.assert_valid()

        value = _swig_getattr(self, self.__class__, name)

        return self._retrieve_swig_value(name, value)

    def __setattr__(self, name, value):
      """Set an attribute on this object"""
      self.assert_valid()

    # Save a copy of the object, so that the garbage
    # collector won't kill the object while it's in
    # SWIG-land
      self.__dict__.setdefault("_members",{})[name] = value

      return _set_instance_attr(self, name, value)


    def new_revision_record(self, *args):
      return svn_repos_parse_fns2_invoke_new_revision_record(self, *args)


    def uuid_record(self, *args):
      return svn_repos_parse_fns2_invoke_uuid_record(self, *args)


    def new_node_record(self, *args):
      return svn_repos_parse_fns2_invoke_new_node_record(self, *args)


    def set_revision_property(self, *args):
      return svn_repos_parse_fns2_invoke_set_revision_property(self, *args)


    def set_node_property(self, *args):
      return svn_repos_parse_fns2_invoke_set_node_property(self, *args)


    def delete_node_property(self, *args):
      return svn_repos_parse_fns2_invoke_delete_node_property(self, *args)


    def remove_node_props(self, *args):
      return svn_repos_parse_fns2_invoke_remove_node_props(self, *args)


    def set_fulltext(self, *args):
      return svn_repos_parse_fns2_invoke_set_fulltext(self, *args)


    def apply_textdelta(self, *args):
      return svn_repos_parse_fns2_invoke_apply_textdelta(self, *args)


    def close_node(self, *args):
      return svn_repos_parse_fns2_invoke_close_node(self, *args)


    def close_revision(self, *args):
      return svn_repos_parse_fns2_invoke_close_revision(self, *args)

svn_repos_parse_fns2_t_swigregister = _repos.svn_repos_parse_fns2_t_swigregister
svn_repos_parse_fns2_t_swigregister(svn_repos_parse_fns2_t)

class svn_repos_parser_fns_t(object):
    """Proxy of C svn_repos_parse_fns_t struct."""

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    new_revision_record = _swig_property(_repos.svn_repos_parser_fns_t_new_revision_record_get, _repos.svn_repos_parser_fns_t_new_revision_record_set)
    uuid_record = _swig_property(_repos.svn_repos_parser_fns_t_uuid_record_get, _repos.svn_repos_parser_fns_t_uuid_record_set)
    new_node_record = _swig_property(_repos.svn_repos_parser_fns_t_new_node_record_get, _repos.svn_repos_parser_fns_t_new_node_record_set)
    set_revision_property = _swig_property(_repos.svn_repos_parser_fns_t_set_revision_property_get, _repos.svn_repos_parser_fns_t_set_revision_property_set)
    set_node_property = _swig_property(_repos.svn_repos_parser_fns_t_set_node_property_get, _repos.svn_repos_parser_fns_t_set_node_property_set)
    remove_node_props = _swig_property(_repos.svn_repos_parser_fns_t_remove_node_props_get, _repos.svn_repos_parser_fns_t_remove_node_props_set)
    set_fulltext = _swig_property(_repos.svn_repos_parser_fns_t_set_fulltext_get, _repos.svn_repos_parser_fns_t_set_fulltext_set)
    close_node = _swig_property(_repos.svn_repos_parser_fns_t_close_node_get, _repos.svn_repos_parser_fns_t_close_node_set)
    close_revision = _swig_property(_repos.svn_repos_parser_fns_t_close_revision_get, _repos.svn_repos_parser_fns_t_close_revision_set)
    def set_parent_pool(self, parent_pool=None):
      """Create a new proxy object for TYPE"""
      import libsvn.core, weakref
      self.__dict__["_parent_pool"] = \
        parent_pool or libsvn.core.application_pool;
      if self.__dict__["_parent_pool"]:
        self.__dict__["_is_valid"] = weakref.ref(
          self.__dict__["_parent_pool"]._is_valid)

    def assert_valid(self):
      """Assert that this object is using valid pool memory"""
      if "_is_valid" in self.__dict__:
        assert self.__dict__["_is_valid"](), "Variable has already been deleted"

    def _retrieve_swig_value(self, name, value):
    # If we got back a different object than we have cached, we need to copy
    # all our metadata into it, so that it looks identical to the one
    # originally set.
      members = self.__dict__.get('_members')
      if members is not None and name in members:
        _copy_metadata_deep(value, members[name])

    # Verify that the new object is good
      _assert_valid_deep(value)

      return value

    # Attribute access must be intercepted to ensure that objects coming from
    # read attribute access match those that are set with write attribute access.
    # Specifically the metadata, such as the associated apr_pool object, should
    # match the originally assigned object.
    #
    # For classic classes it is enough to use __getattr__ to intercept swig
    # derived attributes. However, with new style classes SWIG makes use of
    # descriptors which mean that __getattr__ is never called. Therefore,
    # __getattribute__ must be used for the interception.

    if _newclass:
      def __getattribute__(self, name):
        """Manage access to all attributes of this object."""

    # Start by mimicing __getattr__ behavior: immediately return __dict__ or
    # items directly present in __dict__
        mydict = object.__getattribute__(self, '__dict__')

        if name == "__dict__":
          return mydict

        if name in mydict:
          return mydict[name]

        object.__getattribute__(self, 'assert_valid')()

        value = _get_instance_attr(self, name)
        fn = object.__getattribute__(self, '_retrieve_swig_value')
        return fn(name, value)
    else:
      def __getattr__(self, name):
        """Get an attribute from this object"""
        self.assert_valid()

        value = _swig_getattr(self, self.__class__, name)

        return self._retrieve_swig_value(name, value)

    def __setattr__(self, name, value):
      """Set an attribute on this object"""
      self.assert_valid()

    # Save a copy of the object, so that the garbage
    # collector won't kill the object while it's in
    # SWIG-land
      self.__dict__.setdefault("_members",{})[name] = value

      return _set_instance_attr(self, name, value)

svn_repos_parser_fns_t_swigregister = _repos.svn_repos_parser_fns_t_swigregister
svn_repos_parser_fns_t_swigregister(svn_repos_parser_fns_t)


def svn_repos_parse_dumpstream2(*args) -> "svn_error_t *":
    """svn_repos_parse_dumpstream2(svn_stream_t * stream, svn_repos_parse_fns2_t parse_fns, void * parse_baton, svn_cancel_func_t cancel_func, apr_pool_t pool) -> svn_error_t"""
    return _repos.svn_repos_parse_dumpstream2(*args)

def svn_repos_parse_dumpstream(*args) -> "svn_error_t *":
    """svn_repos_parse_dumpstream(svn_stream_t * stream, svn_repos_parser_fns_t parse_fns, void * parse_baton, svn_cancel_func_t cancel_func, apr_pool_t pool) -> svn_error_t"""
    return _repos.svn_repos_parse_dumpstream(*args)

def svn_repos_get_fs_build_parser3(*args) -> "SWIGTYPE **, void **":
    """svn_repos_get_fs_build_parser3(svn_repos_t * repos, svn_boolean_t use_history, svn_boolean_t validate_props, enum svn_repos_load_uuid uuid_action, char const * parent_dir, svn_repos_notify_func_t notify_func, void * notify_baton, apr_pool_t pool) -> svn_error_t"""
    return _repos.svn_repos_get_fs_build_parser3(*args)

def svn_repos_get_fs_build_parser2(*args) -> "SWIGTYPE **, void **":
    """svn_repos_get_fs_build_parser2(svn_repos_t * repos, svn_boolean_t use_history, enum svn_repos_load_uuid uuid_action, svn_stream_t * outstream, char const * parent_dir, apr_pool_t pool) -> svn_error_t"""
    return _repos.svn_repos_get_fs_build_parser2(*args)

def svn_repos_get_fs_build_parser(*args) -> "svn_repos_parser_fns_t const **, void **":
    """svn_repos_get_fs_build_parser(svn_repos_t * repos, svn_boolean_t use_history, enum svn_repos_load_uuid uuid_action, svn_stream_t * outstream, char const * parent_dir, apr_pool_t pool) -> svn_error_t"""
    return _repos.svn_repos_get_fs_build_parser(*args)

def svn_repos_authz_initialize(*args) -> "svn_error_t *":
    """svn_repos_authz_initialize(apr_pool_t pool) -> svn_error_t"""
    return _repos.svn_repos_authz_initialize(*args)

def svn_repos_authz_read4(*args) -> "svn_authz_t **":
    """svn_repos_authz_read4(char const * path, char const * groups_path, svn_boolean_t must_exist, svn_repos_t * repos_hint, svn_repos_authz_warning_func_t warning_func, void * warning_baton, apr_pool_t result_pool, apr_pool_t scratch_pool) -> svn_error_t"""
    return _repos.svn_repos_authz_read4(*args)

def svn_repos_authz_read3(*args) -> "svn_authz_t **":
    """svn_repos_authz_read3(char const * path, char const * groups_path, svn_boolean_t must_exist, svn_repos_t * repos_hint, apr_pool_t result_pool, apr_pool_t scratch_pool) -> svn_error_t"""
    return _repos.svn_repos_authz_read3(*args)

def svn_repos_authz_read2(*args) -> "svn_authz_t **":
    """svn_repos_authz_read2(char const * path, char const * groups_path, svn_boolean_t must_exist, apr_pool_t pool) -> svn_error_t"""
    return _repos.svn_repos_authz_read2(*args)

def svn_repos_authz_read(*args) -> "svn_authz_t **":
    """svn_repos_authz_read(char const * file, svn_boolean_t must_exist, apr_pool_t pool) -> svn_error_t"""
    return _repos.svn_repos_authz_read(*args)

def svn_repos_authz_parse2(*args) -> "svn_authz_t **":
    """svn_repos_authz_parse2(svn_stream_t * stream, svn_stream_t * groups_stream, svn_repos_authz_warning_func_t warning_func, void * warning_baton, apr_pool_t result_pool, apr_pool_t scratch_pool) -> svn_error_t"""
    return _repos.svn_repos_authz_parse2(*args)

def svn_repos_authz_parse(*args) -> "svn_authz_t **":
    """svn_repos_authz_parse(svn_stream_t * stream, svn_stream_t * groups_stream, apr_pool_t pool) -> svn_error_t"""
    return _repos.svn_repos_authz_parse(*args)

def svn_repos_authz_check_access(*args) -> "svn_boolean_t *":
    """svn_repos_authz_check_access(svn_authz_t * authz, char const * repos_name, char const * path, char const * user, svn_repos_authz_access_t required_access, apr_pool_t pool) -> svn_error_t"""
    return _repos.svn_repos_authz_check_access(*args)
svn_repos_revision_access_none = _repos.svn_repos_revision_access_none
svn_repos_revision_access_partial = _repos.svn_repos_revision_access_partial
svn_repos_revision_access_full = _repos.svn_repos_revision_access_full

def svn_repos_check_revision_access(*args) -> "svn_error_t *":
    """svn_repos_check_revision_access(svn_repos_revision_access_level_t * access_level, svn_repos_t * repos, svn_revnum_t revision, svn_repos_authz_func_t authz_read_func, apr_pool_t pool) -> svn_error_t"""
    return _repos.svn_repos_check_revision_access(*args)
class svn_repos_t(object):
    """Proxy of C svn_repos_t struct."""

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    def set_parent_pool(self, parent_pool=None):
      """Create a new proxy object for TYPE"""
      import libsvn.core, weakref
      self.__dict__["_parent_pool"] = \
        parent_pool or libsvn.core.application_pool;
      if self.__dict__["_parent_pool"]:
        self.__dict__["_is_valid"] = weakref.ref(
          self.__dict__["_parent_pool"]._is_valid)

    def assert_valid(self):
      """Assert that this object is using valid pool memory"""
      if "_is_valid" in self.__dict__:
        assert self.__dict__["_is_valid"](), "Variable has already been deleted"

    def _retrieve_swig_value(self, name, value):
    # If we got back a different object than we have cached, we need to copy
    # all our metadata into it, so that it looks identical to the one
    # originally set.
      members = self.__dict__.get('_members')
      if members is not None and name in members:
        _copy_metadata_deep(value, members[name])

    # Verify that the new object is good
      _assert_valid_deep(value)

      return value

    # Attribute access must be intercepted to ensure that objects coming from
    # read attribute access match those that are set with write attribute access.
    # Specifically the metadata, such as the associated apr_pool object, should
    # match the originally assigned object.
    #
    # For classic classes it is enough to use __getattr__ to intercept swig
    # derived attributes. However, with new style classes SWIG makes use of
    # descriptors which mean that __getattr__ is never called. Therefore,
    # __getattribute__ must be used for the interception.

    if _newclass:
      def __getattribute__(self, name):
        """Manage access to all attributes of this object."""

    # Start by mimicing __getattr__ behavior: immediately return __dict__ or
    # items directly present in __dict__
        mydict = object.__getattribute__(self, '__dict__')

        if name == "__dict__":
          return mydict

        if name in mydict:
          return mydict[name]

        object.__getattribute__(self, 'assert_valid')()

        value = _get_instance_attr(self, name)
        fn = object.__getattribute__(self, '_retrieve_swig_value')
        return fn(name, value)
    else:
      def __getattr__(self, name):
        """Get an attribute from this object"""
        self.assert_valid()

        value = _swig_getattr(self, self.__class__, name)

        return self._retrieve_swig_value(name, value)

    def __setattr__(self, name, value):
      """Set an attribute on this object"""
      self.assert_valid()

    # Save a copy of the object, so that the garbage
    # collector won't kill the object while it's in
    # SWIG-land
      self.__dict__.setdefault("_members",{})[name] = value

      return _set_instance_attr(self, name, value)

svn_repos_t_swigregister = _repos.svn_repos_t_swigregister
svn_repos_t_swigregister(svn_repos_t)

class svn_authz_t(object):
    """Proxy of C svn_authz_t struct."""

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    def set_parent_pool(self, parent_pool=None):
      """Create a new proxy object for TYPE"""
      import libsvn.core, weakref
      self.__dict__["_parent_pool"] = \
        parent_pool or libsvn.core.application_pool;
      if self.__dict__["_parent_pool"]:
        self.__dict__["_is_valid"] = weakref.ref(
          self.__dict__["_parent_pool"]._is_valid)

    def assert_valid(self):
      """Assert that this object is using valid pool memory"""
      if "_is_valid" in self.__dict__:
        assert self.__dict__["_is_valid"](), "Variable has already been deleted"

    def _retrieve_swig_value(self, name, value):
    # If we got back a different object than we have cached, we need to copy
    # all our metadata into it, so that it looks identical to the one
    # originally set.
      members = self.__dict__.get('_members')
      if members is not None and name in members:
        _copy_metadata_deep(value, members[name])

    # Verify that the new object is good
      _assert_valid_deep(value)

      return value

    # Attribute access must be intercepted to ensure that objects coming from
    # read attribute access match those that are set with write attribute access.
    # Specifically the metadata, such as the associated apr_pool object, should
    # match the originally assigned object.
    #
    # For classic classes it is enough to use __getattr__ to intercept swig
    # derived attributes. However, with new style classes SWIG makes use of
    # descriptors which mean that __getattr__ is never called. Therefore,
    # __getattribute__ must be used for the interception.

    if _newclass:
      def __getattribute__(self, name):
        """Manage access to all attributes of this object."""

    # Start by mimicing __getattr__ behavior: immediately return __dict__ or
    # items directly present in __dict__
        mydict = object.__getattribute__(self, '__dict__')

        if name == "__dict__":
          return mydict

        if name in mydict:
          return mydict[name]

        object.__getattribute__(self, 'assert_valid')()

        value = _get_instance_attr(self, name)
        fn = object.__getattribute__(self, '_retrieve_swig_value')
        return fn(name, value)
    else:
      def __getattr__(self, name):
        """Get an attribute from this object"""
        self.assert_valid()

        value = _swig_getattr(self, self.__class__, name)

        return self._retrieve_swig_value(name, value)

    def __setattr__(self, name, value):
      """Set an attribute on this object"""
      self.assert_valid()

    # Save a copy of the object, so that the garbage
    # collector won't kill the object while it's in
    # SWIG-land
      self.__dict__.setdefault("_members",{})[name] = value

      return _set_instance_attr(self, name, value)

svn_authz_t_swigregister = _repos.svn_authz_t_swigregister
svn_authz_t_swigregister(svn_authz_t)


def svn_repos_parse_fns3_invoke_magic_header_record(*args) -> "svn_error_t *":
    """svn_repos_parse_fns3_invoke_magic_header_record(svn_repos_parse_fns3_t _obj, int version, void * parse_baton, apr_pool_t pool) -> svn_error_t"""
    return _repos.svn_repos_parse_fns3_invoke_magic_header_record(*args)

def svn_repos_parse_fns3_invoke_uuid_record(*args) -> "svn_error_t *":
    """svn_repos_parse_fns3_invoke_uuid_record(svn_repos_parse_fns3_t _obj, char const * uuid, void * parse_baton, apr_pool_t pool) -> svn_error_t"""
    return _repos.svn_repos_parse_fns3_invoke_uuid_record(*args)

def svn_repos_parse_fns3_invoke_new_revision_record(*args) -> "void **":
    """svn_repos_parse_fns3_invoke_new_revision_record(svn_repos_parse_fns3_t _obj, apr_hash_t headers, void * parse_baton, apr_pool_t pool) -> svn_error_t"""
    return _repos.svn_repos_parse_fns3_invoke_new_revision_record(*args)

def svn_repos_parse_fns3_invoke_new_node_record(*args) -> "void **":
    """svn_repos_parse_fns3_invoke_new_node_record(svn_repos_parse_fns3_t _obj, apr_hash_t headers, void * revision_baton, apr_pool_t pool) -> svn_error_t"""
    return _repos.svn_repos_parse_fns3_invoke_new_node_record(*args)

def svn_repos_parse_fns3_invoke_set_revision_property(_obj: 'svn_repos_parse_fns3_t', revision_baton: 'void *', name: 'char const *', value: 'svn_string_t const *') -> "svn_error_t *":
    """svn_repos_parse_fns3_invoke_set_revision_property(svn_repos_parse_fns3_t _obj, void * revision_baton, char const * name, svn_string_t const * value) -> svn_error_t"""
    return _repos.svn_repos_parse_fns3_invoke_set_revision_property(_obj, revision_baton, name, value)

def svn_repos_parse_fns3_invoke_set_node_property(_obj: 'svn_repos_parse_fns3_t', node_baton: 'void *', name: 'char const *', value: 'svn_string_t const *') -> "svn_error_t *":
    """svn_repos_parse_fns3_invoke_set_node_property(svn_repos_parse_fns3_t _obj, void * node_baton, char const * name, svn_string_t const * value) -> svn_error_t"""
    return _repos.svn_repos_parse_fns3_invoke_set_node_property(_obj, node_baton, name, value)

def svn_repos_parse_fns3_invoke_delete_node_property(_obj: 'svn_repos_parse_fns3_t', node_baton: 'void *', name: 'char const *') -> "svn_error_t *":
    """svn_repos_parse_fns3_invoke_delete_node_property(svn_repos_parse_fns3_t _obj, void * node_baton, char const * name) -> svn_error_t"""
    return _repos.svn_repos_parse_fns3_invoke_delete_node_property(_obj, node_baton, name)

def svn_repos_parse_fns3_invoke_remove_node_props(_obj: 'svn_repos_parse_fns3_t', node_baton: 'void *') -> "svn_error_t *":
    """svn_repos_parse_fns3_invoke_remove_node_props(svn_repos_parse_fns3_t _obj, void * node_baton) -> svn_error_t"""
    return _repos.svn_repos_parse_fns3_invoke_remove_node_props(_obj, node_baton)

def svn_repos_parse_fns3_invoke_set_fulltext(_obj: 'svn_repos_parse_fns3_t', node_baton: 'void *') -> "svn_stream_t **":
    """svn_repos_parse_fns3_invoke_set_fulltext(svn_repos_parse_fns3_t _obj, void * node_baton) -> svn_error_t"""
    return _repos.svn_repos_parse_fns3_invoke_set_fulltext(_obj, node_baton)

def svn_repos_parse_fns3_invoke_apply_textdelta(_obj: 'svn_repos_parse_fns3_t', node_baton: 'void *') -> "svn_txdelta_window_handler_t *, void **":
    """svn_repos_parse_fns3_invoke_apply_textdelta(svn_repos_parse_fns3_t _obj, void * node_baton) -> svn_error_t"""
    return _repos.svn_repos_parse_fns3_invoke_apply_textdelta(_obj, node_baton)

def svn_repos_parse_fns3_invoke_close_node(_obj: 'svn_repos_parse_fns3_t', node_baton: 'void *') -> "svn_error_t *":
    """svn_repos_parse_fns3_invoke_close_node(svn_repos_parse_fns3_t _obj, void * node_baton) -> svn_error_t"""
    return _repos.svn_repos_parse_fns3_invoke_close_node(_obj, node_baton)

def svn_repos_parse_fns3_invoke_close_revision(_obj: 'svn_repos_parse_fns3_t', revision_baton: 'void *') -> "svn_error_t *":
    """svn_repos_parse_fns3_invoke_close_revision(svn_repos_parse_fns3_t _obj, void * revision_baton) -> svn_error_t"""
    return _repos.svn_repos_parse_fns3_invoke_close_revision(_obj, revision_baton)

def svn_repos_parse_fns2_invoke_new_revision_record(*args) -> "void **":
    """svn_repos_parse_fns2_invoke_new_revision_record(svn_repos_parse_fns2_t _obj, apr_hash_t headers, void * parse_baton, apr_pool_t pool) -> svn_error_t"""
    return _repos.svn_repos_parse_fns2_invoke_new_revision_record(*args)

def svn_repos_parse_fns2_invoke_uuid_record(*args) -> "svn_error_t *":
    """svn_repos_parse_fns2_invoke_uuid_record(svn_repos_parse_fns2_t _obj, char const * uuid, void * parse_baton, apr_pool_t pool) -> svn_error_t"""
    return _repos.svn_repos_parse_fns2_invoke_uuid_record(*args)

def svn_repos_parse_fns2_invoke_new_node_record(*args) -> "void **":
    """svn_repos_parse_fns2_invoke_new_node_record(svn_repos_parse_fns2_t _obj, apr_hash_t headers, void * revision_baton, apr_pool_t pool) -> svn_error_t"""
    return _repos.svn_repos_parse_fns2_invoke_new_node_record(*args)

def svn_repos_parse_fns2_invoke_set_revision_property(_obj: 'svn_repos_parse_fns2_t', revision_baton: 'void *', name: 'char const *', value: 'svn_string_t const *') -> "svn_error_t *":
    """svn_repos_parse_fns2_invoke_set_revision_property(svn_repos_parse_fns2_t _obj, void * revision_baton, char const * name, svn_string_t const * value) -> svn_error_t"""
    return _repos.svn_repos_parse_fns2_invoke_set_revision_property(_obj, revision_baton, name, value)

def svn_repos_parse_fns2_invoke_set_node_property(_obj: 'svn_repos_parse_fns2_t', node_baton: 'void *', name: 'char const *', value: 'svn_string_t const *') -> "svn_error_t *":
    """svn_repos_parse_fns2_invoke_set_node_property(svn_repos_parse_fns2_t _obj, void * node_baton, char const * name, svn_string_t const * value) -> svn_error_t"""
    return _repos.svn_repos_parse_fns2_invoke_set_node_property(_obj, node_baton, name, value)

def svn_repos_parse_fns2_invoke_delete_node_property(_obj: 'svn_repos_parse_fns2_t', node_baton: 'void *', name: 'char const *') -> "svn_error_t *":
    """svn_repos_parse_fns2_invoke_delete_node_property(svn_repos_parse_fns2_t _obj, void * node_baton, char const * name) -> svn_error_t"""
    return _repos.svn_repos_parse_fns2_invoke_delete_node_property(_obj, node_baton, name)

def svn_repos_parse_fns2_invoke_remove_node_props(_obj: 'svn_repos_parse_fns2_t', node_baton: 'void *') -> "svn_error_t *":
    """svn_repos_parse_fns2_invoke_remove_node_props(svn_repos_parse_fns2_t _obj, void * node_baton) -> svn_error_t"""
    return _repos.svn_repos_parse_fns2_invoke_remove_node_props(_obj, node_baton)

def svn_repos_parse_fns2_invoke_set_fulltext(_obj: 'svn_repos_parse_fns2_t', node_baton: 'void *') -> "svn_stream_t **":
    """svn_repos_parse_fns2_invoke_set_fulltext(svn_repos_parse_fns2_t _obj, void * node_baton) -> svn_error_t"""
    return _repos.svn_repos_parse_fns2_invoke_set_fulltext(_obj, node_baton)

def svn_repos_parse_fns2_invoke_apply_textdelta(_obj: 'svn_repos_parse_fns2_t', node_baton: 'void *') -> "svn_txdelta_window_handler_t *, void **":
    """svn_repos_parse_fns2_invoke_apply_textdelta(svn_repos_parse_fns2_t _obj, void * node_baton) -> svn_error_t"""
    return _repos.svn_repos_parse_fns2_invoke_apply_textdelta(_obj, node_baton)

def svn_repos_parse_fns2_invoke_close_node(_obj: 'svn_repos_parse_fns2_t', node_baton: 'void *') -> "svn_error_t *":
    """svn_repos_parse_fns2_invoke_close_node(svn_repos_parse_fns2_t _obj, void * node_baton) -> svn_error_t"""
    return _repos.svn_repos_parse_fns2_invoke_close_node(_obj, node_baton)

def svn_repos_parse_fns2_invoke_close_revision(_obj: 'svn_repos_parse_fns2_t', revision_baton: 'void *') -> "svn_error_t *":
    """svn_repos_parse_fns2_invoke_close_revision(svn_repos_parse_fns2_t _obj, void * revision_baton) -> svn_error_t"""
    return _repos.svn_repos_parse_fns2_invoke_close_revision(_obj, revision_baton)

def svn_repos_invoke_authz_func(*args) -> "svn_boolean_t *":
    """svn_repos_invoke_authz_func(svn_repos_authz_func_t _obj, svn_fs_root_t * root, char const * path, void * baton, apr_pool_t pool) -> svn_error_t"""
    return _repos.svn_repos_invoke_authz_func(*args)

def svn_repos_invoke_authz_callback(*args) -> "svn_boolean_t *":
    """svn_repos_invoke_authz_callback(svn_repos_authz_callback_t _obj, svn_repos_authz_access_t required, svn_fs_root_t * root, char const * path, void * baton, apr_pool_t pool) -> svn_error_t"""
    return _repos.svn_repos_invoke_authz_callback(*args)

def svn_repos_invoke_notify_func(*args) -> "void":
    """svn_repos_invoke_notify_func(svn_repos_notify_func_t _obj, void * baton, svn_repos_notify_t notify, apr_pool_t scratch_pool)"""
    return _repos.svn_repos_invoke_notify_func(*args)

def svn_repos_invoke_dump_filter_func(*args) -> "svn_boolean_t *":
    """svn_repos_invoke_dump_filter_func(svn_repos_dump_filter_func_t _obj, svn_fs_root_t * root, char const * path, void * baton, apr_pool_t scratch_pool) -> svn_error_t"""
    return _repos.svn_repos_invoke_dump_filter_func(*args)

def svn_repos_invoke_freeze_func(*args) -> "svn_error_t *":
    """svn_repos_invoke_freeze_func(svn_repos_freeze_func_t _obj, void * baton, apr_pool_t pool) -> svn_error_t"""
    return _repos.svn_repos_invoke_freeze_func(*args)

def svn_repos_invoke_history_func(*args) -> "svn_error_t *":
    """svn_repos_invoke_history_func(svn_repos_history_func_t _obj, void * baton, char const * path, svn_revnum_t revision, apr_pool_t pool) -> svn_error_t"""
    return _repos.svn_repos_invoke_history_func(*args)

def svn_repos_invoke_path_change_receiver(*args) -> "svn_error_t *":
    """svn_repos_invoke_path_change_receiver(svn_repos_path_change_receiver_t _obj, void * baton, svn_fs_path_change3_t change, apr_pool_t scratch_pool) -> svn_error_t"""
    return _repos.svn_repos_invoke_path_change_receiver(*args)

def svn_repos_invoke_log_entry_receiver(*args) -> "svn_error_t *":
    """svn_repos_invoke_log_entry_receiver(svn_repos_log_entry_receiver_t _obj, void * baton, svn_repos_log_entry_t log_entry, apr_pool_t scratch_pool) -> svn_error_t"""
    return _repos.svn_repos_invoke_log_entry_receiver(*args)

def svn_repos_invoke_file_rev_handler(*args) -> "svn_txdelta_window_handler_t *, void **":
    """svn_repos_invoke_file_rev_handler(svn_repos_file_rev_handler_t _obj, void * baton, char const * path, svn_revnum_t rev, apr_hash_t rev_props, apr_array_header_t prop_diffs, apr_pool_t pool) -> svn_error_t"""
    return _repos.svn_repos_invoke_file_rev_handler(*args)

def svn_repos_invoke_verify_callback(*args) -> "svn_error_t *":
    """svn_repos_invoke_verify_callback(svn_repos_verify_callback_t _obj, void * baton, svn_revnum_t revision, svn_error_t verify_err, apr_pool_t scratch_pool) -> svn_error_t"""
    return _repos.svn_repos_invoke_verify_callback(*args)

def svn_repos_invoke_authz_warning_func(*args) -> "void":
    """svn_repos_invoke_authz_warning_func(svn_repos_authz_warning_func_t _obj, void * baton, svn_error_t error, apr_pool_t scratch_pool)"""
    return _repos.svn_repos_invoke_authz_warning_func(*args)
class svn_repos_authz_func_t(object):
    """Proxy of C svn_repos_authz_func_t struct."""

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    def set_parent_pool(self, parent_pool=None):
      """Create a new proxy object for TYPE"""
      import libsvn.core, weakref
      self.__dict__["_parent_pool"] = \
        parent_pool or libsvn.core.application_pool;
      if self.__dict__["_parent_pool"]:
        self.__dict__["_is_valid"] = weakref.ref(
          self.__dict__["_parent_pool"]._is_valid)

    def assert_valid(self):
      """Assert that this object is using valid pool memory"""
      if "_is_valid" in self.__dict__:
        assert self.__dict__["_is_valid"](), "Variable has already been deleted"

    def _retrieve_swig_value(self, name, value):
    # If we got back a different object than we have cached, we need to copy
    # all our metadata into it, so that it looks identical to the one
    # originally set.
      members = self.__dict__.get('_members')
      if members is not None and name in members:
        _copy_metadata_deep(value, members[name])

    # Verify that the new object is good
      _assert_valid_deep(value)

      return value

    # Attribute access must be intercepted to ensure that objects coming from
    # read attribute access match those that are set with write attribute access.
    # Specifically the metadata, such as the associated apr_pool object, should
    # match the originally assigned object.
    #
    # For classic classes it is enough to use __getattr__ to intercept swig
    # derived attributes. However, with new style classes SWIG makes use of
    # descriptors which mean that __getattr__ is never called. Therefore,
    # __getattribute__ must be used for the interception.

    if _newclass:
      def __getattribute__(self, name):
        """Manage access to all attributes of this object."""

    # Start by mimicing __getattr__ behavior: immediately return __dict__ or
    # items directly present in __dict__
        mydict = object.__getattribute__(self, '__dict__')

        if name == "__dict__":
          return mydict

        if name in mydict:
          return mydict[name]

        object.__getattribute__(self, 'assert_valid')()

        value = _get_instance_attr(self, name)
        fn = object.__getattribute__(self, '_retrieve_swig_value')
        return fn(name, value)
    else:
      def __getattr__(self, name):
        """Get an attribute from this object"""
        self.assert_valid()

        value = _swig_getattr(self, self.__class__, name)

        return self._retrieve_swig_value(name, value)

    def __setattr__(self, name, value):
      """Set an attribute on this object"""
      self.assert_valid()

    # Save a copy of the object, so that the garbage
    # collector won't kill the object while it's in
    # SWIG-land
      self.__dict__.setdefault("_members",{})[name] = value

      return _set_instance_attr(self, name, value)


    def __call__(self, *args):
      return svn_repos_invoke_authz_func(self, *args)

svn_repos_authz_func_t_swigregister = _repos.svn_repos_authz_func_t_swigregister
svn_repos_authz_func_t_swigregister(svn_repos_authz_func_t)

class svn_repos_authz_callback_t(object):
    """Proxy of C svn_repos_authz_callback_t struct."""

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    def set_parent_pool(self, parent_pool=None):
      """Create a new proxy object for TYPE"""
      import libsvn.core, weakref
      self.__dict__["_parent_pool"] = \
        parent_pool or libsvn.core.application_pool;
      if self.__dict__["_parent_pool"]:
        self.__dict__["_is_valid"] = weakref.ref(
          self.__dict__["_parent_pool"]._is_valid)

    def assert_valid(self):
      """Assert that this object is using valid pool memory"""
      if "_is_valid" in self.__dict__:
        assert self.__dict__["_is_valid"](), "Variable has already been deleted"

    def _retrieve_swig_value(self, name, value):
    # If we got back a different object than we have cached, we need to copy
    # all our metadata into it, so that it looks identical to the one
    # originally set.
      members = self.__dict__.get('_members')
      if members is not None and name in members:
        _copy_metadata_deep(value, members[name])

    # Verify that the new object is good
      _assert_valid_deep(value)

      return value

    # Attribute access must be intercepted to ensure that objects coming from
    # read attribute access match those that are set with write attribute access.
    # Specifically the metadata, such as the associated apr_pool object, should
    # match the originally assigned object.
    #
    # For classic classes it is enough to use __getattr__ to intercept swig
    # derived attributes. However, with new style classes SWIG makes use of
    # descriptors which mean that __getattr__ is never called. Therefore,
    # __getattribute__ must be used for the interception.

    if _newclass:
      def __getattribute__(self, name):
        """Manage access to all attributes of this object."""

    # Start by mimicing __getattr__ behavior: immediately return __dict__ or
    # items directly present in __dict__
        mydict = object.__getattribute__(self, '__dict__')

        if name == "__dict__":
          return mydict

        if name in mydict:
          return mydict[name]

        object.__getattribute__(self, 'assert_valid')()

        value = _get_instance_attr(self, name)
        fn = object.__getattribute__(self, '_retrieve_swig_value')
        return fn(name, value)
    else:
      def __getattr__(self, name):
        """Get an attribute from this object"""
        self.assert_valid()

        value = _swig_getattr(self, self.__class__, name)

        return self._retrieve_swig_value(name, value)

    def __setattr__(self, name, value):
      """Set an attribute on this object"""
      self.assert_valid()

    # Save a copy of the object, so that the garbage
    # collector won't kill the object while it's in
    # SWIG-land
      self.__dict__.setdefault("_members",{})[name] = value

      return _set_instance_attr(self, name, value)


    def __call__(self, *args):
      return svn_repos_invoke_authz_callback(self, *args)

svn_repos_authz_callback_t_swigregister = _repos.svn_repos_authz_callback_t_swigregister
svn_repos_authz_callback_t_swigregister(svn_repos_authz_callback_t)

class svn_repos_notify_func_t(object):
    """Proxy of C svn_repos_notify_func_t struct."""

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    def set_parent_pool(self, parent_pool=None):
      """Create a new proxy object for TYPE"""
      import libsvn.core, weakref
      self.__dict__["_parent_pool"] = \
        parent_pool or libsvn.core.application_pool;
      if self.__dict__["_parent_pool"]:
        self.__dict__["_is_valid"] = weakref.ref(
          self.__dict__["_parent_pool"]._is_valid)

    def assert_valid(self):
      """Assert that this object is using valid pool memory"""
      if "_is_valid" in self.__dict__:
        assert self.__dict__["_is_valid"](), "Variable has already been deleted"

    def _retrieve_swig_value(self, name, value):
    # If we got back a different object than we have cached, we need to copy
    # all our metadata into it, so that it looks identical to the one
    # originally set.
      members = self.__dict__.get('_members')
      if members is not None and name in members:
        _copy_metadata_deep(value, members[name])

    # Verify that the new object is good
      _assert_valid_deep(value)

      return value

    # Attribute access must be intercepted to ensure that objects coming from
    # read attribute access match those that are set with write attribute access.
    # Specifically the metadata, such as the associated apr_pool object, should
    # match the originally assigned object.
    #
    # For classic classes it is enough to use __getattr__ to intercept swig
    # derived attributes. However, with new style classes SWIG makes use of
    # descriptors which mean that __getattr__ is never called. Therefore,
    # __getattribute__ must be used for the interception.

    if _newclass:
      def __getattribute__(self, name):
        """Manage access to all attributes of this object."""

    # Start by mimicing __getattr__ behavior: immediately return __dict__ or
    # items directly present in __dict__
        mydict = object.__getattribute__(self, '__dict__')

        if name == "__dict__":
          return mydict

        if name in mydict:
          return mydict[name]

        object.__getattribute__(self, 'assert_valid')()

        value = _get_instance_attr(self, name)
        fn = object.__getattribute__(self, '_retrieve_swig_value')
        return fn(name, value)
    else:
      def __getattr__(self, name):
        """Get an attribute from this object"""
        self.assert_valid()

        value = _swig_getattr(self, self.__class__, name)

        return self._retrieve_swig_value(name, value)

    def __setattr__(self, name, value):
      """Set an attribute on this object"""
      self.assert_valid()

    # Save a copy of the object, so that the garbage
    # collector won't kill the object while it's in
    # SWIG-land
      self.__dict__.setdefault("_members",{})[name] = value

      return _set_instance_attr(self, name, value)


    def __call__(self, *args):
      return svn_repos_invoke_notify_func(self, *args)

svn_repos_notify_func_t_swigregister = _repos.svn_repos_notify_func_t_swigregister
svn_repos_notify_func_t_swigregister(svn_repos_notify_func_t)

class svn_repos_dump_filter_func_t(object):
    """Proxy of C svn_repos_dump_filter_func_t struct."""

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    def set_parent_pool(self, parent_pool=None):
      """Create a new proxy object for TYPE"""
      import libsvn.core, weakref
      self.__dict__["_parent_pool"] = \
        parent_pool or libsvn.core.application_pool;
      if self.__dict__["_parent_pool"]:
        self.__dict__["_is_valid"] = weakref.ref(
          self.__dict__["_parent_pool"]._is_valid)

    def assert_valid(self):
      """Assert that this object is using valid pool memory"""
      if "_is_valid" in self.__dict__:
        assert self.__dict__["_is_valid"](), "Variable has already been deleted"

    def _retrieve_swig_value(self, name, value):
    # If we got back a different object than we have cached, we need to copy
    # all our metadata into it, so that it looks identical to the one
    # originally set.
      members = self.__dict__.get('_members')
      if members is not None and name in members:
        _copy_metadata_deep(value, members[name])

    # Verify that the new object is good
      _assert_valid_deep(value)

      return value

    # Attribute access must be intercepted to ensure that objects coming from
    # read attribute access match those that are set with write attribute access.
    # Specifically the metadata, such as the associated apr_pool object, should
    # match the originally assigned object.
    #
    # For classic classes it is enough to use __getattr__ to intercept swig
    # derived attributes. However, with new style classes SWIG makes use of
    # descriptors which mean that __getattr__ is never called. Therefore,
    # __getattribute__ must be used for the interception.

    if _newclass:
      def __getattribute__(self, name):
        """Manage access to all attributes of this object."""

    # Start by mimicing __getattr__ behavior: immediately return __dict__ or
    # items directly present in __dict__
        mydict = object.__getattribute__(self, '__dict__')

        if name == "__dict__":
          return mydict

        if name in mydict:
          return mydict[name]

        object.__getattribute__(self, 'assert_valid')()

        value = _get_instance_attr(self, name)
        fn = object.__getattribute__(self, '_retrieve_swig_value')
        return fn(name, value)
    else:
      def __getattr__(self, name):
        """Get an attribute from this object"""
        self.assert_valid()

        value = _swig_getattr(self, self.__class__, name)

        return self._retrieve_swig_value(name, value)

    def __setattr__(self, name, value):
      """Set an attribute on this object"""
      self.assert_valid()

    # Save a copy of the object, so that the garbage
    # collector won't kill the object while it's in
    # SWIG-land
      self.__dict__.setdefault("_members",{})[name] = value

      return _set_instance_attr(self, name, value)


    def __call__(self, *args):
      return svn_repos_invoke_dump_filter_func(self, *args)

svn_repos_dump_filter_func_t_swigregister = _repos.svn_repos_dump_filter_func_t_swigregister
svn_repos_dump_filter_func_t_swigregister(svn_repos_dump_filter_func_t)

class svn_repos_freeze_func_t(object):
    """Proxy of C svn_repos_freeze_func_t struct."""

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    def set_parent_pool(self, parent_pool=None):
      """Create a new proxy object for TYPE"""
      import libsvn.core, weakref
      self.__dict__["_parent_pool"] = \
        parent_pool or libsvn.core.application_pool;
      if self.__dict__["_parent_pool"]:
        self.__dict__["_is_valid"] = weakref.ref(
          self.__dict__["_parent_pool"]._is_valid)

    def assert_valid(self):
      """Assert that this object is using valid pool memory"""
      if "_is_valid" in self.__dict__:
        assert self.__dict__["_is_valid"](), "Variable has already been deleted"

    def _retrieve_swig_value(self, name, value):
    # If we got back a different object than we have cached, we need to copy
    # all our metadata into it, so that it looks identical to the one
    # originally set.
      members = self.__dict__.get('_members')
      if members is not None and name in members:
        _copy_metadata_deep(value, members[name])

    # Verify that the new object is good
      _assert_valid_deep(value)

      return value

    # Attribute access must be intercepted to ensure that objects coming from
    # read attribute access match those that are set with write attribute access.
    # Specifically the metadata, such as the associated apr_pool object, should
    # match the originally assigned object.
    #
    # For classic classes it is enough to use __getattr__ to intercept swig
    # derived attributes. However, with new style classes SWIG makes use of
    # descriptors which mean that __getattr__ is never called. Therefore,
    # __getattribute__ must be used for the interception.

    if _newclass:
      def __getattribute__(self, name):
        """Manage access to all attributes of this object."""

    # Start by mimicing __getattr__ behavior: immediately return __dict__ or
    # items directly present in __dict__
        mydict = object.__getattribute__(self, '__dict__')

        if name == "__dict__":
          return mydict

        if name in mydict:
          return mydict[name]

        object.__getattribute__(self, 'assert_valid')()

        value = _get_instance_attr(self, name)
        fn = object.__getattribute__(self, '_retrieve_swig_value')
        return fn(name, value)
    else:
      def __getattr__(self, name):
        """Get an attribute from this object"""
        self.assert_valid()

        value = _swig_getattr(self, self.__class__, name)

        return self._retrieve_swig_value(name, value)

    def __setattr__(self, name, value):
      """Set an attribute on this object"""
      self.assert_valid()

    # Save a copy of the object, so that the garbage
    # collector won't kill the object while it's in
    # SWIG-land
      self.__dict__.setdefault("_members",{})[name] = value

      return _set_instance_attr(self, name, value)


    def __call__(self, *args):
      return svn_repos_invoke_freeze_func(self, *args)

svn_repos_freeze_func_t_swigregister = _repos.svn_repos_freeze_func_t_swigregister
svn_repos_freeze_func_t_swigregister(svn_repos_freeze_func_t)

class svn_repos_history_func_t(object):
    """Proxy of C svn_repos_history_func_t struct."""

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    def set_parent_pool(self, parent_pool=None):
      """Create a new proxy object for TYPE"""
      import libsvn.core, weakref
      self.__dict__["_parent_pool"] = \
        parent_pool or libsvn.core.application_pool;
      if self.__dict__["_parent_pool"]:
        self.__dict__["_is_valid"] = weakref.ref(
          self.__dict__["_parent_pool"]._is_valid)

    def assert_valid(self):
      """Assert that this object is using valid pool memory"""
      if "_is_valid" in self.__dict__:
        assert self.__dict__["_is_valid"](), "Variable has already been deleted"

    def _retrieve_swig_value(self, name, value):
    # If we got back a different object than we have cached, we need to copy
    # all our metadata into it, so that it looks identical to the one
    # originally set.
      members = self.__dict__.get('_members')
      if members is not None and name in members:
        _copy_metadata_deep(value, members[name])

    # Verify that the new object is good
      _assert_valid_deep(value)

      return value

    # Attribute access must be intercepted to ensure that objects coming from
    # read attribute access match those that are set with write attribute access.
    # Specifically the metadata, such as the associated apr_pool object, should
    # match the originally assigned object.
    #
    # For classic classes it is enough to use __getattr__ to intercept swig
    # derived attributes. However, with new style classes SWIG makes use of
    # descriptors which mean that __getattr__ is never called. Therefore,
    # __getattribute__ must be used for the interception.

    if _newclass:
      def __getattribute__(self, name):
        """Manage access to all attributes of this object."""

    # Start by mimicing __getattr__ behavior: immediately return __dict__ or
    # items directly present in __dict__
        mydict = object.__getattribute__(self, '__dict__')

        if name == "__dict__":
          return mydict

        if name in mydict:
          return mydict[name]

        object.__getattribute__(self, 'assert_valid')()

        value = _get_instance_attr(self, name)
        fn = object.__getattribute__(self, '_retrieve_swig_value')
        return fn(name, value)
    else:
      def __getattr__(self, name):
        """Get an attribute from this object"""
        self.assert_valid()

        value = _swig_getattr(self, self.__class__, name)

        return self._retrieve_swig_value(name, value)

    def __setattr__(self, name, value):
      """Set an attribute on this object"""
      self.assert_valid()

    # Save a copy of the object, so that the garbage
    # collector won't kill the object while it's in
    # SWIG-land
      self.__dict__.setdefault("_members",{})[name] = value

      return _set_instance_attr(self, name, value)


    def __call__(self, *args):
      return svn_repos_invoke_history_func(self, *args)

svn_repos_history_func_t_swigregister = _repos.svn_repos_history_func_t_swigregister
svn_repos_history_func_t_swigregister(svn_repos_history_func_t)

class svn_repos_path_change_receiver_t(object):
    """Proxy of C svn_repos_path_change_receiver_t struct."""

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    def set_parent_pool(self, parent_pool=None):
      """Create a new proxy object for TYPE"""
      import libsvn.core, weakref
      self.__dict__["_parent_pool"] = \
        parent_pool or libsvn.core.application_pool;
      if self.__dict__["_parent_pool"]:
        self.__dict__["_is_valid"] = weakref.ref(
          self.__dict__["_parent_pool"]._is_valid)

    def assert_valid(self):
      """Assert that this object is using valid pool memory"""
      if "_is_valid" in self.__dict__:
        assert self.__dict__["_is_valid"](), "Variable has already been deleted"

    def _retrieve_swig_value(self, name, value):
    # If we got back a different object than we have cached, we need to copy
    # all our metadata into it, so that it looks identical to the one
    # originally set.
      members = self.__dict__.get('_members')
      if members is not None and name in members:
        _copy_metadata_deep(value, members[name])

    # Verify that the new object is good
      _assert_valid_deep(value)

      return value

    # Attribute access must be intercepted to ensure that objects coming from
    # read attribute access match those that are set with write attribute access.
    # Specifically the metadata, such as the associated apr_pool object, should
    # match the originally assigned object.
    #
    # For classic classes it is enough to use __getattr__ to intercept swig
    # derived attributes. However, with new style classes SWIG makes use of
    # descriptors which mean that __getattr__ is never called. Therefore,
    # __getattribute__ must be used for the interception.

    if _newclass:
      def __getattribute__(self, name):
        """Manage access to all attributes of this object."""

    # Start by mimicing __getattr__ behavior: immediately return __dict__ or
    # items directly present in __dict__
        mydict = object.__getattribute__(self, '__dict__')

        if name == "__dict__":
          return mydict

        if name in mydict:
          return mydict[name]

        object.__getattribute__(self, 'assert_valid')()

        value = _get_instance_attr(self, name)
        fn = object.__getattribute__(self, '_retrieve_swig_value')
        return fn(name, value)
    else:
      def __getattr__(self, name):
        """Get an attribute from this object"""
        self.assert_valid()

        value = _swig_getattr(self, self.__class__, name)

        return self._retrieve_swig_value(name, value)

    def __setattr__(self, name, value):
      """Set an attribute on this object"""
      self.assert_valid()

    # Save a copy of the object, so that the garbage
    # collector won't kill the object while it's in
    # SWIG-land
      self.__dict__.setdefault("_members",{})[name] = value

      return _set_instance_attr(self, name, value)


    def __call__(self, *args):
      return svn_repos_invoke_path_change_receiver(self, *args)

svn_repos_path_change_receiver_t_swigregister = _repos.svn_repos_path_change_receiver_t_swigregister
svn_repos_path_change_receiver_t_swigregister(svn_repos_path_change_receiver_t)

class svn_repos_log_entry_receiver_t(object):
    """Proxy of C svn_repos_log_entry_receiver_t struct."""

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    def set_parent_pool(self, parent_pool=None):
      """Create a new proxy object for TYPE"""
      import libsvn.core, weakref
      self.__dict__["_parent_pool"] = \
        parent_pool or libsvn.core.application_pool;
      if self.__dict__["_parent_pool"]:
        self.__dict__["_is_valid"] = weakref.ref(
          self.__dict__["_parent_pool"]._is_valid)

    def assert_valid(self):
      """Assert that this object is using valid pool memory"""
      if "_is_valid" in self.__dict__:
        assert self.__dict__["_is_valid"](), "Variable has already been deleted"

    def _retrieve_swig_value(self, name, value):
    # If we got back a different object than we have cached, we need to copy
    # all our metadata into it, so that it looks identical to the one
    # originally set.
      members = self.__dict__.get('_members')
      if members is not None and name in members:
        _copy_metadata_deep(value, members[name])

    # Verify that the new object is good
      _assert_valid_deep(value)

      return value

    # Attribute access must be intercepted to ensure that objects coming from
    # read attribute access match those that are set with write attribute access.
    # Specifically the metadata, such as the associated apr_pool object, should
    # match the originally assigned object.
    #
    # For classic classes it is enough to use __getattr__ to intercept swig
    # derived attributes. However, with new style classes SWIG makes use of
    # descriptors which mean that __getattr__ is never called. Therefore,
    # __getattribute__ must be used for the interception.

    if _newclass:
      def __getattribute__(self, name):
        """Manage access to all attributes of this object."""

    # Start by mimicing __getattr__ behavior: immediately return __dict__ or
    # items directly present in __dict__
        mydict = object.__getattribute__(self, '__dict__')

        if name == "__dict__":
          return mydict

        if name in mydict:
          return mydict[name]

        object.__getattribute__(self, 'assert_valid')()

        value = _get_instance_attr(self, name)
        fn = object.__getattribute__(self, '_retrieve_swig_value')
        return fn(name, value)
    else:
      def __getattr__(self, name):
        """Get an attribute from this object"""
        self.assert_valid()

        value = _swig_getattr(self, self.__class__, name)

        return self._retrieve_swig_value(name, value)

    def __setattr__(self, name, value):
      """Set an attribute on this object"""
      self.assert_valid()

    # Save a copy of the object, so that the garbage
    # collector won't kill the object while it's in
    # SWIG-land
      self.__dict__.setdefault("_members",{})[name] = value

      return _set_instance_attr(self, name, value)


    def __call__(self, *args):
      return svn_repos_invoke_log_entry_receiver(self, *args)

svn_repos_log_entry_receiver_t_swigregister = _repos.svn_repos_log_entry_receiver_t_swigregister
svn_repos_log_entry_receiver_t_swigregister(svn_repos_log_entry_receiver_t)

class svn_repos_file_rev_handler_t(object):
    """Proxy of C svn_repos_file_rev_handler_t struct."""

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    def set_parent_pool(self, parent_pool=None):
      """Create a new proxy object for TYPE"""
      import libsvn.core, weakref
      self.__dict__["_parent_pool"] = \
        parent_pool or libsvn.core.application_pool;
      if self.__dict__["_parent_pool"]:
        self.__dict__["_is_valid"] = weakref.ref(
          self.__dict__["_parent_pool"]._is_valid)

    def assert_valid(self):
      """Assert that this object is using valid pool memory"""
      if "_is_valid" in self.__dict__:
        assert self.__dict__["_is_valid"](), "Variable has already been deleted"

    def _retrieve_swig_value(self, name, value):
    # If we got back a different object than we have cached, we need to copy
    # all our metadata into it, so that it looks identical to the one
    # originally set.
      members = self.__dict__.get('_members')
      if members is not None and name in members:
        _copy_metadata_deep(value, members[name])

    # Verify that the new object is good
      _assert_valid_deep(value)

      return value

    # Attribute access must be intercepted to ensure that objects coming from
    # read attribute access match those that are set with write attribute access.
    # Specifically the metadata, such as the associated apr_pool object, should
    # match the originally assigned object.
    #
    # For classic classes it is enough to use __getattr__ to intercept swig
    # derived attributes. However, with new style classes SWIG makes use of
    # descriptors which mean that __getattr__ is never called. Therefore,
    # __getattribute__ must be used for the interception.

    if _newclass:
      def __getattribute__(self, name):
        """Manage access to all attributes of this object."""

    # Start by mimicing __getattr__ behavior: immediately return __dict__ or
    # items directly present in __dict__
        mydict = object.__getattribute__(self, '__dict__')

        if name == "__dict__":
          return mydict

        if name in mydict:
          return mydict[name]

        object.__getattribute__(self, 'assert_valid')()

        value = _get_instance_attr(self, name)
        fn = object.__getattribute__(self, '_retrieve_swig_value')
        return fn(name, value)
    else:
      def __getattr__(self, name):
        """Get an attribute from this object"""
        self.assert_valid()

        value = _swig_getattr(self, self.__class__, name)

        return self._retrieve_swig_value(name, value)

    def __setattr__(self, name, value):
      """Set an attribute on this object"""
      self.assert_valid()

    # Save a copy of the object, so that the garbage
    # collector won't kill the object while it's in
    # SWIG-land
      self.__dict__.setdefault("_members",{})[name] = value

      return _set_instance_attr(self, name, value)


    def __call__(self, *args):
      return svn_repos_invoke_file_rev_handler(self, *args)

svn_repos_file_rev_handler_t_swigregister = _repos.svn_repos_file_rev_handler_t_swigregister
svn_repos_file_rev_handler_t_swigregister(svn_repos_file_rev_handler_t)

class svn_repos_verify_callback_t(object):
    """Proxy of C svn_repos_verify_callback_t struct."""

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    def set_parent_pool(self, parent_pool=None):
      """Create a new proxy object for TYPE"""
      import libsvn.core, weakref
      self.__dict__["_parent_pool"] = \
        parent_pool or libsvn.core.application_pool;
      if self.__dict__["_parent_pool"]:
        self.__dict__["_is_valid"] = weakref.ref(
          self.__dict__["_parent_pool"]._is_valid)

    def assert_valid(self):
      """Assert that this object is using valid pool memory"""
      if "_is_valid" in self.__dict__:
        assert self.__dict__["_is_valid"](), "Variable has already been deleted"

    def _retrieve_swig_value(self, name, value):
    # If we got back a different object than we have cached, we need to copy
    # all our metadata into it, so that it looks identical to the one
    # originally set.
      members = self.__dict__.get('_members')
      if members is not None and name in members:
        _copy_metadata_deep(value, members[name])

    # Verify that the new object is good
      _assert_valid_deep(value)

      return value

    # Attribute access must be intercepted to ensure that objects coming from
    # read attribute access match those that are set with write attribute access.
    # Specifically the metadata, such as the associated apr_pool object, should
    # match the originally assigned object.
    #
    # For classic classes it is enough to use __getattr__ to intercept swig
    # derived attributes. However, with new style classes SWIG makes use of
    # descriptors which mean that __getattr__ is never called. Therefore,
    # __getattribute__ must be used for the interception.

    if _newclass:
      def __getattribute__(self, name):
        """Manage access to all attributes of this object."""

    # Start by mimicing __getattr__ behavior: immediately return __dict__ or
    # items directly present in __dict__
        mydict = object.__getattribute__(self, '__dict__')

        if name == "__dict__":
          return mydict

        if name in mydict:
          return mydict[name]

        object.__getattribute__(self, 'assert_valid')()

        value = _get_instance_attr(self, name)
        fn = object.__getattribute__(self, '_retrieve_swig_value')
        return fn(name, value)
    else:
      def __getattr__(self, name):
        """Get an attribute from this object"""
        self.assert_valid()

        value = _swig_getattr(self, self.__class__, name)

        return self._retrieve_swig_value(name, value)

    def __setattr__(self, name, value):
      """Set an attribute on this object"""
      self.assert_valid()

    # Save a copy of the object, so that the garbage
    # collector won't kill the object while it's in
    # SWIG-land
      self.__dict__.setdefault("_members",{})[name] = value

      return _set_instance_attr(self, name, value)


    def __call__(self, *args):
      return svn_repos_invoke_verify_callback(self, *args)

svn_repos_verify_callback_t_swigregister = _repos.svn_repos_verify_callback_t_swigregister
svn_repos_verify_callback_t_swigregister(svn_repos_verify_callback_t)

class svn_repos_authz_warning_func_t(object):
    """Proxy of C svn_repos_authz_warning_func_t struct."""

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    def set_parent_pool(self, parent_pool=None):
      """Create a new proxy object for TYPE"""
      import libsvn.core, weakref
      self.__dict__["_parent_pool"] = \
        parent_pool or libsvn.core.application_pool;
      if self.__dict__["_parent_pool"]:
        self.__dict__["_is_valid"] = weakref.ref(
          self.__dict__["_parent_pool"]._is_valid)

    def assert_valid(self):
      """Assert that this object is using valid pool memory"""
      if "_is_valid" in self.__dict__:
        assert self.__dict__["_is_valid"](), "Variable has already been deleted"

    def _retrieve_swig_value(self, name, value):
    # If we got back a different object than we have cached, we need to copy
    # all our metadata into it, so that it looks identical to the one
    # originally set.
      members = self.__dict__.get('_members')
      if members is not None and name in members:
        _copy_metadata_deep(value, members[name])

    # Verify that the new object is good
      _assert_valid_deep(value)

      return value

    # Attribute access must be intercepted to ensure that objects coming from
    # read attribute access match those that are set with write attribute access.
    # Specifically the metadata, such as the associated apr_pool object, should
    # match the originally assigned object.
    #
    # For classic classes it is enough to use __getattr__ to intercept swig
    # derived attributes. However, with new style classes SWIG makes use of
    # descriptors which mean that __getattr__ is never called. Therefore,
    # __getattribute__ must be used for the interception.

    if _newclass:
      def __getattribute__(self, name):
        """Manage access to all attributes of this object."""

    # Start by mimicing __getattr__ behavior: immediately return __dict__ or
    # items directly present in __dict__
        mydict = object.__getattribute__(self, '__dict__')

        if name == "__dict__":
          return mydict

        if name in mydict:
          return mydict[name]

        object.__getattribute__(self, 'assert_valid')()

        value = _get_instance_attr(self, name)
        fn = object.__getattribute__(self, '_retrieve_swig_value')
        return fn(name, value)
    else:
      def __getattr__(self, name):
        """Get an attribute from this object"""
        self.assert_valid()

        value = _swig_getattr(self, self.__class__, name)

        return self._retrieve_swig_value(name, value)

    def __setattr__(self, name, value):
      """Set an attribute on this object"""
      self.assert_valid()

    # Save a copy of the object, so that the garbage
    # collector won't kill the object while it's in
    # SWIG-land
      self.__dict__.setdefault("_members",{})[name] = value

      return _set_instance_attr(self, name, value)


    def __call__(self, *args):
      return svn_repos_invoke_authz_warning_func(self, *args)

svn_repos_authz_warning_func_t_swigregister = _repos.svn_repos_authz_warning_func_t_swigregister
svn_repos_authz_warning_func_t_swigregister(svn_repos_authz_warning_func_t)



