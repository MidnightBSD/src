.Dd 2015-03-02
.Dt GPERF 7
.Os
.Sh NAME
.Nm gperf
.Nd Perfect Hash Function Generator
.Sh  Introduction
This manual documents the GNU
.Li gperf
perfect hash function generator utility, focusing on its features and how
to use them, and how to report bugs.
.Pp
.Sh  GNU GENERAL PUBLIC LICENSE
.Bd -filled -offset indent
Copyright \(co 1989, 1991 Free Software Foundation, Inc., 59 Temple Place, Suite
330, Boston, MA 02111-1307, USA.
.Pp
Everyone is permitted to copy and distribute verbatim copies of this license
document, but changing it is not allowed.
.Ed
.Pp
.Ss  Preamble
The licenses for most software are designed to take away your freedom to share
and change it. By contrast, the GNU General Public License is intended to
guarantee your freedom to share and change free software---to make sure the
software is free for all its users. This General Public License applies to
most of the Free Software Foundation's software and to any other program whose
authors commit to using it. (Some other Free Software Foundation software
is covered by the GNU Library General Public License instead.) You can apply
it to your programs, too.
.Pp
When we speak of free software, we are referring to freedom, not price. Our
General Public Licenses are designed to make sure that you have the freedom
to distribute copies of free software (and charge for this service if you
wish), that you receive source code or can get it if you want it, that you
can change the software or use pieces of it in new free programs; and that
you know you can do these things.
.Pp
To protect your rights, we need to make restrictions that forbid anyone to
deny you these rights or to ask you to surrender the rights. These restrictions
translate to certain responsibilities for you if you distribute copies of
the software, or if you modify it.
.Pp
For example, if you distribute copies of such a program, whether gratis or
for a fee, you must give the recipients all the rights that you have. You
must make sure that they, too, receive or can get the source code. And you
must show them these terms so they know their rights.
.Pp
We protect your rights with two steps: (1) copyright the software, and (2)
offer you this license which gives you legal permission to copy, distribute
and/or modify the software.
.Pp
Also, for each author's protection and ours, we want to make certain that
everyone understands that there is no warranty for this free software. If
the software is modified by someone else and passed on, we want its recipients
to know that what they have is not the original, so that any problems introduced
by others will not reflect on the original authors' reputations.
.Pp
Finally, any free program is threatened constantly by software patents. We
wish to avoid the danger that redistributors of a free program will individually
obtain patent licenses, in effect making the program proprietary. To prevent
this, we have made it clear that any patent must be licensed for everyone's
free use or not licensed at all.
.Pp
The precise terms and conditions for copying, distribution and modification
follow.
.Pp
.Bl -enum
.It
This License applies to any program or other work which contains a notice
placed by the copyright holder saying it may be distributed under the terms
of this General Public License. The \(lqProgram\(rq, below, refers to any such program
or work, and a \(lqwork based on the Program\(rq means either the Program or any derivative
work under copyright law: that is to say, a work containing the Program or
a portion of it, either verbatim or with modifications and/or translated into
another language. (Hereinafter, translation is included without limitation
in the term \(lqmodification\(rq.) Each licensee is addressed as \(lqyou\(rq.
.Pp
Activities other than copying, distribution and modification are not covered
by this License; they are outside its scope. The act of running the Program
is not restricted, and the output from the Program is covered only if its
contents constitute a work based on the Program (independent of having been
made by running the Program). Whether that is true depends on what the Program
does.
.Pp
.It
You may copy and distribute verbatim copies of the Program's source code as
you receive it, in any medium, provided that you conspicuously and appropriately
publish on each copy an appropriate copyright notice and disclaimer of warranty;
keep intact all the notices that refer to this License and to the absence
of any warranty; and give any other recipients of the Program a copy of this
License along with the Program.
.Pp
You may charge a fee for the physical act of transferring a copy, and you
may at your option offer warranty protection in exchange for a fee.
.Pp
.It
You may modify your copy or copies of the Program or any portion of it, thus
forming a work based on the Program, and copy and distribute such modifications
or work under the terms of Section 1 above, provided that you also meet all
of these conditions:
.Pp
.Bl -enum
.It
You must cause the modified files to carry prominent notices stating that
you changed the files and the date of any change.
.Pp
.It
You must cause any work that you distribute or publish, that in whole or in
part contains or is derived from the Program or any part thereof, to be licensed
as a whole at no charge to all third parties under the terms of this License.
.Pp
.It
If the modified program normally reads commands interactively when run, you
must cause it, when started running for such interactive use in the most ordinary
way, to print or display an announcement including an appropriate copyright
notice and a notice that there is no warranty (or else, saying that you provide
a warranty) and that users may redistribute the program under these conditions,
and telling the user how to view a copy of this License. (Exception: if the
Program itself is interactive but does not normally print such an announcement,
your work based on the Program is not required to print an announcement.)
.El
.Pp
These requirements apply to the modified work as a whole. If identifiable
sections of that work are not derived from the Program, and can be reasonably
considered independent and separate works in themselves, then this License,
and its terms, do not apply to those sections when you distribute them as
separate works. But when you distribute the same sections as part of a whole
which is a work based on the Program, the distribution of the whole must be
on the terms of this License, whose permissions for other licensees extend
to the entire whole, and thus to each and every part regardless of who wrote
it.
.Pp
Thus, it is not the intent of this section to claim rights or contest your
rights to work written entirely by you; rather, the intent is to exercise
the right to control the distribution of derivative or collective works based
on the Program.
.Pp
In addition, mere aggregation of another work not based on the Program with
the Program (or with a work based on the Program) on a volume of a storage
or distribution medium does not bring the other work under the scope of this
License.
.Pp
.It
You may copy and distribute the Program (or a work based on it, under Section
2) in object code or executable form under the terms of Sections 1 and 2 above
provided that you also do one of the following:
.Pp
.Bl -enum
.It
Accompany it with the complete corresponding machine-readable source code,
which must be distributed under the terms of Sections 1 and 2 above on a medium
customarily used for software interchange; or,
.Pp
.It
Accompany it with a written offer, valid for at least three years, to give
any third party, for a charge no more than your cost of physically performing
source distribution, a complete machine-readable copy of the corresponding
source code, to be distributed under the terms of Sections 1 and 2 above on
a medium customarily used for software interchange; or,
.Pp
.It
Accompany it with the information you received as to the offer to distribute
corresponding source code. (This alternative is allowed only for noncommercial
distribution and only if you received the program in object code or executable
form with such an offer, in accord with Subsection b above.)
.El
.Pp
The source code for a work means the preferred form of the work for making
modifications to it. For an executable work, complete source code means all
the source code for all modules it contains, plus any associated interface
definition files, plus the scripts used to control compilation and installation
of the executable. However, as a special exception, the source code distributed
need not include anything that is normally distributed (in either source or
binary form) with the major components (compiler, kernel, and so on) of the
operating system on which the executable runs, unless that component itself
accompanies the executable.
.Pp
If distribution of executable or object code is made by offering access to
copy from a designated place, then offering equivalent access to copy the
source code from the same place counts as distribution of the source code,
even though third parties are not compelled to copy the source along with
the object code.
.Pp
.It
You may not copy, modify, sublicense, or distribute the Program except as
expressly provided under this License. Any attempt otherwise to copy, modify,
sublicense or distribute the Program is void, and will automatically terminate
your rights under this License. However, parties who have received copies,
or rights, from you under this License will not have their licenses terminated
so long as such parties remain in full compliance.
.Pp
.It
You are not required to accept this License, since you have not signed it.
However, nothing else grants you permission to modify or distribute the Program
or its derivative works. These actions are prohibited by law if you do not
accept this License. Therefore, by modifying or distributing the Program (or
any work based on the Program), you indicate your acceptance of this License
to do so, and all its terms and conditions for copying, distributing or modifying
the Program or works based on it.
.Pp
.It
Each time you redistribute the Program (or any work based on the Program),
the recipient automatically receives a license from the original licensor
to copy, distribute or modify the Program subject to these terms and conditions.
You may not impose any further restrictions on the recipients' exercise of
the rights granted herein. You are not responsible for enforcing compliance
by third parties to this License.
.Pp
.It
If, as a consequence of a court judgment or allegation of patent infringement
or for any other reason (not limited to patent issues), conditions are imposed
on you (whether by court order, agreement or otherwise) that contradict the
conditions of this License, they do not excuse you from the conditions of
this License. If you cannot distribute so as to satisfy simultaneously your
obligations under this License and any other pertinent obligations, then as
a consequence you may not distribute the Program at all. For example, if a
patent license would not permit royalty-free redistribution of the Program
by all those who receive copies directly or indirectly through you, then the
only way you could satisfy both it and this License would be to refrain entirely
from distribution of the Program.
.Pp
If any portion of this section is held invalid or unenforceable under any
particular circumstance, the balance of the section is intended to apply and
the section as a whole is intended to apply in other circumstances.
.Pp
It is not the purpose of this section to induce you to infringe any patents
or other property right claims or to contest validity of any such claims;
this section has the sole purpose of protecting the integrity of the free
software distribution system, which is implemented by public license practices.
Many people have made generous contributions to the wide range of software
distributed through that system in reliance on consistent application of that
system; it is up to the author/donor to decide if he or she is willing to
distribute software through any other system and a licensee cannot impose
that choice.
.Pp
This section is intended to make thoroughly clear what is believed to be a
consequence of the rest of this License.
.Pp
.It
If the distribution and/or use of the Program is restricted in certain countries
either by patents or by copyrighted interfaces, the original copyright holder
who places the Program under this License may add an explicit geographical
distribution limitation excluding those countries, so that distribution is
permitted only in or among countries not thus excluded. In such case, this
License incorporates the limitation as if written in the body of this License.
.Pp
.It
The Free Software Foundation may publish revised and/or new versions of the
General Public License from time to time. Such new versions will be similar
in spirit to the present version, but may differ in detail to address new
problems or concerns.
.Pp
Each version is given a distinguishing version number. If the Program specifies
a version number of this License which applies to it and \(lqany later version\(rq,
you have the option of following the terms and conditions either of that version
or of any later version published by the Free Software Foundation. If the
Program does not specify a version number of this License, you may choose
any version ever published by the Free Software Foundation.
.Pp
.It
If you wish to incorporate parts of the Program into other free programs whose
distribution conditions are different, write to the author to ask for permission.
For software which is copyrighted by the Free Software Foundation, write to
the Free Software Foundation; we sometimes make exceptions for this. Our decision
will be guided by the two goals of preserving the free status of all derivatives
of our free software and of promoting the sharing and reuse of software generally.
.Pp
.It
BECAUSE THE PROGRAM IS LICENSED FREE OF CHARGE, THERE IS NO WARRANTY FOR THE
PROGRAM, TO THE EXTENT PERMITTED BY APPLICABLE LAW. EXCEPT WHEN OTHERWISE
STATED IN WRITING THE COPYRIGHT HOLDERS AND/OR OTHER PARTIES PROVIDE THE PROGRAM
\(lqAS IS\(rq WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING,
BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
FOR A PARTICULAR PURPOSE. THE ENTIRE RISK AS TO THE QUALITY AND PERFORMANCE
OF THE PROGRAM IS WITH YOU. SHOULD THE PROGRAM PROVE DEFECTIVE, YOU ASSUME
THE COST OF ALL NECESSARY SERVICING, REPAIR OR CORRECTION.
.Pp
.It
IN NO EVENT UNLESS REQUIRED BY APPLICABLE LAW OR AGREED TO IN WRITING WILL
ANY COPYRIGHT HOLDER, OR ANY OTHER PARTY WHO MAY MODIFY AND/OR REDISTRIBUTE
THE PROGRAM AS PERMITTED ABOVE, BE LIABLE TO YOU FOR DAMAGES, INCLUDING ANY
GENERAL, SPECIAL, INCIDENTAL OR CONSEQUENTIAL DAMAGES ARISING OUT OF THE USE
OR INABILITY TO USE THE PROGRAM (INCLUDING BUT NOT LIMITED TO LOSS OF DATA
OR DATA BEING RENDERED INACCURATE OR LOSSES SUSTAINED BY YOU OR THIRD PARTIES
OR A FAILURE OF THE PROGRAM TO OPERATE WITH ANY OTHER PROGRAMS), EVEN IF SUCH
HOLDER OR OTHER PARTY HAS BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGES.
.El
.Pp
.Ss  How to Apply These Terms to Your New Programs
If you develop a new program, and you want it to be of the greatest possible
use to the public, the best way to achieve this is to make it free software
which everyone can redistribute and change under these terms.
.Pp
To do so, attach the following notices to the program. It is safest to attach
them to the start of each source file to most effectively convey the exclusion
of warranty; and each file should have at least the \(lqcopyright\(rq line and a pointer
to where the full notice is found.
.Pp
.Bd -literal -offset indent
one line to give the program's name and an idea of what it does.
Copyright (C) year  name of author

This program is free software; you can redistribute it and/or
modify it under the terms of the GNU General Public License
as published by the Free Software Foundation; either version 2
of the License, or (at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program; if not, write to the Free Software
Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307, USA.
.Ed
.Pp
Also add information on how to contact you by electronic and paper mail.
.Pp
If the program is interactive, make it output a short notice like this when
it starts in an interactive mode:
.Pp
.Bd -literal -offset indent
Gnomovision version 69, Copyright (C) year  name of author
Gnomovision comes with ABSOLUTELY NO WARRANTY; for details
type `show w'.  This is free software, and you are welcome
to redistribute it under certain conditions; type `show c' 
for details.
.Ed
.Pp
The hypothetical commands
.Li show w
and
.Li show c
should show the appropriate parts of the General Public License. Of course,
the commands you use may be called something other than
.Li show w
and
.Li show c
; they could even be mouse-clicks or menu items---whatever suits your program.
.Pp
You should also get your employer (if you work as a programmer) or your school,
if any, to sign a \(lqcopyright disclaimer\(rq for the program, if necessary. Here
is a sample; alter the names:
.Pp
.Bd -literal -offset indent

Yoyodyne, Inc., hereby disclaims all copyright
interest in the program `Gnomovision'
(which makes passes at compilers) written 
by James Hacker.

signature of Ty Coon, 1 April 1989
Ty Coon, President of Vice

.Ed
.Pp
This General Public License does not permit incorporating your program into
proprietary programs. If your program is a subroutine library, you may consider
it more useful to permit linking proprietary applications with the library.
If this is what you want to do, use the GNU Library General Public License
instead of this License.
.Pp
.Sh  Contributors to GNU Li gperf Utility
.Bl -bullet
.It
The GNU
.Li gperf
perfect hash function generator utility was written in GNU C++ by Douglas
C. Schmidt. The general idea for the perfect hash function generator was inspired
by Keith Bostic's algorithm written in C, and distributed to net.sources around
1984. The current program is a heavily modified, enhanced, and extended implementation
of Keith's basic idea, created at the University of California, Irvine. Bugs,
patches, and suggestions should be reported to
.Li <bug-gnu-gperf@gnu.org> .
.Pp
.It
Special thanks is extended to Michael Tiemann and Doug Lea, for providing
a useful compiler, and for giving me a forum to exhibit my creation.
.Pp
In addition, Adam de Boor and Nels Olson provided many tips and insights that
greatly helped improve the quality and functionality of
.Li gperf .
.Pp
.It
Bruno Haible enhanced and optimized the search algorithm. He also rewrote
the input routines and the output routines for better reliability, and added
a testsuite.
.El
.Pp
.Sh  Introduction
.Li gperf
is a perfect hash function generator written in C++. It transforms an
.Va n
element user-specified keyword set
.Va W
into a perfect hash function
.Va F .
.Va F
uniquely maps keywords in
.Va W
onto the range 0..
.Va k ,
where
.Va k
>=
.Va n-1 .
If
.Va k
=
.Va n-1
then
.Va F
is a
.Em minimal
perfect hash function.
.Li gperf
generates a 0..
.Va k
element static lookup table and a pair of C functions. These functions determine
whether a given character string
.Va s
occurs in
.Va W ,
using at most one probe into the lookup table.
.Pp
.Li gperf
currently generates the reserved keyword recognizer for lexical analyzers
in several production and research compilers and language processing tools,
including GNU C, GNU C++, GNU Java, GNU Pascal, GNU Modula 3, and GNU indent.
Complete C++ source code for
.Li gperf
is available from
.Li http://ftp.gnu.org/pub/gnu/gperf/ .
A paper describing
.Li gperf
\&'s design and implementation in greater detail is available in the Second
USENIX C++ Conference proceedings or from
.Li http://www.cs.wustl.edu/~schmidt/resume.html .
.Pp
.Sh  Static search structures and GNU Li gperf
A
.Em static search structure
is an Abstract Data Type with certain fundamental operations, e.g.,
.Em initialize ,
.Em insert ,
and
.Em retrieve .
Conceptually, all insertions occur before any retrievals. In practice,
.Li gperf
generates a
.Em static
array containing search set keywords and any associated attributes specified
by the user. Thus, there is essentially no execution-time cost for the insertions.
It is a useful data structure for representing
.Em static search sets .
Static search sets occur frequently in software system applications. Typical
static search sets include compiler reserved words, assembler instruction
opcodes, and built-in shell interpreter commands. Search set members, called
.Em keywords ,
are inserted into the structure only once, usually during program initialization,
and are not generally modified at run-time.
.Pp
Numerous static search structure implementations exist, e.g., arrays, linked
lists, binary search trees, digital search tries, and hash tables. Different
approaches offer trade-offs between space utilization and search time efficiency.
For example, an
.Va n
element sorted array is space efficient, though the average-case time complexity
for retrieval operations using binary search is proportional to log
.Va n .
Conversely, hash table implementations often locate a table entry in constant
time, but typically impose additional memory overhead and exhibit poor worst
case performance.
.Pp
.Em Minimal perfect hash functions
provide an optimal solution for a particular class of static search sets.
A minimal perfect hash function is defined by two properties:
.Pp
.Bl -bullet
.It
It allows keyword recognition in a static search set using at most
.Em one
probe into the hash table. This represents the \(lqperfect\(rq property.
.It
The actual memory allocated to store the keywords is precisely large enough
for the keyword set, and
.Em no larger .
This is the \(lqminimal\(rq property.
.El
.Pp
For most applications it is far easier to generate
.Em perfect
hash functions than
.Em minimal perfect
hash functions. Moreover, non-minimal perfect hash functions frequently execute
faster than minimal ones in practice. This phenomena occurs since searching
a sparse keyword table increases the probability of locating a \(lqnull\(rq entry,
thereby reducing string comparisons.
.Li gperf
\&'s default behavior generates
.Em near-minimal
perfect hash functions for keyword sets. However,
.Li gperf
provides many options that permit user control over the degree of minimality
and perfection.
.Pp
Static search sets often exhibit relative stability over time. For example,
Ada's 63 reserved words have remained constant for nearly a decade. It is
therefore frequently worthwhile to expend concerted effort building an optimal
search structure
.Em once ,
if it subsequently receives heavy use multiple times.
.Li gperf
removes the drudgery associated with constructing time- and space-efficient
search structures by hand. It has proven a useful and practical tool for serious
programming projects. Output from
.Li gperf
is currently used in several production and research compilers, including
GNU C, GNU C++, GNU Java, GNU Pascal, and GNU Modula 3. The latter two compilers
are not yet part of the official GNU distribution. Each compiler utilizes
.Li gperf
to automatically generate static search structures that efficiently identify
their respective reserved keywords.
.Pp
.Sh  High-Level Description of GNU Li gperf
The perfect hash function generator
.Li gperf
reads a set of \(lqkeywords\(rq from an input file (or from the standard input by
default). It attempts to derive a perfect hashing function that recognizes
a member of the
.Em static keyword set
with at most a single probe into the lookup table. If
.Li gperf
succeeds in generating such a function it produces a pair of C source code
routines that perform hashing and table lookup recognition. All generated
C code is directed to the standard output. Command-line options described
below allow you to modify the input and output format to
.Li gperf .
.Pp
By default,
.Li gperf
attempts to produce time-efficient code, with less emphasis on efficient space
utilization. However, several options exist that permit trading-off execution
time for storage space and vice versa. In particular, expanding the generated
table size produces a sparse search structure, generally yielding faster searches.
Conversely, you can direct
.Li gperf
to utilize a C
.Li switch
statement scheme that minimizes data space storage size. Furthermore, using
a C
.Li switch
may actually speed up the keyword retrieval time somewhat. Actual results
depend on your C compiler, of course.
.Pp
In general,
.Li gperf
assigns values to the bytes it is using for hashing until some set of values
gives each keyword a unique value. A helpful heuristic is that the larger
the hash value range, the easier it is for
.Li gperf
to find and generate a perfect hash function. Experimentation is the key to
getting the most from
.Li gperf .
.Pp
.Ss  Input Format to Li gperf
You can control the input file format by varying certain command-line arguments,
in particular the
.Li -t
option. The input's appearance is similar to GNU utilities
.Li flex
and
.Li bison
(or UNIX utilities
.Li lex
and
.Li yacc ) .
Here's an outline of the general format:
.Pp
.Bd -literal -offset indent

declarations
%%
keywords
%%
functions

.Ed
.Pp
.Em Unlike
.Li flex
or
.Li bison ,
the declarations section and the functions section are optional. The following
sections describe the input format for each section.
.Pp
It is possible to omit the declaration section entirely, if the
.Li -t
option is not given. In this case the input file begins directly with the
first keyword line, e.g.:
.Pp
.Bd -literal -offset indent

january
february
march
april
\&...

.Ed
.Pp
.Em  Declarations
.Pp
The keyword input file optionally contains a section for including arbitrary
C declarations and definitions,
.Li gperf
declarations that act like command-line options, as well as for providing
a user-supplied
.Li struct .
.Pp
.No  User-supplied Li struct
.Pp
If the
.Li -t
option (or, equivalently, the
.Li %struct-type
declaration)
.Em is
enabled, you
.Em must
provide a C
.Li struct
as the last component in the declaration section from the input file. The
first field in this struct must be of type
.Li char *
or
.Li const char *
if the
.Li -P
option is not given, or of type
.Li int
if the option
.Li -P
(or, equivalently, the
.Li %pic
declaration) is enabled. This first field must be called
.Li name ,
although it is possible to modify its name with the
.Li -K
option (or, equivalently, the
.Li %define slot-name
declaration) described below.
.Pp
Here is a simple example, using months of the year and their attributes as
input:
.Pp
.Bd -literal -offset indent

struct month { char *name; int number; int days; int leap_days; };
%%
january,   1, 31, 31
february,  2, 28, 29
march,     3, 31, 31
april,     4, 30, 30
may,       5, 31, 31
june,      6, 30, 30
july,      7, 31, 31
august,    8, 31, 31
september, 9, 30, 30
october,  10, 31, 31
november, 11, 30, 30
december, 12, 31, 31

.Ed
.Pp
Separating the
.Li struct
declaration from the list of keywords and other fields are a pair of consecutive
percent signs,
.Li %% ,
appearing left justified in the first column, as in the UNIX utility
.Li lex .
.Pp
If the
.Li struct
has already been declared in an include file, it can be mentioned in an abbreviated
form, like this:
.Pp
.Bd -literal -offset indent

struct month;
%%
january,   1, 31, 31
\&...

.Ed
.Pp
.No  Gperf Declarations
.Pp
The declaration section can contain
.Li gperf
declarations. They influence the way
.Li gperf
works, like command line options do. In fact, every such declaration is equivalent
to a command line option. There are three forms of declarations:
.Pp
.Bl -enum
.It
Declarations without argument, like
.Li %compare-lengths .
.Pp
.It
Declarations with an argument, like
.Li %switch= Va count .
.Pp
.It
Declarations of names of entities in the output file, like
.Li %define lookup-function-name Va name .
.El
.Pp
When a declaration is given both in the input file and as a command line option,
the command-line option's value prevails.
.Pp
The following
.Li gperf
declarations are available.
.Pp
.Bl -tag -width Ds
.It  %delimiters= Va delimiter-list
Allows you to provide a string containing delimiters used to separate keywords
from their attributes. The default is ",". This option is essential if you
want to use keywords that have embedded commas or newlines.
.Pp
.It  %struct-type
Allows you to include a
.Li struct
type declaration for generated code; see above for an example.
.Pp
.It  %ignore-case
Consider upper and lower case ASCII characters as equivalent. The string comparison
will use a case insignificant character comparison. Note that locale dependent
case mappings are ignored.
.Pp
.It  %language= Va language-name
Instructs
.Li gperf
to generate code in the language specified by the option's argument. Languages
handled are currently:
.Pp
.Bl -tag -width Ds
.It  KR-C
Old-style K&R C. This language is understood by old-style C compilers and
ANSI C compilers, but ANSI C compilers may flag warnings (or even errors)
because of lacking
.Li const .
.Pp
.It  C
Common C. This language is understood by ANSI C compilers, and also by old-style
C compilers, provided that you
.Li #define const
to empty for compilers which don't know about this keyword.
.Pp
.It  ANSI-C
ANSI C. This language is understood by ANSI C compilers and C++ compilers.
.Pp
.It  C++
C++. This language is understood by C++ compilers.
.El
.Pp
The default is C.
.Pp
.It  %define slot-name Va name
This declaration is only useful when option
.Li -t
(or, equivalently, the
.Li %struct-type
declaration) has been given. By default, the program assumes the structure
component identifier for the keyword is
.Li name .
This option allows an arbitrary choice of identifier for this component, although
it still must occur as the first field in your supplied
.Li struct .
.Pp
.It  %define initializer-suffix Va initializers
This declaration is only useful when option
.Li -t
(or, equivalently, the
.Li %struct-type
declaration) has been given. It permits to specify initializers for the structure
members following
.Va slot-name
in empty hash table entries. The list of initializers should start with a
comma. By default, the emitted code will zero-initialize structure members
following
.Va slot-name .
.Pp
.It  %define hash-function-name Va name
Allows you to specify the name for the generated hash function. Default name
is
.Li hash .
This option permits the use of two hash tables in the same file.
.Pp
.It  %define lookup-function-name Va name
Allows you to specify the name for the generated lookup function. Default
name is
.Li in_word_set .
This option permits multiple generated hash functions to be used in the same
application.
.Pp
.It  %define class-name Va name
This option is only useful when option
.Li -L C++
(or, equivalently, the
.Li %language=C++
declaration) has been given. It allows you to specify the name of generated
C++ class. Default name is
.Li Perfect_Hash .
.Pp
.It  %7bit
This option specifies that all strings that will be passed as arguments to
the generated hash function and the generated lookup function will solely
consist of 7-bit ASCII characters (bytes in the range 0..127). (Note that
the ANSI C functions
.Li isalnum
and
.Li isgraph
do
.Em not
guarantee that a byte is in this range. Only an explicit test like
.Li c >= 'A' && c <= 'Z'
guarantees this.)
.Pp
.It  %compare-lengths
Compare keyword lengths before trying a string comparison. This option is
mandatory for binary comparisons (see Section
.Dq Binary Strings ) .
It also might cut down on the number of string comparisons made during the
lookup, since keywords with different lengths are never compared via
.Li strcmp .
However, using
.Li %compare-lengths
might greatly increase the size of the generated C code if the lookup table
range is large (which implies that the switch option
.Li -S
or
.Li %switch
is not enabled), since the length table contains as many elements as there
are entries in the lookup table.
.Pp
.It  %compare-strncmp
Generates C code that uses the
.Li strncmp
function to perform string comparisons. The default action is to use
.Li strcmp .
.Pp
.It  %readonly-tables
Makes the contents of all generated lookup tables constant, i.e., \(lqreadonly\(rq.
Many compilers can generate more efficient code for this by putting the tables
in readonly memory.
.Pp
.It  %enum
Define constant values using an enum local to the lookup function rather than
with #defines. This also means that different lookup functions can reside
in the same file. Thanks to James Clark
.Li <jjc@ai.mit.edu> .
.Pp
.It  %includes
Include the necessary system include file,
.Li <string.h> ,
at the beginning of the code. By default, this is not done; the user must
include this header file himself to allow compilation of the code.
.Pp
.It  %global-table
Generate the static table of keywords as a static global variable, rather
than hiding it inside of the lookup function (which is the default behavior).
.Pp
.It  %pic
Optimize the generated table for inclusion in shared libraries. This reduces
the startup time of programs using a shared library containing the generated
code. If the
.Li %struct-type
declaration (or, equivalently, the option
.Li -t )
is also given, the first field of the user-defined struct must be of type
.Li int ,
not
.Li char * ,
because it will contain offsets into the string pool instead of actual strings.
To convert such an offset to a string, you can use the expression
.Li stringpool + Va o ,
where
.Va o
is the offset. The string pool name can be changed through the
.Li %define string-pool-name
declaration.
.Pp
.It  %define string-pool-name Va name
Allows you to specify the name of the generated string pool created by the
declaration
.Li %pic
(or, equivalently, the option
.Li -P ) .
The default name is
.Li stringpool .
This declaration permits the use of two hash tables in the same file, with
.Li %pic
and even when the
.Li %global-table
declaration (or, equivalently, the option
.Li -G )
is given.
.Pp
.It  %null-strings
Use NULL strings instead of empty strings for empty keyword table entries.
This reduces the startup time of programs using a shared library containing
the generated code (but not as much as the declaration
.Li %pic ) ,
at the expense of one more test-and-branch instruction at run time.
.Pp
.It  %define word-array-name Va name
Allows you to specify the name for the generated array containing the hash
table. Default name is
.Li wordlist .
This option permits the use of two hash tables in the same file, even when
the option
.Li -G
(or, equivalently, the
.Li %global-table
declaration) is given.
.Pp
.It  %define length-table-name Va name
Allows you to specify the name for the generated array containing the length
table. Default name is
.Li lengthtable .
This option permits the use of two length tables in the same file, even when
the option
.Li -G
(or, equivalently, the
.Li %global-table
declaration) is given.
.Pp
.It  %switch= Va count
Causes the generated C code to use a
.Li switch
statement scheme, rather than an array lookup table. This can lead to a reduction
in both time and space requirements for some input files. The argument to
this option determines how many
.Li switch
statements are generated. A value of 1 generates 1
.Li switch
containing all the elements, a value of 2 generates 2 tables with 1/2 the
elements in each
.Li switch ,
etc. This is useful since many C compilers cannot correctly generate code
for large
.Li switch
statements. This option was inspired in part by Keith Bostic's original C
program.
.Pp
.It  %omit-struct-type
Prevents the transfer of the type declaration to the output file. Use this
option if the type is already defined elsewhere.
.El
.Pp
.No  C Code Inclusion
.Pp
Using a syntax similar to GNU utilities
.Li flex
and
.Li bison ,
it is possible to directly include C source text and comments verbatim into
the generated output file. This is accomplished by enclosing the region inside
left-justified surrounding
.Li %{ ,
.Li %}
pairs. Here is an input fragment based on the previous example that illustrates
this feature:
.Pp
.Bd -literal -offset indent

%{
#include <assert.h>
/* This section of code is inserted directly into the output. */
int return_month_days (struct month *months, int is_leap_year);
%}
struct month { char *name; int number; int days; int leap_days; };
%%
january,   1, 31, 31
february,  2, 28, 29
march,     3, 31, 31
\&...

.Ed
.Pp
.Em  Format for Keyword Entries
.Pp
The second input file format section contains lines of keywords and any associated
attributes you might supply. A line beginning with
.Li #
in the first column is considered a comment. Everything following the
.Li #
is ignored, up to and including the following newline. A line beginning with
.Li %
in the first column is an option declaration and must not occur within the
keywords section.
.Pp
The first field of each non-comment line is always the keyword itself. It
can be given in two ways: as a simple name, i.e., without surrounding string
quotation marks, or as a string enclosed in double-quotes, in C syntax, possibly
with backslash escapes like
.Li \e"
or
.Li \e234
or
.Li \exa8 .
In either case, it must start right at the beginning of the line, without
leading whitespace. In this context, a \(lqfield\(rq is considered to extend up to,
but not include, the first blank, comma, or newline. Here is a simple example
taken from a partial list of C reserved words:
.Pp
.Bd -literal -offset indent

# These are a few C reserved words, see the c.gperf file 
# for a complete list of ANSI C reserved words.
unsigned
sizeof
switch
signed
if
default
for
while
return

.Ed
.Pp
Note that unlike
.Li flex
or
.Li bison
the first
.Li %%
marker may be elided if the declaration section is empty.
.Pp
Additional fields may optionally follow the leading keyword. Fields should
be separated by commas, and terminate at the end of line. What these fields
mean is entirely up to you; they are used to initialize the elements of the
user-defined
.Li struct
provided by you in the declaration section. If the
.Li -t
option (or, equivalently, the
.Li %struct-type
declaration) is
.Em not
enabled these fields are simply ignored. All previous examples except the
last one contain keyword attributes.
.Pp
.Em  Including Additional C Functions
.Pp
The optional third section also corresponds closely with conventions found
in
.Li flex
and
.Li bison .
All text in this section, starting at the final
.Li %%
and extending to the end of the input file, is included verbatim into the
generated output file. Naturally, it is your responsibility to ensure that
the code contained in this section is valid C.
.Pp
.Em  Where to place directives for GNU Li indent.
.Pp
If you want to invoke GNU
.Li indent
on a
.Li gperf
input file, you will see that GNU
.Li indent
doesn't understand the
.Li %% ,
.Li %{
and
.Li %}
directives that control
.Li gperf
\&'s interpretation of the input file. Therefore you have to insert some directives
for GNU
.Li indent .
More precisely, assuming the most general input file structure
.Pp
.Bd -literal -offset indent

declarations part 1
%{
verbatim code
%}
declarations part 2
%%
keywords
%%
functions

.Ed
.Pp
you would insert
.Li *INDENT-OFF*
and
.Li *INDENT-ON*
comments as follows:
.Pp
.Bd -literal -offset indent

/* *INDENT-OFF* */
declarations part 1
%{
/* *INDENT-ON* */
verbatim code
/* *INDENT-OFF* */
%}
declarations part 2
%%
keywords
%%
/* *INDENT-ON* */
functions

.Ed
.Pp
.Ss  Output Format for Generated C Code with Li gperf
Several options control how the generated C code appears on the standard output.
Two C functions are generated. They are called
.Li hash
and
.Li in_word_set ,
although you may modify their names with a command-line option. Both functions
require two arguments, a string,
.Li char *
.Va str ,
and a length parameter,
.Li int
.Va len .
Their default function prototypes are as follows:
.Pp
Function:
.Ft  unsigned int
.Fo  hash
.Fa  (const char * Va str, unsigned int Va len)
.Fc
.Pp
By default, the generated
.Li hash
function returns an integer value created by adding
.Va len
to several user-specified
.Va str
byte positions indexed into an
.Em associated values
table stored in a local static array. The associated values table is constructed
internally by
.Li gperf
and later output as a static local C array called
.Li hash_table .
The relevant selected positions (i.e. indices into
.Va str )
are specified via the
.Li -k
option when running
.Li gperf ,
as detailed in the
.Em Options
section below (see Section
.Dq Options ) .
.Pp
Function:
.Ft 
.Fo  in_word_set
.Fa  (const char * Va str, unsigned int Va len)
.Fc
.Pp
If
.Va str
is in the keyword set, returns a pointer to that keyword. More exactly, if
the option
.Li -t
(or, equivalently, the
.Li %struct-type
declaration) was given, it returns a pointer to the matching keyword's structure.
Otherwise it returns
.Li NULL .
.Pp
If the option
.Li -c
(or, equivalently, the
.Li %compare-strncmp
declaration) is not used,
.Va str
must be a NUL terminated string of exactly length
.Va len .
If
.Li -c
(or, equivalently, the
.Li %compare-strncmp
declaration) is used,
.Va str
must simply be an array of
.Va len
bytes and does not need to be NUL terminated.
.Pp
The code generated for these two functions is affected by the following options:
.Pp
.Bl -tag -width Ds
.It  -t
.It  --struct-type
Make use of the user-defined
.Li struct .
.Pp
.It  -S Va total-switch-statements
.It  --switch= Va total-switch-statements
Generate 1 or more C
.Li switch
statement rather than use a large, (and potentially sparse) static array.
Although the exact time and space savings of this approach vary according
to your C compiler's degree of optimization, this method often results in
smaller and faster code.
.El
.Pp
If the
.Li -t
and
.Li -S
options (or, equivalently, the
.Li %struct-type
and
.Li %switch
declarations) are omitted, the default action is to generate a
.Li char *
array containing the keywords, together with additional empty strings used
for padding the array. By experimenting with the various input and output
options, and timing the resulting C code, you can determine the best option
choices for different keyword set characteristics.
.Pp
.Ss  Use of NUL bytes
By default, the code generated by
.Li gperf
operates on zero terminated strings, the usual representation of strings in
C. This means that the keywords in the input file must not contain NUL bytes,
and the
.Va str
argument passed to
.Li hash
or
.Li in_word_set
must be NUL terminated and have exactly length
.Va len .
.Pp
If option
.Li -c
(or, equivalently, the
.Li %compare-strncmp
declaration) is used, then the
.Va str
argument does not need to be NUL terminated. The code generated by
.Li gperf
will only access the first
.Va len ,
not
.Va len+1 ,
bytes starting at
.Va str .
However, the keywords in the input file still must not contain NUL bytes.
.Pp
If option
.Li -l
(or, equivalently, the
.Li %compare-lengths
declaration) is used, then the hash table performs binary comparison. The
keywords in the input file may contain NUL bytes, written in string syntax
as
.Li \e000
or
.Li \ex00 ,
and the code generated by
.Li gperf
will treat NUL like any other byte. Also, in this case the
.Li -c
option (or, equivalently, the
.Li %compare-strncmp
declaration) is ignored.
.Pp
.Sh  Invoking Li gperf
There are
.Em many
options to
.Li gperf .
They were added to make the program more convenient for use with real applications.
\(lqOn-line\(rq help is readily available via the
.Li --help
option. Here is the complete list of options.
.Pp
.Ss  Specifying the Location of the Output File
.Bl -tag -width Ds
.It  --output-file= Va file
Allows you to specify the name of the file to which the output is written
to.
.El
.Pp
The results are written to standard output if no output file is specified
or if it is
.Li - .
.Pp
.Ss  Options that affect Interpretation of the Input File
These options are also available as declarations in the input file (see Section
.Dq Gperf Declarations ) .
.Pp
.Bl -tag -width Ds
.It  -e Va keyword-delimiter-list
.It  --delimiters= Va keyword-delimiter-list
Allows you to provide a string containing delimiters used to separate keywords
from their attributes. The default is ",". This option is essential if you
want to use keywords that have embedded commas or newlines. One useful trick
is to use -e'TAB', where TAB is the literal tab character.
.Pp
.It  -t
.It  --struct-type
Allows you to include a
.Li struct
type declaration for generated code. Any text before a pair of consecutive
.Li %%
is considered part of the type declaration. Keywords and additional fields
may follow this, one group of fields per line. A set of examples for generating
perfect hash tables and functions for Ada, C, C++, Pascal, Modula 2, Modula
3 and JavaScript reserved words are distributed with this release.
.Pp
.It  --ignore-case
Consider upper and lower case ASCII characters as equivalent. The string comparison
will use a case insignificant character comparison. Note that locale dependent
case mappings are ignored. This option is therefore not suitable if a properly
internationalized or locale aware case mapping should be used. (For example,
in a Turkish locale, the upper case equivalent of the lowercase ASCII letter
.Li i
is the non-ASCII character
.Li capital i with dot above . )
For this case, it is better to apply an uppercase or lowercase conversion
on the string before passing it to the
.Li gperf
generated function.
.El
.Pp
.Ss  Options to specify the Language for the Output Code
These options are also available as declarations in the input file (see Section
.Dq Gperf Declarations ) .
.Pp
.Bl -tag -width Ds
.It  -L Va generated-language-name
.It  --language= Va generated-language-name
Instructs
.Li gperf
to generate code in the language specified by the option's argument. Languages
handled are currently:
.Pp
.Bl -tag -width Ds
.It  KR-C
Old-style K&R C. This language is understood by old-style C compilers and
ANSI C compilers, but ANSI C compilers may flag warnings (or even errors)
because of lacking
.Li const .
.Pp
.It  C
Common C. This language is understood by ANSI C compilers, and also by old-style
C compilers, provided that you
.Li #define const
to empty for compilers which don't know about this keyword.
.Pp
.It  ANSI-C
ANSI C. This language is understood by ANSI C compilers and C++ compilers.
.Pp
.It  C++
C++. This language is understood by C++ compilers.
.El
.Pp
The default is C.
.Pp
.It  -a
This option is supported for compatibility with previous releases of
.Li gperf .
It does not do anything.
.Pp
.It  -g
This option is supported for compatibility with previous releases of
.Li gperf .
It does not do anything.
.El
.Pp
.Ss  Options for fine tuning Details in the Output Code
Most of these options are also available as declarations in the input file
(see Section
.Dq Gperf Declarations ) .
.Pp
.Bl -tag -width Ds
.It  -K Va slot-name
.It  --slot-name= Va slot-name
This option is only useful when option
.Li -t
(or, equivalently, the
.Li %struct-type
declaration) has been given. By default, the program assumes the structure
component identifier for the keyword is
.Li name .
This option allows an arbitrary choice of identifier for this component, although
it still must occur as the first field in your supplied
.Li struct .
.Pp
.It  -F Va initializers
.It  --initializer-suffix= Va initializers
This option is only useful when option
.Li -t
(or, equivalently, the
.Li %struct-type
declaration) has been given. It permits to specify initializers for the structure
members following
.Va slot-name
in empty hash table entries. The list of initializers should start with a
comma. By default, the emitted code will zero-initialize structure members
following
.Va slot-name .
.Pp
.It  -H Va hash-function-name
.It  --hash-function-name= Va hash-function-name
Allows you to specify the name for the generated hash function. Default name
is
.Li hash .
This option permits the use of two hash tables in the same file.
.Pp
.It  -N Va lookup-function-name
.It  --lookup-function-name= Va lookup-function-name
Allows you to specify the name for the generated lookup function. Default
name is
.Li in_word_set .
This option permits multiple generated hash functions to be used in the same
application.
.Pp
.It  -Z Va class-name
.It  --class-name= Va class-name
This option is only useful when option
.Li -L C++
(or, equivalently, the
.Li %language=C++
declaration) has been given. It allows you to specify the name of generated
C++ class. Default name is
.Li Perfect_Hash .
.Pp
.It  -7
.It  --seven-bit
This option specifies that all strings that will be passed as arguments to
the generated hash function and the generated lookup function will solely
consist of 7-bit ASCII characters (bytes in the range 0..127). (Note that
the ANSI C functions
.Li isalnum
and
.Li isgraph
do
.Em not
guarantee that a byte is in this range. Only an explicit test like
.Li c >= 'A' && c <= 'Z'
guarantees this.) This was the default in versions of
.Li gperf
earlier than 2.7; now the default is to support 8-bit and multibyte characters.
.Pp
.It  -l
.It  --compare-lengths
Compare keyword lengths before trying a string comparison. This option is
mandatory for binary comparisons (see Section
.Dq Binary Strings ) .
It also might cut down on the number of string comparisons made during the
lookup, since keywords with different lengths are never compared via
.Li strcmp .
However, using
.Li -l
might greatly increase the size of the generated C code if the lookup table
range is large (which implies that the switch option
.Li -S
or
.Li %switch
is not enabled), since the length table contains as many elements as there
are entries in the lookup table.
.Pp
.It  -c
.It  --compare-strncmp
Generates C code that uses the
.Li strncmp
function to perform string comparisons. The default action is to use
.Li strcmp .
.Pp
.It  -C
.It  --readonly-tables
Makes the contents of all generated lookup tables constant, i.e., \(lqreadonly\(rq.
Many compilers can generate more efficient code for this by putting the tables
in readonly memory.
.Pp
.It  -E
.It  --enum
Define constant values using an enum local to the lookup function rather than
with #defines. This also means that different lookup functions can reside
in the same file. Thanks to James Clark
.Li <jjc@ai.mit.edu> .
.Pp
.It  -I
.It  --includes
Include the necessary system include file,
.Li <string.h> ,
at the beginning of the code. By default, this is not done; the user must
include this header file himself to allow compilation of the code.
.Pp
.It  -G
.It  --global-table
Generate the static table of keywords as a static global variable, rather
than hiding it inside of the lookup function (which is the default behavior).
.Pp
.It  -P
.It  --pic
Optimize the generated table for inclusion in shared libraries. This reduces
the startup time of programs using a shared library containing the generated
code. If the option
.Li -t
(or, equivalently, the
.Li %struct-type
declaration) is also given, the first field of the user-defined struct must
be of type
.Li int ,
not
.Li char * ,
because it will contain offsets into the string pool instead of actual strings.
To convert such an offset to a string, you can use the expression
.Li stringpool + Va o ,
where
.Va o
is the offset. The string pool name can be changed through the option
.Li --string-pool-name .
.Pp
.It  -Q Va string-pool-name
.It  --string-pool-name= Va string-pool-name
Allows you to specify the name of the generated string pool created by option
.Li -P .
The default name is
.Li stringpool .
This option permits the use of two hash tables in the same file, with
.Li -P
and even when the option
.Li -G
(or, equivalently, the
.Li %global-table
declaration) is given.
.Pp
.It  --null-strings
Use NULL strings instead of empty strings for empty keyword table entries.
This reduces the startup time of programs using a shared library containing
the generated code (but not as much as option
.Li -P ) ,
at the expense of one more test-and-branch instruction at run time.
.Pp
.It  -W Va hash-table-array-name
.It  --word-array-name= Va hash-table-array-name
Allows you to specify the name for the generated array containing the hash
table. Default name is
.Li wordlist .
This option permits the use of two hash tables in the same file, even when
the option
.Li -G
(or, equivalently, the
.Li %global-table
declaration) is given.
.Pp
.It  --length-table-name= Va length-table-array-name
Allows you to specify the name for the generated array containing the length
table. Default name is
.Li lengthtable .
This option permits the use of two length tables in the same file, even when
the option
.Li -G
(or, equivalently, the
.Li %global-table
declaration) is given.
.Pp
.It  -S Va total-switch-statements
.It  --switch= Va total-switch-statements
Causes the generated C code to use a
.Li switch
statement scheme, rather than an array lookup table. This can lead to a reduction
in both time and space requirements for some input files. The argument to
this option determines how many
.Li switch
statements are generated. A value of 1 generates 1
.Li switch
containing all the elements, a value of 2 generates 2 tables with 1/2 the
elements in each
.Li switch ,
etc. This is useful since many C compilers cannot correctly generate code
for large
.Li switch
statements. This option was inspired in part by Keith Bostic's original C
program.
.Pp
.It  -T
.It  --omit-struct-type
Prevents the transfer of the type declaration to the output file. Use this
option if the type is already defined elsewhere.
.Pp
.It  -p
This option is supported for compatibility with previous releases of
.Li gperf .
It does not do anything.
.El
.Pp
.Ss  Options for changing the Algorithms employed by Li gperf
.Bl -tag -width Ds
.It  -k Va selected-byte-positions
.It  --key-positions= Va selected-byte-positions
Allows selection of the byte positions used in the keywords' hash function.
The allowable choices range between 1-255, inclusive. The positions are separated
by commas, e.g.,
.Li -k 9,4,13,14
; ranges may be used, e.g.,
.Li -k 2-7
; and positions may occur in any order. Furthermore, the wildcard '*' causes
the generated hash function to consider
.Sy all
byte positions in each keyword, whereas '$' instructs the hash function to
use the \(lqfinal byte\(rq of a keyword (this is the only way to use a byte position
greater than 255, incidentally).
.Pp
For instance, the option
.Li -k 1,2,4,6-10,'$'
generates a hash function that considers positions 1,2,4,6,7,8,9,10, plus
the last byte in each keyword (which may be at a different position for each
keyword, obviously). Keywords with length less than the indicated byte positions
work properly, since selected byte positions exceeding the keyword length
are simply not referenced in the hash function.
.Pp
This option is not normally needed since version 2.8 of
.Li gperf
; the default byte positions are computed depending on the keyword set, through
a search that minimizes the number of byte positions.
.Pp
.It  -D
.It  --duplicates
Handle keywords whose selected byte sets hash to duplicate values. Duplicate
hash values can occur if a set of keywords has the same names, but possesses
different attributes, or if the selected byte positions are not well chosen.
With the -D option
.Li gperf
treats all these keywords as part of an equivalence class and generates a
perfect hash function with multiple comparisons for duplicate keywords. It
is up to you to completely disambiguate the keywords by modifying the generated
C code. However,
.Li gperf
helps you out by organizing the output.
.Pp
Using this option usually means that the generated hash function is no longer
perfect. On the other hand, it permits
.Li gperf
to work on keyword sets that it otherwise could not handle.
.Pp
.It  -m Va iterations
.It  --multiple-iterations= Va iterations
Perform multiple choices of the
.Li -i
and
.Li -j
values, and choose the best results. This increases the running time by a
factor of
.Va iterations
but does a good job minimizing the generated table size.
.Pp
.It  -i Va initial-value
.It  --initial-asso= Va initial-value
Provides an initial
.Va value
for the associate values array. Default is 0. Increasing the initial value
helps inflate the final table size, possibly leading to more time efficient
keyword lookups. Note that this option is not particularly useful when
.Li -S
(or, equivalently,
.Li %switch )
is used. Also,
.Li -i
is overridden when the
.Li -r
option is used.
.Pp
.It  -j Va jump-value
.It  --jump= Va jump-value
Affects the \(lqjump value\(rq, i.e., how far to advance the associated byte value
upon collisions.
.Va Jump-value
is rounded up to an odd number, the default is 5. If the
.Va jump-value
is 0
.Li gperf
jumps by random amounts.
.Pp
.It  -n
.It  --no-strlen
Instructs the generator not to include the length of a keyword when computing
its hash value. This may save a few assembly instructions in the generated
lookup table.
.Pp
.It  -r
.It  --random
Utilizes randomness to initialize the associated values table. This frequently
generates solutions faster than using deterministic initialization (which
starts all associated values at 0). Furthermore, using the randomization option
generally increases the size of the table.
.Pp
.It  -s Va size-multiple
.It  --size-multiple= Va size-multiple
Affects the size of the generated hash table. The numeric argument for this
option indicates \(lqhow many times larger or smaller\(rq the maximum associated value
range should be, in relationship to the number of keywords. It can be written
as an integer, a floating-point number or a fraction. For example, a value
of 3 means \(lqallow the maximum associated value to be about 3 times larger than
the number of input keywords\(rq. Conversely, a value of 1/3 means \(lqallow the maximum
associated value to be about 3 times smaller than the number of input keywords\(rq.
Values smaller than 1 are useful for limiting the overall size of the generated
hash table, though the option
.Li -m
is better at this purpose.
.Pp
If `generate switch' option
.Li -S
(or, equivalently,
.Li %switch )
is
.Em not
enabled, the maximum associated value influences the static array table size,
and a larger table should decrease the time required for an unsuccessful search,
at the expense of extra table space.
.Pp
The default value is 1, thus the default maximum associated value about the
same size as the number of keywords (for efficiency, the maximum associated
value is always rounded up to a power of 2). The actual table size may vary
somewhat, since this technique is essentially a heuristic.
.El
.Pp
.Ss  Informative Output
.Bl -tag -width Ds
.It  -h
.It  --help
Prints a short summary on the meaning of each program option. Aborts further
program execution.
.Pp
.It  -v
.It  --version
Prints out the current version number.
.Pp
.It  -d
.It  --debug
Enables the debugging option. This produces verbose diagnostics to \(lqstandard
error\(rq when
.Li gperf
is executing. It is useful both for maintaining the program and for determining
whether a given set of options is actually speeding up the search for a solution.
Some useful information is dumped at the end of the program when the
.Li -d
option is enabled.
.El
.Pp
.Sh  Known Bugs and Limitations with Li gperf
The following are some limitations with the current release of
.Li gperf :
.Pp
.Bl -bullet
.It
The
.Li gperf
utility is tuned to execute quickly, and works quickly for small to medium
size data sets (around 1000 keywords). It is extremely useful for maintaining
perfect hash functions for compiler keyword sets. Several recent enhancements
now enable
.Li gperf
to work efficiently on much larger keyword sets (over 15,000 keywords). When
processing large keyword sets it helps greatly to have over 8 megs of RAM.
.Pp
.It
The size of the generate static keyword array can get
.Em extremely
large if the input keyword file is large or if the keywords are quite similar.
This tends to slow down the compilation of the generated C code, and
.Em greatly
inflates the object code size. If this situation occurs, consider using the
.Li -S
option to reduce data size, potentially increasing keyword recognition time
a negligible amount. Since many C compilers cannot correctly generate code
for large switch statements it is important to qualify the
.Va -S
option with an appropriate numerical argument that controls the number of
switch statements generated.
.Pp
.It
The maximum number of selected byte positions has an arbitrary limit of 255.
This restriction should be removed, and if anyone considers this a problem
write me and let me know so I can remove the constraint.
.El
.Pp
.Sh  Things Still Left to Do
It should be \(lqrelatively\(rq easy to replace the current perfect hash function
algorithm with a more exhaustive approach; the perfect hash module is essential
independent from other program modules. Additional worthwhile improvements
include:
.Pp
.Bl -bullet
.It
Another useful extension involves modifying the program to generate \(lqminimal\(rq
perfect hash functions (under certain circumstances, the current version can
be rather extravagant in the generated table size). This is mostly of theoretical
interest, since a sparse table often produces faster lookups, and use of the
.Li -S
.Li switch
option can minimize the data size, at the expense of slightly longer lookups
(note that the gcc compiler generally produces good code for
.Li switch
statements, reducing the need for more complex schemes).
.Pp
.It
In addition to improving the algorithm, it would also be useful to generate
an Ada package as the code output, in addition to the current C and C++ routines.
.El
.Pp
.Sh  Bibliography
[1] Chang, C.C.:
.Em A Scheme for Constructing Ordered Minimal Perfect Hashing Functions
Information Sciences 39(1986), 187-195.
.Pp
[2] Cichelli, Richard J.
.Em Author's Response to \(lqOn Cichelli's Minimal Perfect Hash Functions Method\(rq
Communications of the ACM, 23, 12(December 1980), 729.
.Pp
[3] Cichelli, Richard J.
.Em Minimal Perfect Hash Functions Made Simple
Communications of the ACM, 23, 1(January 1980), 17-19.
.Pp
[4] Cook, C. R. and Oldehoeft, R.R.
.Em A Letter Oriented Minimal Perfect Hashing Function
SIGPLAN Notices, 17, 9(September 1982), 18-27.
.Pp
[5] Cormack, G. V. and Horspool, R. N. S. and Kaiserwerth, M.
.Em Practical Perfect Hashing
Computer Journal, 28, 1(January 1985), 54-58.
.Pp
[6] Jaeschke, G.
.Em Reciprocal Hashing: A Method for Generating Minimal Perfect Hashing Functions
Communications of the ACM, 24, 12(December 1981), 829-833.
.Pp
[7] Jaeschke, G. and Osterburg, G.
.Em On Cichelli's Minimal Perfect Hash Functions Method
Communications of the ACM, 23, 12(December 1980), 728-729.
.Pp
[8] Sager, Thomas J.
.Em A Polynomial Time Generator for Minimal Perfect Hash Functions
Communications of the ACM, 28, 5(December 1985), 523-532
.Pp
[9] Schmidt, Douglas C.
.Em GPERF: A Perfect Hash Function Generator
Second USENIX C++ Conference Proceedings, April 1990.
.Pp
[10] Schmidt, Douglas C.
.Em GPERF: A Perfect Hash Function Generator
C++ Report, SIGS 10 10 (November/December 1998).
.Pp
[11] Sebesta, R.W. and Taylor, M.A.
.Em Minimal Perfect Hash Functions for Reserved Word Lists
SIGPLAN Notices, 20, 12(September 1985), 47-53.
.Pp
[12] Sprugnoli, R.
.Em Perfect Hashing Functions: A Single Probe Retrieving Method for Static Sets
Communications of the ACM, 20 11(November 1977), 841-850.
.Pp
[13] Stallman, Richard M.
.Em Using and Porting GNU CC
Free Software Foundation, 1988.
.Pp
[14] Stroustrup, Bjarne
.Em The C++ Programming Language.
Addison-Wesley, 1986.
.Pp
[15] Tiemann, Michael D.
.Em User's Guide to GNU C++
Free Software Foundation, 1989.
.Pp
.Sh  Concept Index
